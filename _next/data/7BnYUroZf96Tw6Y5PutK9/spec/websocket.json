{"pageProps":{"frontmatter":{},"content":"# Specification: Ballerina WebSocket Library\n\n_Owners_: @shafreenAnfar @bhashinee  \n_Reviewers_: @shafreenAnfar  \n_Created_: 2021/12/09  \n_Updated_: 2022/12/08  \n_Edition_: Swan Lake  \n\n## Introduction\n\nThis is the specification for the WebSocket standard library of [Ballerina language](https://ballerina.io/), which provides WebSocket client-server functionalities.\n\nThe WebSocket library specification has evolved and may continue to evolve in the future. The released versions of the specification can be found under the relevant GitHub tag.\n\nIf you have any feedback or suggestions about the library, start a discussion via a [GitHub issue](https://github.com/ballerina-platform/ballerina-standard-library/issues) or in the [Discord server](https://discord.gg/ballerinalang). Based on the outcome of the discussion, the specification and implementation can be updated. Community feedback is always welcome. Any accepted proposal, which affects the specification is stored under `/docs/proposals`. Proposals under discussion can be found with the label `type/proposal` in GitHub.\n\nThe conforming implementation of the specification is released and included in the distribution. Any deviation from the specification is considered a bug.\n\n## Contents\n1. [Overview](#1-overview)\n2. [Listener](#2-listener)\n    * 2.1. [Listener Configurations](#21-listener-configurations)\n    * 2.2. [Initialization](#22-initialization)\n3. [Service Types](#3-service-types)\n    * 3.1. [UpgradeService](#31-upgradeservice)\n        * 3.1.1. [UpgradeService Configurations](#311-upgradeservice-configurations)\n    * 3.2. [WebSocket Service](#32-websocket-service)\n        * 3.2.1. [Remote methods associated with WebSocket Service](#321-remote-methods-associated-with-websocket-service)\n            * [onOpen](#onopen)\n            * [onTextMessage](#ontextmessage)\n            * [onBinaryMessage](#onbinarymessage)\n            * [onMessage](#onmessage)\n            * [onPing and onPong](#onping-and-onpong)\n            * [onIdleTimeout](#onidletimeout)\n            * [onClose](#onclose)\n            * [onError](#onerror)\n4. [Client](#4-client)\n    * 4.1. [Client Configurations](#41-client-configurations)\n    * 4.2. [Initialization](#42-initialization)\n    * 4.3. [Send and receive messages using the Client](#43-send-and-receive-messages-using-the-client)\n        * [writeTextMessage](#writetextmessage)\n        * [writeBinaryMessage](#writebinarymessage)\n        * [readTextMessage](#readtextmessage)\n        * [readBinaryMessage](#readbinarymessage)\n        * [readMessage](#readmessage)\n        * [close](#close)\n        * [ping](#ping)\n        * [pong](#pong)\n        * [onPing and onPong remote methods](#onping-and-onpong-remote-methods)\n5. [Securing the WebSocket Connections](#5-securing-the-websocket-connections)\n    * 5.1. [SSL/TLS](#51-ssl-tls)\n    * 5.2. [Authentication and Authorization](#52-authentication-and-authorization)\n6. [Samples](#6-samples)\n\n## 1. [Overview](#1-overview)\n\nWebSocket is a protocol that allows a long held full-duplex connection between a server and client. This specification elaborates on how Ballerina language provides a tested WebSocket client and server implementation that is compliant with the [RFC 6455](https://www.rfc-editor.org/rfc/rfc6455.html).\n\n## 2. [Listener](#2-listener)\n\nThe WebSocket listener can be constructed with a port or an http:Listener. When initiating the listener it opens up the port and attaches the upgrade service at the given service path. It is also worth noting that upgrade service is quite similar to an HTTP service.\n\n### 2.1. [Listener Configurations](#21-listener-configurations)\n\nWhen initializing the listener, following configurations can be provided,\n```ballerina\n# Provides a set of configurations for HTTP service endpoints.\n#\n# + host - The host name/IP of the endpoint\n# + http1Settings - Configurations related to HTTP/1.x protocol\n# + secureSocket - The SSL configurations for the service endpoint. This needs to be configured in order to\n#                  communicate through WSS.\n# + timeout - Period of time in seconds that a connection waits for a read/write operation in the\n#                     initial upgrade request. Use value 0 to disable timeout\n# + server - The server name which should appear as a response header\n# + webSocketCompressionEnabled - Enable support for compression in WebSocket\n# + requestLimits - Configurations associated with inbound request size limits\npublic type ListenerConfiguration record {|\n    string host = \"0.0.0.0\";\n    ListenerHttp1Settings http1Settings = {};\n    ListenerSecureSocket secureSocket?;\n    decimal timeout = 120;\n    string? server = ();\n    boolean webSocketCompressionEnabled = true;\n    RequestLimitConfigs requestLimits = {};\n|};\n```\n\n`ListenerHttp1Settings` record contains the settings related to HTTP/1.x protocol. This is an included record from the HTTP package, and this will only be applicable to the initial WebSocket upgrade request.\n```ballerina\n# Provides settings related to HTTP/1.x protocol.\npublic type ListenerHttp1Settings record {|\n    *http:ListenerHttp1Settings;\n|};\n```\n\nThe actual `ListenerHttp1Settings` record in the HTTP package contains the following fields.\n\n```ballerina\n# Provides settings related to HTTP/1.x protocol.\n#\n# + keepAlive - Can be set to either `KEEPALIVE_AUTO`, which respects the `connection` header, or `KEEPALIVE_ALWAYS`,\n#               which always keeps the connection alive, or `KEEPALIVE_NEVER`, which always closes the connection\n# + maxPipelinedRequests - Defines the maximum number of requests that can be processed at a given time on a single\n#                          connection. By default 10 requests can be pipelined on a single connection and user can\n#                          change this limit appropriately.\npublic type ListenerHttp1Settings record {|\n    KeepAlive keepAlive = KEEPALIVE_AUTO;\n    int maxPipelinedRequests = MAX_PIPELINED_REQUESTS;\n|};\n```\n\n`ListenerSecureSocket` record contains configurations related to enabling SSL/TLS on the listener side, and it is an included record from the HTTP package. More details and examples of how to configure them can be found in a following section on `Securing the WebSocket Connections`.\n```ballerina\n# Configures the SSL/TLS options to be used for WebSocket service.\npublic type ListenerSecureSocket record {|\n    *http:ListenerSecureSocket;\n|};\n```\n\nThe actual `ListenerSecureSocket` record in the HTTP package contains the following fields.\n```ballerina\n# Configures the SSL/TLS options to be used for HTTP service.\n#\n# + key - Configurations associated with `crypto:KeyStore` or combination of certificate and (PKCS8) private key of the server\n# + mutualSsl - Configures associated with mutual SSL operations\n# + protocol - SSL/TLS protocol related options\n# + certValidation - Certificate validation against OCSP_CRL, OCSP_STAPLING related options\n# + ciphers - List of ciphers to be used\n#             eg: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n# + shareSession - Enable/Disable new SSL session creation\n# + handshakeTimeout - SSL handshake time out\n# + sessionTimeout - SSL session time out\npublic type ListenerSecureSocket record {|\n    crypto:KeyStore|CertKey key;\n    record {|\n        VerifyClient verifyClient = REQUIRE;\n        crypto:TrustStore|string cert;\n    |} mutualSsl?;\n    record {|\n        Protocol name;\n        string[] versions = [];\n    |} protocol?;\n    record {|\n        CertValidationType 'type = OCSP_STAPLING;\n        int cacheSize;\n        int cacheValidityPeriod;\n    |} certValidation?;\n    string[] ciphers = [\"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\",\n                        \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\",\n                        \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\", \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\",\n                        \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n                        \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\"];\n    boolean shareSession = true;\n    decimal handshakeTimeout?;\n    decimal sessionTimeout?;\n|};\n```\n\n`RequestLimitConfigs` record represents configurations related to maximum sizes of URI, headers and entity body which is also an included record from the hTTP package as this will only be applicable to the initial WebSocket upgrade request.\n```ballerina\n# Provides inbound request URI, total header and entity body size threshold configurations.\npublic type RequestLimitConfigs record {|\n    *http:RequestLimitConfigs;\n|};\n```\n\nThe actual `RequestLimitConfigs` record in the HTTP package contains the following fields.\n```ballerina\n# Provides inbound request URI, total header and entity body size threshold configurations.\n#\n# + maxUriLength - Maximum allowed length for a URI. Exceeding this limit will result in a `414 - URI Too Long`\n#                  response\n# + maxHeaderSize - Maximum allowed size for headers. Exceeding this limit will result in a\n#                   `431 - Request Header Fields Too Large` response\n# + maxEntityBodySize - Maximum allowed size for the entity body. By default it is set to -1 which means there\n#                       is no restriction `maxEntityBodySize`, On the Exceeding this limit will result in a\n#                       `413 - Payload Too Large` response\npublic type RequestLimitConfigs record {|\n    int maxUriLength = 4096;\n    int maxHeaderSize = 8192;\n    int maxEntityBodySize = -1;\n|};\n```\n### 2.2. [Initialization](#22-initialization)\n\nThe WebSocket listener can be initialized by providing the `port` or a `http:Listener` and optionally a `ListenerConfiguration`.\n```ballerina\n# Gets invoked during the module initialization to initialize the listener.\n# ```ballerina\n# listener websocket:Listener securedEP = new(9090,\n#   secureSocket = {\n#       key: {\n#           certFile: \"../resource/path/to/public.crt\",\n#           keyFile: \"../resource/path/to/private.key\"\n#       }\n#   }\n# );\n# ```\n#\n# + port - Listening port of the WebSocket service listener\n# + config - Configurations for the WebSocket service listener\npublic isolated function init(int|http:Listener 'listener, *ListenerConfiguration config) returns Error? {\n```\n\n## 3. [Service Types](#3-service-types)\n\n### 3.1. [UpgradeService](#31-upgrade-service)\n\nUpgrade service is pretty much similar to an HTTP service. It has a single `get` resource, which takes in an `http:Request` optionally. The `get` resource returns a `websocket:Service` to which incoming messages get dispatched after a successful WebSocket connection upgrade. This resource can be used to intercept the initial HTTP upgrade with custom headers or to cancel the WebSocket upgrade by returning an error.\n\n#### 3.1.1. [UpgradeService Configurations](#311-upgradeservice-configurations)\n\nWhen writing the service, following configurations can be provided,\n```ballerina\n# Configurations for a WebSocket service.\n#\n# + subProtocols - Negotiable sub protocol by the service\n# + idleTimeout - Idle timeout for the client connection. Upon timeout, `onIdleTimeout` resource (if defined)\n#                          in the server service will be triggered. Note that this overrides the `timeout` config\n#                          in the `websocket:Listener` which is applicable only for the initial HTTP upgrade request.\n# + maxFrameSize - The maximum payload size of a WebSocket frame in bytes.\n#                  If this is not set or is negative or zero, the default frame size which is 65536 will be used.\n# + auth - Listener authenticaton configurations\npublic type WSServiceConfig record {|\n    string[] subProtocols = [];\n    decimal idleTimeout = 0;\n    int maxFrameSize = 65536;\n    ListenerAuthConfig[] auth?;\n|};\n```\n\n### 3.2. [WebSocket Service](#32-websocket-service)\n\nOnce the WebSocket upgrade is accepted by the UpgradeService, it returns a `websocket:Service`. This service has a fixed set of remote methods that do not have any configs. Receiving messages will get dispatched to the relevant remote method. Each remote method is explained below.\n\n```ballerina\nservice /ws on new websocket:Listener(21003) {\n    resource function get .(http:Request req) returns websocket:Service|websocket:UpgradeError {\n        return new WsService();\n    }    \n}\n        \nservice class WsService {\n    *websocket:Service;\n    remote isolated function onTextMessage(websocket:Caller caller, string data) returns websocket:Error? {\n        check caller->writeTextMessage(data);\n    }\n}              \n```\n\n#### 3.2.1. [Remote methods associated with WebSocket Service](#remote-methods-associated-with-websocket-service)\n\n##### [onOpen](#onopen)\n\nAs soon as the WebSocket handshake is completed and the connection is established, the `onOpen` remote method is dispatched.\n\n```ballerina\nremote function onOpen(websocket:Caller caller) returns error? {\n    io:println(\"Opened a WebSocket connection\");\n}\n```\n\n##### [onTextMessage](#ontextmessage)\n\nThe received text messages are dispatched to this remote method.\n\n```ballerina\nremote isolated function onTextMessage(websocket:Caller caller, string text) returns websocket:Error? {\n     io:println(\"Text message: \" + text);\n}\n```\n\n##### [onBinaryMessage](#onbinarymessage)\n\nThe received binary messages are dispatched to this remote method.\n\n```ballerina\nremote isolated function onBinaryMessage(websocket:Caller caller, byte[] data) returns websocket:Error? {\n    io:println(data);\n}\n```\n\n##### [onMessage](#onmessage)\n\nThe received messages are dispatched to this remote method. Data binding support is provided to accept the messages as `anydata`.\n\n```ballerina\nremote isolated function onMessage(websocket:Caller caller, json data) returns websocket:Error? {\n    io:println(data);\n}\n```\n\nData deserialization for text messages happens similar to the following,\n\n- If the contextually-expected data type is string, received data will be directly presented to the API without doing any deserialization.\n- If the contextually-expected data type is xml, received text data will be deserialized to xml.\n- All the other data types are treated as json and received text data will be deserialized to json.\n\nData deserialization for binary messages happens similar to the following,\n\n- If the contextually-expected data type is byte[], received data will be directly presented to the API without doing any deserialization.\n- If the contextually-expected data type is xml, received binary data will be first converted to the string representation of the byte[] and then deserialized to xml.\n- All the other data types are treated as json and received binary data will be first converted to the string representation of the byte[] and then will be deserialized to json.\n\nIf the data binding fails, the connection will get terminated by sending a close frame with the 1003 error code(1003 indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept ) and will print an error log at the listener side.\n\n##### [onPing and onPong](#onping-and-onpong)\n\nThe received ping and pong messages are dispatched to these remote methods respectively. You do not need to explicitly control these messages as they are handled automatically by the services and clients.\n\n```ballerina\nremote function onPing(websocket:Caller caller, byte[] data) returns error? {\n    io:println(string `Ping received with data: ${data.toBase64()}`);\n    check caller->pong(data);\n}\n \nremote function onPong(websocket:Caller caller, byte[] data) {\n    io:println(string `Pong received with data: ${data.toBase64()}`);\n}\n```\n\n##### [onIdleTimeout](#onidletimeout)\n\nThis remote method is dispatched when the idle timeout is reached. The idleTimeout has to be configured either in the WebSocket service or the client configuration.\n\n```ballerina\nremote function onIdleTimeout(websocket:Caller caller) {\n    io:println(\"Connection timed out\");\n}\n```\n\n##### [onClose](#onclose)\n\nThis remote method is dispatched when a close frame with a statusCode and a reason is received.\n\n```ballerina\nremote function onClose(websocket:Caller caller, int statusCode, string reason) {\n    io:println(string `Client closed connection with ${statusCode} because of ${reason}`);\n}\n```\n\n##### [onError](#onerror)\n\nThis remote method is dispatched when an error occurs in the WebSocket connection. This will always be preceded by a connection closure with an appropriate close frame.\n\n```ballerina\nremote function onError(websocket:Caller caller, error err) {\n    io:println(err.message());\n}\n```\n\n## 4. [Client](#4-client)\n\n`websocket:Client` can be used to send and receive data synchronously over WebSocket connection. The underlying implementation is non-blocking.\n\n### 4.1. [Client Configurations](#41-client-configurations)\n\nWhen initializing the client, following configurations can be provided,\n```ballerina\n# Client configurations for WebSocket clients.\n#\n# + subProtocols - Negotiable sub protocols of the client\n# + customHeaders - Custom headers, which should be sent to the server\n# + readTimeout - Read timeout (in seconds) of the client\n# + secureSocket - SSL/TLS-related options\n# + maxFrameSize - The maximum payload size of a WebSocket frame in bytes.\n#                  If this is not set, is negative, or is zero, the default frame size of 65536 will be used\n# + webSocketCompressionEnabled - Enable support for compression in the WebSocket\n# + handShakeTimeout - Time (in seconds) that a connection waits to get the response of\n#                               the WebSocket handshake. If the timeout exceeds, then the connection is terminated with\n#                               an error. If the value < 0, then the value sets to the default value(300)\n# + cookies - An Array of `http:Cookie`\n# + auth - Configurations related to client authentication\n# + pingPongHandler - A service to handle the ping/pong frames.\n#                     Resources in this service gets called on the receipt of ping/pong frames from the server\npublic type ClientConfiguration record {|\n    string[] subProtocols = [];\n    map<string> customHeaders = {};\n    decimal readTimeout = -1;\n    ClientSecureSocket? secureSocket = ();\n    int maxFrameSize = 65536;\n    boolean webSocketCompressionEnabled = true;\n    decimal handShakeTimeout = 300;\n    http:Cookie[] cookies?;\n    ClientAuthConfig auth?;\n    PingPongService pingPongHandler?;\n|};\n```\n### 4.2. [Initialization](#42-initialization)\n\nA client can be initialized by providing the WebSocket server url and optionally the `ClientConfiguration`.\n```ballerina\n# Initializes the synchronous client when called.\n# ```ballerina\n# websocket:Client wsClient = check new(\"ws://localhost:9090/foo\", { retryConfig: { maxCount: 20 } });\n# ```\n#\n# + url - URL of the target service\n# + config - The configurations to be used when initializing the client\npublic isolated function init(string url, *ClientConfiguration config) returns Error? {\n```\n\n### 4.3. [Send and receive messages using the Client](#43-send-and-receive-messages-using-the-client)\n\n#### [writeTextMessage](#writetextmessage)\n\n`writeTextMessage` API can be used to send a text message. It takes in the message to be sent as a `string` and returns an error if an error occurs while sending the text message to the connection.\n\n```ballerina\n# Writes text messages to the connection. If an error occurs while sending the text message to the connection, that message\n# will be lost.\n# ```ballerina\n# check wsClient->writeTextMessage(\"Text message\");\n# ```\n#\n# + data - Data to be sent.\n# + return  - A `websocket:Error` if an error occurs when sending\nremote isolated function writeTextMessage(string data) returns Error? {}\n```\n\n#### [writeBinaryMessage](#writebinarymessage)\n\n`writeBinaryMessage` API can be used to send a binary message. It takes in the message to be sent as a `byte[]` and returns an error if an error occurs while sending the binary message to the connection.\n\n```ballerina\n# Writes binary data to the connection. If an error occurs while sending the binary message to the connection,\n# that message will be lost.\n# ```ballerina\n# check wsClient->writeBinaryMessage(\"Text message\".toBytes());\n# ```\n#\n# + data - Binary data to be sent\n# + return  - A `websocket:Error` if an error occurs when sending\nremote isolated function writeBinaryMessage(byte[] data) returns Error? {}\n```\n\n#### [writeMessage](#writemessage)\n\n`writeMessage` API can be used to send messages. It takes in the message to be sent as subtypes of `anydata` and returns an error if an error occurs while sending the message to the connection.\nThe input data is internally converted to relevant frame type as follows,\n\n* subtypes of string, xml, json - write out using text frames\n* byte[] - write out using binary frames\n\n```ballerina\n# Writes messages to the connection. If an error occurs while sending the message to the connection, that message\n# will be lost.\n# ```ballerina\n# check wsClient->writeMessage({x: 1, y: 2});\n# ```\n#\n# + data - Data to be sent\n# + return  - A `websocket:Error` if an error occurs when sending\nremote isolated function writeMessage(anydata data) returns Error? {\n```\n\n#### [readTextMessage](#readtextmessage)\n\n`readTextMessage` API can be used to receive a text message. It returns the complete text message as a `string` or else an error if an error occurs while reading the messages.\n\n```ballerina\n# Reads text messages in a synchronous manner\n# ```ballerina\n# string textResp = check wsClient->readTextMessage();\n# ```\n#\n# + return  - The text data sent by the server or a `websocket:Error` if an error occurs when receiving\nremote isolated function readTextMessage() returns string|Error {}\n```\n\n#### [readBinaryMessage](#readbinarymessage)\n\n`readBinaryMessage` API can be used to receive a binary message. It returns the complete binary message as a `byte[]` or else an error if an error occurs while reading the messages.\n\n```ballerina\n# Reads binary data in a synchronous manner\n# ```ballerina\n# byte[] textResp = check wsClient->readBinaryMessage();\n# ```\n#\n# + return  - The binary data sent by the server or an `websocket:Error` if an error occurs when receiving\nremote isolated function readBinaryMessage() returns byte[]|Error {}\n```\n\n#### [readMessage](#readmessage)\n\n`readMessage` API can be used to receive a message without prior knowledge of message type. `anydata` type is supported by this API.\nThe contextually-expected data type is inferred from the LHS variable type. If there is an error when converting the expected data type or else any other error occurs while reading the messages, the respective error will be returned from the API \n\n```ballerina\n# Reads data from the WebSocket connection\n# ```ballerina\n# byte[]|string|websocket:Error data = wsClient->readMessage();\n# if (data is string) {\n#     io:println(data);\n# } else if (data is byte[]) {\n#     io:println(data);\n# } else {\n#     io:println(\"Error occurred\", data.message());\n# }\n#```\n#\n# + targetType - The payload type (sybtype of `anydata`), which is expected to be returned after data binding\n# + return - The data sent by the server or a `websocket:Error` if an error occurs when receiving\nremote isolated function readMessage(typedesc<anydata> targetType = <>) returns targetType|Error\n```\nWhen the receiving data are of the text frame type, data will be deserialized to the expected data type. If the incoming data is of binary frames, and if the LHS type is some other data type apart from byte[], incoming data will first be converted to the string representation of the binary data and then be converted to the expected data type.\n\nData deserialization for text messages happens similar to the following,\n\n- If the contextually-expected data type is string, received data will be directly presented to the API without doing any deserialization.\n- If the contextually-expected data type is xml, received text data will be deserialized to xml.\n- All the other data types are treated as json and received text data will be deserialized to json.\n\nData deserialization for binary messages happens similar to the following,\n\n- If the contextually-expected data type is byte[], received data will be directly presented to the API without doing any deserialization.\n- If the contextually-expected data type is xml, received binary data will be first converted to the string representation of the byte[] and then deserialized to xml.\n- All the other data types are treated as json and received binary data will be first converted to the string representation of the byte[] and then will be deserialized to json.\n\n#### [close](#close)\n\n`close` API can be used to close the connection. It takes in the optional parameters `statusCode` for closing the connection, `reason` for closing the connection if there is any and the `timeout` to wait until a close frame is received from the remote endpoint.\n\n```ballerina\n# Closes the connection.\n# ```ballerina\n# check wsClient->close();\n# ```\n#\n# + statusCode - Status code for closing the connection\n# + reason - Reason for closing the connection\n# + timeout - Time to wait (in seconds) for the close frame to be received from the remote endpoint before closing the\n#                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n#                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n#                   waits until a close frame is received. If the WebSocket frame is received from the remote\n#                   endpoint within the waiting period, the connection is terminated immediately.\n# + return - A `websocket:Error` if an error occurs while closing the WebSocket connection\nremote isolated function close(int? statusCode = 1000, string? reason = (), decimal timeout = 60) returns Error? {}\n```\n\n#### [ping](#ping)\n\n`ping` API can be used to send ping messages. It takes in the message to be sent as a `byte[]` and returns an error if an error occurs while sending the ping message to the connection.\n\n```ballerina\n# Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n# ```ballerina\n# check wsClient->ping([5, 24, 56, 243]);\n# ```\n#\n# + data - Binary data to be sent\n# + return  - A `websocket:Error` if an error occurs when sending\nremote isolated function ping(byte[] data) returns Error? {}\n```\n\n#### [pong](#pong)\n\n`pong` API can be used to send pong messages. It takes in the message to be sent as a `byte[]` and returns an error if an error occurs while sending the pong message to the connection.\n\n```ballerina\n# Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n# the frame will be lost.\n# ```ballerina\n# check wsClient->pong([5, 24, 56, 243]);\n# ```\n#\n# + data - Binary data to be sent\n# + return  - A `websocket:Error` if an error occurs when sending\nremote isolated function pong(byte[] data) returns Error? {}\n```\n\n#### [onPing and onPong remote methods](#onping-and-onpong-remote-methods)\n\nTo receive ping/pong messages, users have to register a `websocket:PingPongService` when creating the client. If the service is registered, receiving ping/pong messages will get dispatched to the `onPing` and `onPong` remote methods respectively.\n```ballerina\nservice class PingPongService {\n   *websocket:PingPongService;\n   remote function onPong(websocket:Caller wsEp, byte[] data) {\n       io:println(\"Pong received\", data);\n   }\n   \n   remote isolated function onPing(websocket:Caller caller, byte[] localData) returns byte[] {\n       return localData;\n   }    \n}\n\nwebsocket:Client wsClient = check new (\"ws://localhost:21020\", {pingPongHandler : new PingPongService()});\n```\nIf the user has implemented `onPing` on their service, it's user's responsibility to send the `pong` frame. It can be done simply by returning the data from the remote method, or else can be done using the `pong` API of websocket:Caller. If the user hasn't implemented the `onPing` remote method, `pong` will be sent automatically.\n\n## 5. [Securing the WebSocket Connections](#5-securing-the-websocket-connections)\n\nBallerina provides inbuilt support for SSL/TLS and configurations to enforce authentication and authorization such as Basic Auth, JWT auth, and OAuth2.\n\n### 5.1. [SSL/TLS](#51-ssl-tls)\nYou can configure a secure socket for your WebSocket listener and client to upgrade to a TCP connection with TLS.\n\nThe TLS-enabled Listener\n\n```ballerina\nlistener websocket:Listener wsListener = new(9090,\n    secureSocket = {\n        key: {\n             certFile: \"/path/to/public.crt\",\n             keyFile: \"/path/to/private.key\"\n        }\n    }\n);\n```\n\nThe TLS-enabled Client\n\n```ballerina\nwebsocket:Client wsClient = check new (string `wss://localhost:9090/taxi/${username}`,\n    secureSocket = {\n        cert: \"/path/to/public.crt\"\n    }\n);\n```\n\n### 5.2. [Authentication and Authorization](#52-authentication-and-authorization)\n\n#### Listener\n\nThe Ballerina WebSocket library provides built-in support for the following listener authentication mechanisms that are validated in the initial upgrade request.\n1. Basic authentication\n2. JWT authentication\n3. OAuth2 authentication\n\nTo enable one of the above, you should configure the `auth` field in `websocket:ServiceConfig` annotation which consists of the following records:\n1. FileUserStoreConfigWithScopes\n2. LdapUserStoreConfigWithScopes\n3. JwtValidatorConfigWithScopes\n4. OAuth2IntrospectionConfigWithScopes\n\nEach of the above records consists of configurations specific to each type as `FileUserStoreConfig` , `LdapUserStoreConfig` ,`JwtValidatorConfig` and `OAuth2IntrospectionConfig` respectively. You just have to configure them and there will be no need for any extensions or handlers. Ballerina will perform the required validation for you.\n\n```ballerina\n\nlistener websocket:Listener wsListener = new(9090,\n    secureSocket = {\n        key: {\n            certFile: \"../resource/path/to/public.crt\",\n            keyFile: \"../resource/path/to/private.key\"\n        }\n    }\n);\n\n@websocket:ServiceConfig {\n     auth: [\n        {\n            oauth2IntrospectionConfig: {\n                url: \"https://localhost:9445/oauth2/introspect\",\n                tokenTypeHint: \"access_token\",\n                scopeKey: \"scp\",\n                clientConfig: {\n                    secureSocket: {\n                        cert: \"../resource/path/to/introspect/service/public.crt\"\n                    }\n                }\n            },\n            scopes: [\"write\", \"update\"]\n        }\n    ]\n}\nservice /ws on wsListener {\n    resource function get .() returns websocket:Service|websocket:UpgradeError {\n        // ....\n    }\n}\n```\n\n#### Client\n\nThe Ballerina WebSocket client can be configured to send authentication information to the endpoint being invoked. The Ballerina WebSocket library also has built-in support for the following client authentication mechanisms.\n1. Basic authentication\n2. JWT authentication\n3. OAuth2 authentication\n\nThe following code snippet shows how a WebSocket client can be configured to call a secured endpoint. The `auth` field of the client configurations (websocket:ClientConfiguration) should have either one of the `CredentialsConfig`, `BearerTokenConfig`, `JwtIssuerConfig`, `OAuth2ClientCredentialsGrantConfig`, `OAuth2PasswordGrantConfig`, and `OAuth2RefreshTokenGrantConfig` records. Once this is configured, Ballerina will take care of the rest of the validation process.\n\n```ballerina\nwebsocket:Client wsClient = check new (string `wss://localhost:9090/taxi/${username}`,\n     auth = {\n         tokenUrl: \"https://localhost:9445/oauth2/token\",\n         username: \"johndoe\",\n         password: \"A3ddj3w\",\n         clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68\",\n         clientSecret: \"9205371918321623741\",\n         scopes: [\"write\", \"update\"],\n         clientConfig: {\n             secureSocket: {\n                 cert: \"../resource/path/to/introspect/service/public.crt\"\n             }\n         }\n     },\n     secureSocket = {\n         cert: \"../resource/path/to/public.crt\"\n     }\n);\n```\n\n## 6. [Samples](#6-samples)\n\nListener\n\n```ballerina\nimport ballerina/io;\nimport ballerina/websocket;\n\nservice /basic/ws on new websocket:Listener(9090) {\n   resource isolated function get .() returns websocket:Service|websocket:Error {\n       return new WsService();\n   }\n}\n\nservice class WsService {\n    *websocket:Service;\n    remote isolated function onTextMessage(websocket:Caller caller, string text) returns websocket:Error? {\n        io:println(\"Text message: \" + text);\n        check caller->writeTextMessage(text);\n    }\n    \n    remote isolated function onBinaryMessage(websocket:Caller caller, byte[] data) returns websocket:Error? {\n        io:println(data);\n        check caller->writeBinaryMessage(data);\n    }\n}\n```\n\nClient\n\n```ballerina\nimport ballerina/io;\nimport ballerina/websocket;\n\npublic function main() returns error? {\n   websocket:Client wsClient = check new(\"ws://localhost:9090/basic/ws\");\n\n   check wsClient->writeTextMessage(\"Text message\");\n\n   string textResp = check wsClient->readTextMessage();\n   io:println(textResp);\n   \n   check wsClient->writeBinaryMessage(\"Binary message\".toBytes());\n\n   byte[] byteResp = check wsClient->readBinaryMessage();\n   string stringResp = check 'string:fromBytes(byteResp);\n   io:println(stringResp);\n}\n```","codeSnippets":"[[-734236871,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Provides a set of configurations for HTTP service endpoints.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + host - The host name/IP of the endpoint</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + http1Settings - Configurations related to HTTP/1.x protocol</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + secureSocket - The SSL configurations for the service endpoint. This needs to be configured in order to</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                  communicate through WSS.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + timeout - Period of time in seconds that a connection waits for a read/write operation in the</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                     initial upgrade request. Use value 0 to disable timeout</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + server - The server name which should appear as a response header</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + webSocketCompressionEnabled - Enable support for compression in WebSocket</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + requestLimits - Configurations associated with inbound request size limits</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type ListenerConfiguration record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    string host = &quot;0.0.0.0&quot;;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    ListenerHttp1Settings http1Settings = {};</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    ListenerSecureSocket secureSocket?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    decimal timeout = 120;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    string? server = ();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    boolean webSocketCompressionEnabled = true;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    RequestLimitConfigs requestLimits = {};</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[-754871896,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Provides settings related to HTTP/1.x protocol.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type ListenerHttp1Settings record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    *http:ListenerHttp1Settings;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[1093538446,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Provides settings related to HTTP/1.x protocol.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + keepAlive - Can be set to either `KEEPALIVE_AUTO`, which respects the `connection` header, or `KEEPALIVE_ALWAYS`,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#               which always keeps the connection alive, or `KEEPALIVE_NEVER`, which always closes the connection</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + maxPipelinedRequests - Defines the maximum number of requests that can be processed at a given time on a single</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                          connection. By default 10 requests can be pipelined on a single connection and user can</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                          change this limit appropriately.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type ListenerHttp1Settings record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    KeepAlive keepAlive = KEEPALIVE_AUTO;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    int maxPipelinedRequests = MAX_PIPELINED_REQUESTS;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[1781974013,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Configures the SSL/TLS options to be used for WebSocket service.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type ListenerSecureSocket record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    *http:ListenerSecureSocket;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[584834866,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Configures the SSL/TLS options to be used for HTTP service.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + key - Configurations associated with `crypto:KeyStore` or combination of certificate and (PKCS8) private key of the server</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + mutualSsl - Configures associated with mutual SSL operations</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + protocol - SSL/TLS protocol related options</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + certValidation - Certificate validation against OCSP_CRL, OCSP_STAPLING related options</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + ciphers - List of ciphers to be used</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#             eg: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + shareSession - Enable/Disable new SSL session creation</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + handshakeTimeout - SSL handshake time out</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + sessionTimeout - SSL session time out</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type ListenerSecureSocket record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    crypto:KeyStore|CertKey key;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        VerifyClient verifyClient = REQUIRE;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        crypto:TrustStore|string cert;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    |} mutualSsl?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        Protocol name;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        string[] versions = [];</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    |} protocol?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        CertValidationType &#39;type = OCSP_STAPLING;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        int cacheSize;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        int cacheValidityPeriod;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    |} certValidation?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    string[] ciphers = [&quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">                        &quot;TLS_DHE_RSA_WITH_AES_128_CBC_SHA256&quot;, &quot;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">                        &quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_DHE_RSA_WITH_AES_128_CBC_SHA&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">                        &quot;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&quot;, &quot;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">                        &quot;TLS_DHE_RSA_WITH_AES_128_GCM_SHA256&quot;];</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    boolean shareSession = true;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    decimal handshakeTimeout?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    decimal sessionTimeout?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[-67726219,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Provides inbound request URI, total header and entity body size threshold configurations.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type RequestLimitConfigs record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    *http:RequestLimitConfigs;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[968704605,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Provides inbound request URI, total header and entity body size threshold configurations.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + maxUriLength - Maximum allowed length for a URI. Exceeding this limit will result in a `414 - URI Too Long`</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                  response</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + maxHeaderSize - Maximum allowed size for headers. Exceeding this limit will result in a</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                   `431 - Request Header Fields Too Large` response</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + maxEntityBodySize - Maximum allowed size for the entity body. By default it is set to -1 which means there</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                       is no restriction `maxEntityBodySize`, On the Exceeding this limit will result in a</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                       `413 - Payload Too Large` response</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type RequestLimitConfigs record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    int maxUriLength = 4096;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    int maxHeaderSize = 8192;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    int maxEntityBodySize = -1;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[293655353,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Gets invoked during the module initialization to initialize the listener.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[-1180317236,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Configurations for a WebSocket service.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + subProtocols - Negotiable sub protocol by the service</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + idleTimeout - Idle timeout for the client connection. Upon timeout, `onIdleTimeout` resource (if defined)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                          in the server service will be triggered. Note that this overrides the `timeout` config</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                          in the `websocket:Listener` which is applicable only for the initial HTTP upgrade request.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + maxFrameSize - The maximum payload size of a WebSocket frame in bytes.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                  If this is not set or is negative or zero, the default frame size which is 65536 will be used.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + auth - Listener authenticaton configurations</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type WSServiceConfig record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    string[] subProtocols = [];</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    decimal idleTimeout = 0;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    int maxFrameSize = 65536;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    ListenerAuthConfig[] auth?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[1166286326,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">service /ws on new websocket:Listener(21003) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    resource function get .(http:Request req) returns websocket:Service|websocket:UpgradeError {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        return new WsService();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    }    </span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        </span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">service class WsService {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    *websocket:Service;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    remote isolated function onTextMessage(websocket:Caller caller, string data) returns websocket:Error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        check caller-&gt;writeTextMessage(data);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[-1302701193,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote function onOpen(websocket:Caller caller) returns error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    io:println(&quot;Opened a WebSocket connection&quot;);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[1596162690,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote isolated function onTextMessage(websocket:Caller caller, string text) returns websocket:Error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">     io:println(&quot;Text message: &quot; + text);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[-1010609306,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote isolated function onBinaryMessage(websocket:Caller caller, byte[] data) returns websocket:Error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    io:println(data);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[1202348295,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote isolated function onMessage(websocket:Caller caller, json data) returns websocket:Error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    io:println(data);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[1847716186,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote function onPing(websocket:Caller caller, byte[] data) returns error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    io:println(string `Ping received with data: ${data.toBase64()}`);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    check caller-&gt;pong(data);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"> </span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote function onPong(websocket:Caller caller, byte[] data) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    io:println(string `Pong received with data: ${data.toBase64()}`);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[-1177600348,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote function onIdleTimeout(websocket:Caller caller) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    io:println(&quot;Connection timed out&quot;);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[-1683095243,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote function onClose(websocket:Caller caller, int statusCode, string reason) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    io:println(string `Client closed connection with ${statusCode} because of ${reason}`);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[-546541450,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">remote function onError(websocket:Caller caller, error err) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    io:println(err.message());</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[-1053537033,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Client configurations for WebSocket clients.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + subProtocols - Negotiable sub protocols of the client</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + customHeaders - Custom headers, which should be sent to the server</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + readTimeout - Read timeout (in seconds) of the client</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + secureSocket - SSL/TLS-related options</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + maxFrameSize - The maximum payload size of a WebSocket frame in bytes.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                  If this is not set, is negative, or is zero, the default frame size of 65536 will be used</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + webSocketCompressionEnabled - Enable support for compression in the WebSocket</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + handShakeTimeout - Time (in seconds) that a connection waits to get the response of</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                               the WebSocket handshake. If the timeout exceeds, then the connection is terminated with</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                               an error. If the value &lt; 0, then the value sets to the default value(300)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + cookies - An Array of `http:Cookie`</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + auth - Configurations related to client authentication</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># + pingPongHandler - A service to handle the ping/pong frames.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#                     Resources in this service gets called on the receipt of ping/pong frames from the server</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public type ClientConfiguration record {|</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    string[] subProtocols = [];</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    map&lt;string&gt; customHeaders = {};</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    decimal readTimeout = -1;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    ClientSecureSocket? secureSocket = ();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    int maxFrameSize = 65536;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    boolean webSocketCompressionEnabled = true;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    decimal handShakeTimeout = 300;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    http:Cookie[] cookies?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    ClientAuthConfig auth?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    PingPongService pingPongHandler?;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">|};</span></span></code></pre>\"],[-688216807,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Initializes the synchronous client when called.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[-2085498474,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Writes text messages to the connection. If an error occurs while sending the text message to the connection, that message</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># will be lost.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[-1476398578,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Writes binary data to the connection. If an error occurs while sending the binary message to the connection,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># that message will be lost.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[1024870482,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Writes messages to the connection. If an error occurs while sending the message to the connection, that message</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># will be lost.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[-737562902,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Reads text messages in a synchronous manner</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[853396468,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Reads binary data in a synchronous manner</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[-315250785,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Reads data from the WebSocket connection</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[508834578,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Closes the connection.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[-336495444,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[-379944034,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\"># the frame will be lost.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">#</span></span></code></pre>\"],[1082948394,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">service class PingPongService {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   *websocket:PingPongService;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   remote function onPong(websocket:Caller wsEp, byte[] data) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">       io:println(&quot;Pong received&quot;, data);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   </span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   remote isolated function onPing(websocket:Caller caller, byte[] localData) returns byte[] {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">       return localData;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   }    </span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">websocket:Client wsClient = check new (&quot;ws://localhost:21020&quot;, {pingPongHandler : new PingPongService()});</span></span></code></pre>\"],[-2065315187,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">listener websocket:Listener wsListener = new(9090,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    secureSocket = {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        key: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">             certFile: &quot;/path/to/public.crt&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">             keyFile: &quot;/path/to/private.key&quot;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">);</span></span></code></pre>\"],[-11872543,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">websocket:Client wsClient = check new (string `wss://localhost:9090/taxi/${username}`,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    secureSocket = {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        cert: &quot;/path/to/public.crt&quot;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">);</span></span></code></pre>\"],[-353498249,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">istener websocket:Listener wsListener = new(9090,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   secureSocket = {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">       key: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">           certFile: &quot;../resource/path/to/public.crt&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">           keyFile: &quot;../resource/path/to/private.key&quot;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">       }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">;</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">websocket:ServiceConfig {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    auth: [</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">       {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">           oauth2IntrospectionConfig: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">               url: &quot;https://localhost:9445/oauth2/introspect&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">               tokenTypeHint: &quot;access_token&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">               scopeKey: &quot;scp&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">               clientConfig: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">                   secureSocket: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">                       cert: &quot;../resource/path/to/introspect/service/public.crt&quot;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">                   }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">               }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">           },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">           scopes: [&quot;write&quot;, &quot;update&quot;]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">       }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   ]</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">ervice /ws on wsListener {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   resource function get .() returns websocket:Service|websocket:UpgradeError {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">       // ....</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   }</span></span></code></pre>\"],[-1806675342,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">websocket:Client wsClient = check new (string `wss://localhost:9090/taxi/${username}`,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">     auth = {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         tokenUrl: &quot;https://localhost:9445/oauth2/token&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         username: &quot;johndoe&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         password: &quot;A3ddj3w&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         clientId: &quot;3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         clientSecret: &quot;9205371918321623741&quot;,</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         scopes: [&quot;write&quot;, &quot;update&quot;],</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         clientConfig: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">             secureSocket: {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">                 cert: &quot;../resource/path/to/introspect/service/public.crt&quot;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">             }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">     },</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">     secureSocket = {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">         cert: &quot;../resource/path/to/public.crt&quot;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">     }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">);</span></span></code></pre>\"],[1238435662,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">import ballerina/io;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">import ballerina/websocket;</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">service /basic/ws on new websocket:Listener(9090) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   resource isolated function get .() returns websocket:Service|websocket:Error {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">       return new WsService();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">service class WsService {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    *websocket:Service;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    remote isolated function onTextMessage(websocket:Caller caller, string text) returns websocket:Error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        io:println(&quot;Text message: &quot; + text);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        check caller-&gt;writeTextMessage(text);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    </span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    remote isolated function onBinaryMessage(websocket:Caller caller, byte[] data) returns websocket:Error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        io:println(data);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">        check caller-&gt;writeBinaryMessage(data);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">    }</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"],[-1423503914,\"<pre class=\\\"shiki\\\" style=\\\"background-color: #ffffff\\\"><code><span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">import ballerina/io;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">import ballerina/websocket;</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">public function main() returns error? {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   websocket:Client wsClient = check new(&quot;ws://localhost:9090/basic/ws&quot;);</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   check wsClient-&gt;writeTextMessage(&quot;Text message&quot;);</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   string textResp = check wsClient-&gt;readTextMessage();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   io:println(textResp);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   </span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   check wsClient-&gt;writeBinaryMessage(&quot;Binary message&quot;.toBytes());</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   byte[] byteResp = check wsClient-&gt;readBinaryMessage();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   string stringResp = check &#39;string:fromBytes(byteResp);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">   io:println(stringResp);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"color: #24292F\\\">}</span></span></code></pre>\"]]"},"__N_SSG":true}