{"pageProps":{"frontmatter":{"layout":"ballerina-left-nav-release-notes","title":"Swan Lake Beta4","permalink":"/downloads/swan-lake-release-notes/swan-lake-beta4/","active":"swan-lake-beta4","redirect_from":["/downloads/swan-lake-release-notes/swan-lake-beta4"]},"content":"## Overview of Ballerina Swan Lake Beta4\n\n<em>This is the fourth Beta release in a series of planned Alpha and Beta releases leading up to the Ballerina Swan Lake GA release.</em> \n\nIt introduces the new language features planned for the Swan Lake GA release and includes improvements and bug fixes done to the compiler, runtime, standard library, and developer tooling after the Swan Lake Beta3 release.\n\n## Updating Ballerina\n\nIf you are already using Ballerina, you can use the [update tool](/learn/cli-documentation/update-tool/) to directly update to Ballerina Swan Lake Beta4 as follows. \n\nTo do this, first, execute the command below to get the update tool updated to its latest version. \n\n> `bal update`\n\nIf you are using an **update tool version below 0.8.14**, execute the `ballerina update` command to update it. Next, execute the command below to update to Swan Lake Beta4.\n\n> `bal dist pull slbeta4`\n\n## Installing Ballerina\n\nIf you have not installed Ballerina, then download the [installers](/downloads/#swanlake) to install.\n\n## Language updates\n\n### New features\n\n#### Support for numeric operations with operands of optional numeric types\n\nUpdated unary expressions (`+`, `-`, and `~`), multiplicative expressions, additive expressions, shift expressions, and binary bitwise expressions to be used with operands of optional numeric types. If the static type of an operand is an optional numeric type, the static type of the result will also be an optional numeric type.\n\nThe examples below are allowed now.\n\n```ballerina\nimport ballerina/io;\n\npublic function main() {\n    int? a = 10;\n    int? b = 5;\n    int? c = ();\n\n    int? d = a + b;\n    io:println(d is ()); // Prints `false`.\n    io:println(d); // Prints `15`.\n\n    int? e = a - c;\n    io:println(e is ()); // Prints `true`.\n\n    // Also allowed.\n    int? f = a * b;\n    int? g = a << c;\n    int? h = a & b;\n    int? i = -a;\n    int? j = +c; // The result is `()`.\n}\n```\n\n#### Support for accessing optional fields of a record using field access\n\nUpdated optional fields of records, which are of types that do not include nil to be accessed using field access expressions.\n\n```ballerina\ntype Employee record {\n    string name;\n    int id?;\n    string? department?;\n};\n\npublic function main() {\n    Employee employee = {\n        name: \"John\",\n        department: \"finance\"\n    };\n    int? id = employee.id;\n}\n```\n\nHowever, the below is still not allowed since the field's type includes nil.\n\n```ballerina\nstring? department = employee.department; // Error.\n```\n\nIf the static type of the expression on which the access is done is a non-lax union type, field access is allowed only if it is a union of record types and\n- each member of the union has a required field with the specific field name or\n- each member of the union has either a required field or an optional field with the specific field name, and the type of the field in each record type does not include nil\n\n```ballerina\ntype Employee record {|\n    string name;\n    string? dob;\n    float salary?;\n|};\n\ntype Person record {|\n    string name?;\n    string dob?;\n|};\n\npublic function main() {\n    Employee|Person val = <Person> {\n        name: \"Jo\",\n        dob: \"1990-01-10\"\n    };\n\n    // This is allowed now since `name` is an optional field in `Person`\n    // and a required field in `Employee`, and the type of the field is `string` \n    // in both records and does not include nil.\n    string? _ = val.name;\n\n    // This is not allowed even though `dob` is an optional field in `Person`\n    // and a required field in `Employee`, since the type of `dob` in `Employee`, `string?`,\n    // includes nil.\n    string? _ = val.dob;\n\n    // This is not allowed since `salary` is neither a required field nor an optional \n    // field in `Person`.\n    float? _ = val.salary;\n}\n```\n\n### Improvements\n\n#### Restrictions when calling a function or a method in a match guard\n\nIntroduced restrictions for when a function or a method is called in a match guard to ensure that the match guard does not mutate the value being matched.\n\nA function or method call is allowed now in a match guard only if it meets one of the conditions below.\n- the type of the expression following `match` is a subtype of `readonly` or\n- the function/method is `isolated` and the types of any and all arguments are subtypes of `readonly`\n\nThe below will now result in compilation errors.\n\n```ballerina\ntype Data record {\n    string name;\n    boolean valid;\n    int id?;\n    decimal price?;\n};\n\npublic function main() {\n    Data data = {name: \"Jo\", valid: false};\n    [int, decimal] currentValues = [1234, 20.5];\n\n    match data {\n        var {id, price} => {\n        }\n        // Now, this results in compilation errors for the match guard since neither the type of the \n        // matched expression nor the types of the arguments are subtypes of `readonly`.\n        var {name} if stillValid(data, currentValues) => {\n        }\n    }\n}\n\nisolated function stillValid(Data data, [int, decimal] values) returns boolean {\n    // ...\n    data.id = values[0];\n    data.price = values[1];\n    return false;\n}\n```\n\n#### Improved support for unreachability\n\nImproved the unreachability analysis of `if-else` statements and `while` statements. Constant conditions that are known to be either true or false at compile-time are now considered in the unreachability analysis.\n\nThe conditions below are taken into consideration in the analysis of unreachability.\n\n1. If a statement block is unreachable, then every statement in it is unreachable.\n2. The `if` statements with constant conditions are not errors except `insofar` as they lead to statements being unreachable.\n3. An `is` expression is constantly `true` if the static type of the expression is a subtype of the type against which the check is done. \n4. Calling a function with a return type of `never` cannot complete normally making subsequent code unreachable.\n\n```ballerina\nimport ballerina/io;\n\nfunction fn1() {\n    if false {\n        io:println(\"unreachable\"); // This will now result in a compilation error: unreachable code.\n    }\n\n    while false {\n        io:println(\"unreachable\"); // This will now result in a compilation error: unreachable code.\n    }\n}\n\nfunction fn2() {\n    if true {\n        io:println(\"reachable\");\n    } else {\n        io:println(\"unreachable\"); // This will now result in a compilation error: unreachable code.\n    }\n}\n\nfunction fn3() {\n    if true {\n        return;\n    }\n    io:println(\"unreachable\"); // This will now result in a compilation error: unreachable code.\n}\n\nfunction fn4() {\n    while true {\n        return;\n    }\n    io:println(\"unreachable\"); // This will now result in a compilation error: unreachable code.\n}\n```\n\nThe below is another example.\n\n```ballerina\nenum E {\n    X,\n    Y,\n    Z\n}\n\nfunction fn1(E e) {\n    if e is X {\n        doX();\n    } else if e is Y {\n        doY();\n    } else if e is Z {\n        doZ();\n    } else {\n        // Any statement in this block will now be unreachable.\n    }\n}\n\nfunction fn2(E e) {\n    if e is X {\n        doX();\n    } else if e is Y {\n        doY();\n    } else if e is Z {\n        doZ();\n    } else if e is Y {\n        // Any statement in this block will now be unreachable.\n    }\n}\n\nfunction fn3(E e) returns int {\n    if e is X {\n        return 1;\n    }\n    if e is Y {\n        return 2;\n    }\n    if e is Z {\n        return 3;\n    }\n    // Any statement here will now be unreachable.\n}\n```\n\n#### Type narrowing following an `if` statement without an `else` block if the `if` statement block cannot complete normally\n\nNarrowed the types following an `if` statement without an `else` block, if the `if` statement block cannot complete normally by building on the improvements introduced to the unreachabillity analysis.\n\n```ballerina\nfunction populate(int[] arr, string str) returns error? {\n    int|error res = int:fromString(str);\n\n    if res is error {\n        return error(\"Invalid Value\", res);\n    }\n\n    // The type of `res` is now narrowed to `int` here.\n    // The variable `res` can be used as an `int` and can therefore be used in an `array:push` call with an `int[]`.\n    arr.push(res);\n}\n```\n\nThis narrowing may lead to other compilation errors since the static type of the variable will now be a narrowed type.\n\n```ballerina\nfunction populate(int[] arr, string str) returns error? {\n    int|error res = int:fromString(str);\n\n    if res is error {\n        return error(\"Invalid Value\", res);\n    }\n\n    // This was previously allowed but now a compilation error since `res`'s type is now `int` and doesn't include `error`.\n    int intRes = check res;\n\n    arr.push(intRes);\n}\n```\n\n#### Restrictions on assignments to narrowed variables within loops\n\nStopped the possibility to assign a value to a variable that was narrowed outside the statement within a `while` statement or a `foreach` statement. Unless the loop terminates after the assignment (i.e., at the end of the loop body and at every `continue` statement), there must be no possibility that a narrowed variable to be assigned.\n\nThe example below which previously resulted in a runtime panic will now result in a compilation error.\n\n```ballerina\nfunction validate(int?[] arr) returns boolean {\n    int? value = let int length = arr.length()\n        in length > 0 ? length : ();\n\n    if value is int {\n        foreach int? item in arr {\n            int currentValue = value;\n\n            if item is () {\n                value = (); // Error: invalid attempt to assign a value to a variable narrowed outside the loop.\n                continue;\n            }\n\n            return item < value;\n        }\n    }\n\n    return false;\n}\n\npublic function main() {\n    boolean validationRes = validate([(), 2, 1]);\n}\n```\n\n#### Change in expected return statements in a function with an optional type as the return type\n\nUpdated a function having an optional type that is not a subtype of `error?` as the return type to explicitly return a value. A warning is emitted when such a function does not explicitly return a value and falls off at the end of the function body. \n\n```ballerina\nfunction parse(string str) returns int? { // Now, results in a warning. \n    int|error a = int:fromString(str);\n    if a is int {\n        return a;\n    }\n}\n```\n\n### Bug fixes and breaking changes\n\n- Disallowed the trailing dot format of the floating-point literal to avoid lexical ambiguity.\n\n    ```ballerina\n    // The below are now disallowed.\n    decimal d1 = 2.;\n    decimal d2 = 2.d;\n    decimal d3 = 2.D;\n    decimal d4 = 2.e12;\n    float f1 = 2.f;\n    float f2 = 2.F;\n    float f3 = 0x1A.;\n    float f4 = 0x1A.p4;\n\n    // The below can be used instead.\n    decimal d11 = 2.0;\n    decimal d12 = 2.0d;\n    decimal d13 = 2.0D;\n    decimal d14 = 2.0e12;\n    float f11 = 2.0f;\n    float f12 = 2.0F;\n    float f13 = 0x1A.0;\n    float f14 = 0x1A.0p4;\n    ```\n\n- Disallowed intervening white spaces in the qualified identifier to avoid a parsing ambiguity between the ternary conditional expression and qualified identifier.\n  \n    ```ballerina\n    import ballerina/io;\n\n    public function main() {\n        io:print(\"Ballerina\"); // Valid.\n        io : print(\"Ballerina\"); // Compilation error: intervening whitespaces are not allowed in a qualified identifier.\n    }\n    ```\n\n    With this, `x ? a : b:c` will now be parsed as `x ? a : (b:c)` since the colon with spaces is interpreted only as part of a conditional expression.\n\n- Fixed a bug that resulted in hash collisions not being handled correctly in `table` values.\n\n    ```ballerina\n    import ballerina/io;\n    \n    public function main() {\n        table<record {readonly int? k;}> key(k) t = table [];\n        t.add({k: 0});\n        io:println(t.hasKey(()));\n    }\n    ```\n\n    The above code snippet, which previously printed `true` will now print `false`.\n\n- Disallowed object type inclusions with an object that has private fields or members.\n\n    ```ballerina\n    class Person {\n        string firstName;\n        string lastName;\n        private string dob;\n\n        function init(string firstName, string lastName, string dob) {\n            self.firstName = firstName;\n            self.lastName = lastName;\n            self.dob = dob;\n        }\n\n        private function getName() returns string => self.firstName + self.lastName;\n    }\n    \n    class Employee {\n        *Person; // Will now result in an error.\n        int id;\n\n        function init(string firstName, string lastName, string dob, int id) {\n            self.firstName = firstName;\n            self.lastName = lastName;\n            self.dob = dob;       \n            self.id = id;\n        }\n\n        private function getName() returns string => self.firstName;\t\n    }\n    ```\n\n- Fixed a bug that resulted in compilation errors not being emitted for invalid `xml` template expressions.\n\n    ```ballerina\n    xml x = xml `</>`; // Will now result in an error.\n    ```\n\n- Fixed a bug that resulted in compilation errors not being emitted for duplicate fields written with escape sequences in the mapping constructor.\n\n    ```ballerina\n    map<any> x = {a\\\\: 454, \"a\\\\\": false}; // Will now result in an error.\n    ```\n\n- Updated the `xml:createElement` to accept the attribute map as the second argument.\n\n    ```ballerina\n    xml:Element jo = xml:createElement(\"name\", {id: \"1234\"}, xml `Jo`);\n    ```\n\n- Updated the `xml:get` function’s return type to return the exact type `T` when the `xml` sequence is of type `xml<T>`.\n\n    ```ballerina\n    xml<xml:Element> employees = xml `<e1><name>Jo</name></e1><e2><name>Mary</name></e2>`;\n    xml:Element employee1 = employees.get(0);// Allowed now.\n    ```\n\n- Updated the `table:map` function’s function argument `func` and the return type to work with subtypes of mapping types instead of any type.\n\n    ```ballerina\n    table<record {int id; string name;}> tb = table [\n            {id: 1234, name: \"Jo\"},\n            {id: 2345, name: \"May\"}\n        ];\n\n    var idTable = tb.map(function(record {int id; string name;} r) returns int { // No longer allowed.\n        return r.id;\n    });\n    ```\n\n- Corrected a few deviations in the `lang.error` module according to the language specification. The `CallStack` class and `CallStackElement` records have been removed. Now, a stack frame is represented by an `error:StackFrame` object.\n\t\n    Prior to Swan Lake Beta4, the `error:stackTrace()` function returned an `error:CallStack` object which had the structure below which was a deviation from the specification.\n\n    ```ballerina\n    public class CallStack {\n        public CallStackElement[] callStack = [];\n    }\n    ```\n\n    This has now been fixed, and it is no longer possible to retrieve an `error:CallStack` object or directly access the `callStack` array as shown below.\n\n    ```ballerina\n    error:CallStack callStack = err.stackTrace(); // `CallStack` is undefined.\n    error:CallStackElement[] elements = err.stackTrace().callStack; // Not allowed, `CallStackElement` is undefined, no `callStack` field.\n    ```\n\n    The `error:stackTrace` function now returns an array of `StackFrame` objects.\n\n    ```ballerina\n    public type StackFrame readonly & object {\n        public function toString() returns string;\n    };\n    ```\n\n    ```ballerina\n    error:StackFrame[] stackTrace = e.stackTrace(); // Now, returns `error:StackFrame[]`.\n    ```\n\n- Made the return type of the `error:detail` function in the `lang.error` module a subtype of `readonly`. It is the intersection of `readonly` and the detail type of the error.\n\n    ```ballerina\n    type Detail record {|\n        int code;\n    |};\n\n    type Error error<Detail>;\n\n    function fn(Error e) {\n        Detail & readonly detail = e.detail(); // Allowed now.\n    }\n    ```\n\n- Fixed a deviation in the `stream:next` function’s stream argument name. The name has been changed from `strm` to `stm`.\n\n- Fixed a bug in `array:sort`, which was sorting the original list. The function now returns a new sorted array. The original array remains unchanged.\n\n- Changed the name of the argument to `transaction:setData()` from `e` to `data`. Moreover, changed the static type of the argument to `transaction:setData()` and the return type of `lang.transaction:getData()` to `readonly`. They were previously of type `(any|error) & readonly` and even this change would accept/return the same set of values.\n\n- Updated the `float:min()` and `float:max()` functions to return `float:NaN` if an argument is `float:NaN`. \n\n    ```ballerina\n    import ballerina/io;\n\n    public function main() {\n        float result = float:min(1, float:NaN);\n        io:println(result === float:NaN); // Prints `true`.\n\n        result = float:max(5, float:NaN);\n        io:println(result === float:NaN); // Prints `true`.\n    }\n    ```\n\n- Fixed a bug in the `decimal:fromString()` function, which allowed parsing a string that matched the `HexFloatingPointLiteral`. It now returns an error.\n\n    ```ballerina\n    import ballerina/io;\n\n    public function main() {\n        decimal|error result = decimal:fromString(\"0xab12\"); // Now, returns an error.\n        io:println(result is error); // Prints `true`.\n    }\n    ```\n\n- Fixed a bug in the `float:fromString()` function allowed parsing a string that had matched a `DecimalFloatingPointNumber` with `FloatingPointTypeSuffix`. This will now return an error.\n\n    ```ballerina\n    import ballerina/io;\n\n    public function main() {\n        float|error result = float:fromString(\"12.24f\"); // Now, returns an error.\n        io:println(result is error); // Prints `true`.\n    }\n    ```\n\n- Updated the `float:fromHexString()` function to return an error if the provided string argument does not match a `HexFloatingPointLiteral`. \n\n    ```ballerina\n    import ballerina/io;\n\n    public function main() {\n        float|error result = float:fromHexString(\"12.3\");\n        io:println(result is error); // Prints `true`, error message - invalid hex string: ‘12.3’.\n    }\n    ```\n\n- Fixed a spec deviation in the `int:toHexString`, which was causing it to convert negative values to a positive number before converting to a hexadecimal string.\n\n- Fixed a deviation in the `lang.error` `RetryManager` and `DefaultRetryManager` objects' `shouldRetry` method argument type. The type has been changed from `error?` to `error`.\n\t\n    ```ballerina\n    public class CustomRetryManager {\n        private int count;\n        public function init(int count = 3) {\n            self.count = count;\n        }\n        public function shouldRetry(error e) returns boolean {\n            if e is CustomError && self.count > 0 {\n                self.count -= 1;\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n    ```\n\n- Updated the attempting to use an out of range float value where the applicable contextually-expected type is `float` to result in a compile-time error.\n\n    ```ballerina\n    public function main() {\n        float x = 945e99876; // Will now result in an error.\n    }\n    ```\n\n- Fixed the spec deviations related to identifying the types of numeric literals. \n\n    If the numeric literal does not include the float type suffix or the decimal type suffix and if it is not a hex floating-point literal, the type of the numeric literal will be based on the rules below.\n\n    1. If the literal is a floating-point literal, then the possible basic types in order of preference are `[float, decimal]`. Otherwise, they are `[int, float, decimal]`.\n    2. If there is a contextually-expected type `C` and there is an intersection between `C` and the possible numeric basic types identified above, use the most preferred such type.\n    3. Otherwise, use the most preferred possible basic type.\n\n    ```ballerina\n    import ballerina/io;\n\n    type Foo 1f|1d|2d;\n\n    public function main() {\n        int|float|decimal l = 10;\n        io:println(l is int); // Prints `true`.\n\n        decimal|float m = 5.5;\n        io:println(m is float); // Prints `true`.\n\n        int|decimal n = 5.5;\n        io:println(n is decimal); // Prints `true`.\n\n        Foo y = 1;\n        io:println(y is float); // Prints `true`.\n        io:println(y is decimal); // Prints `false`.\n\n        var q = 10;\n        io:println(q is int); // Prints `true`.\n\n        var r = 5.5;\n        io:println(r is float); // Prints `true`.\n    }\n    ```\n\n    The example below now results in a compile-time error since the type of the literal is considered to be `float` and `Foo` does not contain `float` `2`.\n\n    ```ballerina\n    Foo z = 2; // Now, results in a compile-time error.\n    ```\n\n\nTo view bug fixes, see the [GitHub milestone for Swan Lake Beta4](https://github.com/ballerina-platform/ballerina-lang/issues?q=is%3Aissue+is%3Aclosed+milestone%3A%22Ballerina+Swan+Lake+-+Beta4%22+label%3AType%2FBug+label%3ATeam%2FCompilerFE).\n\n## Runtime updates\n\n### Improvements\n\n#### Improved error messages on a type conversion failure\n\nUpdated the detailed error messages to be given on a type conversion failure narrowing down the specific location of errors in the structural types. A maximum number of 20 errors are shown at a time.\n\nFor example, the code below \n\n```ballerina\ntype Journey record {|\n    map<int> destinations;\n    boolean[] enjoyable;\n    [string, decimal] rating;\n|};\n\ntype tupleType [Journey, [Journey, map<Journey>], ()[], int...];\n\npublic function main() {\n    json j = [\n        {\"destinations\": {\"Bali\": \"2\", \"Hawaii\": 3}, \"enjoyable\": true},\n        [\n            12,\n            {\n                \"first\": {\n                    \"destinations\": {\"Bali\": true, \"Hawaii\": \"3\"},\n                    \"enjoyable\": [1],\n                    \"rating\": [10, 8.5]\n                }\n            }\n        ],\n        [null, 0],\n        \"12345678901234567890123\"\n    ];\n    tupleType val = checkpanic j.cloneWithType();\n}\n``` \nnow gives the error below.\n\n```bash\nerror: {ballerina/lang.value}ConversionError {\"message\":\"'json[]' value cannot be converted to '[Journey,[Journey,map<Journey>],()[],int...]': \n                missing required field '[0].rating' of type '[string,decimal]' in record 'Journey'\n                map field '[0].destinations.Bali' should be of type 'int', found '\"2\"'\n                field '[0].enjoyable' in record 'Journey' should be of type 'boolean[]', found 'true'\n                tuple element '[1][0]' should be of type 'Journey', found '12'\n                map field '[1][1].first.destinations.Bali' should be of type 'int', found 'true'\n                map field '[1][1].first.destinations.Hawaii' should be of type 'int', found '\"3\"'\n                array element '[1][1].first.enjoyable[0]' should be of type 'boolean', found '1'\n                tuple element '[1][1].first.rating[0]' should be of type 'string', found '10'\n                array element '[2][1]' should be of type '()', found '0'\n                tuple element '[3]' should be of type 'int', found '\"1234567890123456789...'\"}\n        at ballerina.lang.value.0:cloneWithType(value.bal:86)\n           errmsg:main(errmsg.bal:18)\n```\n\n#### Improvement in the runtime error creator API \n\nImproved the runtime Java error creator API to get a `BMap` as the `details` parameter. \n\n```Java\nBError createError(Module module, String errorTypeName, BString message, BError cause, BMap<BString, Object> details)\n```\n\n#### New runtime Java APIs\n\n##### API to access information of type inclusions at the runtime\n\nIntroduced a new API to retrieve the type IDs of the given `io.ballerina.runtime.api.types.ObjectType`.\n\n```Java\nTypeIdSet getTypeIdSet();\n``` \n\n##### API to retrieve the constituent types of an intersection type\n\nIntroduced a new API to provide the list of constituent types of a given `io.ballerina.runtime.api.types.IntersectionType`.\n\n```Java\nList<Type> getConstituentTypes();\n``` \n\n### Bug fixes\n\n#### Removed supporting the single-quote to mark the boundary of a JSON string value \n\nStopped the JSON parser supporting single quotes to mark the boundaries of a string to comply with the JSON [specification](https://www.json.org/). Only double quotes are supported now.\n\n```ballerina\npublic function main() {\n    string s = \"{ 'foo': 'bar' }\";\n    json j = checkpanic s.fromJsonString();\n    // This will now result in a runtime error.\n}\n```\n\n#### Throw unused configurable value warnings as errors\n\nWhen there is a configuration value provided in the `Config.toml` file or a command-line argument that does not match with the existing configurable variables, it will fail at runtime with an error instead of a warning.\n\nFor example, if you have the below in the `main.bal` file,\n\n```ballerina\nconfigurable int a = ?;\n```\n\nand the below in the `Config.toml` file,\n\n```toml\na = 2\nb = \"invalid\"\n\n[c]\nd = 45\n```\n\nthen, it will fail with the errors below.\n\n```bash\nerror: [Config.toml:(2:1,2:14)] unused configuration value 'b'\nerror: [Config.toml:(4:1,5:7)] unused configuration value 'c'\nerror: [Config.toml:(5:1,5:7)] unused configuration value 'c.d'\n```\n\nTo view bug fixes, see the [GitHub milestone for Swan Lake Beta4](https://github.com/ballerina-platform/ballerina-lang/issues?q=is%3Aissue+is%3Aclosed+milestone%3A%22Ballerina+Swan+Lake+-+Beta4%22+label%3AType%2FBug+label%3ATeam%2FjBallerina).\n\n## Standard library updates\n\n### New features\n\n#### `mysql` package\n- Introduced failover and retry support\n- Added `noAccessToProcedureBodies` options\n\n#### `log` package\n- Introduced the `setOutputFile` function to write the log output to a file\n\n#### `http` package\n- Introduced request and request error interceptors\n\n#### `grpc` package\n- Introduced Protobuf `Any` type support\n\n### Improvements\n\n#### `sql` package\n- Improved the `queryRow()` function to support union return types\n- Improved the parameterized query to support the escaped backtick as insertions\n\n#### `log` package\n- Added `error:StackFrame[]` as a key-value pair type\n    \n#### `http` package\n- Relaxed the data-binding restriction for status codes without content\n- Changed the `Listener.getConfig()` API to return an `InferredListenerConfiguration`\n\n#### `websub` package\n- Updated to not change the generated unique-service-path after compilation\n\n### Changes\n- Marked all the standard library services as `distinct`\n- Removed all the `info` logs printed from the listeners\n\n### Bug fixes\n\nTo view bug fixes, see the [GitHub milestone for Swan Lake Beta4](https://github.com/ballerina-platform/ballerina-standard-library/issues?q=is%3Aclosed+is%3Aissue+milestone%3A%22Swan+Lake+Beta4%22+label%3AType%2FBug).\n\n## Developer tools updates\n\n### New features\n\t\n### Language server \n- Added `document symbol` support\n- Added the `pull module` code action to pull locally unavailable Ballerina packages from Ballerina Central\n- Added a new code action to add an explicit return statement where required\n- Added a new code action to create a readonly clone\n- Added the `ignore unused variables` code action\n- Added  the `remove unreachable statement` code action\n- Added dynamic capability registration support for extended services\n\nTo view bug fixes, see the [GitHub milestone for Swan Lake Beta4](https://github.com/ballerina-platform/ballerina-lang/issues?q=is%3Aissue+is%3Aclosed+milestone%3A%22Ballerina+Swan+Lake+-+Beta4%22+label%3AType%2FBug+label%3ATeam%2FLanguageServer).\n\n#### Debugger\n- Added support to debug pause instructions. With this support, any running Ballerina programs can be suspended immediately at the current execution line of the program.\n- [Preview Feature] Introduced Ballerina code completion support in the Visual Studio Code debug console. Now, a context-aware completion list will be suggested automatically for Ballerina expressions in the VSCode evaluation window.\n- Added string template support for debug logpoints. Now, you can interpolate expressions within debug logpoint messages by using the `${}` syntax so that the debug logpoints can be used to log state variable information without suspending the program. \n\n### Bug fixes\n\nTo view bug fixes, see the GitHub milestone for Swan Lake Beta4 of the repositories below.\n\n- [Language Server](https://github.com/ballerina-platform/ballerina-lang/issues?q=is%3Aissue+is%3Aclosed+milestone%3A%22Ballerina+Swan+Lake+-+Beta4%22+label%3AType%2FBug+label%3ATeam%2FDevTools)\n- [OpenAPI](https://github.com/ballerina-platform/ballerina-openapi/issues?q=is%3Aissue+is%3Aclosed+label%3AType%2FBug+milestone%3A%22Ballerina+Swan+Lake+-+Beta4%22) \n","id":"swan-lake-beta4"},"__N_SSG":true}