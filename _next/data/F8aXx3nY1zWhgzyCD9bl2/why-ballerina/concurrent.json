{"pageProps":{"frontmatter":{"layout":"ballerina-why-ballerina-left-nav-pages-swanlake","title":"Concurrent","description":"Concurrency in Ballerina is enabled by strands, which are lightweight threads.","keywords":"ballerina, ballerina platform, concurrency, workers, strands, threads, lightweight threads","permalink":"/why-ballerina/concurrent/","active":"concurrent","intro":"Concurrency in Ballerina is enabled by strands, which are lightweight threads.","redirect_from":["/learn/user-guide/why-ballerina/concurrent","/learn/user-guide/why-ballerina/concurrent/","/learn/why-ballerina/concurrent","/learn/why-ballerina/concurrent/","/why-ballerina/concurrent"]},"content":"\nBallerina's concurrency model supports both threads and coroutines and has been designed to have a close correspondence with sequence diagrams.\n\nA Ballerina program is executed on one or more threads. A thread can consist of one or more strands, which are language-managed, logical threads of control. Only one strand of a particular thread can run at a time. The strands belonging to a single thread are cooperatively multitasked. Therefore, strands of a single thread behave as coroutines relative to each other.\n\nStrands enable cooperative multitasking by \"yielding\". The runtime scheduler may switch the execution of a strand only when it yields via a `wait` action, a worker receive action, a library function resulting in a blocking call, etc.\n\nA strand is created due to the execution of either a named worker declaration or `start` action.\n\nConcurrent operations in a function can be defined by multiple named workers. A function has a default worker and may additionally contain named workers. A worker executes concurrently with the other workers (function worker and named workers) in the function.\n\n```ballerina\nimport ballerina/io;\n\ntype Person record {|\n    string name;\n    boolean employed;\n|};\n\nfunction process(Person[] members, int[] quantities) {\n    worker w1 {\n        Person[] employedMembers = from Person p in members\n            where p.employed\n            select p;\n        int count = employedMembers.length();\n        count -> w2;\n        string `Employed Members: ${count}` -> function;\n    }\n\n    worker w2 {\n        int total = int:sum(...quantities);\n\n        int employedCount = <- w1;\n\n        int avg = employedCount == 0 ? 0 : total / employedCount;\n        string `Average: ${avg}` -> function;\n    }\n\n    string x = <- w1;\n    io:println(x);\n\n    string y = <- w2;\n    io:println(y);\n}\n```\n\nWorker message passing (via Ballerinaâ€™s `send (->)` and `receive (<-)` actions) is used for communication between workers. The compiler also explicitly verifies that the `send` and `receive` actions are in a consistent state to avoid any deadlock scenarios at runtime.\n\nA strand in Ballerina runs on a separate thread if it is safe. The isolated feature is used to identify such cases. \nA call to an isolated function is concurrency-safe if it is called with arguments that are safe at least until the \ncall returns. The strand created in a `start` action for an isolated function may run on a separate thread. The strand \nof a named worker may run on a separate thread from the default worker if the function is isolated.\n\n```ballerina\nimport ballerina/io;\n\ntype Person record {|\n    string name;\n    boolean employed;\n|};\n\nisolated function process(Person[] & readonly members, int[] & readonly quantities) {\n    worker w1 {\n        Person[] employedMembers = from Person p in members\n            where p.employed\n            select p;\n        int count = employedMembers.length();\n        count -> function;\n    }\n\n    int totalMemberCount = members.length();\n\n    int memberCount = <- w1;\n    io:println(string `Employed Members: ${memberCount}`);\n\n    future<int> avgFuture = start get_average(quantities, memberCount);\n\n    int unemployedCount = totalMemberCount - memberCount;\n    io:println(string `Unemployed Members: ${unemployedCount}`);\n\n    int avg = checkpanic wait avgFuture;\n    io:println(string `Average: ${avg}`);\n}\n\nisolated function get_average(int[] & readonly quantities, int employedCount) returns int {\n    int total = int:sum(...quantities);\n    int avg = employedCount == 0 ? 0 : total / employedCount;\n    return avg;\n}\n```\n\nConcurrency in Ballerina works well with sequence diagrams. A function can be viewed as a sequence diagram. Each worker is represented by a separate lifeline (vertical line).\n\nImmutability in the type system can be leveraged to write reliable concurrent programs. Immutability in Ballerina is deep guaranteeing that an immutable structure will always have only immutable values. Therefore, an immutable value can be safely accessed concurrently without using a lock statement.\n\n```ballerina\ntype Details record {|\n    int id;\n    string location?;\n|};\n\nfunction process(map<Details> & readonly entities) {\n    string[] detailsWithLocation = [];\n    string[] detailsWithoutLocation = [];\n\n    foreach var [name, details] in entities.entries() {\n        if details.hasKey(\"location\") {\n            detailsWithLocation.push(name);\n        } else {\n            detailsWithoutLocation.push(name);\n        }\n    }\n\n    // The casts within the workers are safe because the lists were created\n    // based on an immutable map and is therefore guaranteed to have the \n    // exact same entries with the exact same fields.\n    worker w1 {\n        foreach var name in detailsWithoutLocation {\n            persistId(<record {|int id;|} & readonly>entities.get(name));\n        }\n    }\n\n    worker w2 {\n        foreach var name in detailsWithLocation {\n            persistIdWithLocation(\n                <record {|int id; string location;|} & readonly>entities.get(name));\n        }\n    }\n}\n\nfunction persistId(record {|int id;|} rec) {\n\n}\n\nfunction persistIdWithLocation(record {|int id; string location;|} rec) {\n\n}\n```\n\n<style>\n.cBallerinaTocContainer {\n    display: none !important;\n}\n/*.cBalleinaBreadcrumbs li:nth-child(3) , .cBalleinaBreadcrumbs li:nth-child(2) {\n   display:none !important;\n}*/\n</style>\n","id":"concurrent","slug":"concurrent"},"__N_SSG":true}