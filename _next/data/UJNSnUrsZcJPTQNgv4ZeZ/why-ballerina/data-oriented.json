{"pageProps":{"frontmatter":{"layout":"ballerina-why-ballerina-left-nav-pages-swanlake","title":"Data oriented","description":"Language-integrated queries specify the logic in SQL-like syntax to process data and events. They are easy to write and understand due to the simplicity of the syntax. See how Ballerina provides first-class support for writing queries that process data.","keywords":"ballerina, networking, microservices, programming language, distributed computing, services, data oriented, data transformation","permalink":"/why-ballerina/data-oriented/","active":"data-oriented","intro":"Language-integrated queries specify the logic in SQL-like syntax to process data and events. They are easy to write and understand due to the simplicity of the syntax. See how Ballerina provides first-class support for writing queries that process data.","redirect_from":["/learn/user-guide/why-ballerina/data-oriented/","/learn/user-guide/why-ballerina/data-oriented","/learn/why-ballerina/data-oriented","/learn/why-ballerina/data-oriented/","/why-ballerina/data-oriented"]},"content":"\nAs of now, language-integrated queries are supported for iterator implementations such as an array, map, stream, and table. There are two kinds of integrated queries that can be written in Ballerina:\n\n- [**Query expression:**](#query-expressions) allows generating a list, table, string, or XML\n- [**Query action:**](#query-actions) executes a set of statements for each element of the iterator\n\n## Query expressions\n\nQuery expressions allow you to generate a list, stream, table, string, or XML. The sections below look at the clauses you can use in a query expression.\n\n### Query clauses\n\nQuery expressions contain a set of clauses similar to SQL to process the data. They must start with the `from` clause and can perform various operations such as filter, join, sort, limit, and projection. There are various SQL-like clauses below to perform these operations. \n\n#### `from` clause\n\nThe `from` clause is used to define the input iterator source that is considered for processing the data. Similar to the `for each` statement, you can specify any iterator as the expression. Similar to a list and stream, you can use all kinds of iterators as the input in the `from` clause.\n\n#### `where` clause\n\nThe `where` clause allows you to filter by condition. You can define any conditional expression, which returns a boolean. A `where` clause contains logical operators, equality, and range checks.\n\n#### `let` clause\n\nThe `let` clause allows you to define variables that can be used only within the query expression scope. These variables cannot be accessed out of the query expression. You can define one or more variables in the `let` clause and use them within query expressions. \n\n#### `join` clause\n\nA `join` clause performs an inner or left outer equijoin. In the `join` clause, there are two input iterators. During the joining process, each value of an iterator is matched against all the values in the other iterator based on the given condition, and the output values are generated for all the matching event pairs. Here, you can only perform equality checks as the joining condition.\n\n#### `order by` clause \n\nThe `order by` clause allows ordering the result in the ascending and/or descending order based on the specified attributes. Ordering will be done in an ascending manner by default. You can use the `descending` keyword to order in a descending manner. Here, attributes that are considered for the `order by` operations are order-keys, which should be an ordered type. You can define more than one order key in the `order by` clause and it’s possible to have more than one `order by` clause. \n\n#### `limit` clause\n\nThe `limit` clause limits the number of frames/values emitted by a query pipeline. You should define an integer value to specify the number of output values.\n\n#### `select` clause\n\nThe `select` clause is a mandatory clause in query expressions that is used for projection. You can use this clause to create the values required to generate iterators such as list, table, XML, string, and stream. \n\n#### `on conflict` clause\n\nAn `on conflict` clause is only allowed for a query expression that constructs a table with a key sequence. The expression is evaluated when the `select` clause emits a value that conflicts with a previous value, in the sense, that both values have the same key value in the table. The `on conflict` clause gets executed when the `select` clause emits a row that has the same key as a row that it emitted earlier. It gives an `onConflictError` error if there is a key conflict.\n\n## Query actions\n\nQuery actions are executed in the same way as the clauses in the query expression. However, it doesn't generate an output such as a list. Rather, it executes a set of statements defined by you. The block inside the `do` clause is executed in each iteration.\n\n### Query action example\n\n```ballerina\nvar x = from var person in personList\n    from var dept in deptList\n    let string hrDepartment = \"Human Resource\"\n    do {\n        if (dept.name == \"HR\") {\n            Employee employee = {firstName: person.firstName, lastName: person.lastName, deptAccess: hrDepartment};\n            employeeList[employeeList.length()] = employee;\n        }\n    };\n```\n\n## Write integrated queries\n\nThe example below provides in-depth knowledge on how to utilize the capabilities of the Ballerina query expressions. This example explains the use case of finding popular books in a store.\n\n```ballerina\nimport ballerina/io;\n\ntype Author record {|\n    readonly int id;\n    string name;\n|};\n\ntype Category record {|\n    readonly int id;\n    string name;\n|};\n\ntype Book record {|\n    readonly int id;\n    string title;\n    int year;\n    float price;\n    Author[] authors;\n    Category[] categories;\n|};\n\ntype Sale record {|\n    int bookId;\n    int qty;\n|};\n\ntype AuthorTable table<Author> key(id);\n\ntype CategoryTable table<Category> key(id);\n\ntype BookTable table<Book> key(id);\n\nerror onConflictError = error(\"Key Conflict\", message = \"record with same key exists.\");\n```\n\nIn the above code, the necessary custom types and variables are created to perform the data manipulation.\n\n```ballerina\nfunction loadAuthors() returns AuthorTable|error {\n    json[] authors = [\n        {\"id\": 1, \"name\": \"Giada De Laurentiis\"},\n        {\"id\": 2, \"name\": \"J. K. Rowling\"},\n        {\"id\": 3, \"name\": \"Henrique C. M. Andrade\"},\n        {\"id\": 4, \"name\": \"Buğra Gedik\"},\n        {\"id\": 5, \"name\": \"Deepak S. Turaga\"}\n    ];\n\n    // Iterates through the `authors` JSON array, constructs the `Author` records, and collects them into a table.\n    return table key(id) from var author in authors\n        select check author.cloneWithType(Author)\n        on conflict onConflictError;\n}\n```\n\nHere, the author details are represented as JSON elements. In this method, the respective author JSON elements are converted into tabular data using Ballerina query expressions for further processing.\n\n```ballerina\nfunction loadCategories() returns CategoryTable|error {\n    xml categories = xml `<categories>\n                       <category>\n                           <id>1</id>\n                           <name>cooking</name>\n                       </category>\n                       <category>\n                           <id>2</id>\n                           <name>children</name>\n                       </category>\n                       <category>\n                           <id>3</id>\n                           <name>fantasy</name>\n                       </category>\n                       <category>\n                           <id>4</id>\n                           <name>education</name>\n                       </category>\n                   </categories>`;\n\n    // Iterates through the `categories` XML array, constructs the `Category` records, and collects them into a table.\n    return table key(id) from var category in categories/<category>\n        select {\n            id: check 'int:fromString((category/**/<id>/*).toString()),\n            name: (category/**/<name>/*).toString()\n        }\n        on conflict onConflictError;\n}\n```\n\nThe above method iterates through a `categories` XML array and constructs a table with the category ID and name. Query expression clauses such as `from`, `select`, and `on conflict` are used in it.\n\n```ballerina\nfunction getCategories(CategoryTable categories, int[] ids) returns Category[] {\n    // Queries the `categories` of each ID and collects the matching categories into an array.\n    return from int id in ids\n        join Category c in categories on id equals c.id\n        select c;\n}\n```\n\nThe above method returns the book category names according to the given category IDs. As written in the query expression, a `join` clause iterates through the `categories` array to find the respective category name according to the ID. \n\n```ballerina\nfunction getAuthors(AuthorTable authors, int[] ids) returns Author[] {\n    // Queries the `authors` of each ID and collects the matching authors into an array.\n    return from int id in ids\n        join Author a in authors on id equals a.id\n        select a;\n}\n```\n\nHere, the author names are identified according to the author IDs. As similar to the previous method, query joins are utilized to create the `authors` array. \n\n```ballerina\nfunction loadBooks() returns BookTable|error {\n    map<anydata>[] books = [\n        {\"id\": 1, \"title\": \"Everyday Italian\", \"year\": 2005, \"price\": 30.00, \"authors\": [1], \"categories\": [1]},\n        {\"id\": 2, \"title\": \"Harry Potter\", \"year\": 1997, \"price\": 29.99, \"authors\": [2], \"categories\": [2, 3]},\n        {\"id\": 3, \"title\": \"Fundamentals of Stream Processing\", \"year\": 2014, \"price\": 123.99, \"authors\": [3, 4, 5], \"categories\": [4]},\n        {\"id\": 4, \"title\": \"Fantastic Beasts\", \"year\": 2001, \"price\": 29.99, \"authors\": [2], \"categories\": [2, 3]}\n    ];\n\n    // Iterates through the `books` map<anydata> array, constructs the `Book` records, and collects them into a table.\n    return table key(id) from var book in books\n        let AuthorTable authors = check loadAuthors()\n        let CategoryTable categories = check loadCategories()\n        select {\n            id: <int>book[\"id\"],\n            title: <string>book[\"title\"],\n            year: <int>book[\"year\"],\n            price: <float>book[\"price\"],\n            authors: getAuthors(authors, check book[\"authors\"].cloneWithType()),\n            categories: getCategories(categories, check book[\"categories\"].cloneWithType())\n        }\n        on conflict onConflictError;\n}\n```\n\nNow, the author details and book category details exist as individual table values. The book details exist as an array. Further, this array has the necessary keys to identify the respective authors and book categories. Hence, there is a requirement to generate a table, which contains the relevant book details, author names, and category names. As shown in the above example, Ballerina query expressions can be utilized to create such table values.  \n\n```ballerina\nfunction getPopularBooks(stream<Sale> sales, int minSales, int 'limit) returns Book[]|error {\n    // Join each sale value from the `sales` stream with the retrieved `BookTable`,\n    // filter books with at least `minSales` number of sales,\n    // order filtered books by sales quantity,\n    // and collect the `limit` number of books into an array.\n    return from Sale s in sales\n        join Book b in check loadBooks() on s.bookId equals b.id\n        where s.qty >= minSales\n        order by s.qty descending\n        limit 'limit\n        select b;\n}\n```\n\nNow, you have the book details as a table value and there is a requirement to identify the popular books based on the number of sales copies. As shown in the above example, you have to combine the `sales` array and the `books` table to identify the popular books. In this example, Ballerina query clauses such as `join`, `where`, `order by`, and `limit` are utilized to cater to the requirement. \n\n```ballerina\npublic function main() returns error? {\n    Sale[] sales = [\n        {bookId: 1, qty: 150},\n        {bookId: 2, qty: 3500},\n        {bookId: 3, qty: 1250},\n        {bookId: 4, qty: 2100}\n    ];\n\n    // Retrieve the two most popular books with at least 1000 sales.\n    Book[]|error mostPopular2Books = getPopularBooks(sales.toStream(), 1000, 2);\n    io:println(mostPopular2Books);\n}\n```\n\nThe `main` method is responsible for identifying the popular books according to the number of copies sold. Hence, the respective `getPopularBooks` method gets called with the required parameters.\n\n<style>\n.nav > li.cVersionItem {\n    display: none !important;\n}\n/**.cBalleinaBreadcrumbs li:nth-child(3) , .cBalleinaBreadcrumbs li:nth-child(2) {\n   display:none !important;\n}**/\n</style>\n","id":"data-oriented","slug":"data-oriented"},"__N_SSG":true}