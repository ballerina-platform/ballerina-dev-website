{"pageProps":{"frontmatter":{},"content":"# Specification: Ballerina OAuth2 Library\n\n_Owners_: @ldclakmal @shafreenAnfar  \n_Reviewers_: @shafreenAnfar  \n_Created_: 2021/10/01  \n_Updated_: 2022/02/17  \n_Edition_: Swan Lake  \n\n## Introduction\nThis is the specification for the OAuth2 standard library of [Ballerina language](https://ballerina.io/), which is used for authorization of listeners and clients (HTTP, gRPC, GraphQL, WebSocket, WebSub, etc.).\n\nThe OAuth2 library specification has evolved and may continue to evolve in the future. The released versions of the specification can be found under the relevant GitHub tag.\n\nIf you have any feedback or suggestions about the library, start a discussion via a [GitHub issue](https://github.com/ballerina-platform/ballerina-standard-library/issues) or in the [Slack channel](https://ballerina.io/community/). Based on the outcome of the discussion, the specification and implementation can be updated. Community feedback is always welcome. Any accepted proposal, which affects the specification is stored under `/docs/proposals`. Proposals under discussion can be found with the label `type/proposal` in GitHub.\n\nThe conforming implementation of the specification is released and included in the distribution. Any deviation from the specification is considered a bug.\n\n## Contents\n\n1. [Overview](#1-overview)\n2. [OAuth2](#2-oauth2)\n3. [Listener Auth](#3-listener-auth)\n    * 3.1. [OAuth2 Provider](#31-oauth2-provider)\n    * 3.2. [OAuth2 Handler](#32-oauth2-handler)\n    * 3.3. [Declarative Approach](#33-declarative-approach)\n    * 3.4. [Imperative Approach](#34-imperative-approach)\n4. [Client Auth](#4-client-auth)\n    * 4.1. [OAuth2 Provider](#41-oauth2-provider)\n    * 4.2. [OAuth2 Handler](#42-oauth2-handler)\n        * 4.2.1. [Bearer Token](#421-bearer-token)\n        * 4.2.2. [Grant Types](#422-grant-types)\n    * 4.3. [Declarative Approach](#43-declarative-approach)\n    * 4.4. [Imperative Approach](#44-imperative-approach)\n5. [Samples](#5-samples)\n    * 5.1. [Listener Auth](#51-listener-auth)\n        * 5.1.1. [Declarative Approach (HTTP Listener)](#511-declarative-approach-http-listener)\n        * 5.1.2. [Imperative Approach (HTTP Listener)](#512-imperative-approach-http-listener)\n    * 5.2. [Client Auth](#52-client-auth)\n        * 5.2.1. [Declarative Approach (HTTP Client)](#521-declarative-approach-http-client)\n            * 5.2.1.1. [Bearer Token](#5211-bearer-token)\n            * 5.2.1.2. [Grant TypesT](#5212-grant-types)\n        * 5.2.2. [Imperative Approach (HTTP Client)](#522-imperative-approach-http-client)\n            * 5.2.2.1. [Bearer Token](#5221-bearer-token)\n            * 5.2.2.2. [Grant Types](#5222-grant-types)\n\n## 1. Overview\nThis specification elaborates on OAuth2 authorization for all the Ballerina listeners and\nclients. The HTTP, gRPC, GraphQL, WebSocket, WebSub protocol-based listeners and clients are secured according to this\nspecification.\n\nThis has a number of design principles:\n- **Listener auth**: This refers to the authentication and authorization of the listener as defined in\n  [Ballerina 2021R1 Section 5.7.4](https://ballerina.io/spec/lang/2021R1/#section_5.7.4). The inbound requests/messages\n  independent of the transport protocol are authenticated and authorized according to the configured authentication\n  protocol and related configurations.\n- **Client auth**: This refers to the authentication of the client as defined in\n  [Ballerina 2021R1 Section 7.9](https://ballerina.io/spec/lang/2021R1/#section_7.9). The outbound requests/messages\n  independent of the transport protocol are enriched according to the configured authentication protocol and related\n  configurations.\n- **Auth provider**: This is the entity that is responsible for providing all the auth protocol-related implementations.\n- **Auth handler**: This is the entity that is responsible for handling the security of the API based on the transport\n  protocol and with the use of provider APIs. This API gets the credentials and required configurations as user inputs\n  and returns the authentication protocol-related information. Internally, these APIs call the provider APIs of the\n  relevant authentication protocol.\n- **Declarative approach**: This is also known as the configuration-driven approach, which is used for simple use cases,\n  where users have to provide a set of configurations and do not need to be worried more about how authentication and\n  authorization works.\n- **Imperative approach**: This is also known as the code-driven approach, which is used for advanced use cases, where\n  users need to be worried more about how authentication and authorization work and need to have further customizations.\n\n## 2. OAuth2\nOAuth2 protocol defines the credential as an access token which is defined in \n[RFC6749 Section 1.4](https://datatracker.ietf.org/doc/html/rfc6749#section-1.4).\n\n## 3. Listener Auth\nThis refers to the authentication and authorization of the listener as defined in\n[Ballerina 2021R1 Section 5.7.4](https://ballerina.io/spec/lang/2021R1/#section_5.7.4). The inbound requests/messages\nindependent of the transport protocol are authenticated and authorized according to the configured authentication\nprotocol and related configurations.\n\n### 3.1. OAuth2 Provider\nThe OAuth2 Provider has an API to authorize the OAuth2 credential. The `IntrospectionConfig` record is used to provide \nthe configuration related to the introspection server which is being called at the time of credential validation. This \nreturns the `IntrospectionResponse` which consists of all the available information of the introspection server response.\n\n```ballerina\nimport ballerina/cache;\n\npublic type IntrospectionConfig record {\n    string url;\n    string tokenTypeHint?;\n    map<string> optionalParams?;\n    cache:CacheConfig cacheConfig?;\n    decimal defaultTokenExpTime = 3600;\n    ClientConfiguration clientConfig = {};\n};\n\npublic type IntrospectionResponse record {\n    boolean active;\n    string scope?;\n    string clientId?;\n    string username?;\n    string tokenType?;\n    int exp?;\n    int iat?;\n    int nbf?;\n    string sub?;\n    string aud?;\n    string iss?;\n    string jti?;\n};\n\npublic class ListenerOAuth2Provider {\n\n    public function init(IntrospectionConfig config) {\n        // init OAuth2 provider\n    }\n\n    public function authorize(string credential, map<string>? optionalParams = ()) returns IntrospectionResponse|Error {\n        // validate the credential against introspection endpoint\n    }\n}\n```\n\n### 3.2. OAuth2 Handler\n\n> **NOTE**: Since the auth handlers are tightly bound with the transport protocol, for the explanation of the concept,\n> all the samples are created for HTTP transport protocol hereinafter.\n\nThe OAuth2 Handler has an API to authorize the HTTP request, headers of the HTTP request, or the credential as defined \nin [RFC6750 Section 2.1](https://datatracker.ietf.org/doc/html/rfc6750#section-2.1). This API is also used to authorize \nthe user against the expected scope or scopes. The `OAuth2IntrospectionConfig` record is used to provide the \nconfiguration related to the introspection server which is being called at the time of credential validation along with \nthe `scopeKey` which defines the claim used for scopes. This returns the `IntrospectionResponse` which consists of all \nthe available information of the introspection server response or `Unauthorized` in case of authentication failure or \n`Forbidden` in case of authorization failure.\n\n```ballerina\nimport ballerina/oauth2;\n\npublic type OAuth2IntrospectionConfig record {|\n    *oauth2:IntrospectionConfig;\n    string scopeKey = \"scope\";\n|};\n\npublic client class ListenerOAuth2Handler {\n\n    private final oauth2:ListenerOAuth2Provider provider;\n\n    public function init(OAuth2IntrospectionConfig config) {\n        self.provider = new (config);\n    }\n\n    remote function authorize(Request|Headers|string data, string|string[]? expectedScopes = (), \n                  map<string>? optionalParams = ()) returns oauth2:IntrospectionResponse|Unauthorized|Forbidden {\n        // extract the credential from data\n        oauth2:IntrospectionResponse|oauth2:Error response = self.provider.authorize(credential, optionalParams);\n        if (response is oauth2:Error) {\n            // return `Unauthorized`\n        }\n        // match the scopes with the provided `expectedScopes`\n        // if not matched return `Forbidden`\n        return <oauth2:IntrospectionResponse>response;\n    }\n}\n```\n\n### 3.3. Declarative Approach\nThis is also known as the configuration-driven approach, which is used for simple use cases, where users have to\nprovide a set of configurations and do not need to be worried more about how authentication and authorization works.\nThe user does not have full control over the configuration-driven approach.\n\nThe service and/or resource configurations are used to define the authentication and authorization configurations.\nUsers can configure the configurations needed for different authentication schemes and configurations needed for\nauthorizations of each authentication scheme. Also, the configurations can be provided at both the service and resource\nlevels. The priority will be given from bottom to top. Then, the auth handler creation and request\nauthentication/authorization is handled internally without user intervention. The requests that succeeded both\nauthentication and/or authorization phases according to the configurations will be passed to the business logic layer.\n\n### 3.4. Imperative Approach\nThis is also known as the code-driven approach, which is used for advanced use cases, where users need to be worried\nmore about how authentication and authorization work and need to have further customizations. The user has full control\nof the code-driven approach. The handler creation and authentication/authorization calls are made by the user at the\nbusiness logic layer.\n\n## 4. Client Auth\nThis refers to the authentication of the client as defined in\n[Ballerina 2021R1 Section 7.9](https://ballerina.io/spec/lang/2021R1/#section_7.9). The outbound requests/messages\nindependent of the transport protocol are enriched according to the configured authentication protocol and related\nconfigurations.\n\n### 4.1. OAuth2 Provider\nThe OAuth2 Provider has an API to generate the OAuth2 credential. The `ClientCredentialsGrantConfig`, \n`PasswordGrantConfig`, `RefreshTokenGrantConfig`, or `JwtBearerGrantConfig` records are used to provide the \nconfiguration related to the OAuth2 grant type used for access token generation. This returns the generated access token.\n\n```ballerina\npublic type ClientCredentialsGrantConfig record {|\n    string tokenUrl;\n    string clientId;\n    string clientSecret;\n    string[] scopes?;\n    decimal defaultTokenExpTime = 3600;\n    decimal clockSkew = 0;\n    map<string> optionalParams?;\n    CredentialBearer credentialBearer = AUTH_HEADER_BEARER;\n    ClientConfiguration clientConfig = {};\n|};\n\npublic type PasswordGrantConfig record {|\n    string tokenUrl;\n    string username;\n    string password;\n    string clientId?;\n    string clientSecret?;\n    string[] scopes?;\n    record {|\n        string refreshUrl;\n        string[] scopes?;\n        map<string> optionalParams?;\n        CredentialBearer credentialBearer = AUTH_HEADER_BEARER;\n        ClientConfiguration clientConfig = {};\n    |} refreshConfig?;\n    decimal defaultTokenExpTime = 3600;\n    decimal clockSkew = 0;\n    map<string> optionalParams?;\n    CredentialBearer credentialBearer = AUTH_HEADER_BEARER;\n    ClientConfiguration clientConfig = {};\n|};\n\npublic type RefreshTokenGrantConfig record {|\n    string refreshUrl;\n    string refreshToken;\n    string clientId;\n    string clientSecret;\n    string[] scopes?;\n    decimal defaultTokenExpTime = 3600;\n    decimal clockSkew = 0;\n    map<string> optionalParams?;\n    CredentialBearer credentialBearer = AUTH_HEADER_BEARER;\n    ClientConfiguration clientConfig = {};\n|};\n\npublic type JwtBearerGrantConfig record {|\n    string tokenUrl;\n    string assertion;\n    string clientId?;\n    string clientSecret?;\n    string[] scopes?;\n    decimal defaultTokenExpTime = 3600;\n    decimal clockSkew = 0;\n    map<string> optionalParams?;\n    CredentialBearer credentialBearer = AUTH_HEADER_BEARER;\n    ClientConfiguration clientConfig = {};\n|};\n\npublic type GrantConfig ClientCredentialsGrantConfig|PasswordGrantConfig|RefreshTokenGrantConfig|JwtBearerGrantConfig;\n\npublic class ClientOAuth2Provider {\n\n    public function init(GrantConfig config) {\n        // init OAuth2 provider\n    }\n\n    public function generateToken() returns string|Error {\n        // get the OAuth2 token by calling to IDP with given configurations\n    }\n}\n```\n\n### 4.2. OAuth2 Handler\n\n> **NOTE**: Since the auth handlers are tightly bound with the transport protocol, for the explanation of the concept,\n> all the samples are created for HTTP transport protocol hereinafter.\n\n#### 4.2.1. Bearer Token\nThe Bearer Token Auth Handler has an API to enrich the HTTP request as defined in \n[RFC6750 Section 2.1](https://datatracker.ietf.org/doc/html/rfc6750#section-2.1). The `BearerTokenConfig` record is \nused to provide the configuration related to the access token. This returns the enriched `Request` with headers or \n`Error` in case of failure.\n\n```ballerina\npublic type BearerTokenConfig record {|\n    string token;\n|};\n\npublic class ClientBearerTokenAuthHandler {\n\n    private final BearerTokenConfig & readonly config;\n\n    public function init(BearerTokenConfig config) {\n        self.config = config.cloneReadOnly();\n    }\n\n    public function enrich(Request req) returns Request|Error {\n        // set the token as the `Authorization: Bearer <token>` header\n    }\n}\n```\n\n#### 4.2.2. Grant Types\nThe OAuth2 Handler has an API to enrich the HTTP request as defined in \n[RFC6750 Section 2.1](https://datatracker.ietf.org/doc/html/rfc6750#section-2.1). The \n`OAuth2ClientCredentialsGrantConfig`, `OAuth2PasswordGrantConfig`, `OAuth2RefreshTokenGrantConfig`, or \n`OAuth2JwtBearerGrantConfig` records are used to provide the configuration related to the OAuth2 grant type used for \naccess token generation. This returns the enriched `Request` with headers or `Error` in case of failure.\n\n```ballerina\nimport ballerina/oauth2;\n\npublic type OAuth2GrantConfig OAuth2ClientCredentialsGrantConfig|OAuth2PasswordGrantConfig|\n                              OAuth2RefreshTokenGrantConfig|OAuth2JwtBearerGrantConfig;\n\npublic type OAuth2ClientCredentialsGrantConfig record {|\n    *oauth2:ClientCredentialsGrantConfig;\n|};\n\npublic type OAuth2PasswordGrantConfig record {|\n    *oauth2:PasswordGrantConfig;\n|};\n\npublic type OAuth2RefreshTokenGrantConfig record {|\n    *oauth2:RefreshTokenGrantConfig;\n|};\n\npublic type OAuth2JwtBearerGrantConfig record {|\n    *oauth2:JwtBearerGrantConfig;\n|};\n\npublic client class ClientOAuth2Handler {\n\n    private final oauth2:ClientOAuth2Provider provider;\n\n    public function init(OAuth2GrantConfig config) {\n        self.provider = new (config);\n    }\n\n    remote function enrich(Request req) returns Request|Error {\n        string|oauth2:Error token = self.provider.generateToken();\n        // set the token as the `Authorization: Bearer <token>` header\n    }\n}\n```\n\n### 4.3. Declarative Approach\nThis is also known as a configuration-driven approach, which is used for simple use cases, where users have to provide\na set of configurations and do not need to be worried more about how authentication works. The user does not have full\ncontrol over the configuration-driven approach.\n\nThe client configurations are used to define the authentication configurations. Users can configure the configurations\nneeded for different authentication schemes. Then, the auth handler creation and request enrichment is handled\ninternally without user intervention.\n\n### 4.4. Imperative Approach\nThis is also known as the code-driven approach, which is used for advanced use cases, where users need to be worried\nmore about how authentication works and need to have further customizations. The user has full control of the\ncode-driven approach. The handler creation and request enrichment calls are made by the user at the business logic layer.\n\n## 5. Samples\n\n### 5.1. Listener Auth\n\n#### 5.1.1. Declarative Approach (HTTP Listener)\n\n```ballerina\nimport ballerina/http;\n\n@http:ServiceConfig {\n    auth: [\n        {\n            oauth2IntrospectionConfig: {\n                url: \"https://localhost:9445/oauth2/introspect\",\n                tokenTypeHint: \"access_token\",\n                scopeKey: \"scp\",\n                clientConfig: {\n                    customHeaders: {\"Authorization\": \"Basic YWRtaW46YWRtaW4=\"},\n                    secureSocket: {\n                        cert: \"/path/to/public.crt\"\n                    }\n                }\n            },\n            scopes: [\"admin\"]\n        }\n    ]\n}\nservice /foo on new http:Listener(9090) {\n    resource function get bar() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n#### 5.1.2. Imperative Approach (HTTP Listener)\n\n```ballerina\nimport ballerina/http;\nimport ballerina/oauth2;\n\nhttp:OAuth2IntrospectionConfig config = {\n    url: \"https://localhost:8080/oauth2/introspect\",\n    tokenTypeHint: \"access_token\"\n};\nhttp:ListenerOAuth2Handler handler = new (config);\n\nservice /foo on new http:Listener(9090) {\n    resource function post bar(@http:Header string authorization) returns string|http:Unauthorized|http:Forbidden {\n        oauth2:IntrospectionResponse|http:Unauthorized|http:Forbidden auth = handler->authorize(authorization, \"admin\");\n        if (auth is http:Unauthorized || auth is http:Forbidden) {\n            return auth;\n        }\n        // business logic\n    }\n}\n```\n\n### 5.2. Client Auth\n\n#### 5.2.1. Declarative Approach (HTTP Client)\n\n##### 5.2.1.1. Bearer Token\n\n```ballerina\nimport ballerina/http;\n\nhttp:Client c = check new (\"https://localhost:9090\",\n    auth = {\n        token: \"56ede317-4511-44b4-8579-a08f094ee8c5\"\n    }\n);\n\npublic function main() returns error? {\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n\n```\n\n##### 5.2.1.2. Grant Types\n\n```ballerina\nimport ballerina/http;\n\nhttp:OAuth2ClientCredentialsGrantConfig config = {\n    tokenUrl: \"https://localhost:8080/oauth2/token/authorize\",\n    clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxS\",\n    clientSecret: \"9205371918321623741\"\n};\n\nhttp:Client c = check new (\"https://localhost:9090\", auth = config);\n\npublic function main() returns error? {\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n#### 5.2.2. Imperative Approach (HTTP Client)\n\n##### 5.2.2.1. Bearer Token\n\n```ballerina\nimport ballerina/http;\n\nhttp:BearerTokenConfig config = {\n    token: \"JhbGciOiJIIiwiaWF0IjUzI1NiIsInR5cCI6IkpXVCJ9WIiOiIxMjM0NTY3ODkwI\"\n};\nhttp:ClientBearerTokenAuthHandler handler = new (config);\n\nhttp:Client c = check new (\"https://localhost:9090\");\n\npublic function main() returns error? {\n    http:Request req = new;\n    req = check handler.enrich(req);\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 5.2.2.2. Grant Types\n\n```ballerina\nimport ballerina/http;\n\nhttp:OAuth2ClientCredentialsGrantConfig config = {\n    tokenUrl: \"https://localhost:8080/oauth2/token/authorize\",\n    clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxS\",\n    clientSecret: \"9205371918321623741\"\n};\nhttp:ClientOAuth2Handler handler = new (config);\n\nhttp:Client c = check new (\"https://localhost:9090\");\n\npublic function main() returns error? {\n    http:Request req = new;\n    req = check handler->enrich(req);\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n"},"__N_SSG":true}