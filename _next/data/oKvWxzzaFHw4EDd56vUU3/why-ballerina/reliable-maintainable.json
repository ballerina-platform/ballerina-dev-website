{"pageProps":{"frontmatter":{"layout":"ballerina-why-ballerina-left-nav-pages-swanlake","title":"Reliable, maintainable","description":"The sections below explain how the explicit error handling, static types, and concurrency safety combined with a familiar, readable syntax make programs reliable and maintainable.","keywords":"ballerina, ballerina platform, error handling, concurrency safety, reliability, maintainability","permalink":"/why-ballerina/reliable-maintainable/","active":"reliable-maintainable","intro":"The sections below explain how the explicit error handling, static types, and concurrency safety combined with a familiar, readable syntax make programs reliable and maintainable.","redirect_from":["/learn/user-guide/why-ballerina/reliable-and-maintainable/","/learn/user-guide/why-ballerina/reliable-maintainable","/learn/why-ballerina/reliable-maintainable","/learn/why-ballerina/reliable-maintainable/","/why-ballerina/reliable-maintainable"]},"content":"\n## Explicit error handling  \n\nError handling refers to the act of reacting to and recovering from errors. Error handling plays a critical role in producing reliable, maintainable applications. Ballerina is designed with a conscious decision to have explicit errors instead of exceptions. As a result, Ballerina has explicit error reporting and explicit error testing and handling. It is explained further using examples.\n\nErrors are expected in network handling. In fact, “The network is reliable” is one of the <a href=\"https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing\" target=\"_blank\">fallacies of distributed computing</a>. Therefore, explicit error handling is a must when dealing with network services because it forces you to check for errors and handle or pass them to the caller. \n\nIn Ballerina, errors are reported by functions returning values of the `error` type. The error values are part of their basic type. \n\n### Error reporting\n\nThis example defines a TCP client, which communicates with a remote TCP server. Both `read` and `write` methods interact with the network. Hence, errors can occur at any time. \n\n```ballerina\n# The TCP client is used to connect to a remote TCP server. \npublic client class TcpClient {\n \n   # Initializes the TCP client.\n   function init(string host, int port) returns error? {}\n \n   # Reads bytes from the connected remote host.\n   remote function read() returns byte[] | error {}\n \n   # Writes bytes to the connected remote host.\n   remote function write(byte[] bytes) returns error? {}\n}\n```\n\nWhen the `read` method is completed successfully, it returns a `byte[]` value. In the case of a failure, it returns an error value. You can describe this behavior using union types in Ballerina. The union type `byte[] | error` means that the value could be either a `byte[]` or an `error`. The fact that this method can fail is explicit in the method signature.\n\n```ballerina\n# Reads bytes from the connected remote host.\nremote function read() returns byte[] | error {}\n```\n\nThe `write` method does not return anything if it completes successfully. However, it returns an error otherwise. Optional types in Ballerina can be used to describe this behavior. Options types are syntactic sugar for union types containing the nil type, which is written as `()`. The `error?` is sugar for `error | ()`. The examples below show how you can check whether a function returns the expected value or an error.\n\n```ballerina\n# Writes bytes to the connected remote host.\nremote function write(byte[] bytes) returns error? {}\n```\n\n### Error checking \n\nBallerina has language constructs for explicit error checking. Both explicit error reporting and checking improve code readability and maintainability simply because they are explicit. When you read Ballerina code, you can quickly notice the code, which reports errors, and you can check for errors.  \n\nUsually, a function handles errors by passing them up to the caller. Even the main function, which is the program entry point can return an error resulting in an error printed in your terminal. \n\nThe function below returns information about the provided domain name. It internally does a WHOIS database lookup via the provided TCP client. The code is correct and readable. However, it is verbose. Most of the time, you don’t need to handle every error. Instead, you pass errors to the caller. \n\n```ballerina\nimport ballerina/tcp;\n\nfunction whois(string domain, tcp:Client whoisClient) returns string|error {\n    error? err = whoisClient->writeBytes(domain.toBytes());\n    // The `is` operator tests whether a value belongs to a type.\n    if err is error {\n        // The `is` operator causes the type to be narrowed.\n        // The type of `err` variable is `error` in this block.\n        return err;\n    }\n\n    byte[]|error bytes = whoisClient->readBytes();\n    if bytes is error {\n        return bytes;\n    } else {\n        return string:fromBytes(bytes);\n    }\n}\n```\n\nThis `is` operator-based error checking pattern is very common and you would end up having too many of them in your code. \n\n```ballerina\n   if result is error {\n       // handle error\n   }\n```\n\nBallerina provides a much more lightweight, shorthand for this pattern. The behavior of the function below is the same as the previous version. However, it is much more elegant. The `check expr` check expression performs an explicit error check, and the control flow also remains explicit.\n\n```ballerina\nimport ballerina/tcp;\n\nfunction whois(string domain, tcp:Client whoisClient) returns string|error {\n    // If `writeBytes` failed with an error, then `check` makes\n    //  the function return that error immediately.\n    check whoisClient->writeBytes(domain.toBytes());\n    byte[] bytes = check whoisClient->readBytes();\n    return string:fromBytes(bytes);\n}\n```\n\nThis function shows another pattern that handles errors in a single place. You can attach an `on fail` clause to some Ballerina statements such as `do`, `while`, `transactions`, `foreach`, etc.  In this example, check does not simply return on error. The enclosing block decides how to handle the error. If the enclosing block has an `on fail` clause, it catches the error. If the enclosing block does not have an `on fail` block, it passes the error up to its enclosing block. Finally, the function handles the error by returning the error. This behavior is different from exceptions in that control flow is explicit. \n\n```ballerina\nimport ballerina/tcp;\n\nfunction whois(string domain, tcp:Client whoisClient) returns string|error {\n    do {\n        check whoisClient->writeBytes(domain.toBytes());\n        byte[] bytes = check whoisClient->readBytes();\n        return string:fromBytes(bytes);\n    } on fail var err {\n        return error(\"Failed to communicate with the given whois server\", cause = err);\n    }\n}\n```\n\n### Ignore return values and error\n\nBallerina does not allow ignoring return values of expressions. \n\n```ballerina\n// Error\nstring:toBytes(\"ballerina.io\");\n```\n\nHowever, you can explicitly ignore a return value of an expression by assigning the result of the expressions to `_;`. This is like an implicitly declared variable of the `any` type that cannot be referenced.\n\n```ballerina\n// Ok\n_ = string:toBytes(\"ballerina.io\");\n```\n\nHowever, Ballerina does not allow ignoring the value of an expression if the type includes an error. You are forced to handle the error explicitly. \n\n```ballerina\n// Error\n_ =  whois(\"ballerina.io\", whoisClient);\n```\n\nAs explained earlier, `_` is like an implicitly declared variable of the `any` type; this is a union type that includes all the types in Ballerina except for the error type. Therefore, the type, which includes all values supported by Ballerina is `any|error`. As per the typing rules in Ballerina, the above statement causes a compilation error because `string|error` is not a subtype of the `any` type.\n\n### Deal with abnormal errors\n\nBallerina has made a conscious decision to distinguish normal errors from abnormal errors. The sections above explained how to deal with normal errors. Out of memory, division by zero, programming bugs are examples of abnormal errors in Ballerina. Such errors typically result in immediate program termination. \n\nAbnormal errors can be reported using the `panic` statement. Some language constructs such as type casts generate panics. \n\n```ballerina\nfunction toInt(any a) returns int {\n    // This is a programming bug.\n    // Raise a panic if the value of `a` is not an `int`.\n    return <int>a;\n}\n```\n\nA panic always has an associated error value as illustrated in the example below.\n\n```ballerina\nfunction divide(int m, int n) returns int {\n    if n == 0 {\n        panic error(\"division by 0\");\n    }\n    return m / n;\n}\n```\n\nPanics can be trapped with a `trap` expression. Ballerina raises a panic on an integer overflow. You can convert this panic to an error with a trap expression. \n\n```ballerina\nint|error result = trap (m + n);\n```\n\n<style>\n.nav > li.cVersionItem {\n    display: none !important;\n}\n/* .cBalleinaBreadcrumbs li:nth-child(3) , .cBalleinaBreadcrumbs li:nth-child(2) {\n   display:none !important;\n} */\n</style>\n","id":"reliable-maintainable","slug":"reliable-maintainable"},"__N_SSG":true}