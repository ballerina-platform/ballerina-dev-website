{"pageProps":{"frontmatter":{"layout":"ballerina-language-basics-left-nav-pages-swanlake","title":"Language basics","description":"This guide introduces the Ballerina language to help you get started with basics that are common to all C-Family programming languages.","keywords":"ballerina, programming language, ballerina packages,language-guide","permalink":"/learn/language-basics/","active":"language-basics","intro":"This guide introduces the Ballerina language to help you get started with basics that are common to all C-Family programming languages.","redirect_from":["/learn/language-basics","/learn/getting-started/language-basics/","/learn/getting-started/language-basics"]},"content":"\n## Familiar subset of Ballerina\n\nBallerina is a modern programming language focused on building applications for the cloud era. It has a familiar syntax resembling the C-family of languages such as C/C++, C#, Java, and JavaScript. It brings in many powerful concepts from existing programming languages and some unconventional abstraction mechanisms to make application development for the cloud more intuitive and less strenuous.\n\nThis guide presents the subset of the Ballerina language that is common to most modern programming languages. It covers the baseline features such as data types, control flow, and error handling, which should be very familiar to most programmers. These features are the foundation for some of the more [distinctive features of Ballerina](/learn/distinctive-language-features/network-interaction/). \n\n## Programs and modules\n\nBallerina programs consist of modules and each module consists of one or more *`.bal`* files.\n  \nThe most important thing that a module does is define named functions.\n\nHere's what a simple Ballerina module looks like:\n\n```ballerina\nimport ballerina/io; \n\npublic function main() {\n    io:println(\"Hello World!\"); \n}\n```\n\nThe ``import`` keyword is used to bind predefined library modules to the module prefix. Ballerina modules have two-part names represented by an organization name and a module name. In this case, the organization is **``ballerina``**  and the module is **``io``**. The bound identifier that refers to this library module is set to the module name **``io``**. To override the default identifier binding for the module, you can use the ``as`` keyword as follows: *``import ballerina/io as oi``*.\n\nModule hierarchies follow the ``/`` and ``.`` notations. For example, *``org/x.y.z``* represents a hierarchical module name. The ``z:f`` notation points to a symbol ``f`` (e.g., a function) defined within the module ``x.y.z``.\n\nThe ``main`` function is the program entry point and the ``public`` keyword makes this function visible outside the module. This ``main`` function calls the ``println()`` function defined in the ``ballerina/io`` module. Every statement in Ballerina code must terminate with a semicolon.\n\n## Variables and types\n\nModules and functions can declare variables.\n\nVariables have types. Ballerina defines several built-in types such as integers, floating point numbers, strings, and booleans.\n\nHere is a typical way of declaring variables:\n\n```ballerina\nimport ballerina/io;\n\nstring greeting = \"Hello\";\n\npublic function main() {\n    string name = \"Ballerina\";\n    io:println(greeting, \" \", name);\n}\n```\n\n**``greeting``** is a module-level variable of type ``string`` initialized to a value of `\"Hello\"`. The **``name``** variable is a local variable of type ``string`` initialized to a value `\"Ballerina\"`.\n\nIn Ballerina, variable assignments are statements and not expressions.\n\n## Functions\n\nLike all high-level programming languages, Ballerina supports functions. \n\nA function definition in Ballerina has a familiar syntax that includes parameters and a return type.\n\n```ballerina\nfunction add(int x, int y) returns int {\n    int sum = x + y;\n    return sum;\n}\n```\n\nIn the above code example, you see the definition for the **``add``** function. It accepts two parameters of type ``int``, **``x``**, and **``y``**. It also returns a value of type `int`. The ``returns`` keyword specifies the type of return value.\n\nThe function performs a simple addition operation and stores the result in another variable **``sum``** of type ``int``. The ``return`` statement returns the value assigned to **``sum``**.\n\n## Syntax\n\nThe general syntax of a Ballerina program is as follows:\n\n```ballerina\n// This is a comment.\nint count = 0;\n\n// You can have Unicode identifiers.\nfunction พิมพ์ชื่อ(string ชื่อ) {\n    // Use \\u{H} to specify character using Unicode code point in hex.\n   io:println(ชื่\\u{E2D});\n}\n\nstring 'string = \"xyz\";\n```\n\nThe overall syntax is more or less C-like. Comments start with ``//`` and end at the end of the line. Module definitions/declarations and statements use braces or terminate with a semicolon.   \n\nYou can also use Unicode characters in identifiers. Unicode literals can be defined using the `\\u{H}` syntax to represent Unicode code points in the hex format.\n\nKeywords such as ``int``, ``function``, and ``string`` are reserved keywords in Ballerina. You can use them as identifiers by prefixing them with a single quote.\n\n## Integers\n\nBallerina defines an integer data type of a 64-bit signed representation. The ``int`` keyword is used to declare an integer. Integer literals can be declared either in decimal or hexadecimal format.\n\n```ballerina\nint m = 1;\n\nint n = 0xFFFF;\n```\n\nThe integer data type supports all the basic arithmetic operators: ``+``, ``-``, ``*``, ``/``, and ``%``, the comparison operators: ``==``, ``!=``, ``<``, ``>``, ``<=``, and ``>=`` as well as the compound assignment operators: ``+=`` and ``-=``. It also supports the usual bitwise operators (i.e., ``&``, ``|``, ``^``, ``~``, ``<<``,  and  ``>>``). The operator precedence rules are exactly as per C.\n\nHowever, there are a couple of notable deviations in Ballerina. Firstly, increment and decrement operators (i.e., ``++`` and ``--``) are not supported. Moreover, integer overflow results in a runtime error unlike in C where it rolls over.\n\n## Floating point numbers\n\nIn Ballerina, floating point numbers have an IEEE 64-bit binary representation similar to `double` in Java. Variables of the `float` type are declared with the ``float`` keyword and they support all operations similar to integers except bitwise operators.\n\n```ballerina\nint n = 2;\nfloat x = 1.0;\n\nfloat y = x + <float>n;\n```\n\nHowever, they cannot be implicitly converted to or from integers. You can use the ``<T>`` notation for explicit conversion.\n\nIn Ballerina, ``NaN``, the IEEE defined terminology for Not a Number is equal to itself. Therefore, the ``==`` operator on two ``NaN``s will return `true`. For floating point types, the ``==`` and ``!=`` operators test for the same value and do not test for numerical equivalence as per the IEEE convention.\n\n## Booleans and conditionals\n\nThe boolean type has only two values: ``true`` and ``false``.\n\n```ballerina\nboolean flag = true;\n```\n\nBallerina supports the logical operators, ``!``, ``||``, and ``&&`` with boolean values. The ``||`` and ``&&`` operators support the same short-circuit behavior as in C. Implicit conversion between boolean and integer is not supported.\n\nBooleans are also used in conditional expressions:\n\n```ballerina\nint n = flag ? 1 : 2;\n```\n\nAs usual, booleans can be used in if-else statements:\n\n```ballerina\nfunction foo() {\n    if flag {\n        io:println(1);\n    } else {\n        io:println(2);\n    }\n}\n```\n\nIf-else statements and all compound statements in Ballerina require curly braces. However, the parenthesis before the curly braces are optional.\n\n## Nil\n\nNil is another data type. It has a special significance in Ballerina as it denotes the equivalent of what is known as a null value in other C-family languages. If you want to declare a variable or a value of type nil, here is how it is done.\n\n```ballerina\nint? v = ();\n```\n\nThe keyword ``int`` is followed by a ``?`` notation. It means that **``v``** can take an integer value or can be nil. It is initialized to nil, which is denoted by ``()``. Types do not allow their values to be set as nil implicitly. There is also no implicit conversion to boolean.\n\nThe ``==`` and ``!=`` comparison operators operate on a value to test whether the value is nil.\n\n```ballerina\nint n = v == () ? 0 : v;\n```\n\nSimilarly, you can also use the Elvis operator like *``x ?: y``* that returns **``x``** if it is not nil or **``y``** otherwise.\n\n```ballerina\nint n = v ?: 0;\n```\n\nLeaving off the return type of a function is the same as defining nil as the return type. Moreover, falling off the end of a function or `return`\nby itself is equivalent to `return ()`. Therefore, you can write a function as follows:\n\n```ballerina\nfunction foo() returns () {\n    return ();\n}\n```\n\n## Strings\n\nStrings are immutable sequences of zero or more Unicode characters. To define a variable of type `string`, you use the ``string`` keyword in Ballerina.\n\n```ballerina\nstring grin = \"\\u{1F600}\";\n```\n\nString literals are enclosed in double quotes and support the usual C-style escape sequences as well as numeric escape characters for Unicode code points.\n\nThe `string` type supports the usual operators. The ``==``  operator checks for the same characters. The comparison operators (i.e., ``<``, ``<=``, ``=>``, and ``>``) work by comparing code points. The ``+`` operator is used for concatenation.\n\n```ballerina\nstring greeting = \"Hello\" + grin;\n```\n\nThe member access expression (e.g., ``s[i]``) on a string value points to the character at index `i` of the string. The index positions on values of the `string` type start with zero.\n\nBallerina does not support the notion of a separate character type like in C. Instead, a character is considered a string of length one.\n\n## Langlib functions\n\nBallerina defines lang libraries to provide fundamental operations on built-in datatypes. \n\nFor example, you can perform standard operations such as getting a substring or finding the length of the string on values of the ``string`` type.\n\n```ballerina\nstring s = \"abc\".substring(1, 2);\n\nint n = s.length();\n```\n\nThe ``substring()`` and ``length()`` functions are ``string`` lang library functions called using the convenient method call syntax. However, the functions are called on variables/values of the ``string`` type rather than objects.\n\nA lang library **``ballerina/lang.T``** is defined for each built-in type **``T``**. Ballerina automatically imports these lang libraries and pre-declares a prefix **``T``**, which you can use to access the constructs of the module. Therefore, in the case of the above code example, you can also find the length of the string value referring to the **``length()``** function as **``string:length()``** and using the function call syntax.\n\n```ballerina\nstring s = \"abc\".substring(1, 2);\n\nint n = string:length(s);\n```\n\nThe lang library can also be imported explicitly as **``import ballerina/lang.'string``**.\n\n```ballerina\nimport ballerina/lang.'string;\n\nstring s = \"abc\".substring(1, 2);\n\nint n = string:length(s);\n```\n\n## Arrays\n\nArrays are sequential data structures consisting of values of the same type.  \n\nYou can declare an array of integers as:\n\n```ballerina\nint[] v = [1, 2, 3];  \n```\n\nYou can index the individual elements of this array using the ``v[i]`` notation. Array indexing starts with zero. So the second element of **``v``** can be accessed as *``v[1]``*.\n\n```ballerina\nint n = v[1];\n```\n\nArrays are mutable. Ballerina supports ordering based on a lexicographical ordering of members.\n\nThe ``==`` and ``!=`` comparison operators perform a deep comparison of two arrays based on the members and their order instead of the memory location.\n\nLanglib functions for arrays are available to perform operations such as finding the length of an array.\n\n```ballerina\nint len = v.length();\n```\n\n## ``foreach`` statement\n\nA ``foreach`` statement iterates over an array by binding a variable to each array member at every loop iteration.\n\n```ballerina\nfunction sum(float[] v) returns float {\n    float r = 0.0;\n    foreach float x in v {\n        r += x;\n    }\n    return r;        \n}\n```\n\nIn this code example, the **``x``** variable of the ``float`` type is bound to each element of the **``v``**  array. Similarly, it also works with the ``string`` type by iterating over each character in the string.\n\nYou can also construct the ``foreach`` statement using a range expression such as `..<`.\n\n```ballerina\nfunction sum(float[ ] v) returns float {\n    float r = 0.0;\n    foreach int i in 0 ..< v.length() {\n        r += v[i];\n    }\n    return r;\n}\n```\n\nThe above statement sets the **``i``** variable of the ``int`` type to a sequence of linearly incrementing numbers that range from zero to the length of the array **``v``**. Therefore, the ``foreach`` statement iterates over the length of the array and increments **``i``** during each iteration.\n\n## ``while`` Statement\n\nThe `while` loop in Ballerina behaves exactly like in C.\n\n```ballerina\ntype LinkedList record {\n    string value;\n    LinkedList? next;\n};\n\nfunction len(LinkedList ll) returns int {\n    int n = 0;\n    \n    LinkedList? nextLL = ll.next;\n\n    while nextLL != () {\n        n += 1;\n        nextLL = nextLL.next;\n    }\n\n    return n;\n}\n```\n\nIn this example, the ``while`` loop is checking for a boolean condition to check for the end of the linked list **``ll``**.\n\nThe ``while`` statement also supports the usual ``break`` and ``continue`` statements.\n\n## Binary data\n\nBinary data is represented by an array of bytes.\n\n```ballerina\nbyte[] data = base64 `yPHaytRgJPg+QjjylUHakEwz1fWPx/wXCW41JSmqYW8=`; \n```\n\nAn array of bytes can also be represented in the source code using base-64 or base-16 literal formats.\n\nThe ``byte`` type represents a number between ``0`` and ``0xFF``. You can define a variable of the ``byte`` type with the ``byte`` keyword.\n\n```ballerina\nbyte b = 0xFF;\n```\n\nIn Ballerina, ``byte`` is a subtype of the integer type. Therefore, it supports all the bitwise operators available on integers. Some of these operators produce a value that belongs to the integer type, and some operators like the ``&`` operator produce a value that belongs to the ``byte`` type.\n\n## Maps\n\nA map is an associative structure of multiple string values as keys and their values.  If you want to create a map of integers, then you would define it as:\n\n```ballerina\nmap<int> m = {\n    \"x\": 1,\n    \"y\": 2\n};\n```\n \nThe syntax to define a map is very similar to JSON. Maps are mutable, and *``m[\"x\"]``* will return the integer value stored against *``x``* as the key, or nil if the key is not present.\n\n```ballerina\nm[\"x\"] = 5;\n\nint? v = m[\"x\"];\n```\n  \nWhen used in a ``foreach`` loop, it will iterate over all the values of the map. You can also use lang library functions such as *``get(k)``* to get the value mapped to the string key *``k``*, or *``keys( )``* to return an array containing all the key strings of the map.\n\nYou can perform a deep comparison by using the ``==`` and ``!=`` comparison operators on a map. Two maps are equal if they have the same set of keys and the values for each key are equal.\n\n## Type definitions\n\nBallerina allows you to define a name for a type. You can create user-defined type identifiers for the built-in types supported by the language.\n\nFor example, if you have an array of maps of the ``string`` type, *``map<string>[]``*, you can define a type definition for it as follows:\n\n```ballerina\ntype MapArray map<string>[];\n\nMapArray arr = [\n    {\"x\": \"foo\"},\n    {\"y\": \"bar\"}\n];\n```\n\nThis is similar to the typedef concept in C, where the identifier **``MapArray``** acts as an alias for the actual type.\n\n## Records\n\nA record is a collection of fields of a specific type. With record types, you have control over what your keys are.  \n\n```ballerina\nrecord { int x; int y; } r = {\n    x: 1,\n    y: 2\n};\n```\n\nThe above code defines a record **``r``** with two integer fields **``x``** and **``y``**, and initializes their values to 1 and 2, respectively.\n\nYou can also define it using the type definition as follows:\n\n```ballerina\ntype Coord record {\n    int x;\n    int y;\n};\n```\n\nSubsequently, you can use the **``Coord``** record to declare a variable and set or access its field values.\n\n```ballerina\nCoord c = {x: 1, y: 2};\n\nint a = c.x;\n```\n\nRecords are mutable. *``c.x``* is an ``lvalue``. Rules for record comparison are the same as those for maps.\n\n## Structural typing\n\nIn Ballerina, the data types are defined in terms of a set of values. A type is a label for a set of values. These values can be part of a finite set or an infinite set.\n\nFor example, the ``int`` type has a finite set consisting of values within the range of 64-bit signed numbers. The ``string`` type is an infinite set that contains sequences of any number or order of characters. In this way, Ballerina partitions the universe of all values into the basic types it supports such as nil, boolean, integer, floating point, and string. Values of these basic types are immutable, and each value belongs to exactly one basic type.\n\nThere is also a concept of semantic subtyping, which means a subset of the values of the basic types. For example, the ``byte`` type is a subset of integer as it allows only a subset of values that are a part of the integer value set.\n\nAdditionally, Ballerina allows you to define your own types, such as arrays, maps, and records, which are mutable.\n\n## Unions\n\nBallerina's type system allows you to define custom types based on the combination of two or more types. A union is, therefore, a superset of that combination.\n \nA variable of type ``T?`` can hold a value of type ``T`` or nil as explained in the section on the [Nil](#nil) type.\n\nSimilarly, you can define a variable that holds an integer or a string.\n\n```ballerina\ntype flexType string|int;\n\nflexType a = 1;\n\nflexType b = \"Hello\";\n```\n\nYou can create a union of multiple types using the ``|`` symbol in the type definition. Therefore, in the above example, **``flexType``** can hold an integer value as well as a string value, and the Ballerina compiler won't complain.\n\nYou can also apply the concept of unions to structured data types like records. So it is possible to have a union of a record type containing fields of the ``string`` type and the basic ``string`` type.\n\n```ballerina\ntype StructuredName record {\n    string firstName;\n    string lastName;\n};\n\ntype Name StructuredName|string;\n```\n \nAt runtime, you can define the business logic by checking the currently held value of the union-typed variable using the `is` operator.\n\n```ballerina\nfunction nameToString(Name nm) returns string {\n   \n    if nm is string {\n        return nm;\n    } else {\n        return nm.firstName + \" \" + nm.lastName;\n    }\n}\n```\n \nIn this way, the ``is`` operator in a condition causes the declared type to be narrowed.\n\n## Error reporting\n\nBallerina does not support the notion of exceptions. Instead, errors are handled as part of the normal control flow. Errors are first-class citizens in Ballerina. Ballerina supports a few mechanisms that are centered around an ``error`` type to handle errors. The ``error`` type is a basic type. Ballerina programs can pass around error values similar to values of any other type.\n\nFunctions report errors by returning error values.\n\n```ballerina\nfunction parse(string s) returns int|error {\n    \n    int n = 0;\n    int[] cps = s.toCodePointInts();\n    \n    foreach int cp in cps {\n        int p = cp - 0x30;\n        if p < 0 || p > 9 {\n            return error(\"not a digit\");\n        }\n        n = n * 10 + p;\n    }\n    return n;\n}\n```\n \nIn the above code example, the function **``parse()``** returns either an integer or an error. At the point of returning the error, the error constructor *``error(\"not a digit\")``*  is called.\n\nIn case a function is expected to explicitly return only error values, a return type of ``error?`` is used. Ignoring an error also has to be done explicitly.\n\nAn error value includes a string message and the stack trace from the point where *``error(...)``* is called. An error value is immutable.\n\n## Error handling\n\nWhen an error is reported from a function, it is passed up to its caller. Ultimately it is handled at the ``main`` function, which can return it. Alternatively, you can use the ``is`` operator to check for the error type as part of the regular control flow to make a decision.\n\n```ballerina\nfunction intFromBytes(byte[] bytes) returns int|error {\n    \n    string|error ret = string:fromBytes(bytes);\n\n    if ret is error {\n        return ret;\n    } else {\n        return int:fromString(ret);\n    }\n}\n```\n\nIn the above code example, the function defines a local variable **``ret``** to hold the value returned by the **``string:fromBytes()``** function. The **``ret``** variable is of a union type of the ``string`` and ``error`` types. Therefore to ascertain the actual type, ``is`` operator is used.\n\n## ``check`` expression\n\nInstead of using the ``is`` operator within the regular conditional flow to check for errors, Ballerina supports the ``check`` keyword as a shorthand method. Error handling and return statements become much more concise when using the ``check`` keyword.\n\nFor example, you can write the **``intFromBytes()``** function defined in the [Error handling](#error-handling) section as follows:\n\n```ballerina\nfunction intFromBytes(byte[] bytes) returns int|error {\n\n    string str = check string:fromBytes(bytes);\n    \n    return int:fromString(str);\n}\n```\n  \nIn this case, the expression following the ``check`` keyword (``string:fromBytes(bytes)``) is evaluated and the **``intFromBytes``** function returns immediately if the **``string:fromBytes()``** function returns an error.\n\n## Error subtyping\n\nBallerina also allows fine-grained error detection based on error subtypes. Error subtypes can be defined using the distinct keyword.\n\n```ballerina\ntype XErr distinct error;\ntype YErr distinct error;\n\ntype Err XErr|YErr;\n```\n\nNow, you can use the defined subtype in an error constructor to create error values of that type.\n\n```ballerina\nErr err = error XErr(\"Whoops!\");\n```\n\nYou can use the ``is`` operator to distinguish between the distinct subtypes.\n\n```ballerina\nfunction desc(Err err) returns string {\n    return err is XErr ? \"X\" : \"Y\";\n}\n```\n\n## Panics\n\nIn Ballerina, there is a distinction between normal and abnormal errors. Normal errors are the ones that you typically handle as part of the usual business logic and are under your control. But some errors are not under the control of the programmer. These are abnormal errors. Things such as bugs in library code or out of memory errors fall under this category.\n\nNormal errors are handled by returning values of the ``error`` type. Abnormal errors are handled using the ``panic`` statement.\n\n```ballerina\nfunction divide(int m, int n) returns int {\n    if n == 0 {\n        panic error(\"division by 0\");\n    }\n    return m/n;\n}\n```\n \nA panic statement results in immediate program termination and has an associated error value.\n\n## ``any`` type\n\nBallerina also has an ``any`` type, which means any value except an error value. A variable of type ``any`` can be cast to a specific type using the type cast expression (``<T>x``).\n\n```ballerina\nany x = 1;\n\nint n = <int>x;\n```\n\nIt can be converted to string.\n\n```ballerina\nstring s = x.toString();\n```\n\nYou can also use the ``is`` operator to test the type of the actual value held by the variable.\n\n```ballerina\nfloat f = x is int|float ? <float>x : 0.0;\n```\n\n## Ignore return values and errors\n\nBallerina does not allow silently ignoring return values of functions unless they return nil.\n\n```ballerina\n// Allowed only if return value is ()\ndoX();\n```\n\nTo ignore the return value, you can assign it to ``_``, which acts as an implicitly declared variable of any type that cannot be referenced.\n\n```ballerina\n_ = getX();\n```\n\nWhen a function's return type includes an ``error`` type, it has to be handled explicitly. Otherwise, the ``checkpanic`` keyword can be used but it panics on error rather than returning.\n\n```ballerina\ncheckpanic tryX();\n```\n\n## Covariance\n\nBallerina's type system follows a structured type system based on the set of values that belongs to a type. For example, the integer type allows a set of values. Similarly, the ``any`` type also allows a set of values, including the subset of values that belong to the integer type.\n\nTherefore, you can have an array of the integer type that is assigned to an array of the ``any`` type.\n\n```ballerina\nint[] iv = [1, 2, 3];\n\nany[] av = iv;\n```\n  \nThis is perfectly valid in Ballerina because the set of values allowed by an array of the integer type is a subset of the values allowed by an array of the ``any`` type. So this way, you can have some flexibility in allowing fixed inherent type substitution based on the set of values.\n\nBallerina's static type checking ensures that the result of a read operation on the array  **``av``** will be consistent with static type. However, writing may result in an error because the inherent type of the ``iv`` array is array of integers. As a result, the code below will lead to a runtime error since it is trying to mutate the array to a type other than the inherent type (``int[]``).\n\n```ballerina\nav[0] = \"str\"; // panics\n```\n\nThis is covariance, which means that a write to a mutable structure may result in a runtime error. Apart from arrays, maps and records are the other data structures with an inherent type that constrains mutation.\n\n## Object\n\nBallerina provides another basic type which is the object type. Object types bundle together code and data.\n\nObjects are initialized based on a class defined within a module.\n\n```ballerina\nfunction demoMyClass( ) {\n    m:MyClass x = new m:MyClass(1234);\n    x.foo( );\n    int n = x.n;\n}\n```\n\nIn the above code example, the function **``demoMyClass()``** uses the ``new`` expression to create an object **``x``** using the **``MyClass``** class that is defined in module `m`. You can use the ``.`` notation to call the object's methods or access its fields.\n\n## Define classes\n\nBallerina supports the concept of a class which is a structured type containing data and behavior.\n\n```ballerina\nclass MyClass {\n    \n    private int n;\n\n    public function init(int n = 0) {\n        self.n = n;\n    }\n\n    public function inc() {\n        self.n += 1;\n    }\n\n    public function get() returns int {\n        return self.n;\n    }\n}\n```\n\nThe **``init``** method is the constructor for this class, and the keyword ``self`` is used to access the object. It also uses the standard access specifiers, ``private`` and ``public``, which translate to accessibility within the class definition and outside of it.\n\n## ``init`` return type\n\nThe **``init()``** method of a class can have a return type. The return type must be a subtype of the union of ``error`` and ``nil``.\n\n```ballerina\nclass File {\n\n    string path;\n\n    string contents;\n\n    function init(string p) returns error? {\n        self.path = p;\n        self.contents = check io:fileReadString(p);\n    }\n\n}\n\nFile f = check new File(\"text.txt\");\n```\n \nIf the *``init()``* call returns normally, the newly constructed object is returned. Otherwise, the ``new`` expression returns the error value.\n\nThe return type of the **``init()``** method is nil if a return type is not explicitly specified. It also means that the ``init`` method will never return an error.\n\n## Identity\n\nIn Ballerina, the identity of an object is determined by the memory location in which the object resides at runtime. To check the identity, you can use the ``===`` and ``!==`` equality expressions.\n\n```ballerina\nMyClass obj1 = new MyClass();\nMyClass obj2 = new MyClass();\n\n// true\nboolean b1 = (obj1 === obj1);\n\n// false\nboolean b2 = (obj1 === obj2);\n```\n\nIn the above code example, both **``obj1``** and **``obj2``** are **``MyClass``** objects. *``obj1 === obj1``* returns true as both operands of the operation refer to the same memory location. Similarly, *``obj1 === obj2``* returns false since they refer to different memory locations.\n \nThe ``==`` operator is used to check for contents of a structure type like arrays.\n\n```ballerina\n// true\nboolean b3 = ([1,2,3] == [1,2,3]);\n\n// false\nboolean b4 = ([1,2,3] === [1,2,3]);\n```\n\nIn the above code example, the first operation results in true as both the arrays have exactly the same content. However, the second operation is false because it is using the ``===`` operator to check for memory locations, and the two inline arrays point to different memory locations, even though their contents are the same.  \n\nIn the case of floating point numbers, IEEE defines -0.0 and +0.0 as the same. Therefore applying ``==`` to compare -0.0 and +0.0 would return ``true``, whereas *``-0.0 === +0.0``* would always be ``false`` as they are not identical.\n\n## ``const`` and ``final``\n\nBallerina supports constants. Constants are defined using the ``const`` keyword and are immutable singleton types having a value known at compile time.\n\n```ballerina\nconst MAX_VALUE = 1000;\n```\n\nApart from ``const``, there is also support for ``final``. Variables defined with the ``final`` keyword cannot be reassigned to after being initialized.\n\n```ballerina\nfinal string msg = loadMessage();\n```\n\nThis is also applicable for class fields.\n\n## Enumerations\n\nBallerina supports the notion of enumerations which is a shorthand way for expressing unions of string constants.\n\n```ballerina\nenum Color {\n    RED, GREEN, BLUE\n}\n```\n\nUsing the ``enum`` keyword, you can define this enumeration of three string values \"RED\", \"GREEN\", and \"BLUE\", which would otherwise be defined separately as a union of string constants:\n\n```ballerina\nconst RED = \"RED\";\nconst GREEN = \"GREEN\";\nconst BLUE = \"BLUE\";\n\ntype Color RED|GREEN|BLUE;\n```\n \nYou can also have an enumeration where members define associated string values explicitly.\n\n```ballerina\nenum Language {\n    ENG = \"English\",\n    TL = \"Tamil\",\n    SI = \"Sinhala\"\n}\n```\n\n## ``match`` statement\n\nThe ``match`` statement is like the switch case statement in C, but it is more flexible. You can use it to match values of different types.\n\n```ballerina\nconst KEY = \"xyzzy\";\n\nfunction mtest(any v) returns string {\n\n    match v {\n        17 => { return \"number\"; }\n        true => { return \" boolean\"; }\n        \"str\" => { return \"string\"; }\n        KEY => { return \"constant\"; }\n        0|1 => { return \"or\"; }\n        _ => { return \"any\"; }\n    }\n}\n```\n\nThe match statement defines multiple clause statement blocks with the ``=>`` operator. The left-hand side of the ``=>`` operator in each clause is the pattern for the value match. It can contain literals or identifiers referring to constants. It can also contain multiple patterns specified using ``|``. Additionally, ``_`` can be used to match any value that is not an error.  \n\nIn the above example, the match statement uses the value held by **``v``** and matches it against six match clauses having distinct patterns. During execution, the patterns will be evaluated in order, using the equality expression (``==``) to test the pattern match, and the matched clause's statement block will be executed.\n\n## Type inference\n\nType inference allows the program to infer the actual data type of variables.\n\nThis feature is a convenient way to use a generic type for a local variable and helps avoid repeated type declarations.\n\n```ballerina\nvar x = \"str\";\n```\n\nIn this code example, the keyword ``var`` is used to declare the variable **``x``**. It means that the variable's actual type will be inferred from the type of the expression used to initialize it. In this case, it is the ``string`` type.\n\nThis is especially useful in a ``foreach`` loop to declare the local variable for iterating over a collection, like arrays.\n\n```ballerina\nfunction printLines(string[] sv) {\n    \n    foreach var s in sv {\n        io:println(s);\n    }\n\n}\n```\n\nIn this code example, the type of variable **``s``** is inferred to be of type ``string``, from the type of **``sv``**, which is an array of type ``string``.\n\nType inference also works with classes.\n\n```ballerina\nvar x = new MyClass();\n```\n\nHere the variable **``x``** is declared with ``var`` and the type is inferred as **``MyClass``**. \n\nThe opposite syntax is also valid, wherein the variable **``x``** is defined with the **``MyClass``** type and is initialized with ``new``.\n\n```ballerina\nMyClass x = new;\n```\n\nType inference is applicable for variables in local scopes. Therefore ``var`` should be used sparingly for variables used within a very limited scope, like in a ``foreach`` loop. Overusing it makes the code harder to understand.\n\n## Functional programming\n\nBallerina defines functions also as values, and they work as closures. Therefore ``function`` is also a type, which can be defined as a basic type as follows:\n\n```ballerina\nvar isOdd = function(int n) returns boolean {\n    return n % 2 != 0;\n};\n\ntype IntFilter function (int n) returns boolean;\n\nfunction isEven(int n) returns boolean {\n    return n % 2 == 0;\n}\n\nIntFilter f = isEven;\n```\n\nIn the above example, the variable **``isOdd``** defines an anonymous function. **``IntFilter``** is a function type that accepts a function with an ``int`` argument and returns a ``boolean`` value. And later on, the **``isEven``** function, with a matching signature, is assigned to a variable of this type.\n\nThese function values can be passed around as arguments. For example, the lang library for arrays defines a function **``filter(f)``** which accepts a function type **``f``** to perform specific filtering operations on arrays.\n\n```ballerina\nint[] nums = [1, 2, 3];\n\nint[] evenNums = nums.filter(f);\n```\n\nThe **``filter()``** function takes the function value as a parameter, which is **``isEven``**, assigned to **``f``**. Therefore, passing it as the argument results in ``filter()`` returning an array of even numbers.  \n\nInstead of passing a function variable, you can also pass anonymous functions as an argument.\n\n```ballerina\nint[] oddNums = nums.filter(n => n % 2 != 0);\n```\n\nAs shown for the array **``oddNums``**, the type of parameter **``n``** is inferred from the array with which the **``filter()``** function is used.\n\n## Asynchronous function calls\n\nBallerina also supports asynchronous function calls. You can call a function asynchronously as follows:\n\n```ballerina\nfuture<int> f1 = start foo();\n\nfuture<int> f2 = start foo();\n```\n\nThe use of the ``start`` keyword before the function call makes it asynchronous. Each asynchronous call runs on a separate logical thread, also known as strand, that is cooperatively multitasked by default.\n\nThe result of this invocation is returned as a future. It is a separate basic type that has an attached type *``T``* as *``future<T>``*.\n\nYou can then wait for the result with the ``wait`` keyword.\n\n```ballerina\nint x1 = check wait f1;\nint x2 = check wait f2; \n```\n\nWaiting on a *``future<T>``* returns *``T|error``*. Waiting on the same future more than once returns an error value.\n\nInstead of waiting for each future separately, you can also do the following.\n\n```ballerina\nrecord {| int|error f1; int|error f2; |} f = wait {f1, f2};\n\nint x1 = check f.f1;\nint x2 = check f.f2;\n```\n \nIn case you want to terminate the ``future``, you can do *``f.cancel( )``*.\n\n## Documentation\n\nBallerina supports a structured way to document code. Documentation lines start with ``#`` and contain structured documentation in Markdown format.\n\n\n<pre><div><pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #6E7781\"># Adds two integers.</span></span>\n<span class=\"line\"><span style=\"color: #6E7781\"># </span><span style=\"color: #CF222E\">+ </span><span style=\"color: #24292F\">x</span><span style=\"color: #CF222E\"> - </span><span style=\"color: #6E7781\">an integer</span></span>\n<span class=\"line\"><span style=\"color: #6E7781\"># </span><span style=\"color: #CF222E\">+ </span><span style=\"color: #24292F\">y</span><span style=\"color: #CF222E\"> - </span><span style=\"color: #6E7781\">another integer</span></span>\n<span class=\"line\"><span style=\"color: #6E7781\"># </span><span style=\"color: #CF222E\">+ </span><span style=\"color: #24292F\">return</span><span style=\"color: #CF222E\"> - </span><span style=\"color: #6E7781\">the sum of `x` and `y`</span></span>\n<span class=\"line\"><span style=\"color: #CF222E\">public</span><span style=\"color: #24292F\"> </span><span style=\"color: #CF222E\">function</span><span style=\"color: #24292F\"> </span><span style=\"color: #8250DF\">add</span><span style=\"color: #24292F\">(</span><span style=\"color: #0550AE\">int</span><span style=\"color: #24292F\"> </span><span style=\"color: #953800\">x</span><span style=\"color: #24292F\">, </span><span style=\"color: #0550AE\">int</span><span style=\"color: #24292F\"> </span><span style=\"color: #953800\">y</span><span style=\"color: #24292F\">)</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">                    </span><span style=\"color: #CF222E\">returns</span><span style=\"color: #24292F\"> </span><span style=\"color: #0550AE\">int</span><span style=\"color: #24292F\"> {</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">    </span><span style=\"color: #CF222E\">return</span><span style=\"color: #24292F\"> x </span><span style=\"color: #CF222E\">+</span><span style=\"color: #24292F\"> y;</span></span>\n<span class=\"line\"><span style=\"color: #24292F\">}</span></span></code></pre></div></pre>\n\n\nThe above code example adds documentation to describe the parameters and the return type of the **``add()``** function. This is Ballerina-flavoured Markdown (BFM) which makes it convenient to generate pretty documentation using one of the platform tools.\n\n## Annotations\n\nAnnotations are defined using the ``@`` notation followed by a tag. This is a way of attaching metadata to the code.\n\n```ballerina\n@display {\n    iconPath: \"transform.png\"\n}\npublic function transform(string s) returns string {\n   return s.toUpperAscii();\n}\n\nfuture<int> fut = @strand { thread: \"any\" } start foo();\n```\n\nIn the above code example, the *``@display``* annotation is attached to the function **``transform()``**, and the *``@strand``* annotation applies to the keyword ``start``, calling the function **``foo()``** asynchronously. These annotations use mapping constructor expressions, which is one of the ways to define them.\n\nThe annotations shown above use unprefixed tags and refer to standard platform-defined annotations. You can also have prefixed tags for user-defined annotations declared in modules.\n \n","id":"language-basics","sub":"","third":"","slug":"language-basics"},"__N_SSG":true}