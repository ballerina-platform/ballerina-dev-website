{"pageProps":{"frontmatter":{"layout":"ballerina-left-nav-release-notes","title":"Swan Lake Preview 1","permalink":"/downloads/swan-lake-release-notes/swan-lake-preview1/","active":"swan-lake-preview1","redirect_from":["/downloads/swan-lake-release-notes/swan-lake-preview1"]},"content":"### Overview of Ballerina Swan Lake - Preview 1\nBallerina Swan Lake will be a major new version of Ballerina that we plan to release in January 2021. We will be doing major releases every 6 months from then on. We also plan to use popular ballet names as the codename for each release - so the 2021-07 release will be the Nutcracker release. We will announce details on maintenance of released versions and will also have an LTS release model similar to Ubuntu or Java.\n\nThis release is the first preview version of Ballerina Swan Lake. This release includes a new set of language features and significant improvements to the compiler, runtime, standard libraries, and developer tooling.\n\nYou can use the update tool to update to Ballerina Swan Lake Preview 1 as follows.\n\n**For existing users:**\n\nIf you are already using jBallerina, you can directly update your distribution to the Swan Lake channel using the [Ballerina update tool](/swan-lake/learn/keeping-ballerina-up-to-date/). To do this, first, execute the command below to get the update tool updated to its latest version. \n                        \n> `ballerina update`\n\n Next, execute the command below to update to Swan Lake Preview 1.\n\n > `ballerina dist pull slp1`                  \n\nHowever, if you are using a jBallerina version below 1.1.0, install via the [installers](https://ballerina.io/downloads/).\n\n**For new users:**\n\nIf you have not installed jBallerina, then download the [installers](https://ballerina.io/downloads/) to install.\n\n### Highlights\n\n- Immutability in the type system: Ballerina compiler guarantees that when you state a value as immutable,  it stays unchanged \n- `distinct` types bring native support for nominal typing into the structural type system in Ballerina \n- Improved the error type design eliminates pain-points in the previous version. The `distinct error` type allows programmers  to define more refined error types that support common error handling use cases\n- Improved transaction support in the language: A set of language features that are designed to make it easier and more convenient to write robust applications in Ballerina\n- Enhanced Query expressions that bring the power of SQL-like query capabilities directly into the language as comprehensions for data processing\n- Introducing the `table` type: A new built-in collection type that works like a general-purpose hash table, where the keys are part of the values being stored\n- Improved Ballerina SQL module API that leverages the latest languages features such as `stream` type, query expressions, and raw templates\n- The new mocking API in Ballerina test framework helps you to mock an entire object or a function allowing you to test your code independent of external dependencies\n\n### What's new in Ballerina Swan Lake - Preview 1\n\n#### Language\n\nThe Language implementation is based on [Ballerina Language Specifications Draft 2020-06-18](https://ballerina.io/spec/lang/draft/v2020-06-18/). This Specification introduces a set of new features and improvements in the following main areas.   \n\n- Type system enhancements\n- Improved immutability support \n- New transactions support \n- Improved query support \n\nSome of these new language features are revamped versions of the existing language features. Therefore, the source code will not be backward compatible with the stable Ballerina 1.2 releases. \n\nIn addition to the new Language features, this release introduces a new parser implementation aiming to improve the performance and usability of the compiler. Now, the compiler has more control over syntax errors and it can provide better diagnostics for syntax errors. Additionally, the new parser has tightened up the language parser rules with respect to the Ballerina language specification. However, it still does not cover the full set of the language features. This will be fixed in the upcoming preview versions.  \n\n##### Type system enhancements\n###### Enum\n\nAn Enum provides a convenient syntax for declaring a union of string constants.\n\n```ballerina\npublic enum Color {\n  RED,\n  GREEN,\n  BLUE\n}\n```\nis exactly equivalent to:\n\n```ballerina\npublic const RED = \"RED\";\npublic const GREEN = \"GREEN\";\npublic const BLUE = \"BLUE\";\npublic type Color RED|GREEN|BLUE;\n```\n\n###### New `readonly` type\n\nA value belongs to the `readonly` type if its read-only flag is set. A value belonging to one of the following inherently-immutable basic types will always have it’s read-only bit set and will always belong to the `readonly` type.\n\n- all simple basic types - nil, boolean, int, float, decimal\n- string\n- error\n- function\n- service \n- typedesc\n\nA value belonging to one of the following selectively-immutable types will belong to `readonly` (i.e., will be immutable) only if its read-only bit is set.\n\n- xml\n- list\n- mapping \n- table\n- object\n\nAn immutable value is deeply immutable and thus an immutable structure is guaranteed to have only immutable values at any level. As with previous versions of Ballerina, an immutable value can be created by calling `.cloneReadOnly()` on the value. Additionally, it is now possible to create an immutable value by providing a read-only type as the contextually expected type.\n\n```ballerina\nreadonly immutableValue = “hello world“;\n```\n###### Intersection type \n\nIntersection types have been introduced with this release. A value belongs to an intersection type `T1 & T2` if the value belongs to both `T1` and `T2`. The implementation currently supports intersection types only if one of the constituent types of the intersection is `readonly`.\n\nIntersection types are especially useful when defining immutable values of selectively immutable types. Providing a `readonly` intersection type as the contextually expected type for a constructor expression results in the value being created as an immutable value. By definition, such a value belongs to the `readonly` type too.\n\n```ballerina\nmap<int> & readonly immutableMap = {\n    a: 1,\n    b: 2,\n    c: 3\n};\n\nreadonly immutableValue = immutableMap;\n```\n\nHere, `immutableMap` belongs to both `map<int>` and `readonly`.\n\n###### Introduction of `distinct` types\n\nDistinct types provide functionalities similar to that provided by nominal types but they work within Ballerina's structural type system. Distinct types are similar to the branded types found in some other structurally typed languages, such as Modula-3. \n\nWith`distinct` types, it is possible to define unique types that are structurally similar. Distinct types can be used only with the object or error basic types. This release adds `distinct error` support and `distinct object` support will be added later. \n###### Revamped `error` type\n\nThe error type has been revised to take advantage of distinct types. The previous error value had a reason string for categorizing errors and a detail record for additional data about the error such as message and cause. \n\n*Old Syntax*\n```ballerina\ntype Error error<reasonType, detailType>;\n```\nHere the `reasonType` is a subtype of `string` and `detailType` is a subtype of `record {| string message?; error cause; (anydata|error)... |}`.\n\nNow error value has a message string, an optional cause, and mapping value for additional details about the error value and distinct error types are used for categorizing. .\n\n*New Syntax*\n```ballerina\ntype Error error<typeParameter>;\n```\n\nHere the error `typeParameter` has to be a subtype of `map<anydata|readonly>`. The error type parameter is optional and if absent, it defaults to `map<anydata|readonly>`. If present, it must be a subtype of `map<anydata|readonly>`.\n\n```ballerina\ntype Error0 error;\ntype Error1 error<map<string>>;\ntype Error2 error<record {| int code; |}>;\n```\n**Revised error constructor**\n\nError values of user-defined types are created using the error constructor of that type. The first mandatory positional augment of the error constructor is the error message and it must be a subtype of `string`. The second optional positional argument can be provided to pass an `error` cause. Error details are provided as named arguments in the error constructor.\n\n```ballerina\ntype AppError error<record {| string buildNo; string userId; |};\n\nAppError appError = AppError(\"Failed to delete the order line\", buildNo=getBuildNo(), userId=userId);\n```\n**Inferring the type of the error**\n\nA type of `error<*>` means that the type is a subtype of `error`, where the precise subtype is to be inferred from the context.\n\n```ballerina\ntype TrxErrorData record {|\n   string message = \"\";\n   error cause?;\n   string data = \"\";\n|};\n\ntype TrxError error<TrxErrorData>;\n\nTrxError e = TrxError(\"IAmAnInferredErr\");\nerror<*> err = e;\n```\n###### The `distinct error` type\n\nThe `error` types can be defined as `distinct` types so that Ballerina programmers can have more fine-grained control over error handling. \n\n```ballerina\n// Define a distinct error type `ApplicationError` to be a subtype of `error`.\ntype ApplicationError distinct error;\n\n// `FileUploadError` is a subtype of `ApplicationError`.\ntype FileUploadError distinct ApplicationError;\n\n// `UserPermissionError` is a subtype of `ApplicationError`.\ntype UserPermissionError distinct ApplicationError;\n \n// Creating Error values\nFileUploadError fileErr = FileUploadError(\"File upload failed\");\n\nApplicationError err = fileErr;\nUserPermissionError userErr = fileErr;  // Compile Time Error.\n```\n\nThe type test expression can be used to identify values of each distinct error type at runtime.\n\n###### The `never` type\n\nThe `never` type describes the type that does not contain any shapes. No value ever belongs to `never`.\n\nThis can be useful to describe the return type of a function, if the function never returns. It can also be useful as a type parameter. For example, `xml<never>` describes an `xml` type that has no constituents, i.e. the empty xml value.\n\n```ballerina\nfunction aNeverReturningFunction() returns never {\n    panic error(\"Invalid function call\");\n}\n```\n###### Revamped `table` type\n\nThe table type has been redesigned to be more consistent with other structural types and no longer has preview status.\n\nA `table` is a structural value whose members are mapping values that represent rows of the table. A table provides access to its members using a key, which comes from the read-only fields of the member. It keeps its members in order but does not provide random access to a member using its position in this order. The built-in functions enable inserting, accessing, deleting data, and applying functions on members of a table.\n\n```ballerina\ntype Employee record {\n    readonly int id;\n    string name;\n    float salary;\n};\n\ntable<Employee> tbEmployee = table {\n    {key id, name, salary},\n    [\n        {1, \"Mary\", 300.5},\n        {2, \"John\", 200.5},\n        {3, \"Jim\", 330.5}\n    ]\n};\n\ntype EmployeeTable table<Employee> key(id);\n\npublic function main() {\n    EmployeeTable employeeTab = table [\n        {id: 1, name: \"John\", salary: 300.50},\n        {id: 2, name: \"Bella\", salary: 500.50},\n        {id: 3, name: \"Peter\", salary: 750.0}\n    ];\n    \n    Employee emp = {id: 5, name: \"Gimantha\", salary: 100.50};\n    employeeTab.add(emp);\n    Employee peekEmp = employeeTab.get(1);\n}\n```\n###### Type inclusion\n\nThe type (including type) that includes another object (included type) can override fields and functions of the included type. The types of the fields and functions in the including type should be subtypes of the types of the corresponding fields and functions in the included type. Object type inclusion can now include non-abstract objects. \n\n```ballerina\ntype GridMessage object {\n    int|string address = \"\";\n    string body = \"\";\n\n    public function init(string body, int|string address) {\n        self.body = body;\n        self.address = address;\n    }\n\n    function getAddress() returns int|string {\n        return self.address;\n    }\n};\n\ntype EfficientGridMessage object {\n    *GridMessage;\n\n    int address = 0;\n\n    public function init(string body, int address) {\n        self.body = body;\n        self.address = address;\n    }\n\n    function getAddress() returns int {\n        return self.address;\n    }\n};\n```\n\n```ballerina\ntype GridPacket record {\n    int|string address;\n    string body = \"\";\n    (int|byte|string)[] header?;\n};\n\ntype EfficientGridPacket record {\n    *GridPacket;\n\n    int address = 0;\n    byte[] header?;\n};\n```\n###### Raw templates\nSimilar to string template literals, a raw template literal allows interpolating expressions into a string literal. However, for a raw template, the resulting value is an object whose type is a subtype of `lang.object:RawTemplate`.\n\n```ballerina\nimport ballerina/io;\nimport ballerina/lang.'object;\n\npublic function main() {\n    string name = \"Ballerina\";\n    'object:RawTemplate greeting = `Hello ${name}!!!`;\n\n    io:println(greeting.strings);\n    io:println(greeting.insertions[0]);\n}\n```\n###### Dependently-typed function signatures\nA function's return type descriptor can now refer to a name of a parameter of the function if the type of the parameter is a subtype of `typedesc`. The actual return type of such a function then depends on the value the user specifies for the referenced `typedesc` parameter when calling the function.\n\nNote that currently this is only supported for external functions.\n\n```ballerina\nimport ballerina/java;\n\nfunction query(typedesc<anydata> rowType) returns map<rowType> = @java:Method {\n    class: \"org.ballerinalang.test.DependentlyTypedFunctions\",\n    name: \"query\",\n    paramTypes: [\"org.ballerinalang.jvm.values.api.BTypedesc\"]\n} external;\n\npublic function main() {\n    map<int> m1 = query(int);\n    map<string> m2 = query(string);\n}\n```\n\n##### Improved support for immutability\n\nThis release introduces improved support for immutability. With the introduction of the `readonly` type, values that are known to be immutable can now be defined at compile-time. \n\nAn intersection type `T & readonly` where `T` is a selectively-immutable type results in a read-only type. When such a type is used as the contextually expected type for a constructor expression, the value created will be an immutable value.\n\n```ballerina\nimport ballerina/io;\n \ntype Details record {|\n   int id;\n   string country;\n|};\n \ntype Employee record {|\n   Details details;\n   string department;\n|};\n \npublic function main() {\n   Employee & readonly emp = {\n       details: {\n           id: 112233,\n           country: \"Sri Lanka\"\n       },\n       department: \"IT\"\n   };\n \n   io:println(emp.isReadOnly());           // true\n   io:println(emp.details.isReadOnly());   // true\n}\n```\n\nAttempting to create an immutable value with incompatible mutable values as members will result in compilation errors.Read-only intersections for objects are only allowed with abstract objects. In order to represent a non-abstract object type as a read-only type, the object would have to be defined as a `readonly object`. For more information, see [Read-only objects](#read-only-objects).\n\n###### Read-only fields\nA record or an object can now have `readonly` fields. A `readonly` field cannot be updated once the record or the object value is created and the value provided for the particular field should be an immutable value. If the field is of type `T`, the contextually-expected type for a value provided for a field would be `T & readonly`.\n\nThus, a `readonly` field guarantees that the field will not change and also that the value set for the field itself will not be updated.\n\n```ballerina\ntype Details record {|\n   int id;\n   string country;\n|};\n \ntype Employee record {|\n   readonly Details details;\n   string department;\n|};\n \npublic function main() {\n   Details & readonly immutableDetails = {\n       id: 112233,\n       country: \"Sri Lanka\"\n   };\n \n   Employee emp = {\n       details: immutableDetails,\n       department: \"IT\"\n   };\n \n   emp.details = { // error - cannot update 'readonly' record field 'details' in 'Employee'\n       id: 2222,\n       country: \"UK\"\n   };\n}\n```\n\nIf all the fields of a closed record or an object are `readonly`, the record or the object itself is considered immutable and a value of the particular type can be used where an immutable value is expected.\n\n```ballerina\ntype Identifier record {|\n   readonly int id;\n   readonly string code;\n|};\n \ntype Controller object {\n   readonly int id;\n  \n   function init(int id) {\n       self.id = id;\n   }\n \n   function getId() returns int {\n       return self.id;\n   }\n};\n \npublic function main() {\n   Identifier details = {\n       id: 112233,\n       code: \"SLC\"\n   };\n  \n   Controller controller = new (1234);\n \n   readonly[] arr = [details, controller];\n}\n```\n\n###### Read-only objects\nAn object type can also be defined as a `readonly object` type and any value belonging to this type will be immutable. Similar to `readonly` fields, each value provided for a field of a `readonly object` is expected to be immutable and the field itself cannot be updated once set.\n\n```ballerina\ntype Details record {\n   int id;\n   string country;\n};\n \ntype Controller readonly object {\n   Details details;\n   boolean allow = true;\n  \n   function init(Details & readonly details) {\n       self.details = details;\n   }\n \n   function getDetails() returns Details {\n       return self.details;\n   }\n};\n \npublic function main() {\n   Controller controller = new ({id: 1234, country: \"SL\"});\n \n   controller.allow = false; // error - cannot update 'readonly' value of type 'Controller'\n}\n```\n##### Transactions\nTransaction support has been revisited based on a [new  proposal](https://github.com/ballerina-platform/ballerina-spec/blob/master/lang/proposals/transaction/transaction.md)\n\nA Ballerina transaction is a series of data manipulation statements that must either fully complete or fully fail, thereby, leaving the system in a consistent state. A transaction is performed using a transaction statement. The semantics of the transaction statement guarantees that every `Begin()` operation will be paired with a corresponding `Rollback()` or `Commit()` operation. It is also possible to perform retry operations over the transactions as well. Other than that, the transaction module provides some util functions to set commit/rollback handlers, retrieve transaction information, etc. This release only supports local transactions.\n\n```ballerina\npublic function main() returns error? {\n    // JDBC Client for H2 database.\n    jdbc:Client dbClient = check new (url = \"jdbc:h2:file:./local-transactions/testdb\",\n                                        user = \"test\", password = \"test\");\n\n    // Create the tables that are required for the transaction.\n    var ret = dbClient->execute(\"CREATE TABLE IF NOT EXISTS CUSTOMER \" +\n                                \"(ID INTEGER, NAME VARCHAR(30))\");\n    handleExecute(ret, \"Create CUSTOMER table\");\n\n    ret = dbClient->execute(\"CREATE TABLE IF NOT EXISTS SALARY \" +\n                                \"(ID INTEGER, MON_SALARY FLOAT)\");\n    handleExecute(ret, \"Create SALARY table\");\n\n    transaction {\n        var customerResult = dbClient->execute(\"INSERT INTO CUSTOMER(ID,NAME) \" +\n                                        \"VALUES (1, 'Anne')\");\n        var salaryResult = dbClient->execute(\"INSERT INTO SALARY (ID, MON_SALARY) \" +\n                                        \"VALUES (1, 2500)\");\n\n        transactions:Info transInfo = transactions:info();\n        io:println(transInfo);\n\n        var commitResult = commit;\n\n        if (commitResult is ()) {\n            io:println(\"Transaction committed\");\n            handleExecute(customerResult, \"Insert data into CUSTOMER table\");\n            handleExecute(salaryResult, \"Insert data into SALARY table\");\n        } else {\n            io:println(\"Transaction failed\");\n        }\n    }\n\n    // Drop the tables.\n    ret = dbClient->execute(\"DROP TABLE CUSTOMER\");\n    handleExecute(ret, \"Drop table CUSTOMER\");\n    ret = dbClient->execute(\"DROP TABLE SALARY\");\n    handleExecute(ret, \"Drop table SALARY\");\n\n    check dbClient.close();\n}\n```\n##### Query improvements \n\nBallerina query action/expression provides a language-integrated query feature using SQL-like syntax. A Ballerina query is a comprehension, which can be used with a value that is iterable with any error type. A query consists of a sequence of clauses (i.e., `from`, `join`, `let`, `on`, `where`, `select`, `do`, and `limit`). The first clause must be a `from` clause and must consist of either a `select` or a `do` clause as well. When a query is evaluated, its clauses are executed in a pipeline by making the sequence of frames emitted by one clause being the input to the next clause. Each clause in the pipeline is executed lazily pulling input from its preceding clause. The result of such a query can either be a list, stream, table, string, XML, or termination value of the iterator which is ().\n\n\n```ballerina\nimport ballerina/io;\n\ntype Student record {\n    string fName;\n    string lName;\n    int intakeYear;\n    float score;\n};\n\ntype Report record {\n    string name;\n    string degree;\n    int expectedGradYear;\n};\n\npublic function main() {\n\n    Student s1 = {fName: \"Alex\", lName: \"George\", intakeYear: 2020, score: 1.5};\n    Student s2 = {fName: \"Ranjan\", lName: \"Fonseka\", intakeYear: 2020, score: 0.9};\n    Student s3 = {fName: \"John\", lName: \"David\", intakeYear: 2022, score: 1.2};\n    Student s4 = {fName: \"Gorge\", lName: \"Fernando\", intakeYear: 2021, score: 1.1};\n    Student[] studentList = [s1, s2, s3, s4];\n\n    Report[] reportList = from var student in studentList\n       where student.score >= 1\n       let string degreeName = \"Bachelor of Medicine\",\n       int graduationYear = student.intakeYear + 5\n       select {\n              name: student.fName,\n              degree: degreeName,\n              expectedGradYear: graduationYear\n       }\n       limit 2;\n\n    foreach var report in reportList {\n        io:println(report);\n    }\n}\n```\n##### Other backward-incompatible/significant improvements\n\n- Parameter defaults are not added if a rest argument is provided when calling a function.\n- The `__init` method of `object` and the `__init` function of modules have been renamed to `init`.\n- Module variables can now be initialized in the module's `init` function.\n- Hex literals have been disallowed as decimal values\n- Record values compatible with `json` can now be assigned to `json` variables.\n- Record values compatible with a `map` type can now be assigned to variables of that `map` type.\n- Type descriptors cannot be used in expression contexts. Only type references are now allowed to be used in expression contexts. \n- List binding patterns can now be used with arrays.\n- Error binding patterns and structured match patterns are not yet supported with the new parser.\n\n\n#### Standard library\n\n##### Introduced new `sql` module\n\nThe newly-introduced `sql` module provides a common interface and functionality to interact with a database. The corresponding database clients can be created by using specific database modules such as MySQL or using the Java Database Connectivity module JDBC. \n\nThe revamped SQL implementation has the support for `sql:ParameterizedQuery` through which parameterized queries can be passed easily.\n\nA sample connector for a MySQL database is as follows.\n```ballerina\nimport ballerina/mysql;\nimport ballerina/sql;\n\npublic function main() returns sql:Error? {\n\n    mysql:Client mysqlClient = check new (\"localhost\", \"root\", \"root\", \"testdb\");\n\n    int id = 10;\n    string name = \"Alice\";\n    sql:ParameterizedQuery sqlQuery = `INSERT INTO Persons (id, name) values (${id}, ${name})`;\n\n    sql:ExecutionResult result = check mysqlClient->execute(sqlQuery);\n    \n    check mysqlClient.close();   \n}\n```\n\n##### Enhanced `logapi` module\n\nRevamped log API to support `anydata` and improved performance.\n\n```ballerina\nimport ballerina/log;\n\npublic function main() {\n    log:printDebug(\"Debug log\");\n    log:printDebug(12345);\n    log:printDebug(3.146);\n    log:printDebug(true);\n\n    Fruit apple = new (\"Apple\", 20);\n    log:printDebug(function() returns int {\n        return apple.getCount();\n    });\n}\n\npublic type Fruit object {\n    string name;\n    int count;\n    public function init(string name, int count) {\n        self.name = name;\n        self.count = count;\n    }\n    function getCount() returns int {\n        return self.count;\n    }\n};\n```\n\n##### Enhanced `grpc` module\n\nThe client/bidirectional streaming service implementation is revamped to support multiple service resources.\n\nThe previous gRPC client/bidirectional streaming had a shortcoming where a service can only contain a single streaming resource. In order to overcome this, the implementation of the client/bidi streaming has been changed to accept a stream type like below.\n\nE.g.,\n\n```ballerina\n\nservice HelloWorld on new grpc:Listener(9090) {\n   resource function lotsOfGreetings(grpc:Caller caller, stream<string,error> clientStream) {\n\n       //Read and process each message in the client stream\n       error? e = clientStream.forEach(function(string name) {\n       });\n       //Once the client sends a notification to indicate the end of the stream, 'grpc:EOS' is returned by the stream\n       if (e is grpc:EOS) {\n           grpc:Error? err = caller->send(\"Ack\");\n\n       //If the client sends an error to the server, the stream closes and returns the error\n       } else if (e is error) {\n\n       }\n   }\n}\n\n```\n\n##### Enhanced `auth` module\n\nThe capability to validate the JWT signature with JWKs is extended now. With that, the JWT signature can be validated either from the TrustStore configuration or JWKs configuration.\n\n```ballerina\njwt:JwtValidatorConfig validatorConfig = {\n    issuer: \"ballerina\",\n    audience: \"vEwzbcasJVQm1jVYHUHCjhxZ4tYa\",\n    clockSkewInSeconds: 60,\n    jwksConfig: {\n        url: \"https://example.com/oauth2/jwks\",\n        clientConfig: {\n            secureSocket: {\n                trustStore: trustStore\n            }\n        }\n    }\n};\n```\n\n##### Enhanced `email` module\n\nThe Email Connector clients are given the capability to add custom SMTP properties, custom POP properties, and custom IMAP properties via the configuration of each of the clients.\n\nThe SMTP client is made capable of sending custom email headers (SMTP header) via the SMTP client and retrieving all the email headers to the user via POP and IMAP clients.\n\nA `listener` is introduced to asynchronously listen to email servers with polling and receive if any email is received. This listener supports both POP3 and IMAP4 protocols. A sample code is given below.\n\n```ballerina\n\nimport ballerina/email;\nimport ballerina/io;\n\nemail:PopConfig popConfig = {\n     port: 995,\n     enableSsl: true\n};\n\nlistener email:Listener emailListener = new ({\n    host: \"pop.email.com\",\n    username: \"reader@email.com\",\n    password: \"pass456\",\n    protocol: \"POP\",\n    protocolConfig: popConfig,\n    pollingInterval: 2000\n});\n\nservice emailObserver on emailListener {\n\n    resource function onMessage(email:Email emailMessage) {\n    }\n\n    resource function onError(email:Error emailError) {\n    }\n\n}\n```\n\n\n##### Adding the `socket` module to Ballerina Central\n\nPreviously, the Socket module was available only in the Ballerina distribution. From this release onwards, it is available in both the\n released Ballerina distribution and Ballerina Central. This will allow us to release the module independently.\n\n#### Developer tools\n\n##### Maven dependency management\n\nNow, you can specify your native jar dependencies with maven artifact id in the Ballerina.toml. When you build the program build tool will fetch those dependencies from the Maven Central automatically. If you specify the maven artifact id and the jar path both the jar path will get precedence.\n\nE.g.,\n\n```ballerina\n[[platform.libraries]]\nmodules = [ \"module1\", \"module2\"]\nartifactId = \"json\"\ngroupId = \"json.org\"\nversion = \"0.7.2\"\n```\n\n##### Scoping support for native dependencies\n\nNow you can specify the scope for platform libraries. Based on the scope, dependencies will be included to different phases. The values of this will be as follows\n\n- default - will be available to compile, run tests, execute, and also distributed with the BALO.\n- provided - will be available to compile, run tests, execute but not distributed with the BALO.\n- testOnly - will be only available to run tests.\n\nE.g., \n\n```ballerina\n[platform]\ntarget = \"java8\"\n\n[[platform.libraries]]\nmodules = [\"sap-client\"]\npath = \"path/to/sap_client_1.2.3.jar\"\nscope = \"provided\" \n```\n\n##### The Bindgen tool\n\n- Java Subtyping support is added to the generated bindings.\n- Maven dependency resolving is integrated into the tool and a new `-mvn|--maven` command option is introduced to facilitate this.\n- Error mappings are improved by generating Ballerina error types for Java exceptions.\n- Introduces a function in the `java` module of the Ballerina standard library to support Java Casting.\n- Introduces the generation of API documentation comments in the generated bindings.\n- Introduces a `--public` flag to change the visibility modifier (which is module private by default) to public.\n- Moves the array util functions into the `java.arrays` module in the Ballerina standard library instead of generating it each time when the tool is executed.\n- Bug fixes and improvements to usability and generated bindings.\n\nThe bindgen tool command after the newly-introduced options is as follows.\n\n```ballerina\nballerina bindgen [(-cp|--classpath) <classpath>...]\n                  [(-mvn|--maven) <groupId>:<artifactId>:<version>]\n                  [(-o|--output) <output>]\n                  [--public]\n                  (<class-name>...)\n```\n\n\n##### API documentation\n\n- The search capability is added into the API Documentation\n- You can now combine documentation from multiple projects using the doc tool\n\n##### Debugger\n\nThis provides variable evaluation support. This will allow you to evaluate a variable using the expression evaluation option to retrieve the value of the variable at a debug hit. \n\n\n#### Test framework\n\n###### Introduction of the mocking API in the `test` module\n\nThe new mocking API simplifies function and object mocking in unit tests via the ***when-then*** convention. \n\nThe mocking features can be used to control the behavior of functions and objects by defining return values or\n replacing the entire object or function with a user-defined equivalent. This feature will help you to test your Ballerina code independently \nfrom other modules and external endpoints. For the complete list of available mocking features, see \n[API Documentation of the test module](https://docs.central.ballerina.io/ballerina/test/latest/).\n\n###### Function mocking\n\nThe `MockFunction` object is added to handle function mocking. The `MockFunction` objects are defined by attaching the `@test:MockFn` annotation to the `MockFunction` to specify the function to mock.\n\n```ballerina\n@test:MockFn {\n    functionName : \"<function_to_mock>\"\n}\ntest:MockFunction mockObj = new();\n```\n\nFunction mocking is done by using the following functions:\n- The `test:when(mockObj)` is used to initialize the mocking capability within a particular test case\n- This allows you to use the associated mocking functions like `call()`, `thenReturn()` and `withArguments()`\n\n###### Object mocking\n\nObject mocking enables controlling the values of member variables and the behavior of the member functions of an object\n\n- Introduced the ability to create a `test double`, which provides an equivalent mock in place of the real object\n- Introduced the capability of stubbing the member function or member variable\n\nObject mocking is done by using the following functions:\n- The `test:mock()` and `test:prepare()` are used to initialize the mocking capability\n- The `test:prepare()` function allows you to use the associated mocking functions like `thenReturn()`, `thenReturnSequence()`, `doNothing() `, and `withArguments()`\n\n\t\n","id":"swan-lake-preview1"},"__N_SSG":true}