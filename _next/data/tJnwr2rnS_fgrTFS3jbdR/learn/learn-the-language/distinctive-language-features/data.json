{"pageProps":{"frontmatter":{"layout":"ballerina-distinctive-language-features-left-nav-pages-swanlake","title":"Data","description":"In this part, you will learn about some of the plain data supported by Ballerina that we have not covered in the last part, specifically, tables and XML types.","keywords":"ballerina, programming language, ballerina packages,language-guide","permalink":"/learn/distinctive-language-features/data/","active":"data","intro":"In this part, you will learn about some of the plain data supported by Ballerina that we have not covered in the last part, specifically, tables and XML types.","redirect_from":["/learn/distinctive-language-features/data"]},"content":"\n## Plain data\n\nLet's now take a look at network data. This is the data that is independent of any specific code operating on the data. This data is typically exchanged through network interfaces between programs. In Ballerina, this is known as plain data.\n\nThis concept is the opposite of objects, which combine data and code as one entity. However, when you are writing network interfaces, you want to work with plain data. It supports a bunch of operations such as deep copy and deep equality checks. You can also serialize and deserialize it without worrying about coupling between the data and its associated code, like objects.\n\nAs a programming language designed for network programming over the cloud, Ballerina makes it easy to work with plain data, and it defines a different type for it.\n\n## Ballerina basic types\n\nIf you categorize all the types of data supported by Ballerina, it is easier for you to know whether they are plain data.\n\nBroadly, all Ballerina values belong to exactly one kind of basic type. These are simple types, sequences, structures, and behavioral types.\n\nSimple types are nil, boolean, integers, floating points, and decimal. These are always plain data.\n\nSequence types are string and XML. These are also always plain data.\n\nStructural types are array, map, record, tuple, and table. These are plain data only if their members are plain data.\n\nAnd finally, the behavioral types include the `function`, `object`, `error`, `stream`, `typedesc`, and `handle` types. \nThese are not plain data.\n\n## ``decimal`` type\n\nBallerina supports one more numeric data type like integers and floating points, which is the ``decimal`` type. The ``decimal`` type also does not support implicit conversion.  \n\nYou can use the ``decimal`` keyword to declare a variable of the ``decimal`` type.\n\n```ballerina\nfunction floatSurprise() {\n    float f = 100.10 - 0.01;\n    // Will print 100.08999999999999\n    io:println(f);\n}\n\ndecimal nanos = 1d/1000000000d;\n```\n\nA decimal number represents a decimal fraction exactly. That means that the precisions are preserved, unlike ``float`` values. For example, a ``decimal`` value of 2.1 kg is not the same as 2.10 kg. \n\nYou can use a literal character ``d`` to indicate a ``decimal`` value, and similarly ``f`` for a ``float`` value.\n\nDecimal numbers are not the same as binary floating point numbers defined as per IEEE standard. They are not built into the ALU logic on the processor. Therefore, their computation is slower yet more accurate and precise.\n\nIn Ballerina, decimal numbers do not offer infinite precision. It is limited to 34 digits only, which is more than enough for representing large physical measurements, such as the universe's age, which takes 27 digits. Additionally, decimal numbers do not support infinity, NaN, or negative zero.\n\n## Plain data basic types to come\n\nBallerina supports two more plain data types that have not been covered yet.\n\nThe first one is the ``table`` type. It is designed to work with arrays and maps. It contains an array of records. It provides random access based on a key, which is a concept similar to relational databases. The keys are stored in fields of records, and these fields are immutable.\n\nThe second one is the ``xml`` type. It is a sequence type built on a sequence of XML items like elements, text, processing instructions, and comments. It is a concept similar to strings and XQuery. XML attributes are represented by *``map<string>``*. XML literals can be written using the XML syntax.\n\n## Immutability\n\nOne of the crucial features of plain data is that it can be made immutable. You cannot do that for objects. Plain data consisting of simple and string values are inherently immutable.\n\nStructural values can be constructed either as mutable or immutable. The value includes a flag that indicates whether it's immutable or not, and it is fixed at the time of construction of the value. Attempting to mutate an immutable structure causes a panic at runtime.\n\nBallerina's notion of immutability is deep. This means that if you have an immutable structure, all its members have to be immutable. This also makes it safer to pass immutable values to other threads for concurrent access.\n\n## ``anydata`` type\n\nYou can use the ``anydata`` keyword to define plain data.\n\n```ballerina\nanydata x1 = [1, \"string\", true];\n```\n\nThe ``anydata`` type is a subtype of the ``any`` type. The ``==`` and ``!=``  operators available on ``anydata`` test for deep equality.\n\nYou can clone an ``anydata`` value using the **``clone()``** function.\n\n```ballerina\nanydata x2 = x1.clone();\n```\n\nThis returns a new ``anydata`` value, with the same mutability as **``x1``**. There is another function **``cloneReadOnly()``** that returns an immutable deep copy. Both the functions do not copy the immutable parts of the ``anydata`` value. This ensures that the clone operations are safe for concurrency.  \n\n``anydata`` also allows boolean comparison and can be used to define constants.\n\n```ballerina\nboolean eq = (x1 == x2);\n\nconst map<int> RED = {R: 0xFF, G: 0, B: 0};\n```\n\nThe equality operation also takes care of cycles within ``anydata`` structure values.\n\n## Configurable variables\n\nBallerina also has a concept of a configurable variable. A module-level variable can be declared as a configurable variable. This is useful when some application code is defined just to configure things. You can use the ``configurable`` keyword in this case.\n\n```ballerina\nconfigurable int port = 8080;\n```\n\nThe initializer of a configurable variable can be overridden at runtime. A variable where runtime configuration is required can use ``?`` as the initializer.\n\n```ballerina\nconfigurable string password = ?;\n```\n\nA configurable variable must be a subtype of ``anydata``.\n\n## Optional fields\n\nBallerina's type system is unique from other programming languages because it describes data both in program memory and on the wire. This is especially relevant for the cloud era, where more applications use APIs which provide network interfaces to a different system to send and receive data on the wire.  \n\nTherefore, Ballerina's type system design is based on defining a data type interface that works consistently across the memory buffers of the process in which the data is processed and in the network.\n\nTo facilitate this requirement, the type system needs to do a few things differently than a regular type system. It must be flexible, like a schema language. And one of the ways it is done in Ballerina is by using optional fields.\n\nYou can define a record with an optional field.\n\n```ballerina\ntype Headers record {\n   string 'from;\n   string to;\n\n   // Records can have optional fields\n   string subject?;\n};\n```\n\nIn the above type declaration, the **``Headers``** record type has three fields. The **``subject``** field is suffixed with ``?``, which tells the compiler that it is an optional field. Thus, you can define a variable of type **``Headers``** with or without the optional field.\n\n```ballerina\nHeaders h = {\n    'from: \"John\",\n    to: \"Jill\"\n};\n\nstring? subject = h?.subject;  \n```\n\nYou can use ``?.`` to access the optional field. It will return nil if the field is not present.\n\nThis feature is handy for describing the type of data payloads transferred across network interfaces that typically contain mandatory and optional fields.\n\n## Open records\n\nOpen records is another concept that is important for dealing with network interfaces. By default, a record type declared in Ballerina is open. This means that you can add more fields to it than those specified.\n\n```ballerina\ntype Person record {\n    string name;\n};\n\ntype Employee record {\n    string name;\n    int id;\n};\n\nEmployee e = {\n    name: \"James\",\n    id: 10\n};\n\nPerson p = e;\n\nPerson p2 = {\n    name: \"John\",\n    \"country\": \"UK\"\n};\n```\n\nIn the above code example, the record types **``Person``** and **``Employee``** are declared. The **``Person``** type has a ``string`` field **``name``**, yet, **``p2``** is initialized with another field, **``country``**. This field can be of type ``anydata`` since it was not specified initially. It is required to specify the keys of the unspecified fields within quotes.\n\nSimilarly, the variable **``p``** of type **``Person``** also accepts the variable **``e``**, which is of the **``Employee``** type. In this case, the field **``id``** is treated as ``anydata`` within **``p``**.  In this way, Ballerina allows a record to be open such that additional unspecified fields can be added at runtime.\n\nAn open record is equivalent to a *``map<anydata>``*.\n\n## Control openness\n\nIf you do not want to allow the open behavior in records, Ballerina has a special syntax.\n\n```ballerina\ntype Coord record {|\n    float x;\n    float y;\n|};\n\nCoord x = {\n    x: 1.0,\n    y: 2.0\n};\n\nmap<float> m1 = x;\n```\n\nIn the above code example, using the ``{|`` and ``|}`` delimiters indicate that the record is closed. The record type **``Coord``** has only the two fields **``x``** and **``y``** of the ``float`` type. So you can also treat it as a map of float.  \n\nYou can also use a ``T...`` notation to allow other fields of a type ``T`` within a record.\n\n```ballerina\ntype Headers record {|\n    string 'from;\n    string to;\n    string...;\n|};\n\nHeaders h = {\n    'from: \"Jane\",\n    to: \"John\",\n    \"cc\": \"James\"\n};\n\nmap<string> m2 = h;\n```\n\nIf you have an open record, then additional fields of the ``anydata`` type can be added. But otherwise, use *``T…;``* to allow other fields of type ``T``. Therefore, *``map<T>``* is the same as *``record {| T...; |}``*.\n\n## ``json`` type\n\nBallerina defines another type ``json``.\n\n```ballerina\njson j = {\n    \"x\": 1,\n    \"y\": 2\n};\n```\n\nThe ``json`` type is the union of ``( ) | boolean | int | float | decimal | string | json[ ] | map<json>`` .  \n\nA ``json`` value can be converted to and from JSON format in a straightforward way, except for the numeric types in Ballerina, which are not natively available in the JSON specification.\n\n```ballerina\nstring s = j.toJsonString();\n\njson j2 = check value:fromJsonString(s);\n\njson j3 = null;\n```\n\nBallerina also allows the use of the ``null`` keyword instead of ``()`` for JSON compatibility. The lang libraries provide several functions such as **``toJson()``** and **``fromJson()``** to convert between ``anydata`` and ``json``.  Table values are converted to arrays, and XML values are converted to strings.\n\nThe ``json`` type is basically ``anydata`` but without ``table`` and ``xml``. ``json`` and ``xml`` types are not parallel.\n\n## Work with JSON - two approaches\n\nBallerina allows two approaches to work with JSON data.\n\nThe first approach enables you to work with ``json`` values directly.  This is easy since valid JSON data is also legitimate Ballerina syntax.\n\nAdditionally, it is also possible to convert from JSON to application specific types as a second approach. For example, you can convert from JSON to a user-defined subtype of ``anydata``, process that data in an application specific subtype, and convert it back to JSON.\n\nThe second approach is something where Ballerina really shines compared to other languages because it is very hard to translate between JSON and the native types in other languages.\n\n## Work with JSON directly\n\nWorking directly with JSON data is easy with the use of the ``json`` type.\n\n```ballerina\njson j = {\n    x: {\n        y: {\n            z: \"ballerina\"\n        }\n    }\n};\n\njson v = check j.x.y.z;\n\nstring s = check v;\n```\n\nYou can define any ``json`` structure like **``j``** and access its fields using  **``j.x``** or **``j?.x``**. The JSON field values are implicitly converted to unstructured types.  \n\nBallerina supports runtime type checking of the ``json`` structure to raise runtime errors using the ``check`` expression. This gives a feel of working with a dynamic language where the JSON structure is unknown at compile time. Additionally, lang library functions are also provided to check for types explicitly.\n\n```ballerina\nstring s = check value:ensureType(v);\n```\n\n## ``match`` statements with maps\n\n``json`` values can be used in a ``match`` statement to provide flexible pattern matching based on the fields in the ``json`` structure.\n\n```ballerina\nfunction foo(json j) returns error? {\n    match j {\n        {command: \"add\", amount: var x} => {\n            decimal n = check x.ensureType(decimal);\n            add(n);\n        }\n        _ => {\n            return error(\"invalid command\");\n        }\n    }\n}\n```\n\nIn the above code example, the ``match`` expression matches the json value **``j``**. The interesting thing is that the match pattern also binds to a variable **``x``** that is used within the code for additional processing. In this way, you can directly use ``json`` structures within the control flow of your program.\n\n``match`` schematics are open, and you do not have to specify all the fields of the ``json`` value in the pattern for matching.\n\n## Convert from user-defined types to JSON\n\nA user-defined type can be easily converted to JSON. In this case, there are two possibilities.\n\nFor types that are closed, the conversion is implicit.\n\n```ballerina\ntype ClosedCoord record {|\n    float x;\n    float y;\n|};\n\nClosedCoord coord = {\n    x: 1.0,\n    y: 2.0\n};\n\njson j = coord;\n```\n\nIn the case of open types, things are a bit complicated. For that purpose, lang libraries provide functions to make your work easier.\n\n```ballerina\ntype Coord record {\n    float x;\n    float y;\n};\n\nCoord coord = {\n    x: 1.0,\n    y: 2.0\n};\n\njson j = coord.toJson();\n```\n\nIn the above code example, **``Coord``** is an open record. Therefore, any number of ``anydata`` fields can be added to it, including tables and XML. The **``toJson()``** function converts ``anydata`` to ``json``, such that all the subtypes, including tables and XML, are handled appropriately.\n\n## Convert from JSON to user-defined types\n\nThere are a few nuances involved in converting from JSON to a user-defined type.\n\nAn obvious mechanism is typecasting.\n\n```ballerina\ntype Coord record {\n    float x;\n    float y;\n};\n\njson j = {\n    x: 1.0,\n    y: 2.0\n};\n\n// Runtime error.\nCoord c = <Coord>j;\n```\n\nHowever, this does not work because the ``json`` fields can later be assigned to something other than ``float``. Therefore, the typecasting operation would not be type-safe. This goes back to the concept of covariance that limits mutation on type structures with inherent types. Therefore, you can only create a read-only copy, and use it in the type cast expression.\n\n```ballerina\njson rj = j.cloneReadOnly();\nCoord c = <Coord>rj;\n```\n\n## Convert to a user-defined type - `cloneWithType`\n\nThere is another way of converting from JSON to a user-defined type.\n\n```ballerina\ntype Coord record {\n    float x;\n    float y;\n};\n\njson j = {x: 1.0, y: 2.0};\n\nCoord c = check j.cloneWithType(Coord);\n```\n\nIn the above example, the **``cloneWithType()``** function uses the ``typedesc`` argument **``Coord``** as inherent type, and works recursively to clone every part of the value, including immutable structural values.\n\nThis is a ``lang.value`` lang library function. You can also use the function without the argument, in which case the argument will be inferred from the contextually-expected type.\n\n```ballerina\nCoord c = check j.cloneWithType();\n```\n\n## Resource method typing\n\nThe features of JSON to user-defined type conversion and vice versa are advantageous when you write service objects in Ballerina.\n\nHere is code that defines a service for a calculator API with the ``add`` endpoint.\n\n```ballerina\nimport ballerina/http;\n\ntype Args record {|\n    decimal x;\n    decimal y;\n|};\n\nlistener http:Listener h = new (9090);\n\nservice /calc on h {\n    resource function post add(@http:Payload Args args) returns decimal {\n        return args.x + args.y;\n    }\n}\n```\n\nIn the above code example, the **``Args``** record is a closed record. It is used as a parameter of the resource method corresponding to the HTTP POST operation whenever the API **``/calc/add``** is triggered.\n\nThanks to the implicit data binding and conversion feature of Ballerina, the JSON payload coming in the wire as part of the HTTP request is converted to the **``Args``** record, using the **``cloneWithType()``** function. Therefore, its fields **``x``** and **``y``** are readily accessible. The return type of the resource method is the ``decimal`` type which is a subtype of ``anydata`` and is mapped to the protocol format on the wire, which in most cases is JSON.  This is how Ballerina types can be used to describe data on the wire, or on network interfaces.\n\nAnnotations added to this code also help in refining the mapping between Ballerina-declared types and the wire format. Further, the service declaration can also be used to generate an OpenAPI specification.\n\n## JSON numbers\n\nThere is one complication in dealing with JSON in Ballerina. This is because Ballerina allows the ``json`` type to have a union of ``int``, ``float``, and ``decimal``. Whereas the JSON specification has only one numeric type, it does not distinguish between integers and floating-point numbers.\n\nWhile converting from Ballerina's numeric types to JSON, using the **``toJsonString()``** function converts Ballerina's ``int``, ``float``, and ``decimal`` values to the JSON numeric syntax. This is straightforward.\n\nBut converting from JSON to Ballerina's numeric types requires additional interpretation. The **``fromJsonString()``** function converts JSON numeric syntax into the ``int`` type, if possible, and ``decimal`` otherwise, to preserve the number precision of the numeric data in JSON. This is the case in which you do not have any information about types. Subsequently, you can use **``cloneWithType()``** or **``ensureType()``** to convert from integer or decimal to the user's chosen numeric type.  \n\nThe net result is the same, and you can convert between JSON and Ballerina's numeric types across the full range of all values. But the types will depend on how far you go in the conversion process within the program. The one exception to this conversion is ``-0``. It is an edge case and is represented as ``float``.\n\n## Query expressions\n\n### SQL-like syntax for list comprehensions\n\nBallerina supports SQL-like query syntax to perform list comprehensions. This is similar to C# and Python's way of list comprehension. In this case, the list is defined as an array.\n\nThe basic concept of list comprehension is based on the concept of mathematical \"set builder\" notation.\n\n```ballerina\nint[] nums = [1, 2, 3, 4];\n\nint[] numsTimes10 = from var i in nums\n    select i * 10;\n\nint[] evenNums = from var i in nums\n    where i % 2 == 0\n    select i;\n```\n\nIn the above code example, **``nums``** is an integer array containing a list of numbers.\n\nThe array **``numTimes10``** is constructed by iterating over **``nums``** using the ``from`` clause,  where **``i``** is the iteration value, and then using the ``select`` clause to evaluate the expression **``i \\* 10``** to include the result in the array. Therefore, the result is a new list **``[10,20,30,40]``**.\n\nSimilarly, you can also apply SQL-like filters to the iteration value using the ``where`` clause. The array **``evenNums``** is built in that way by introducing the ``where`` clause that filters the values for which the expression evaluates to ``true``. The resultant list is **``[2,4]``**.\n\n### Destructure records\n\nThe list comprehension concept can also be applied to structured types, such as records.\n\n```ballerina\ntype Person record {\n    string first;\n    string last;\n    int yearOfBirth;\n};\n\nPerson[] persons = [];\n\nvar names = from var {first: f, last: l} in persons\n    select {first: f, last: l};\n```\n\nIn the above code example, **``persons``** is an array of records. The variable **``names``** is constructed from a binding pattern **``{first: f, last: l}``** that allows you to destructure records using a pattern. This results in variable **``f``** being bound to the ``first`` field of the record and **``l``** being bound to the ``last`` field.  \n\nAs usual, the query expression iterates over the **``persons``** list using the ``from`` clause. At each iteration, the fields of the record are bound to the **``f``** and **``l``** variables, and then the ``select`` clause is used to construct a new array of records containing only the fields **``first``** and **``last``**.\n\nThe binding pattern **``{first: f, last: l}``** can also be simplified as **``{first, last}``**.\n\n```ballerina\nvar names = from var {first, last} in persons\n    select {first, last};\n```\n\nIn this way, a binding pattern **``{x}``** can be substituted for **``{x : x}``**.\n\n### Let clause\n\nYou can also have any number of ``let`` clauses within the query expression, between ``from`` and ``select``.\n\n```ballerina\nstring[] names = from var {first, last} in persons\n    let int len1 = first.length()\n    where len1 > 0\n    let int len2 = last.length()\n    where len2 > 0\n    let string name = first + \" \" + last\n    select name;\n```\n\nIn the above code example, multiple ``let`` and ``where`` clauses are used to construct an array of strings **``names``** containing names of all persons, by concatenating their first and last names. The record entries whose first or last names have a length of zero are filtered out by using the first and second combination of ``let`` and ``where`` clauses. The overall query expression follows semantics like XQUERY FLWOR (for, let, where, order by, and return).\n\nYou can think of the overall semantics like a pipeline, which starts off by generating a list of bindings in the first stage, and the subsequent stages take the bindings from the previous stage of the pipeline and output another set of variable bindings.\n\n### Ordering\n\nYou can also have an ordering of the query results using the ``order by`` clause.\n\n```ballerina\ntype Employee record {\n    string firstName;\n    string lastName;\n    decimal salary;\n};\n\nEmployee[] employees = [\n    // ...\n];\n\nEmployee[] sorted = from var e in employees\n    order by e.lastName ascending, e.firstName ascending\n    select e;\n```\n\nIn the above code example, an ``order by`` clause is added to the query, along with the keys that you want to sort by, and the order of sorting. In this case, the keys are the ``lastName`` and ``firstName`` fields of the **``Employee``** record, and the order is set to ``ascending``. So this query takes a list of variable bindings, sorts them, and generates a new array of records in the specified sorted order.\n\nThe ordering works consistently with the ``<``, ``<=``, ``>``, and ``>=`` operators. The ``order by`` clause also allows other expressions apart from field access. In case the ordering needs to be done for Unicode strings, a library module can be used to specify the sort key such that ordering can be achieved in a locale-specific way.\n\nThere are some complex cases where ordering cannot be achieved. This happens when the type of the ``order by`` expression does not support ordering. For Ballerina, any comparison with nil or floating point ``NaN`` are unordered. So if these unordered types are encountered in the query, they will be returned at the end.\n\nA real-world example of an unordered scenario is the price of items on a shopping website. You see some items that have a price, and some items do not have a price due to some reason, or it indicates that the site will send a notification when the price is available. Now, if you want to list all the items based on an order starting from least expensive, then you want to see the items with the price first, instead of the items without the price. That's why applying the query on item's price with ascending order will return the unordered items, with a price value of nil, at the end. The same is applicable for ordering items in descending order when you want to see the most expensive items first.\n\n### ``limit`` clause\n\nBallerina also supports the ``limit`` clause within query expressions.\n\n```ballerina\nEmployee[] top100 = from var e in employees\n    order by e.salary descending\n    limit 100\n    select e;\n```\n\nIn the above code example, the query pipeline has a ``limit`` clause which evaluates to an integer value of 100. The pipeline generates a list of **``Employee``** record entries in descending order, based on the ``salary`` field and the ``limit`` clause limits the generated result to the first 100 entries.\n\n## Table concept  \n\nBallerina supports yet another structured data type, table.\n\nBallerina's philosophy is to use tables as containers for building centralized data structures that are operated on by multiple functions. This concept augurs well with the various scripting languages, like Lisp, Python, or JavaScript, which are primarily used for integration purposes to glue two disparate systems together. This is the opposite of the philosophy followed in languages like Java, where programmers create separate classes and objects to separate the concerns within the code and write different containers for data structures. Ballerina encourages the use of its built-in data structures rather than everybody designing their own custom data structures.\n\nTables are a built-in data structure. They are just like the arrays and maps that you have seen so far. Therefore, they have some array-like and some map-like features.\n\nA table is an array of records, and each record represents a row in the table. The rows are identified by keys, which is similar to maps. Thus, you can either iterate over the table, item by item, like arrays, or directly point to the item using the associated key. But unlike in maps where the keys are of ``string`` type and are different from the fields, a table stores the keys as fields in the rows. This approach is similar to the concept of primary keys in a SQL-based database table where one of the columns is designated as a primary key, which is used to uniquely identify the database record.\n\nTherefore, a table maintains an invariant that each row is uniquely identified by a key that is not limited to the ``string`` type and is immutable. Additionally, tables also preserve the order of the rows.\n\n### Table syntax\n\nThe table syntax in Ballerina looks like this.\n\n```ballerina\ntype Employee record {\n    readonly string name;\n    int salary;\n};\n\ntable<Employee> key(name) t = table [\n    {name: \"John\", salary: 100},\n    {name: \"Jane\", salary: 200}\n];\n```\n\nIn the above code example, **``Employee``** is a record type that contains the two fields **``name``** and **``salary``**. The **``name``** field is marked as ``readonly``, which prevents updates to the field after record creation.\n  \nTable **``t``** is defined with the ``table`` keyword. The definition also takes the type for the row, which is **``Employee``**, and the key field, which is **``name``**. It is declared with the ``key`` keyword.\n\nThe table constructor adds two records. The table constructor is exactly like an array constructor, except that it uses the ``table`` keyword in front.\n\nOnce the table is constructed, you can look up the records using the key, just like you would do with a map.\n\n```ballerina\nEmployee? e = t[\"Fred\"];\n```\n \nYou can use the ``foreach`` loop to iterate over all the rows in the table.\n\n```ballerina\nfunction increaseSalary(int n) {\n    // Iterates over the rows of `t` in the specified order.\n    foreach Employee e in t {\n        e.salary += n;\n    }\n}\n```\n\nThere is a direct and simple mapping from a table to JSON. Table to JSON conversion will result in an array of JSON objects where each member of the array corresponds to a member of the table.\n\n### Multiple key fields\n\nYou can have a table with a multipart key spread over several fields.\n\n```ballerina\ntype Employee record {\n    readonly string firstName;\n    readonly string lastName;\n    int salary;\n};\n\ntable<Employee> key(firstName, lastName) t = table [\n    {firstName: \"John\", lastName: \"Smith\", salary: 100},\n    {firstName: \"Fred\", lastName: \"Bloggs\", salary: 200}\n];\n```\n\nIn the above code example, the **``Employee``** record has three fields: **``firstName``**, **``lastName``**, and **``salary``**. The table **``t``** is defined with both the **``firstName``** and **``lastName``** fields as keys.\n\nSubsequently, you can also look up the table using both keys.\n\n```ballerina\nEmployee? e = t[\"Fred\", \"Bloggs\"];\n```\n\n### Structured keys\n\nThe keys are not restricted to the ``string`` type. You can also have keys belonging to any subtype of plain data, which also includes structured types.\n\n```ballerina\ntype Employee record {\n    readonly record {\n        string first;\n        string last;\n    } name;\n    int salary;\n};\n\ntable<Employee> key(name) t = table [\n    {name: {first: \"John\", last: \"Smith\"}, salary: 100},\n    {name: {first: \"Fred\", last: \"Bloggs\"}, salary: 200}\n];\n```\n\nIn the above code example, the **``Employee``** record has a **``name``** field, which is also a record type having two fields, **``first``** and **``last``**. The table **``t``** uses the **``name``** field as the key.\n\nAccessing the rows in this table works in the same way.\n\n```ballerina\nEmployee? e = t[{first: \"Fred\", last: \"Bloggs\"}];\n```\n\nWith structured types, you can define rich keys with different types such as arrays of bytes, which makes it a binary key. This is a very powerful way of programming with tables, where you can directly work with the keys, instead of being constrained by faked up string representations of your keys.\n\n### Query tables\n\nApart from looking up rows in a table, you can also combine them with queries.\n\n```ballerina\ntype Employee record {|\n    readonly int id;\n    string firstName;\n    string lastName;\n    int salary;\n|};\n\ntable<Employee> key(id) employees = table [\n    {id: 1, firstName: \"John\", lastName: \"Smith\", salary: 100},\n    {id: 2, firstName: \"Fred\", lastName: \"Bloggs\", salary: 200}\n];\n\nint[] salaries = from var {salary} in employees\n                    select salary;\n```\n  \nIn the above code example, **``salaries``** is an array constructed from a query that selects the salary of each **``Employee``** record within the table **``employees``**. The query returns the list of all salary figures, which are of the integer type.\n\nThe actual type of the query output is determined by the context, for example, integer array in this case, or the input type.\n\n### Create tables with query\n\nYou can also use a query expression to create tables.\n\n```ballerina\nvar highPaidEmployees = \n   table key(id) \n   from var e in employees\n   where e.salary >= 1000\n   select e;\n```\n\nIn the above code example, a new table is produced from the query expression, which selects all the rows whose **``salary``** field is greater than or equal to 1000. A table is created as a result of the query expression explicitly specifying what to create by starting with the ``table`` keyword. The key of the created table can also be specified explicitly.\n\n### Join clause\n\nBallerina queries can also leverage the join clause on table keys.\n\n```ballerina\ntype User record {|\n    readonly int id;\n    string name;\n|};\n\ntype Login record {|\n    int userId;\n    string time;\n|};\n\ntable<User> key(id) users = table [\n    {id: 1234, name: \"Keith\"},\n    {id: 6789, name: \"Anne\"}\n];\n\nLogin[] logins = [\n    {userId: 6789, time: \"20:10:23\"},\n    {userId: 1234, time: \"10:30:02\"},\n    {userId: 3987, time: \"12:05:00\"}\n];\n\nstring[] loginLog = from var login in logins\n                        join var user in users\n                        on login.userId equals user.id\n                        select user.name + \":\" + login.time;\n```\n\nIn the above code example, there is a table **``users``** of **``User``** records and an array **``logins``** of **``Login``** records.\n\nThe query uses the ``join`` clause to combine the list of **``logins``** and the **``users``** table to create a list of user-friendly login information. It uses the ``on`` condition to match the values of the fields **``userId``** and **``id``**, from the **``Login``** and **``User``** records respectively. Finally, it builds out a string containing the fields **``name``** and **``time``** from these two records, separated by a colon symbol.\n\nThe ``join`` clause uses an internal hashtable, thereby improving the query efficiency compared to O(n2) time complexity observed in nested ``from`` clauses.  The type to join on must be ``anydata``.\n\n## Stream type\n\nBallerina supports the concept of a stream. A stream is a sequence of values that are generated as needed. This concept is the opposite of a list that is pre-populated with values before you perform any operations on it.\n\nThe ``stream`` type is a separate basic type but acts as an object. A stream is defined with the ``stream`` keyword, as **``stream<T, E>``**, where members of the stream sequence are of type ``T`` and the termination value is of type ``E``. A shorter definition of **``stream<T>``** can be used to mean **``stream<T,()>``**, where the termination value is nil.\n\nGenerating the values for a stream can result in an error, in which case the stream is terminated with an error value.\n\n### Query with streams\n\nYou can use query expressions with streams.\n\n```ballerina\ntype LS stream<string, error?>;\n\n// Strip blank lines.\nfunction strip(LS lines) returns LS {\n    return stream from var line in lines\n        where line.trim().length() > 0\n        select line;\n}\n```\n\nIn the above code example, **``LS``** is a ``stream`` type that represents a line stream. This stream contains a sequence of ``string`` values and terminates with an ``error`` value or nil. The function **``strip()``** executes a query on a stream of type **``LS``** and returns the same type. The query expression operates over the stream, and for each member of the stream, the ``where`` clause filters out the strings whose length is zero after stripping out the whitespaces.\n\nThe important thing to note here is that the query works the stream lazily. It does not read the whole stream and evaluate it at once when the strip function is called.\n\nUsing the stream keyword in front of ``from`` makes this query expression return a new ``stream`` value of the same type. An error is returned if the iteration results in an error. However, if there is an error as a result of evaluation, then it will result in the returned stream being terminated with that error value. You can capture that error only while reading the returned stream.\n\nYou can also iterate over streams, like a loop operation, to perform some computation. However, you cannot use ``foreach`` with a stream that may terminate with an error since the ``foreach`` statement cannot produce a value because it is a statement, and error values cannot be ignored in Ballerina. You can achieve that with the ``do`` clause, in conjunction with the ``from`` clause.\n\n```ballerina\nfunction count(LS lines) returns int|error {\n    int nLines = 0;\n    check from var line in lines\n        do {\n            nLines += 1;\n        };\n    return nLines;\n}\n```\n\nIn the above code example, the function **``count()``** works on the stream of type **``LS``**. The query iterates over the stream and the ``do`` clause performs an operation to increment the **``nLines``** variable to record the number of lines.\n\nThe use of the ``check`` keyword before the query handles the scenario where the stream’s termination value can be an error by capturing the error locally within the function call and returning it.\n\n## Backtick templates\n\nBallerina supports the concepts of backtick templates. A backtick template is composed of a tag followed by a backtick string, enclosed within the `` ` `` notation, where you can have expressions that are enclosed in **``${...}``**.\n\n```ballerina\nstring name = \"James\";\nstring s = string `Hello, ${name}`;\n```\n  \nIn the above code example, the value of **``s``** is evaluated as ``\"Hello, James\"`` from the backtick template. It has a ``string`` tag, and the expression **``${name}``** evaluates to the value held by the variable **``name``**, which is interpolated within the backtick string to return a string value.\n\nThe backtick template is evaluated in two phases. The first phase accumulates the contents of the template in a list of strings and a list of expressions. In the second phase, depending on the tag, the expression is evaluated and turned into the type of tag. In this case, it converts the result of the expression into a string, since the tag is ``string``.  \n\nIn case you want to add the backtick itself, within a backtick template, you can use the same **``${...}``** syntax.\n\n```ballerina\nstring s = string `Backtick:${\"`\"}`;\n```\n\nIn the above code example, the string **``s``** will be assigned a value of ``\"Backtick:`\"``.\n\n## Raw templates\n\nRaw templates are backtick templates without the tag, in which case phase two of the template evaluation only performs expression evaluation. A raw template returns an object containing an array of strings separated by insertions and an array of the results of expression evaluation.\n\nOne of the important use cases of raw templates is parameterized SQL queries.\n\n```ballerina\ndb->query(`SELECT * FROM  order WHERE customer_id = ${customerId}`);\n```\n\nIn the above example, assume that **``db``** is a client object making a remote call to a SQL database. The raw template passed to the query method translates to an array of two strings ``\"SELECT * FROM order WHERE customer_id =\"`` and ``\"\"``. The second string is empty as it comes after the expression. Along with that, it also passes an array of evaluated expressions which is the value of the **``customerId``** variable here. Thus, the SQL syntax is turned into the right syntax with the required substitution for the underlying SQL implementation.\n\n## XML overview\n\nIn Ballerina, XML is a separate basic type. It is based on the concept of sequence and is derived from the concept of XQuery as well as XPath2. The model of XML used in Ballerina is based on XML Infoset, which follows the basic concept of XML elements and attributes, rather than the XML schema, as in the case of PSVI (Post-Schema Validation Infoset).\n\nBallerina uses the template concept to construct ``xml`` values. It is designed to work with the underlying concepts of elements and attributes, which also forms the basis for HTML. Therefore, Ballerina treats HTML as XML.\n\nAs part of XML handling, Ballerina provides an XPath-like navigation syntax. The ``xml`` type also works well with query expressions to provide XQuery FLWOR-like functionality.\n\nOverall the XML design in Ballerina is opinionated, and it works more like the regular containers such as lists and tables. Also, Ballerina's XML representation doesn't support an up pointer. Therefore, the XML elements do not have references to parents and siblings since they do not know where they are in the overall XML structure.\n\n### Sequences\n\nA sequence is another categorization of types within Ballerina that we briefly mentioned earlier. It is a basic type. The ``string`` and ``xml`` types are the two sequence types in Ballerina.\n\nA sequence is formed by having a value of basic type ``T`` and concatenating it with another sequence of values of type ``T``. An empty sequence of basic type ``T`` or a singleton of basic type ``T`` is also considered a sequence.\n\nSequences are different from arrays in the sense that they are not nested. In the same way, you do not have a string of strings, but just a linear sequence of characters. Also, there is no difference between a singleton ``x`` and a sequence consisting of just ``x``. The basic type of a sequence determines the basic type of its members.\n\nSimilarly, the way an XML element is represented is by a sequence of that XML element.\n\nThe mutability of a sequence is similar to strings. Members of a sequence are also immutable, just like strings. For example, you cannot mutate a sequence of one item into a sequence of two items.\n\nA sequence has no storage identity. Two sequences will match for the ``===`` operator if their members match for the same operation.\n\n### XML data model\n\nIn Ballerina, an ``xml`` value is a sequence representing the parsed content of an XML item.\n\nAn ``xml`` value has four kinds of items. It can have an element, processing instruction, or a comment item, all of which correspond 1:1 with the XML infoset items. The fourth item is the text item that corresponds to a chunk of XML infoset defined character information items. An XML document is represented by an XML sequence with only one element and no text.\n\nAn element item consists of three things, name of type ``string``, attributes of type ``map<string>``, and children of type ``xml``. A text item has no identity, therefore the ``==`` operator has the same meaning as ``===``. Consecutive text items never occur in an ``xml`` value. Instead, they are always merged.\n\nAn element item is mutable whereas text items are immutable.\n\n### XML templates\n\nXML templates are used to create ``xml`` values.\n\n```ballerina\nstring url = \"https://ballerina.io\";\n\nxml content = xml`<a href=\"${url}\">Ballerina</a> is an <em>exciting</em> new language!`;\n\nxml p = xml `<p>${content}</p>`;\n```\n\nThe above code example defines two variables **``content``** and **``p``** of the ``xml`` type using backtick templates containing the ``xml`` tag. In this case, phase two of the template processing does a parsing using the XML 1.0 recommendation's grammar for content (what XML allows between a start-tag and end-tag). You can place the interpolated expressions of the template within XML content, or in attribute values as ``string`` values.\n\n### XML operations\n\nYou can also perform different operations on values of the ``xml`` type.\n\nYou can use the ``+`` operator to concatenate two ``xml`` values.\n\n```ballerina\nxml x1 = xml `<name>Sherlock Holmes</name>`;\nxml x2 = xml `<details>\n                <author>Sir Arthur Conan Doyle</author>\n                <language>English</language>\n              </details>`;\n\nxml x3 = x1 + x2;\n```\n\nThe ``==`` operator does a deep equals comparison.\n\nYou can loop through the ``xml`` elements in a ``foreach`` statement.\n\n```ballerina\nxml x4 = xml `<name>Sherlock Holmes</name><details>\n                    <author>Sir Arthur Conan Doyle</author>\n                    <language>English</language>\n                </details>`;\n\nforeach var item in x4 {\n    io:println(item);\n}\n```\n\nIn the above code example, the code iterates through the ``xml`` value in **``x4``** to print the *\\<name>* and *\\<details>* elements.\n\nYou can also access the ``i``th element using the ``x[i]`` notation, and index into them.\n\n```ballerina\nio:println(x4[0]);\n```\n\nSimilarly, you can use the ``.`` notation to access attributes.\n\n```ballerina\nxml x5 = xml `<para id=\"greeting\">Hello</para>`;\nstring id = check x5.id;\n```\n\nIf you want to check for optional attributes, use the ``?`` notation before ``.`` to get ``()`` in case the attribute is not present.\n\n```ballerina\nstring? name = check x5?.name;\n```\n\nThe **``lang.xml``** lang library provides operations on ``xml`` values. For example, you can also mutate an element using the **``setChildren( )``** function as follows:\n\n```ballerina\nx2.setChildren(xml `<language>French</language>`);\n```\n\n### XML subtyping\n\nBallerina also supports built-in subtypes of the ``xml`` type. This is beneficial for performing operations on some ``xml`` values that represent an element rather than the entire XML sequence. Similarly, it does not make sense to set children on an XML text item since it does not have any children. So such checks can be taken care of by the type system by defining subtypes.\n\nYou can define an XML element value that belongs to the **``xml:Element``** subtype of ``xml``.  \n\n```ballerina\nxml:Element p = xml`<p>Hello</p>`;\n```\n\nIn this case, ``xml:Element`` is a subtype of ``xml`` and **``p``** comprises sequences of length one containing one element. Similarly, ``xml:Comment`` and ``xml:ProcessingInstruction`` subtypes are also available.\n\nAn ``xml`` value belongs to the ``xml:Text`` type if it consists of a text item or is empty. You can create a value of the  ``xml:Text`` type from a ``string`` value, and if the string is empty, then the ``xml:Text`` value is also empty.\n\n```ballerina\nfunction stringToXml(string s) returns xml:Text  {\n    return xml:createText(s);\n}\n```\n\nThe **``createText()``** function is part of the **``lang.xml``** lang library and all functions defined in it work in a typesafe way across the subtypes of ``xml``, without you having to cast all the time.\n\nAn ``xml`` value belongs to the type **``xml<T>``** if each of its members belongs to **``T``**. Iterating over an **``xml<T>``** value gives you access to the items of type **``T``**.\n\n```ballerina\nfunction rename(xml x, string oldName, string newName) {\n    foreach xml:Element e in x.elements() {\n        if e.getName() == oldName {\n            e.setName(newName);\n        }\n        rename(e.getChildren(), oldName, newName);\n    }\n}\n```\n\nIn the above code example, the **``rename()``** function sets a new name for some XML elements. It takes an argument **``x``** of the ``xml`` type, and two strings **``oldName``** and **``newName``**.\n\nIn the function, the ``foreach`` loop iterates through the list of elements of **``x``**  which is returned by the **``elements()``** lang library function and belongs to type **``xml<xml:Element>``**. Therefore, you can call the **``getName()``** function for each ``xml:Element`` value and check for the old name. And if the name matches, the **``setName()``** function is called to change the name. The function executes recursively for children of an ``xml:Element``.\n\n### XML navigation syntactic sugar\n\nBallerina supports the use of navigational syntax to access items within an ``xml`` value. This is similar to the functionality of XPath.\n\nTo explain this navigational syntax, you can assume to have an ``xml`` value **``x``** which contains one or more elements **``e``**. Now there are several possibilities to navigate through ``x``.  \n\nTo access every element in ``x`` named ``para`` you can use **``x.<para>``**. Use of the angle brackets ``<`` and ``>`` selects an element.\n\nTo access the children of ``e``, for every element ``e`` in ``x``, you can use **``x/*``**. Use of ``/`` takes the navigation down one level in ``x``.\n\nTo access every element named ``para`` in the children of ``e``, for every element ``e`` in ``x``, use **``x/<para>``**.\n\nTo access every element named ``th`` or ``td`` in the children of ``e``, for every element ``e`` in ``x``, use **``x/<th|td>``**.\n\nTo access every element in the children of ``e``, for every element ``e`` in ``x``, use **``x/<*>``**.\n\nTo access every text item in the children of ``e``, for every element ``e`` in ``x``, use **`x/*.text()`**.\n\nTo access every element named ``para`` in the descendants of ``e``, for every element ``e`` in ``x``, use **``x/**/<para>``**. Here the use of ``**`` signifies any number of levels within an XML element.\n\nTo access the first element named ``para`` in the children of ``e``, for every element ``e`` in ``x``, use  **``x/<para>[0]``**. You can point to the nth element using the ``[]`` syntax.\n\n### Query with XML\n\nYou can also use query expressions to query XML.\n\n```ballerina\nfunction paraByLang(xml x, string lang) returns xml {\n    return from var para in x.<para>\n            where para?.lang == lang\n            select para;\n}\n```\n\nIn the above code example, you can use the query expression to iterate over all elements ``<para>`` in ``x``, and the variable ``para`` is bound to each ``<para>`` element at every step in the iteration. It uses the ``where`` clause to check the ``lang`` attribute of the element to match it with the ``string`` parameter **``lang``**. Finally, it selects all the ``<para>`` elements that satisfy the ``where`` clause.\n\nThis query returns a new ``xml`` value containing a sequence of ``<para>`` elements.\n\n### Combine XML templates and queries\n\nYou can combine the concept of templates with queries to build nested templates. With this feature, you can build powerful templates having query expressions, with inner templates.\n\n```ballerina\ntype Person record {|\n    string name;\n    string country;\n|};\n\nfunction personsToXml(Person[] persons) returns xml {\n    return xml `<data>${from var {name, country} in persons\n           select xml`<person country=\"${country}\">${name}</person>`}</data>`;\n}\n```\n\nIn the above code example, the **``Person``** type is a record type containing the **``name``** and **``country``** fields. The **``personsToXml()``** function takes an array of **``Person``** records as the **``persons``** parameter, and returns an ``xml`` sequence containing all the array elements.\n\nTo achieve this conversion, it builds a ``xml`` template having ``<data>`` as the parent element. To populate the list of **``persons``**, the template includes a ``${...}`` interpolation containing a query expression.\n\nThe query expression binds to each **``name``** and **``country``** field of the **``Person``** value and returns another ``xml`` template containing the ``<person>`` XML element. This inner template adds the country value as an attribute of ``<person>`` and **``name``** as the text item, using interpolations.\n\nAt the end, an ``xml`` value containing a sequence of the ``<data>`` element with zero or more ``<person>`` child elements is returned.\n\nThis is a very powerful feature unique to Ballerina. In this way, you can also build library functions that build HTML snippets as ``xml`` values for your application.\n\n### XML namespaces\n\nBallerina supports XML namespaces without adding another level of complexity to the existing ``xml`` type system. But this is optional, and you can use XML without using namespaces also.\n\nWhen you see an XML element ``x`` prefixed with a namespace as **``ns:x``**, under the covers, Ballerina expands the prefix and the colon into a **``{url}x``** notation where ``url`` is the namespace name bound to ``ns``.\n\n```ballerina\nxml:Element e = xml`<p:e xmlns:p=\"http://example.com/\"/>`;\nstring name = e.getName();\n```\n\nIn the above code example, an expanded name of **``e``**, which is ``{http://example.com}e ``is set to the variable **``name``**.\n\n### XMLNS declarations\n\nOverall, to make the XML work in Ballerina, you need XML namespace declarations in code. XML namespace declarations look like import declarations.\n\n```ballerina\nxmlns \"http://example.com\" as eg;\nxml x = xml`<eg:doc>Hello</eg:doc>`;\n```\n\nIn the above code example, the **``eg``** is bound as a prefix to a namespace URL. You can use that prefix in the ``xml`` template, and it will get expanded to the correct representation with the namespace.\n\nThe comparison and assignment of ``xml`` elements will implicitly check for and expand the namespace declarations in the correct way.\n\n```ballerina\nxmlns \"http://example.com\" as ex;\n\n// Will be true.\nboolean b = (x === x.<ex:doc>);\n\n// Will be \"{http://example.com}doc\".\nstring exdoc = ex:doc;\n```\n\nIn the above code example, **``ex``** declares the same namespace declaration as **``eg``** previously. Therefore, the boolean **``b``** will be true since the **``x``** variable containing ``<eg:doc>`` will be the same as ``<ex:doc>``. Similarly, the ``exdoc`` string variable will be assigned a value of ``{http://example.com}doc``, which includes the namespace declaration at the top. These declarations are also allowed at the block level.\n","id":"data","sub":"distinctive-language-features","third":"","slug":"distinctive-language-features/data"},"__N_SSG":true}