{"pageProps":{"frontmatter":{"layout":"ballerina-cloud-left-nav-pages-swanlake","title":"Code to Cloud deployment","description":"Ballerina Code to Cloud is designed to allow developers to write code without thinking about the deployment platform.","keywords":"ballerina, programming language, services, cloud, kubernetes, docker","permalink":"/learn/run-ballerina-programs-in-the-cloud/code-to-cloud-deployment/","active":"code-to-cloud-deployment","intro":"Ballerina Code to Cloud is designed to allow developers to write code without thinking about the deployment platform.","redirect_from":["/learn/deployment/code-to-cloud","/swan-lake/learn/deployment/code-to-cloud/","/swan-lake/learn/deployment/code-to-cloud","/learn/deployment/code-to-cloud/","/learn/deployment/code-to-cloud","/learn/deployment/docker/","/learn/deployment/docker","/learn/user-guide/deployment/code-to-cloud","/learn/user-guide/deployment/","/learn/user-guide/deployment","/learn/user-guide/deployment/docker/","/learn/user-guide/deployment/docker","/learn/user-guide/deployment/code-to-cloud/","/learn/running-ballerina-programs-in-the-cloud/code-to-cloud","/learn/running-ballerina-programs-in-the-cloud/code-to-cloud/","/learn/running-ballerina-programs-in-the-cloud/","/learn/running-ballerina-programs-in-the-cloud","/learn/running-ballerina-programs-in-the-cloud/code-to-cloud/code-to-cloud-deployment","/learn/running-ballerina-programs-in-the-cloud/code-to-cloud/code-to-cloud-deployment/","/learn/running-ballerina-programs-in-the-cloud/code-to-cloud-deployment/","/learn/running-ballerina-programs-in-the-cloud/code-to-cloud-deployment","/learn/run-ballerina-programs-in-the-cloud/code-to-cloud-deployment","/learn/run-ballerina-programs-in-the-cloud/","/learn/run-ballerina-programs-in-the-cloud","/learn/guides/running-ballerina-programs-in-the-cloud/code-to-cloud/code-to-cloud-deployment/","/learn/guides/running-ballerina-programs-in-the-cloud/code-to-cloud/code-to-cloud-deployment"]},"content":"\nThis greatly simplifies the experience of developing and deploying Ballerina code in the cloud. It also enables using cloud-native technologies easily without in-depth knowledge.\n\nAs of now, Ballerina Code to Cloud supports generating the deployment artifacts of the platforms below.\n\n1. Docker\n2. Kubernetes\n\n## Set up the prerequisites\n\nTo complete this tutorial, you need:\n1. [Docker](https://www.docker.com/) installed and configured in your machine\n2. [Kubectl](https://kubernetes.io/docs/tasks/tools/) installed and configured in a [Kubernetes cluster](https://minikube.sigs.k8s.io/docs/start/)\n\n## How Code to Cloud works\n\nCode to cloud builds the containers and required artifacts by deriving the required values from the code. This process happens when the package is being compiled. To override the default values given by the compiler, the `Cloud.toml` file needs to be created in the package directory. \n\n## Package layout\n\nBallerina encourages having one microservice per package. To adhere to that rule, Code to Cloud generates only one container per package. These artifacts can be found in the `target` directory of the package. A complete representation of the package layout is as follows.\n\n```\n├── Cloud.toml                               \n├── Ballerina.lock\n├── Ballerina.toml\n├── entry.bal                          \n└── target\n    ├── bala\n    │   └── module-0.0.1.bala\n    ├── bin\n    │   └── <module>.jar\n    ├── docker\n    │       └── Dockerfile                        \n    └── kubernetes\n            └── <module>-0.0.1.yaml \n```\n\n***Cloud.toml***\n\nThe configuration file is used to override the default values generated by Code to Cloud.\n\n>**Note:** The `Cloud.toml` file is completely optional and you only have to specify the values you need to override. If the value is not specified for a certain field, the compiler will take the default value. All the supported properties can be found in the [Code to Cloud specification](https://github.com/ballerina-platform/ballerina-spec/blob/master/c2c/code-to-cloud-spec.md).\n\n***Ballerina.toml***\n\nContains metadata about the Ballerina package. This file is used to fetch defaults for deployment artifacts generation.\n>**Note:** The `Ballerina.toml` file can be used to specify the build option.\n```toml\n[build-options]\n# cloud = \"docker\"\ncloud = \"k8s\" \n```\n\n***entry.bal***\n\nRepresents any `.bal` file that has an entry point. The compiler will be using this file to retrieve service-related information for the deployment artifacts.\n\n***target/docker/***\n\nContains the Docker artifacts generated by Code to Cloud. These artifacts will be required to build the Docker image.\n\n***target/kubernetes/***\n\nContains the Kubernetes artifacts generated by Code to Cloud. These artifacts will be required to deploy the Ballerina application in Kubernetes.\n\n## Docker deployment\n\n### Create the Ballerina package\n\n1. Execute the `bal new hello_docker` command to create a new package named `hello_docker`.\n\n2. Replace the content of the `./hello_docker/main.bal` file with the content below.\n\n    >**Note:** The source is completely focused on the business logic. \n\n    ***main.bal***\n\n    ```ballerina\n    import ballerina/http;\n\n    listener http:Listener helloEP = new(9090);\n\n    service /helloWorld on helloEP {\n        resource function get sayHello() returns string {   \n            return \"Hello, Docker!\";   \n        }\n    }\n    ```\n3. Add `cloud = \"docker\"` under the `[build-options]` table into the `Ballerina.toml` file in the package.\n\n    ***Ballerina.toml***\n\n    ```toml\n    [build-options]\n    cloud = \"docker\"\n    ```\n\n4. Create a file named `Cloud.toml` in the package directory and add the content below.\n\n    ***Cloud.toml***\n\n    ```toml\n    [container.image]\n    repository=\"wso2inc\" # ex - Docker hub name\n    name=\"hello\" # container name\n    tag=\"v0.1.0\"\n\n    [settings]\n    buildImage=true # you can make this false if you don't want to build the image and you just need the Dockerfile\n    ```\n\n### Generate the artifacts\n\nExecute the `bal build` command to build the Ballerina package and view the output below. If you haven't added the cloud option to `Ballerina.toml` file, you can execute `bal build --cloud=docker` to generate the artifacts and build the package by providing the build option inline. \n\n```bash\n$> bal build\nCompiling source\n        wso2/hello_docker:0.1.0\n\nGenerating executable\n\nGenerating artifacts...\n\n        @kubernetes:Docker                       - complete 2/2 \n\n        Execute the below command to run the generated docker image: \n        docker run -d -p 9090:9090 wso2inc/hello:v0.1.0\n\n        target/bin/hello_docker.jar\n```\n\nBefore invoking the container, let’s observe the Dockerfile below that has been generated. This is a Dockerfile created by the compiler extension from your code to run your HTTP service in the Docker environment easily.\n\n***target/docker/hello/Dockerfile***\n\n```\n# Auto Generated Dockerfile\nFROM ballerina/jre11:v1\n\nLABEL maintainer=\"dev@ballerina.io\"\n\nCOPY ballerina-http-2.2.0.jar /home/ballerina/jars/ \nCOPY ballerina-io-1.2.0.jar /home/ballerina/jars/ \nCOPY wso2-hello_docker-0.1.0.jar /home/ballerina/jars/ \n...\n\nRUN addgroup troupe \\\n    && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina \\\n    && apk add --update --no-cache bash \\\n    && chown -R ballerina:troupe /usr/bin/java \\\n    && rm -rf /var/cache/apk/*\n\nWORKDIR /home/ballerina\nCOPY wso2-hello_docker-0.1.0.jar /home/ballerina\n\nEXPOSE  9090\nUSER ballerina\n\nCMD java -Xdiag -cp \"wso2-hello_docker-0.1.0.jar:jars/*\" 'wso2/hello_docker/0/$_init' || cat ballerina-internal.log\n```\n\n### Execute the Docker image\n\nFollow the steps below to execute the Docker image separately.\n\n1. Execute the `docker images` command to verify if the Docker image is generated.\n\n    ```bash\n    $> docker images\n    REPOSITORY                    TAG                 IMAGE ID            CREATED              SIZE\n    wso2inc/hello                 v0.1.0              60d95f0928b2        About a minute ago   228MB\n    ```\n\n2. Execute the `docker run -d -p 9090:9090 wso2inc/hello:v0.1.0` command to run the generated Docker image.\n\n    ```bash\n    $> docker run -d -p 9090:9090 wso2inc/hello:v0.1.0\n    c04194eb0b4d0d78cbc8ca55e0527d381d8ab4a1a68f8ea5dd3770a0845d5fbb\n    ```\n\n3. Execute the `curl http://localhost:9090/helloWorld/sayHello` command to access the service.\n\n    ```bash\n    $> curl http://localhost:9090/helloWorld/sayHello\n    Hello, Docker!\n    ```\n\n## Kubernetes deployment\n\n### Create the Ballerina package\nBelow sample describes a Ballerina application that reads a greeting string from a config map and greets the user upon HTTP request. By following the steps below, you can make a Kubernetes deployment that has container resource limits, horizontal pod autoscaling, config maps and liveness, readiness probes with the help of Code to Cloud.\n\n1. Execute the `bal new hello_k8s` command to create a new package named `hello_k8s` and go inside that directory.\n\n2. Replace the content of the `main.bal` file with the content below.\n\n    ***main.bal***\n\n    ```ballerina\n    import ballerina/http;\n    import ballerina/io;\n\n    listener http:Listener helloEP = new (9090);\n\n    service /helloWorld on helloEP {\n        resource function get sayHello() returns string|error? {\n            json config = check read(\"./resources/config.json\");\n            string greeting = check config.greeting;\n            return greeting + \", Kubernetes!\";\n        }\n    }\n\n    function read(string path) returns @tainted json|error {\n        io:ReadableByteChannel rbc = check io:openReadableFile(path);\n        io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");\n        var result = rch.readJson();\n        _ = check rch.close();\n        return result;\n    }\n    ```\n2. Create `probes.bal` with the following contents.\n\n    ***probes.bal***\n\n    ```ballerina\n    import ballerina/http;\n\n    listener http:Listener probeEP = new (9091);\n    service /probes on probeEP {\n        resource function get healthz() returns boolean {\n            return true;\n        }\n        resource function get readyz() returns boolean {\n            return true;\n        }\n    }\n    ```\n3. Create `resources` directory in the package, create a `config.json` file within it and paste the following contents inside.\n\n    ***resources/config.json***\n    ```json\n    {\n        \"greeting\": \"Hello\"\n    }\n    ```\n    \n4. Add `cloud = \"k8s\"` under the `[build-options]` table into the `Ballerina.toml` file in the package.\n\n    ***Ballerina.toml***\n\n    ```toml\n    [build-options]\n    cloud = \"k8s\"\n    ```\n\n5. Create a file named `Cloud.toml` in the package directory and add the content below. You can use some properties from the docker sample here since `cloud=\"k8s\"` option builds both Docker image and Kubernetes. You can see a brief description of the properties in the comments.\n\n    ***Cloud.toml***\n\n    ```toml\n    [container.image]\n    repository=\"wso2inc\" # Ex - Docker hub repository name.\n    name=\"hello-k8s\" # Container name\n    tag=\"v0.1.0\"\n\n    [cloud.deployment]\n    min_memory=\"100Mi\" # Minimum memory required for the container.\n    max_memory=\"256Mi\" # Maximum memory a single container can take.\n    min_cpu=\"500m\"  # Minimum CPU required for the container.\n    max_cpu=\"500m\" # Maximum CPU a single container can take.\n\n    [cloud.deployment.autoscaling]\n    min_replicas=2 # Minimum number of container instances ran at a given time\n    max_replicas=5 # Maximum number of replicas of the container can scale up to\n    cpu=60 # Average CPU utilization of pods\n\n    [[cloud.config.maps]]\n    file=\"./resources/config.json\" # Path in the source\n    mount_path=\"/home/ballerina/resources/config.json\" # Path in the container\n\n    [cloud.deployment.probes.liveness]\n    port=9091\n    path=\"/probes/healthz\"\n\n    [cloud.deployment.probes.readiness]\n    port=9091\n    path=\"/probes/readyz\"\n    ```\n\n### Generate the artifacts\n\nOnce you build the Ballerina package, the compiler extension will generate the artifacts required for k8s deployment.\n\n>**Tip:** If you are using Minikube, execute the `eval $(minikube docker-env)` command before building the image if you don't want to push the container to the Docker registry.\n\n>**Tip:** If you don't have the cloud=\"k8s\" entry on the `Ballerina.toml` you can execute `bal build --cloud=k8s` command to provide the build option inline.\n\n```bash\n$> bal build\nCompiling source\n        wso2/hello_k8s:0.1.0\n\nGenerating executable\n\nGenerating artifacts...\n\n        @kubernetes:Service                      - complete 1/2\n        @kubernetes:Service                      - complete 2/2\n        @kubernetes:ConfigMap                    - complete 1/1\n        @kubernetes:Deployment                   - complete 1/1\n        @kubernetes:HPA                          - complete 1/1\n        @kubernetes:Docker                       - complete 2/2 \n\n        Execute the below command to deploy the Kubernetes artifacts: \n        kubectl apply -f /home/wso2/c2c-guide/hello_k8s/target/kubernetes/hello_k8s\n\n        Execute the below command to access service via NodePort: \n        kubectl expose deployment hello-k8s-deployment --type=NodePort --name=hello-k8s-svc-local\n\n        target/bin/hello_k8s.jar\n```\n\n>**Note:** Before invoking the Kubernetes service, observe the Kubernetes yamls that have been generated. You should be able to find services for ports that have been exposed, `HorizontalPodAutoscaler` for scaling and Deployment, and Config maps.\n\n***target/kubernetes/hello_k8s***\n\n```yaml\n---\napiVersion: \"v1\"\nkind: \"Service\"\nmetadata:\n  labels:\n    app: \"hello_k8s\"\n  name: \"hello-k8s-svc\"\nspec:\n  ports:\n  - name: \"port-1-hello-k8\"\n    port: 9090\n    protocol: \"TCP\"\n    targetPort: 9090\n  - name: \"port-2-hello-k8\"\n    port: 9091\n    protocol: \"TCP\"\n    targetPort: 9091\n  selector:\n    app: \"hello_k8s\"\n  type: \"ClusterIP\"\n---\napiVersion: \"v1\"\nkind: \"ConfigMap\"\nmetadata:\n  name: \"hello-k8s-config-json\"\ndata:\n  config.json: \"{\\n    \\\"greeting\\\": \\\"Hello\\\"\\n}\"\n---\napiVersion: \"apps/v1\"\nkind: \"Deployment\"\nmetadata:\n  labels:\n    app: \"hello_k8s\"\n  name: \"hello-k8s-deployment\"\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: \"hello_k8s\"\n  template:\n    metadata:\n      labels:\n        app: \"hello_k8s\"\n    spec:\n      containers:\n      - image: \"wso2inc/hello-k8s:v0.1.0\"\n        lifecycle:\n          preStop:\n            exec:\n              command:\n              - \"sleep\"\n              - \"15\"\n        livenessProbe:\n          httpGet:\n            path: \"/probes/healthz\"\n            port: 9091\n          initialDelaySeconds: 30\n        name: \"hello-k8s-deployment\"\n        ports:\n        - containerPort: 9090\n          name: \"port-1-hello-k8\"\n          protocol: \"TCP\"\n        - containerPort: 9091\n          name: \"port-2-hello-k8\"\n          protocol: \"TCP\"\n        readinessProbe:\n          httpGet:\n            path: \"/probes/readyz\"\n            port: 9091\n          initialDelaySeconds: 30\n        resources:\n          limits:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n          requests:\n            memory: \"100Mi\"\n            cpu: \"500m\"\n        volumeMounts:\n        - mountPath: \"/home/ballerina/resources/config.json\"\n          name: \"hello-k8s-config-json-volume\"\n          readOnly: true\n          subPath: \"config.json\"\n      nodeSelector: {}\n      volumes:\n      - configMap:\n          name: \"hello-k8s-config-json\"\n        name: \"hello-k8s-config-json-volume\"\n---\napiVersion: \"autoscaling/v1\"\nkind: \"HorizontalPodAutoscaler\"\nmetadata:\n  labels:\n    app: \"hello_k8s\"\n  name: \"hello-k8s-hpa\"\nspec:\n  maxReplicas: 5\n  minReplicas: 2\n  scaleTargetRef:\n    apiVersion: \"apps/v1\"\n    kind: \"Deployment\"\n    name: \"hello-k8s-deployment\"\n  targetCPUUtilizationPercentage: 60\n```\n\n### Execute the Kubernetes service\n\nFollow the steps below to execute the Kubernetes service.\n1. Execute `docker push <repository>/<name>:<tag>` to push the container to docker hub. You can skip this step if you executed `eval $(minikube docker-env)` before building the container.\n    ```bash\n    $> docker push wso2inc/hello-k8s:v0.1.0\n    ```\n\n2. Execute the `kubectl apply -f target/kubernetes/hello_k8s` command to execute the service.\n\n    ```bash\n    $> kubectl apply -f target/kubernetes/hello_k8s\n    service/hello-k8s-svc created\n    configmap/hello-k8s-config-json created\n    deployment.apps/hello-k8s-deployment created\n    horizontalpodautoscaler.autoscaling/hello-k8s-hpa created\n    ```\n\n3. Execute the `kubectl get pods` command to verify the Kubernetes pods.\n\n    ```bash\n    $> kubectl get pods\n    NAME                                        READY   STATUS    RESTARTS   AGE\n    hello-k8s-deployment-577d8dbf8-p8zg5   1/1     Running   0          37s\n    hello-k8s-deployment-577d8dbf8-p8zg5   1/1     Running   0          57s\n    ```\n\n4. Execute the `kubectl expose deployment hello-k8s-deployment --type=NodePort --name=hello-k8s-svc-local` command to expose the service via NodePort to test in the development environment.\n\n    ```bash\n    $> kubectl expose deployment hello-k8s-deployment --type=NodePort --name=hello-k8s-svc-local\n    service/hello-k8s-svc-local exposed\n    ```\n\n5. Execute the `kubectl get svc` command to get the EXTERNAL-IP and port of the Kubernetes service.\n\n    ```bash\n    $> kubectl get svc\n    NAME                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE\n    hello-k8s-svc         ClusterIP   10.96.173.207   <none>        9090/TCP,9091/TCP               5m11s\n    hello-k8s-svc-local   NodePort    10.99.245.41    <none>        9090:30342/TCP,9091:30515/TCP   66s\n    kubernetes            ClusterIP   10.96.0.1       <none>        443/TCP                         130m\n    ```\n\n    >**Tip:** If you are using Minikube, execute the `minikube ip` command to get the IP address.\n\n    ```bash\n    $> minikube ip\n    192.168.49.2\n    ```\n\n6. Execute the `curl http://192.168.49.2:30342/helloWorld/sayHello` command to access the deployed service via cURL.\n\n    ```bash\n    $> curl http://192.168.49.2:30342/helloWorld/sayHello\n    Hello, Kubernetes!\n    ```\n\n>**Note:** You can visit the [Code to Cloud specification](https://github.com/ballerina-platform/ballerina-spec/blob/master/c2c/code-to-cloud-spec.md) for detailed information about all the supported features. As mentioned in the beginning, Code to Cloud is a tool created to make the development process easier. It does not cover the operational properties in Kubernetes. If you want to have these additional features in your deployment, or you need to change the generated Kubernetes artifacts, you can use [Kustomize](https://kustomize.io/) for modifying the generated YAML.","id":"code-to-cloud-deployment","sub":"run-in-the-cloud","third":"code-to-cloud","slug":"run-in-the-cloud/code-to-cloud/code-to-cloud-deployment"},"__N_SSG":true}