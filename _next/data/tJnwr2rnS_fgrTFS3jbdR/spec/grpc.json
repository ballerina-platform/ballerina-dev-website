{"pageProps":{"frontmatter":{},"content":"# Specification: Ballerina gRPC Library\n\n_Owners_: @shafreenAnfar @daneshk @BuddhiWathsala @MadhukaHarith92 @dilanSachi  \n_Reviewers_: @shafreenAnfar @daneshk @dilanSachi  \n_Created_: 2021/12/05   \n_Updated_: 2022/02/17  \n_Edition_: Swan Lake  \n\n## Introduction\nThis is the specification for the gRPC standard library of [Ballerina language](https://ballerina.io/), which provides APIs for gRPC client and server implementation.\n\nThe gRPC library specification has evolved and may continue to evolve in the future. The released versions of the specification can be found under the relevant GitHub tag.\n\nIf you have any feedback or suggestions about the library, start a discussion via a GitHub issue or in the [Slack channel](https://ballerina.io/community/). Based on the outcome of the discussion, the specification and implementation can be updated. Community feedback is always welcome. Any accepted proposal which affects the specification is stored under `/docs/proposals`. Proposals under discussion can be found with the label `type/proposal` in GitHub.\n\nThe conforming implementation of the specification is released and included in the distribution. Any deviation from the specification is considered a bug.\n\n## Contents\n1. [Overview](#1-overview)\n2. [gRPC command line interface (CLI)](#1-grpc-command-line-interface-cli)\n3. [Protocol buffers to Ballerina data mapping](#3-protocol-buffers-to-ballerina-data-mapping)\n4. [gRPC communication](#4-grpc-communication)\n   * 4.1. [Simple RPC](#41-simple-rpc)\n   * 4.2. [Server streaming RPC](#42-server-streaming-rpc)\n   * 4.3. [Client streaming RPC](#43-client-streaming-rpc)\n   * 4.4. [Bidirectional streaming RPC](#44-bidirectional-streaming-rpc)\n5. [gRPC security](#51-authentication-and-authorization)\n   * 5.1. [Authentication and authorization](#51-authentication-and-authorization)\n      * 5.1.1. [Declarative approach](#511-declarative-approach)\n         * 5.1.1.1. [Service - basic auth - file user store](#5111-service---basic-auth---file-user-store)\n         * 5.1.1.2. [Service - basic auth - LDAP user store](#5112-service---basic-auth---ldap-user-store)\n         * 5.1.1.3. [Service - JWT auth](#5113-service---jwt-auth)\n         * 5.1.1.4. [Service - OAuth2](#5114-service---oauth2)\n         * 5.1.1.5. [Client - basic auth](#5115-client---basic-auth)\n         * 5.1.1.6. [Client - bearer token auth](#5116-client---bearer-token-auth)\n         * 5.1.1.7. [Client - self-signed JWT auth](#5117-client---self-signed-jwt-auth)\n         * 5.1.1.8. [Client - OAuth2](#5118-client---oauth2)\n      * 5.1.2 [Imperative Approach](#512-imperative-approach)\n         * 5.1.2.1. [Service - basic auth - file user store](#5121-service---basic-auth---file-user-store)\n         * 5.1.2.2. [Service - basic auth - LDAP user store](#5122-service---basic-auth---ldap-user-store)\n         * 5.1.2.3. [Service - JWT auth](#5123-service---jwt-auth)\n         * 5.1.2.4. [Service - OAuth2](#5124-service---oauth2)\n         * 5.1.2.5. [Client - basic auth](#5125-client---basic-auth)\n         * 5.1.2.6. [Client - bearer token auth](#5126-client---bearer-token-auth)\n         * 5.1.2.7. [Client - self-signed JWT auth](#5127-client---self-signed-jwt-auth)\n         * 5.1.2.8. [Client - OAuth2](#5128-client---oauth2)\n6. [gRPC utility functions](#6-grpc-utility-functions)\n   * 6.1. [gRPC deadline](#61-grpc-deadline)\n   * 6.2. [gRPC compression](#62-grpc-compression)\n   * 6.3. [gRPC access and trace logs](#63-grpc-access-and-trace-logs)\n   * 6.4. [gRPC retry](#64-grpc-retry)\n\n\n## 1. Overview\nBallerina gRPC standard library has five primary aspects in handling values.\n1. gRPC CLI (command line interface)\n2. Protocol buffers to Ballerina data mapping\n3. gRPC communication\n4. gRPC Security\n5. gRPC utility functions\n\n## 2. gRPC command line interface (CLI)\n\nBallerina language has a command-line interface that manages the lifecycle of a Ballerina program (such as build, test, and run). In addition, Ballerina CLI contains all the gRPC related stub and service skeleton generation capabilities. The gRPC command in Ballerina CLI is as follows.\n\n```sh\nbal grpc --input <proto-file-path> --output <output-directory> --mode client|service --proto-path <proto-directory>\n```\n\nThe `--input` parameter is the only mandatory parameter for the Ballerina gRPC command, and it specifies the path of the protobuf file of a gRPC service. The optional `--output` parameter indicates the path that output will be written to. If the output path is not specified, the output will be written to a directory corresponding to the package in the Protocol Buffers definition. If the package is not specified, the output will be written to a `temp` directory in the current location. The optional `--mode` indicate what type of output files are needed. For example, if mode specifies as service, the gRPC command will generate the relevant stub file along with a service skeleton. If the mode is client, the gRPC command will generate a sample client code along with the stub. If nothing is specified, only the stub file is generated. The optional `--proto-path`parameter states the path to a directory, in which to look for .proto files when resolving import directives.\n\n## 3. Protocol buffers to Ballerina data mapping\n\nThe following table illustrates the data mapping of protocol buffers data types to relevant Ballerina types.\n\n|Protobuf Type|Ballerina Type|\n|---|---|\n|google.protobuf.DoubleValue|float|\n|google.protobuf.FloatValue|float|\n|google.protobuf.Int64Value|int|\n|google.protobuf.UInt64Value|int|\n|google.protobuf.Int32Value|int|\n|google.protobuf.UInt32Value|int|\n|google.protobuf.BoolValue|boolean|\n|google.protobuf.StringValue|string|\n|google.protobuf.BytesValue|byte[]|\n|google.protobuf.Empty|()|\n|google.protobuf.Timestamp|time:Utc|\n|google.protobuf.Duration|time:Seconds|\n|google.protobuf.Struct|map\\<anydata>|\n|google.protobuf.Any|'any:Any|\n\nNote that here the `'any` is the namespace of the `ballerina/protobuf.types.'any` submodule. Additionally, the `google.protobuf.Any` need serialization and deserialization mechanisms. To do that, `ballerina/protobuf.types.'any` module contains two APIs called pack and unpack to serialize and deserialize `Any` type records.\n\n```ballerina\n# Generate and return the generic `'any:Any` record that is used to represent protobuf `Any` type.\n#\n# + message - The record or the scalar value to be packed as Any type\n# + return - Any value representation of the given message\npublic isolated function pack(ValueType message) returns Any;\n\n# Unpack and return the specified Ballerina value\n#\n# + anyValue - Any value to be unpacked\n# + targetTypeOfAny - Type descriptor of the return value\n# + return - Return a value of the given type\npublic isolated function unpack(Any anyValue, ValueTypeDesc targetTypeOfAny = <>) returns targetTypeOfAny|Error;\n```\n\n## 4. gRPC communication\n\ngRPC has 4 types of RPCs (Remote Procedure Calls), and Ballerina supports all of them.\n1. Simple\n2. Server streaming\n3. Client streaming\n4. Bidirectional streaming\n\nNote that, to explain the behaviour of these 4 RPC types, this document uses the standard Route Guide example.\n- [Details of the route guide example](https://grpc.io/docs/languages/go/basics/)\n- [Protocol buffer definition of the route guide example](https://github.com/ballerina-platform/module-ballerina-grpc/blob/674bda12a90f99c2735badc5567cd7dd7e14ba09/examples/routeguide/proto-file/route_guide.proto)\n\n### 4.1. Simple RPC\n\nThe RPC service definition of a simple RPCs is as follows.\n```proto\nservice RouteGuide {\n    rpc GetFeature(Point) returns (Feature) {}\n}\n```\nThe Ballerina service implementation of a gRPC can be done in two ways.\n1. Using direct returning\n2. Using a caller\n\nDirectly returning the response is the most convenient implementation. However, for asynchronous RPC calls, directly returning is not suitable, and for such use cases, using a caller is the ideal approach. In addition, each RPC call (simple, server streaming, client streaming, and bidirectional streaming) can be implemented in both ways.\n\n**RPC using direct return**\n\nBallerina CLI generates the relevant service skeleton, and the implementation of the simple RPC call using direct return is as follows.\n\n```ballerina\nservice \"RouteGuide\" on new grpc:Listener(8980) {\n\n    remote function GetFeature(Point point) returns Feature|error {\n        foreach Feature feature in FEATURES {\n            if feature.location == point {\n                return feature;\n            }\n        }\n        return {location: point, name: \"\"};\n    }\n}\n```\n\nHere, the RPC implementation creates a featured record and directly return it from the remote method.\n\n**RPC using a caller**\n\nThe Ballerina implementation of the same simple RPC using a caller is as follows.\n\n```ballerina\nservice \"RouteGuide\" on new grpc:Listener(8980) {\n\n    remote function GetFeature(RouteGuideFeatureCaller caller, Point point) returns error? {\n        Feature?|error feature = featureFromPoint(point);\n        if feature is Feature {\n            check caller->sendFeature(feature);\n        } else if feature is error {\n            check caller->sendError(<grpc:Error> feature);\n        } else {\n            check caller->sendFeature({location: {latitude: 0, longitude: 0}, name: \"\"});\n        }\n    }\n}\n```\n\n**RPC invocation**\n\nFor each RPC in the protobuf definition, the generated Ballerina stub contains a client. That generated client interacts with the actual RPC service during an RPC call.\n\n```ballerina\npublic function main() returns error? {\n    RouteGuideClient ep = check new (\"http://localhost:8980\");\n    Feature feature = check ep->GetFeature({latitude: 406109563, longitude: -742186778});\n}\n```\n\n\n### 4.2. Server streaming RPC\nThe RPC service definition of a server streaming call is as follows.\n```proto\nservice RouteGuide {\n    rpc ListFeatures(Rectangle) returns (stream Feature) {}\n}\n```\n\n**RPC using direct return**\n\nThe Ballerina implementation of the server streaming RPC using a direct return is as follows.\n\n```ballerina\nservice \"RouteGuide\" on new grpc:Listener(8980) {\n\n    remote function ListFeatures(Rectangle rectangle) returns stream<Feature, grpc:Error?>|error {\n\n        Feature[] selectedFeatures = [];\n        foreach Feature feature in FEATURES {\n            if inRange(feature.location, rectangle) {\n                selectedFeatures.push(feature);\n            }\n        }\n        return selectedFeatures.toStream();\n    }\n}\n```\n\n**RPC using a caller**\n\nThe Ballerina implementation of the server streaming RPC using a caller return is as follows.\n\n```ballerina\nservice \"RouteGuide\" on new grpc:Listener(8980) {\n\n    remote function ListFeatures(RouteGuideFeatureCaller caller, Rectangle rectangle) returns error? {\n\n        foreach Feature feature in FEATURES {\n            if inRange(feature.location, rectangle) {\n                check caller->sendFeature(feature);\n            }\n        }\n    }\n}\n```\n\n**RPC invocation**\n\nFor each RPC in the protobuf definition, the generated Ballerina stub contains a client which interacts with the actual RPC service. In Ballerina gRPC, invoking a server streaming returns a Ballerina streaming object that can iterate through using streaming operations provided by the language.\n\n```ballerina\npublic function main() returns error? {\n    RouteGuideClient ep = check new (\"http://localhost:8980\");\n    Rectangle rectangle = {\n        lo: {latitude: 400000000, longitude: -750000000},\n        hi: {latitude: 420000000, longitude: -730000000}\n    };\n    stream<Feature, grpc:Error?> features = check ep->ListFeatures(rectangle);\n    check features.forEach(function(Feature f) {\n        io:println(`Result: lat=${f.location.latitude}, lon=${f.location.longitude}`);\n    });\n}\n```\n\n### 4.3. Client streaming RPC\nThe RPC service definition of a client streaming call is as follows.\n```proto\nservice RouteGuide {\n    rpc RecordRoute(stream Point) returns (RouteSummary) {}\n}\n```\n\n**RPC using direct return**\n\nThe Ballerina implementation of the client streaming RPC using a direct return is as follows.\n\n```ballerina\nservice \"RouteGuide\" on new grpc:Listener(8980) {\n\n    remote function RecordRoute(stream<Point, grpc:Error?> clientStream) returns RouteSummary|error {\n        Point? lastPoint = ();\n        int pointCount = 0;\n        int featureCount = 0;\n        int distance = 0;\n\n        decimal startTime = time:monotonicNow();\n        check clientStream.forEach(function(Point p) {\n            pointCount += 1;\n            if pointExistsInFeatures(FEATURES, p) {\n                featureCount += 1;\n            }\n\n            if lastPoint is Point {\n                distance = calculateDistance(<Point>lastPoint, p);\n            }\n            lastPoint = p;\n        });\n        decimal endTime = time:monotonicNow();\n        int elapsedTime = <int>(endTime - startTime);\n        return {point_count: pointCount, feature_count: featureCount, distance: distance, elapsed_time: elapsedTime};\n    }\n}\n```\n\n**RPC using a caller**\n\nThe Ballerina implementation of the client streaming RPC using a caller return is as follows.\n\n```ballerina\nservice \"RouteGuide\" on new grpc:Listener(8980) {\n\n    remote function RecordRoute(RouteGuideRouteSummaryCaller caller, stream<Point, grpc:Error?> clientStream) returns error? {\n        Point? lastPoint = ();\n        int pointCount = 0;\n        int featureCount = 0;\n        int distance = 0;\n\n        decimal startTime = time:monotonicNow();\n        check clientStream.forEach(function(Point p) {\n            pointCount += 1;\n            if pointExistsInFeatures(FEATURES, p) {\n                featureCount += 1;\n            }\n\n            if lastPoint is Point {\n                distance = calculateDistance(<Point>lastPoint, p);\n            }\n            lastPoint = p;\n        });\n        decimal endTime = time:monotonicNow();\n        int elapsedTime = <int>(endTime - startTime);\n        return caller->sendRouteSummary({point_count: pointCount, feature_count: featureCount, distance: distance, elapsed_time: elapsedTime});\n    }\n}\n```\n\n**RPC invocation**\n\nFor each RPC in the protobuf definition, the generated Ballerina stub contains a client. That generated client interacts with the actual RPC service during an RPC call. Unlike the server streaming scenario, the Ballerina client streaming does not use a streaming object to pass data to the client-side because it should allow users to send and receive data asynchronously. Instead, it uses a streaming object to send and receive data from the server.\n```ballerina\npublic function main() returns error? {\n    RouteGuideClient ep = check new (\"http://localhost:8980\");\n    Point[] points = [\n        {latitude: 406109563, longitude: -742186778}, \n        {latitude: 411733222, longitude: -744228360}, \n        {latitude: 744228334, longitude: -742186778}\n    ];\n    RecordRouteStreamingClient recordRouteStrmClient = check ep->RecordRoute();\n    foreach Point p in points {\n        check recordRouteStrmClient->sendPoint(p);\n    }\n    check recordRouteStrmClient->complete();\n    RouteSummary? routeSummary = check recordRouteStrmClient->receiveRouteSummary();\n    if routeSummary is RouteSummary {\n        io:println(`Finished trip with ${routeSummary.point_count} points. Passed ${routeSummary.feature_count} features. \"Travelled ${routeSummary.distance} meters. It took ${routeSummary.elapsed_time} seconds.`);\n    }\n}\n```\n\n### 4.4. Bidirectional streaming RPC\nThe RPC service definition of a bidirectional streaming call is as follows.\n```proto\nservice RouteGuide {\n    rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n}\n```\n\n**RPC using direct return**\n\nThe Ballerina implementation of the bidirectional streaming RPC using a direct return is as follows.\n\n```ballerina\nservice \"RouteGuide\" on new grpc:Listener(8980) {\n\n    remote function RouteChat(stream<RouteNote, grpc:Error?> clientNotesStream) returns stream<RouteNote, grpc:Error?>|error {\n        RouteNote[] routeNotes = [];\n        check clientNotesStream.forEach(function(RouteNote note) {\n            ROUTE_NOTES.push(note);\n            foreach RouteNote n in ROUTE_NOTES {\n                if n.location == note.location {\n                    routeNotes.push(note);\n                }\n            }\n        });\n        return routeNotes.toStream();\n    }\n}\n```\n\nNote that, here using direct return will not address the exact use case. This example was added, only for completeness.\n\n**RPC using a caller**\n\nThe Ballerina implementation of the bidirectional streaming RPC using a caller return is as follows.\n\n```ballerina\nservice \"RouteGuide\" on new grpc:Listener(8980) {\n\n    remote function RouteChat(RouteGuideRouteNoteCaller caller, stream<RouteNote, grpc:Error?> clientNotesStream) returns error? {\n        check clientNotesStream.forEach(function(RouteNote note) {\n            future<error?> f1 = start sendRouteNotesFromLocation(caller, note.location);\n            lock {\n                ROUTE_NOTES.push(note);\n            }\n            error? waitErr = wait f1;\n        });\n    }\n}\n```\n\n**RPC invocation**\n\nFor each RPC in the protobuf definition, the generated Ballerina stub contains a client. That generated client interacts with the actual RPC service during an RPC call. As the client streaming scenario, the bidirectional streaming case also uses a streaming object to send and receive data from servers.\n```ballerina\npublic function main() returns error? {\n    RouteGuideClient ep = check new (\"http://localhost:8980\");\n    // Bidirectional streaming\n    RouteNote[] routeNotes = [\n        {location: {latitude: 406109563, longitude: -742186778}, message: \"m1\"}, \n        {location: {latitude: 411733222, longitude: -744228360}, message: \"m2\"}, \n        {location: {latitude: 406109563, longitude: -742186778}, message: \"m3\"}, \n        {location: {latitude: 411733222, longitude: -744228360}, message: \"m4\"}, \n        {location: {latitude: 411733222, longitude: -744228360}, message: \"m5\"}\n    ];\n    RouteChatStreamingClient routeClient = check ep->RouteChat();\n\n    future<error?> f1 = start readResponse(routeClient);\n\n    foreach RouteNote n in routeNotes {\n        check routeClient->sendRouteNote(n);\n    }\n    check routeClient->complete();\n\n    check wait f1;\n}\n```\n\n## 5. gRPC security\n\n### 5.1 Authentication and authorization\n\nThere are two ways to enable authentication and authorization in gRPC.\n1. Declarative approach\n2. Imperative approach\n\n#### 5.1.1 Declarative approach\n\nThis is also known as the configuration-driven approach, which is used for simple use cases, where users have to provide a set of configurations and do not need to be worried more about how authentication and authorization works. The user does not have full control over the configuration-driven approach.\n\nThe service configurations are used to define the authentication and authorization configurations. Users can configure the configurations needed for different authentication schemes and configurations needed for authorizations of each authentication scheme. Also, the configurations can be provided at the service level. The priority will be given from bottom to top. Then, the auth handler creation and request authentication/authorization is handled internally without user intervention. The requests that succeeded both authentication and/or authorization phases according to the configurations will be passed to the business logic layer.\n\n##### 5.1.1.1 Service - basic auth - file user store\n\nBallerina gRPC services enable authentication and authorization using a file user store by setting the `grpc:FileUserStoreConfigWithScopes` configurations in the listener.\n\n```ballerina\n@grpc:ServiceConfig {\n    auth: [\n        {\n            fileUserStoreConfig: {},\n            scopes: [\"admin\"]\n        }\n    ]\n}\n@grpc:Descriptor {\n    value: ROOT_DESCRIPTOR_GRPC_SERVICE\n}\nservice \"HelloWorld\" on new grpc:Listener(9090) {\n    remote function hello() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n```toml\n# Config.toml\n\n[[ballerina.auth.users]]\nusername=\"alice\"\npassword=\"alice@123\"\nscopes=[\"developer\"]\n\n[[ballerina.auth.users]]\nusername=\"ldclakmal\"\npassword=\"ldclakmal@123\"\nscopes=[\"developer\", \"admin\"]\n\n[[ballerina.auth.users]]\nusername=\"eve\"\npassword=\"eve@123\"\n```\n\n##### 5.1.1.2 Service - basic auth - LDAP user store\n\nBallerina gRPC services enable authentication and authorization using an LDAP user store by setting the `grpc:LdapUserStoreConfigWithScopes` configurations in the listener.\n\n```ballerina\n@grpc:ServiceConfig {\n    auth: [\n        {\n            ldapUserStoreConfig: {\n                domainName: \"avix.lk\",\n                connectionUrl: \"ldap://localhost:389\",\n                connectionName: \"cn=admin,dc=avix,dc=lk\",\n                connectionPassword: \"avix123\",\n                userSearchBase: \"ou=Users,dc=avix,dc=lk\",\n                userEntryObjectClass: \"inetOrgPerson\",\n                userNameAttribute: \"uid\",\n                userNameSearchFilter: \"(&(objectClass=inetOrgPerson)(uid=?))\",\n                userNameListFilter: \"(objectClass=inetOrgPerson)\",\n                groupSearchBase: [\"ou=Groups,dc=avix,dc=lk\"],\n                groupEntryObjectClass: \"groupOfNames\",\n                groupNameAttribute: \"cn\",\n                groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",\n                groupNameListFilter: \"(objectClass=groupOfNames)\",\n                membershipAttribute: \"member\",\n                userRolesCacheEnabled: true,\n                connectionPoolingEnabled: false,\n                connectionTimeout: 5,\n                readTimeout: 60\n            },\n            scopes: [\"admin\"]\n        }\n    ]\n}\n@grpc:Descriptor {\n    value: ROOT_DESCRIPTOR_GRPC_SERVICE\n}\nservice \"HelloWorld\" on new grpc:Listener(9090) {\n    remote function hello() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n##### 5.1.1.3 Service - JWT auth\n\nBallerina gRPC services enable authentication and authorization using JWTs by setting the `grpc:JwtValidatorConfigWithScopes` configurations in the listener.\n\n```ballerina\n@grpc:ServiceConfig {\n    auth: [\n        {\n            jwtValidatorConfig: {\n                issuer: \"wso2\",\n                audience: \"ballerina\",\n                signatureConfig: {\n                    certFile: \"/path/to/public.crt\"\n                },\n                scopeKey: \"scp\"\n            },\n            scopes: [\"admin\"]\n        }\n    ]\n}\n@grpc:Descriptor {\n    value: ROOT_DESCRIPTOR_GRPC_SERVICE\n}\nservice \"HelloWorld\" on new grpc:Listener(9090) {\n    remote function hello() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n##### 5.1.1.4 Service - OAuth2\n\nBallerina gRPC services enable authentication and authorization using OAuth2 by setting the `grpc:OAuth2IntrospectionConfigWithScopes` configurations in the listener.\n\n```ballerina\n@grpc:ServiceConfig {\n    auth: [\n        {\n            oauth2IntrospectionConfig: {\n                url: \"https://localhost:9445/oauth2/introspect\",\n                tokenTypeHint: \"access_token\",\n                scopeKey: \"scp\",\n                clientConfig: {\n                    customHeaders: {\"Authorization\": \"Basic YWRtaW46YWRtaW4=\"},\n                    secureSocket: {\n                        cert: \"/path/to/public.crt\"\n                    }\n                }\n            },\n            scopes: [\"admin\"]\n        }\n    ]\n}\n@grpc:Descriptor {\n    value: ROOT_DESCRIPTOR_GRPC_SERVICE\n}\nservice \"HelloWorld\" on securedEP {\n    remote function hello() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n##### 5.1.1.5 Client - basic auth\n\nBallerina gRPC clients enable basic auth with credentials by setting the `grpc:CredentialsConfig` configurations in the client.\n\n```ballerina\nHelloWorldClient securedEP = check new(\"https://localhost:9090\",\n    auth = {\n        username: \"john\",\n        password: \"ballerina@123\"\n    }\n);\n```\n\n##### 5.1.1.6 Client - bearer token auth\n\nBallerina gRPC clients enable authentication using bearer tokens by setting the `grpc:BearerTokenConfig` configurations in the client.\n\n```ballerina \nHelloWorldClient securedEP = check new(\"https://localhost:9090\",\n    auth = {\n        token: \"56ede317-4511-44b4-8579-a08f094ee8c5\"\n    }\n);\n```\n\n##### 5.1.1.7 Client - self-signed JWT auth\n\nBallerina gRPC clients enable authentication using JWTs by setting the `grpc:JwtIssuerConfig` configurations in the client.\n\n```ballerina\nHelloWorldClient securedEP = check new(\"https://localhost:9090\",\n    auth = {\n        username: \"ballerina\",\n        issuer: \"wso2\",\n        audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],\n        keyId: \"5a0b754-895f-4279-8843-b745e11a57e9\",\n        jwtId: \"JlbmMiOiJBMTI4Q0JDLUhTMjU2In\",\n        customClaims: { \"scp\": \"admin\" },\n        expTime: 3600,\n        signatureConfig: {\n            config: {\n                keyFile: \"/path/to/private.key\"\n            }\n        }\n    }\n);\n```\n\n##### 5.1.1.8 Client - OAuth2\n\nBallerina gRPC clients enable authentication using OAuth2 by setting the `grpc:OAuth2GrantConfig` configurations in the client. OAuth2 can configure in 4 ways:\n\n_i. Client credentials grant type_\n\n```ballerina\nHelloWorldClient securedEP = check new(\"https://localhost:9090\",\n    auth = {\n        tokenUrl: \"https://localhost:9445/oauth2/token\",\n        clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",\n        clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",\n        scopes: [\"admin\"],\n        clientConfig: {\n            secureSocket: {\n                cert: \"/path/to/public.crt\"\n            }\n        }\n    }\n);\n```\n\n_ii. Password grant type_\n\n```ballerina\nHelloWorldClient securedEP = check new(\"https://localhost:9090\",\n    auth = {\n        tokenUrl: \"https://localhost:9445/oauth2/token\",\n        username: \"admin\",\n        password: \"admin\",\n        clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",\n        clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",\n        scopes: [\"admin\"],\n        refreshConfig: {\n            refreshUrl: \"https://localhost:9445/oauth2/token\",\n            scopes: [\"hello\"],\n            clientConfig: {\n                secureSocket: {\n                    cert: \"/path/to/public.crt\"\n                }\n            }\n        },\n        clientConfig: {\n            secureSocket: {\n                cert: \"/path/to/public.crt\"\n            }\n        }\n    }\n);\n```\n_iii. Refresh token grant type_\n\n```ballerina\nHelloWorldClient securedEP = check new(\"https://localhost:9090\",\n    auth = {\n        refreshUrl: \"https://localhost:9445/oauth2/token\",\n        refreshToken: \"24f19603-8565-4b5f-a036-88a945e1f272\",\n        clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",\n        clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",\n        scopes: [\"admin\"],\n        clientConfig: {\n            secureSocket: {\n                cert: \"/path/to/public.crt\"\n            }\n        }\n    }\n);\n```\n\n_iv. JWT bearer grant type_\n\n```ballerina\nHelloWorldClient securedEP = check new(\"https://localhost:9090\",\n    auth = {\n        tokenUrl: \"https://localhost:9445/oauth2/token\",\n        assertion: \"eyJhbGciOiJFUzI1NiIsImtpZCI6Ij[...omitted for brevity...]\",\n        clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",\n        clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",\n        scopes: [\"admin\"],\n        clientConfig: {\n            secureSocket: {\n                cert: \"/path/to/public.crt\"\n            }\n        }\n    }\n);\n```\n#### 5.1.2 Imperative approach\n\nThis is also known as the code-driven approach, which is used for advanced use cases, where users need to be worried more about how authentication and authorization work and need to have further customizations. The user has full control of the code-driven approach. The handler creation and authentication/authorization calls are made by the user at the business logic layer.\n\n##### 5.1.2.1 Service - basic auth - file user store\n\nBallerina gRPC services enable authentication and authorization using a file user store by employing the class `grpc:ListenerFileUserStoreBasicAuthHandler`.\n\n```ballerina\nservice \"HelloWorld\" on new grpc:Listener(9090) {\n    remote function sayHello(ContextString request) returns string|error {\n        grpc:ListenerFileUserStoreBasicAuthHandler handler = new;\n        auth:UserDetails|grpc:UnauthenticatedError authnResult = handler.authenticate(request.headers);\n    }\n}\n```\n\n```toml\n# Config.toml\n[[auth.users]]\nusername=\"admin\"\npassword=\"123\"\nscopes=[\"write\", \"update\"]\n```\n\n##### 5.1.2.2 Service - basic auth - LDAP user store\n\nBallerina gRPC services enable authentication and authorization using an LDAP user store by employing the class `grpc:ListenerLdapUserStoreBasicAuthHandler`.\n\n```ballerina\nservice \"HelloWorld\" on new grpc:Listener(9090) {\n    remote function sayHello(ContextString request) returns string|error {\n        grpc:LdapUserStoreConfig config = {\n            domainName: \"avix.lk\",\n            connectionUrl: \"ldap://localhost:389\",\n            connectionName: \"cn=admin,dc=avix,dc=lk\",\n            connectionPassword: \"avix123\",\n            userSearchBase: \"ou=Users,dc=avix,dc=lk\",\n            userEntryObjectClass: \"inetOrgPerson\",\n            userNameAttribute: \"uid\",\n            userNameSearchFilter: \"(&(objectClass=inetOrgPerson)(uid=?))\",\n            userNameListFilter: \"(objectClass=inetOrgPerson)\",\n            groupSearchBase: [\"ou=Groups,dc=avix,dc=lk\"],\n            groupEntryObjectClass: \"groupOfNames\",\n            groupNameAttribute: \"cn\",\n            groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",\n            groupNameListFilter: \"(objectClass=groupOfNames)\",\n            membershipAttribute: \"member\",\n            userRolesCacheEnabled: true,\n            connectionPoolingEnabled: false,\n            connectionTimeout: 5,\n            readTimeout: 60\n        };\n        grpc:ListenerLdapUserStoreBasicAuthHandler handler = new(config);\n        auth:UserDetails|grpc:UnauthenticatedError authnResult = handler->authenticate(request.headers);\n    }\n}\n```\n##### 5.1.2.3 Service - JWT auth\n\nBallerina gRPC services enable authentication and authorization using JWTs by employing the class `grpc:ListenerJwtAuthHandler`.\n\n```ballerina\nservice \"HelloWorld\" on new grpc:Listener(9090) {\n    remote function sayHello(ContextString request) returns string|error {\n        grpc:JwtValidatorConfig config = {\n            issuer: \"wso2\",\n            audience: \"ballerina\",\n            signatureConfig: {\n                trustStoreConfig: {\n                    trustStore: {\n                        path: TRUSTSTORE_PATH,\n                        password: \"ballerina\"\n                    },\n                    certAlias: \"ballerina\"\n                }\n            },\n            scopeKey: \"scope\"\n        };\n        grpc:ListenerJwtAuthHandler handler = new(config);\n        jwt:Payload|grpc:UnauthenticatedError authResult = handler.authenticate(request.headers);\n    }\n}\n```\n##### 5.1.2.4 Service - OAuth2\n\nBallerina gRPC services enable authentication and authorization using OAuth2 by employing the class `grpc:OAuth2IntrospectionConfig`.\n\n```ballerina\nservice \"HelloWorld\" on new grpc:Listener(9090) {\n    remote function sayHello(ContextString request) returns string|error {\n        grpc:OAuth2IntrospectionConfig config = {\n            url: \"https://localhost:\" + oauth2AuthorizationServerPort.toString() + \"/oauth2/token/introspect\",\n            tokenTypeHint: \"access_token\",\n            scopeKey: \"scp\",\n            clientConfig: {\n                secureSocket: {\n                   cert: {\n                       path: TRUSTSTORE_PATH,\n                       password: \"ballerina\"\n                   }\n                }\n            }\n        };\n        grpc:ListenerOAuth2Handler handler = new(config);\n        oauth2:IntrospectionResponse|grpc:UnauthenticatedError|grpc:PermissionDeniedError authResult = handler->authorize(request.headers, \"read\");\n    }\n}\n```\n##### 5.1.2.5 Client - basic auth\n\nBallerina gRPC clients enable authentication and authorization using basic auth by employing class `grpc:ClientBasicAuthHandler`. To enable authentication and authorization, the generated headers of the `enrich` API needs to pass to the RPC call.\n\n```ballerina\ngrpc:CredentialsConfig config = {\n    username: \"admin\",\n    password: \"123\"\n};\n\ngrpc:ClientBasicAuthHandler handler = new (config);\nmap<string|string[]>|grpc:ClientAuthError result = handler.enrich(requestHeaders);\n```\n\n##### 5.1.2.6 Client - bearer token auth\n\nBallerina gRPC clients enable authentication and authorization using bearer tokens by employing class `grpc:ClientBearerTokenAuthHandler`. To enable authentication and authorization, the generated headers of the `enrich` API needs to pass to the RPC call.\n\n```ballerina\ngrpc:BearerTokenConfig config = {token: \"eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QifQ\"};\n\ngrpc:ClientBearerTokenAuthHandler handler = new (config);\nmap<string|string[]>|grpc:ClientAuthError result = handler.enrich(requestHeaders);\n```\n\n##### 5.1.2.7 Client - self-signed JWT auth\n\nBallerina gRPC clients enable authentication and authorization using JWTs by employing class `grpc:ClientSelfSignedJwtAuthHandler`. To enable authentication and authorization, the generated headers of the `enrich` API needs to pass to the RPC call.\n\n```ballerina\ngrpc:JwtIssuerConfig config = {\n    username: \"admin\",\n    issuer: \"wso2\",\n    audience: [\"ballerina\"],\n    customClaims: { \"scope\": \"write\" },\n    signatureConfig: {\n        config: {\n            keyStore: {\n                path: KEYSTORE_PATH,\n                password: \"ballerina\"\n            },\n            keyAlias: \"ballerina\",\n            keyPassword: \"ballerina\"\n        }\n    }\n};\ngrpc:ClientSelfSignedJwtAuthHandler handler = new(config);\nmap<string|string[]>|grpc:ClientAuthError result = handler.enrich(requestHeaders);\n```\n\n##### 5.1.2.8 Client - OAuth2\n\nBallerina gRPC clients enable authentication and authorization using OAuth2 by employing class `grpc:ClientOAuth2Handler`. To enable authentication and authorization, the generated headers of the `enrich` API needs to pass to the RPC call.\n\n```ballerina\ngrpc:OAuth2ClientCredentialsGrantConfig config = {\n    tokenUrl: \"https://localhost:\" + oauth2AuthorizationServerPort.toString() + \"/oauth2/token\",\n    clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68\",\n    clientSecret: \"9205371918321623741\",\n    scopes: [\"token-scope1\", \"token-scope2\"],\n    clientConfig: {\n        secureSocket: {\n            cert: {\n                path: TRUSTSTORE_PATH,\n                password: \"ballerina\"\n            }\n        }\n    }\n};\ngrpc:ClientOAuth2Handler handler = new(config);\nmap<string|string[]>|grpc:ClientAuthError result = handler->enrich(requestHeaders);\n```\n\n### 5.2 SSL/TLS and mutual SSL\n\nA gRPC listener with configuration `grpc:ListenerSecureSocket` exposes gRPC services with SSL/TLS.\n\n```ballerina\nlistener grpc:Listener securedEp = new(9090,\n    secureSocket = {\n        key: {\n            certFile: \"/path/to/public.crt\",\n            keyFile: \"/path/to/private.key\"\n        }\n    }\n);\n\n@grpc:Descriptor {\n    value: ROOT_DESCRIPTOR_GRPC_SERVICE\n}\nservice \"HelloWorld\" on securedEp {\n    remote function hello() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\nA gRPC client with configuration `grpc:ClientSecureSocket` can invoke gRPC services with SSL/TLS.\n\n```ballerina\nHelloWorldClient securedEp = check new(\"https://localhost:9090\",\n    secureSocket = {\n        cert: \"/path/to/public.crt\"\n    }\n);\n```\n\nBy configuring the mutualSsl entry in the `grpc:ListenerSecureSocket`, gRPC services can expose with mutual SSL.\n\n```ballerina\nlistener grpc:Listener securedEP = new(9090,\n    secureSocket = {\n        key: {\n            certFile: \"/path/to/public.crt\",\n            keyFile: \"/path/to/private.key\"\n        },\n        mutualSsl: {\n            verifyClient: grpc:REQUIRE,\n            cert: \"/path/to/public.crt\"\n        },\n        protocol: {\n            name: grpc:TLS,\n            versions: [\"TLSv1.2\", \"TLSv1.1\"]\n        },\n        ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]\n    }\n);\n```\n\n## 6. gRPC utility functions\n\n### 6.1. gRPC deadline\nThe following API sets a deadline for each request.\n\n```ballerina\n# Enables the deadline by adding the `deadline` header to the given headers.\n# ```ballerina\n# time:Utc current = time:utcNow();\n# time:Utc deadline = time:utcAddSeconds(current, 300);\n# map<string|string[]> headers = grpc:setDeadline(deadline);\n# ```\n#\n# + deadline - The deadline time value (this should be a specific time and not a duration)\n# + headerMap - Optional header map (if this is not specified, it creates a new header set)\n# + return - The header map that includes the deadline\npublic isolated function setDeadline(time:Utc deadline, map<string|string[]> headerMap = {}) returns map<string|string[]>;\n```\n\nIf a particular RPC exceeds the specified deadline, the response will be a `grpc:DeadlineExceededError`.\n\n### 6.2. gRPC compression\nThe following API enables compression for gRPC calls. Currently, Gzip compression is supported by the Ballerina gRPC library.\n```ballerina\n# Enables the compression support by adding the `grpc-encoding` header to the given headers.\n# ```ballerina\n# map<string|string[]> headers = grpc:setCompression(grpc:GZIP);\n# ```\n#\n# + compressionType - The compression type.\n# + headerMap - Optional header map (if this is not specified, it creates a new header set)\n# + return - The header map that includes the compression headers\npublic isolated function setCompression(CompressionType compressionType, map<string|string[]> headerMap = {}) returns map<string|string[]>;\n```\n### 6.3. gRPC access and trace Logs\nAccess and trace logs can be enabled by adding the following configurations to the `Config.toml` file in a Ballerina project.\n\n```toml\n[ballerina.grpc.traceLogAdvancedConfig]\n# Enable printing trace logs in console\nconsole = true              # Default is false\n# Prints the trace logs to the given file\npath = \"testTraceLog.txt\"   # Optional\n# Sends the trace logs to the configured endpoint\nhost = \"localhost\"          # Optional\nport = 8080                 # Optional\n\n[ballerina.grpc.accessLogConfig]\n# Enable printing access logs in console\nconsole = true              # Default is false\n# Prints the access logs to the given file\npath = \"testTraceLog.txt\"   # Optional\n```\n\n### 6.4. gRPC retry\nClient-level retrying can be enabled by passing the following configurations to the client initialization.\n\n```ballerina\n# Configurations for facilitating the retry capability of the gRPC client.\n#\n# + retryCount - Maximum number of retry attempts in a failure scenario\n# + interval - Initial interval(in seconds) between the retry attempts\n# + maxInterval - Maximum interval(in seconds) between two retry attempts\n# + backoffFactor - Retry interval will be multiplied by this factor, in between retry attempts\n# + errorTypes - Error types which should be considered as failure scenarios to retry\npublic type RetryConfiguration record {|\n   int retryCount;\n   decimal interval;\n   decimal maxInterval;\n   decimal backoffFactor;\n   ErrorType[] errorTypes = defaultErrorTypes;\n|};\n```\n"},"__N_SSG":true}