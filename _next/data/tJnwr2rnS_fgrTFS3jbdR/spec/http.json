{"pageProps":{"frontmatter":{},"content":"# Specification: Ballerina HTTP Library\n\n_Owners_: @shafreenAnfar @TharmiganK @ayeshLK @chamil321  \n_Reviewers_: @shafreenAnfar @bhashinee @TharmiganK @ldclakmal  \n_Created_: 2021/12/23  \n_Updated_: 2022/04/08   \n_Edition_: Swan Lake\n\n\n## Introduction\nThis is the specification for the HTTP standard library of [Ballerina language](https://ballerina.io/), which provides HTTP client-server functionalities to produce and consume HTTP APIs.  \n\nThe HTTP library specification has evolved and may continue to evolve in the future. The released versions of the specification can be found under the relevant GitHub tag. \n\nIf you have any feedback or suggestions about the library, start a discussion via a [GitHub issue](https://github.com/ballerina-platform/ballerina-standard-library/issues) or in the [Slack channel](https://ballerina.io/community/). Based on the outcome of the discussion, the specification and implementation can be updated. Community feedback is always welcome. Any accepted proposal, which affects the specification is stored under `/docs/proposals`. Proposals under discussion can be found with the label `type/proposal` in GitHub.\n\nThe conforming implementation of the specification is released and included in the distribution. Any deviation from the specification is considered a bug.\n\n## Contents\n\n1. [Overview](#1-overview)\n2. [Components](#2-components)\n    * 2.1. [Listener](#21-listener)\n        * 2.1.1. [Automatically starting the service](#211-automatically-starting-the-service)\n        * 2.1.2. [Programmatically starting the service](#212-programmatically-starting-the-service)\n    * 2.2. [Service](#22-service)\n        * 2.2.1. [Service type](#221-service-type)\n        * 2.2.2. [Service-base-path](#222-service-base-path)\n        * 2.2.3. [Service declaration](#223-service-declaration)\n        * 2.2.4. [Service class declaration](#224-service-class-declaration)\n    * 2.3. [Resource](#23-resource)\n        * 2.3.1. [Accessor](#231-accessor)\n        * 2.3.2. [Resource-name](#232-resource-name)\n        * 2.3.3. [Path parameter](#233-path-parameter)\n        * 2.3.4. [Signature parameters](#234-signature-parameters)\n            * 2.3.4.1. [Caller](#2341-httpcaller)\n            * 2.3.4.2. [Request](#2342-httprequest)\n            * 2.3.4.3. [Query param](#2343-query-parameter)\n            * 2.3.4.4. [Payload param](#2344-payload-parameter)\n            * 2.3.4.5. [Header param](#2345-header-parameter)\n        * 2.3.5. [Return types](#235-return-types)\n            * 2.3.5.1. [Status Code Response](#2351-status-code-response)\n            * 2.3.5.2. [Return nil](#2352-return-nil)\n            * 2.3.5.3. [Default response status codes](#2353-default-response-status-codes)\n        * 2.3.6. [Introspection resource](#236-introspection-resource)\n    * 2.4. [Client](#24-client)\n        * 2.4.1. [Client types](#241-client-types)\n            * 2.4.1.1. [Security](#2411-security)\n            * 2.4.1.2. [Caching](#2412-caching)\n            * 2.4.1.3. [Redirect](#2413-redirect)\n            * 2.4.1.4. [Retry](#2414-retry)\n            * 2.4.1.5. [Circuit breaker](#2415-circuit-breaker)\n            * 2.4.1.6. [Cookie](#2416-cookie)\n            * 2.4.1.7. [Load balance](#2417-load-balance)\n            * 2.4.1.8. [Failover](#2418-failover)\n        * 2.4.2. [Client actions](#242-client-action)\n            * 2.4.2.1. [Entity body methods](#2421-entity-body-methods)\n            * 2.4.2.2. [Non entity body methods](#2422-non-entity-body-methods)\n            * 2.4.2.3. [Resource methods](#2423-resource-methods)\n            * 2.4.2.4. [Forward/execute methods](#2424-forwardexecute-methods)\n            * 2.4.2.5. [HTTP2 additional methods](#2425-http2-additional-methods)\n        * 2.4.3. [Client actions return types](#243-client-action-return-types)\n3. [Request-routing](#3-request-routing)\n    * 3.1. [Uri and http method match](#31-uri-and-http-method-match)\n    * 3.2. [Most specific path match](#32-most-specific-path-match)\n    * 3.3. [Wild card path match](#33-wild-card-path-match)\n    * 3.4. [Path parameter template match](#34-path-parameter-template-match)\n4. [Annotations](#4-annotations)\n    * 4.1. [Service configuration](#41-service-configuration)\n    * 4.2. [Resource configuration](#42-resource-configuration)\n    * 4.3. [Payload annotation](#43-payload-annotation)\n        * 4.3.1. [Payload binding parameter](#431-payload-binding-parameter)\n        * 4.3.2. [Anydata return value info](#432-anydata-return-value-info)\n    * 4.4. [CallerInfo annotation](#44-callerinfo-annotation)\n    * 4.5. [Header annotation](#45-header-annotation)\n    * 4.6. [Cache annotation](#46-cache-annotation)\n5. [url-parameters](#5-url-parameters)\n    * 5.1. [Path](#51-path)\n    * 5.2. [Query](#52-query)\n    * 5.3. [Matrix](#53-matrix)\n6. [Request and Response](#6-request-and-response)\n7. [Header and Payload](#7-header-and-payload)\n    * 7.1. [Parse header functions](#71-parse-header-functions)\n    * 7.2. [Links support](#72-links-support)\n      * 7.2.1 [LinkedTo record](#721-linkedto-record)\n      * 7.2.2 [Links in the response](#722-links-in-the-response)\n8. [Interceptor and error handling](#8-interceptor-and-error-handling)\n    * 8.1. [Interceptor](#81-interceptor)\n        * 8.1.1. [Request interceptor](#811-request-interceptor)\n            * 8.1.1.1. [Request context](#8111-request-context)\n            * 8.1.1.2. [Next method](#8112-next-method)\n            * 8.1.1.3. [Return to respond](#8113-return-to-respond)\n        * 8.1.2. [Response interceptor](#812-response-interceptor)\n            * 8.1.2.1. [Return to respond](#8121-return-to-respond)\n        * 8.1.3. [Request error interceptor and response error interceptor](#813-request-error-interceptor-and-response-error-interceptor)\n        * 8.1.4. [Engaging interceptor](#814-engaging-interceptors)\n            * 8.1.4.1. [Service level](#8141-service-level)\n            * 8.1.4.2. [Listener level](#8142-listener-level)\n            * 8.1.4.3. [Execution order of interceptors](#8143-execution-order-of-interceptors)\n        * 8.1.5. [Data binding](#815-data-binding)\n    * 8.2. [Error handling](#82-error-handling)\n      * 8.2.1. [Error interceptors](#821-error-interceptors)\n      * 8.2.2. [Error types](#822-error-types)\n      * 8.2.3. [Trace log](#823-trace-log)\n      * 8.2.4. [Access log](#824-access-log)\n9. [Security](#9-security)\n    * 9.1. [Authentication and Authorization](#91-authentication-and-authorization)\n        * 9.1.1. [Declarative Approach](#911-declarative-approach)\n            * 9.1.1.1. [Listener - Basic Auth - File User Store](#9111-listener---basic-auth---file-user-store)\n            * 9.1.1.2. [Listener - Basic Auth - LDAP User Store](#9112-listener---basic-auth---ldap-user-store)\n            * 9.1.1.3. [Listener - JWT Auth](#9113-listener---jwt-auth)\n            * 9.1.1.4. [Listener - OAuth2](#9114-listener---oauth2)\n            * 9.1.1.5. [Client - Basic Auth](#9115-client---basic-auth)\n            * 9.1.1.6. [Client - Bearer Token Auth](#9116-client---bearer-token-auth)\n            * 9.1.1.7. [Client - Self Signed JWT Auth](#9117-client---self-signed-jwt)\n            * 9.1.1.8. [Client - Bearer Token OAuth2](#9118-client---bearer-token-oauth2)\n            * 9.1.1.9. [Client - Grant Types OAuth2](#9119-client---grant-types-oauth2)\n        * 9.1.2 [Imperative Approach](#912-imperative-approach)\n            * 9.1.2.1. [Listener - Basic Auth - File User Store](#9121-listener---basic-auth---file-user-store)\n            * 9.1.2.2. [Listener - Basic Auth - LDAP User Store](#9122-listener---basic-auth---ldap-user-store)\n            * 9.1.2.3. [Listener - JWT Auth](#9123-listener---jwt-auth)\n            * 9.1.2.4. [Listener - OAuth2](#9124-listener---oauth2)\n            * 9.1.2.5. [Client - Basic Auth](#9125-client---basic-auth)\n            * 9.1.2.6. [Client - Bearer Token Auth](#9126-client---bearer-token-auth)\n            * 9.1.2.7. [Client - Self Signed JWT Auth](#9127-client---self-signed-jwt)\n            * 9.1.2.8. [Client - Bearer Token OAuth2](#9128-client---bearer-token-oauth2)\n            * 9.1.2.9. [Client - Grant Types OAuth2](#9129-client---grant-types-oauth2)\n   * 9.2. [SSL/TLS and Mutual SSL](#92-ssltls-and-mutual-ssl)\n        * 9.2.1. [Listener - SSL/TLS](#921-listener---ssltls)\n        * 9.2.2. [Client - Mutual SSL](#922-listener---mutual-ssl)\n        * 9.2.3. [Listener - SSL/TLS](#923-client---ssltls)\n        * 9.2.4. [Client - Mutual SSL](#924-client---mutual-ssl)\n10. [Protocol-upgrade](#10-protocol-upgrade)\n    * 10.1. [HTTP2](#101-http2)\n        * 10.1.1. [Push promise and promise response](#1011-push-promise-and-promise-response)\n\n## 1. Overview\nBallerina language provides first-class support for writing network-oriented programs. The HTTP standard library uses these language constructs and creates the programming model to produce and consume HTTP APIs.\n\nThe HTTP standard library is designed to work with HTTP protocol. It includes high-level abstractions such as `http:Request`, `http:Response`, `http:Service`, and `http:Client` which allow users to produce and consume HTTP API. Further, developers can use this library to build other libraries. The standard libraries such as GraphQL, Websub, and WebSubHub use this library internally.\n\nIn addition to functional requirements, this library deals with nonfunctional requirements such as security, observability, and resiliency. Each requirement is discussed in detail in the coming sections.\n\n## 2. Components\n### 2.1. Listener\nThe HTTP listener object receives network data from a remote process according to the HTTP transport protocol and \ntranslates the received data into invocations on the resources functions of services that have been \nattached to the listener object. The listener provides the interface between network and services.\n\nAs defined in [Ballerina 2021R1 Section 5.7.4](https://ballerina.io/spec/lang/2021R1/#section_5.7.4) the Listener has \nthe object constructor and life cycle methods such as attach(), detach(), 'start(), gracefulStop(), and immediateStop().\n\n#### 2.1.1. Automatically starting the service\nIf a service is attached to the listener, then the listener starts listening on the given port after executing \nattach() and start() methods. HTTP listener can be declared as follows honoring to the generic \n[listener declaration](https://ballerina.io/spec/lang/2021R1/#section_8.3.1)\n\n```ballerina\n// Listener object constructor\nlistener http:Listener serviceListener = new(9090);\n```\n```ballerina\n// Service attaches to the Listener\nservice http:Service /foo/bar on serviceListener {\n    resource function get sayHello(http:Caller caller) {}\n}\n```\n\n#### 2.1.2. Programmatically starting the service\n\nUsers can programmatically start the listener by calling each lifecycle method as follows.\n\n```ballerina\npublic function main() {\n    // Listener object constructor\n    listener http:Listener serviceListener = new(9090);\n    \n    error? err1 = serviceListener.attach(s, “/foo/bar”);\n    error? err2 = serviceListener.start();\n    //...\n    error? err3 = serviceListener.gracefulStop();\n}\n\nhttp:Service s = service object {\n    resource function get sayHello(http:Caller caller) {}\n}\n```\n\n### 2.2. Service\nService is a collection of resources functions, which are the network entry points of a ballerina program. \nIn addition to that a service can contain public and private functions which can be accessed by calling with `self`.\n\n#### 2.2.1. Service type\n```ballerina\npublic type Service distinct service object {\n\n};\n```\nAbove distinct type is provided by HTTP module and user can include the type as `*http:Service` to refer it.\nThe comprehensive typing support is yet to be added to the language. Until that, the compiler plugin is used to \nvalidate the services.\n\n#### 2.2.2. Service base path\n\nThe base path is considered during the request dispatching to discover the service. Identifiers and string literals\nare allowed to be stated as base path and it should be started with `/`. The base path is optional and it will be \ndefaulted to `/` when not defined. If the base path contains any special characters, those should be escaped or defined\nas string literals\n\n```ballerina\nservice hello\\-world new http:Listener(9090) {\n   resource function get foo() {\n\n   }\n}\n\nservice http:Service \"hello-world\" new http:Listener(9090) {\n   resource function get foo() {\n\n   }\n}\n```\n\nA service can be declared in three ways upon the requirement.\n\n#### 2.2.3. Service declaration\nThe [Service declaration](https://ballerina.io/spec/lang/2021R1/#section_8.3.2) is a syntactic sugar for creating a\nservice and it is the mostly used approach for creating a service. The declaration gets desugared into creating a \nlistener object, creating a service object, attaching the service object to the listener object.\n\n```ballerina\nservice http:Service /foo/bar on new http:Listener(9090) {\n  resource function get greeting() returns string {\n      return \"hello world\";\n  }\n}\n```\n\n#### 2.2.4. Service class declaration\n\nThe service value can be instantiated using the service class. This way, user has the completed control of attaching\nthe service to the listener. The life cycle methods to used to proceed.\n\n```ballerina\nservice isolated class SClass {\n   *http:Service;\n   resource function get greeting() returns string {\n       return \"hello world\";\n   }\n}\n\npublic function main() returns error? {\n   http:Listener serviceListener = check new (9090);\n   http:Service httpService = new SClass();\n   \n   error? err1 = serviceListener.attach(httpService, [\"foo\", \"bar\"]);\n   error? err2 = serviceListener.'start();\n   runtime:registerListener(serviceListener);\n}\n```\n\n#### 2.2.5. Service constructor expression\n\n```ballerina\nlistener http:Listener serviceListener = new (9090);\n\nhttp:Service httpService = @http:ServiceConfig {} service object {\n   resource function get greeting() returns string {\n       return \"hello world\";\n   }\n};\n\npublic function main() {\n   error? err1 = serviceListener.attach(httpService, \"/foo/bar\");\n   error? err2 = serviceListener.start();\n   runtime:registerListener(serviceListener);\n}\n```\n\n### 2.3. Resource\n\nA method of a service can be declared as a [resource function](https://ballerina.io/spec/lang/2021R1/#resources) \nwhich is associated with configuration data that is invoked by a network message by a Listener. Users write the \nbusiness logic inside a resource and expose it over the network.\n\n#### 2.3.1. Accessor\nThe accessor-name of the resource represents the HTTP method and it can be get, post, put, delete, head, patch, options \nand default. If the accessor is unmatched, 405 Method Not Allowed response is returned. When the accessor name is \nstated as default, any HTTP method can be matched to it in the absence of an exact match. Users can define custom \nmethods such as copy, move based on their requirement. A resource which can handle any method would look like as \nfollows. This is useful when handling unmatched verbs.\n\n```ballerina\nresource function 'default NAME_TEMPLATE () {\n    \n}\n```\n#### 2.3.2. Resource name\nThe resource-name represents the path of the resource which is considered during the request dispatching. The name can \nbe hierarchical(foo/bar/baz). Each path identifier should be separated by `/` and first path identifier should not \ncontain a prefixing `/`. If the paths are unmatched, 404 NOT FOUND response is returned.\n```ballerina\nresource function post hello() {\n    \n}\n```\nOnly the identifiers can be used as resource path not string literals. Dot identifier is \nused to denote the `/` only if the path contains a single identifier. \n```ballerina\nresource function post .() {\n    \n}\n```\nAny special characters can be used in the path by escaping.\n```ballerina\nresource function post hello\\-world() {\n    \n}\n```\n\n#### 2.3.3. Path parameter\nThe path parameter segment is also a part of the resource name which is declared within brackets along with the type. \nAs per the following resource name, baz is the path param segment and it’s type is string. Like wise users can define \nstring, int, boolean, float, and decimal typed path parameters. If the paths are unmatched, 404 NOT FOUND response \nis returned. If the segment failed to parse into the expected type, 500 Internal Server Error response is returned.\n\n```ballerina\nresource function post foo/bar/[string baz]/qux() {\n    // baz is the path param\n}\n\nresource function get data/[int age]/[string name]/[boolean status]/[float weight]() returns json {\n   int balAge = age + 1;\n   float balWeight = weight + 2.95;\n   string balName = name + \" lang\";\n   if (status) {\n       balName = name;\n   }\n   json responseJson = { Name:name, Age:balAge, Weight:balWeight, Status:status, Lang: balName};\n   return responseJson;\n}\n```\n\nIf multiple path segments needs to be matched after the last identifier, Rest param should be used at the end of the \nresource name as the last identifier. string, int, boolean, float, and decimal types are supported as rest parameters.\n```ballerina\nresource function get foo/[string... bar]() returns json {\n   json responseJson = {\"echo\": bar[0]};\n   return responseJson;\n}\n```\n\nUsing both `'default` accessor and the rest parameters, a default resource can be defined to a service. This \ndefault resource can act as a common destination where the unmatched requests (either HTTP method or resource path) may \nget dispatched.\n\n```ballerina\nresource function 'default [string... s]() {\n\n}\n```\n\n#### 2.3.4. Signature parameters\nThe resource function can have the following parameters in the signature. There are not any mandatory params or any \nparticular order. But it’s a good practice to keep the optional param at the end.\n\n```ballerina\nresource function XXX NAME_TEMPLATE ([http:Caller hc], [http:Request req], (anydata queryParam)?, \n    (@http:Payload anydata payload)?, (@http:Header string header)?, (http:Header headers)? ) {\n        \n}\n```\n\nHowever, the first choice should be to use signature params and use returns. Avoid caller unless you have specific \nrequirement. Also use data binding, header params and resource returns to write smaller code with more readability.\n\n##### 2.3.4.1. http:Caller\n\nThe caller client object represents the endpoint which initiates the request. Once the request is processed, the \ncorresponding response is sent back using the remote functions which are associated with the caller object. \nIn addition to that, the caller has certain meta information related to remote and local host such as IP address,\nprotocol. This parameter is not compulsory and not ordered.\n\n\nThe CallerInfo annotation associated with the `Caller` is to denote the response type.\nIt will ensure that the resource function responds with the right type and provides static type information about \nthe response type that can be used to generate OpenAPI.\n\nThe default type is the `http:Response`. Other than that, caller remote functions will accept following types as the \noutbound response payload. Internally an `http:Response` is created including the given payload value\n\n```ballerina\nstring|xml|json|byte[]|int|float|decimal|boolean|map<json>|table<map<json>>|(map<json>|table<map<json>>)[]|\nmime:Entity[]|stream<byte[], io:Error?>|()\n```\n\nBased on the payload types respective header value is added as the `Content-type` of the `http:Response`.\n\n| Type                                                                  | Content Type             |\n|-----------------------------------------------------------------------|--------------------------|\n| ()                                                                    | -                        |\n| string                                                                | text/plain               |\n| xml                                                                   | application/xml          |\n| byte[], stream<byte[], io:Error?>                                     | application/octet-stream |\n| int, float, decimal, boolean                                          | application/json         |\n| map\\<json\\>, table<map\\<json\\>>, map\\<json\\>[], table<map\\<json\\>>)[] | application/json         |\n\nIn addition to the above types, caller `respond()` method can accept `StatusCodeResponse` or `error` type. In case of \n`error`, an error response is returned to the client with the error message.\n\nThe HTTP compiler extension checks the argument of the `respond()` method if the matching payload type is passed as\ndenoted in the CallerInfo annotation. At the moment, in terms of responding error, CallerInfo annotation can only support \n`http:Error` type.\n\n```ballerina\nresource function post foo(@http:CallerInfo {respondType:Person}  http:Caller hc) {\n    Person p = {};\n    hc->respond(p);\n}\n```\n\nWhen the caller `respond()` method is invoked from HTTP post resource by providing `anydata` payload, the status \ncode of the outbound response will be set to HTTP Created (201) by default.\n\n##### 2.3.4.2. http:Request\n\nThe `http:Request` represents the request which is sent and received over the network which includes headers and \nthe entity body. Listener passes it to the resource function as an argument to be accessed by the user based on \ntheir requirement. This parameter is not compulsory and not ordered.\n\n```ballerina\nresource function get person(http:Request req) {\n    \n}\n```\n\nSee section [Request and Response](#6-request-and-response) to find out more. \n\n##### 2.3.4.3. Query parameter\n\nThe query param is a URL parameter which is available as a resource function parameter and it's not associated \nwith any annotation or additional detail. This parameter is not compulsory and not ordered. The type of query param \nare as follows\n\n```ballerina\ntype BasicType boolean|int|float|decimal|string|map<json>;\npublic type QueryParamType ()|BasicType|BasicType[];\n```\n\nThe same query param can have multiple values. In the presence of multiple such values,  If the user has specified \nthe param as an array type, then all values will return. If not the first param values will be returned. As per the \nfollowing resource function, the request may contain at least two query params with the key of bar and id.\nEg : “/hello?bar=hi&id=56”\n\n```ballerina\nresource function get hello(string bar, int id) { \n    \n}\n```\n\nIf the query parameter is not defined in the function signature, then the query param binding does not happen. If a \nquery param of the request URL has no corresponding parameter in the resource function, then that param is ignored. \nIf the parameter is defined in the function, but there is no such query param in the URL, that request will lead \nto a 400 BAD REQUEST error response unless the type is nilable (string?)\n\nThe query param consists of query name and values. Sometimes user may send query without value(`foo:`). In such\nsituations, when the query param type is nilable, the values returns nil and same happened when the complete query is\nnot present in the request. In order to avoid the missing detail, a service level configuration has introduced naming\n`treatNilableAsOptional`\n\n```ballerina\n@http:ServiceConfig {\n    treatNilableAsOptional : false\n}\nservice /queryparamservice on QueryBindingIdealEP {\n\n    resource function get test1(string foo, int bar) returns json {\n        json responseJson = { value1: foo, value2: bar};\n        return responseJson;\n    }\n}\n```\n\n<table>\n<tr>\n<th> Case </th>\n<th>  Resource argument </th>\n<th>  Query </th>\n<th>  Current Mapping (treatNilableAsOptional=true - Default) </th>\n<th>  Ideal Mapping (treatNilableAsOptional=false) </th>\n</tr>\n<tr>\n<td rowspan=4> 1 </td>\n<td rowspan=4> string foo </td>\n<td> foo=bar </td>\n<td> bar </td>\n<td> bar </td>\n</tr>\n<tr>\n<td> foo=</td>\n<td> \"\" </td>\n<td> \"\" </td>\n</tr>\n<tr>\n<td> foo</td>\n<td> Error : no query param value found for 'foo' </td>\n<td> Error : no query param value found for 'foo' </td>\n</tr>\n<tr>\n<td> No query</td>\n<td> Error : no query param value found for 'foo' </td>\n<td> Error : no query param value found for 'foo' </td>\n</tr>\n<tr>\n<td rowspan=4> 2 </td>\n<td rowspan=4> string? foo </td>\n<td> foo=bar </td>\n<td> bar </td>\n<td> bar </td>\n</tr>\n<tr>\n<td> foo=</td>\n<td> \"\" </td>\n<td> \"\" </td>\n</tr>\n<tr>\n<td> foo</td>\n<td> nil </td>\n<td> nil </td>\n</tr>\n<tr>\n<td> No query</td>\n<td> nil </td>\n<td> Error : no query param value found for 'foo' </td>\n</tr>\n</table>\n\nSee section [Query](#52-query) to understand accessing query param via the request object.\n\n##### 2.3.4.4. Payload parameter\n\nThe payload parameter is used to access the request payload during the resource invocation. When the payload param is \ndefined with @http:Payload annotation, the listener deserialize the inbound request payload based on the media type \nwhich retrieved by the `Content-type` header of the request. The data binding happens thereafter considering the \nparameter type. The type of payload parameter can be one of the `anytype`. If the header is not present or not a \nstandard header, the binding type is inferred by the parameter type.\n\nFollowing table explains the compatible `anydata` types with each common media type. In the absence of a standard media \ntype, the binding type is inferred by the payload parameter type itself. If the type is not compatible with the media \ntype, error is returned.\n\n|Ballerina Type | Structure|\"text\" | \"xml\" | \"json\" | \"x-www-form-urlencoded\" | \"octet-stream\"|\n|---------------|----------|-------|-------|--------|-------------------------|---------------|\n|boolean| | ❌ | ❌ | ✅|❌|❌\n| |boolean[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<boolean\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<boolean\\>\\>| ❌ | ❌ | ✅|❌|❌\n|int| | ❌ | ❌ | ✅|❌|❌\n| |int[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<int\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<int\\>\\>| ❌ | ❌ | ✅|❌|❌\nfloat| | ❌ | ❌ | ✅|❌|❌\n| |float[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<float\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<float\\>\\>| ❌ | ❌ | ✅|❌|❌\ndecimal| | ❌ | ❌ | ✅|❌|❌\n| |decimal[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<decimal\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<decimal\\>\\>| ❌ | ❌ | ✅|❌|❌\nbyte[]| | ✅ | ❌ | ✅|❌|✅\n| |byte[][]| ❌ | ❌ | ✅|❌|❌\n| |map\\<byte[]\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<byte[]\\>\\>| ❌ | ❌ | ✅|❌|❌\nstring| |✅|❌|✅|✅|❌\n| |string[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<string\\>| ❌ | ❌ | ✅|✅|❌\n| |table\\<map\\<string\\>\\>| ❌ | ❌ | ✅|❌|❌\nxml| | ❌ | ✅ | ❌|❌|❌\njson| | ❌ | ❌ | ✅|❌|❌\n| |json[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<json\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<json\\>\\>| ❌ | ❌ | ✅|❌|❌\nmap| | ❌ | ❌ | ✅|❌|❌\n| |map[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<map\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<map\\>\\>| ❌ | ❌ | ✅|❌|❌\nrecord| |❌|❌|✅|❌|❌\n| |record[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<record\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<record\\>| ❌ | ❌ | ✅|❌|❌\n\nThe payload binding process begins soon after finding the correct resource for the given URL and before the \nresource execution. \nThe error which may occur during the process will be returned to the caller with the response \nstatus code of 400 BAD REQUEST. The successful binding will proceed the resource execution with the built payload.\n\n```ballerina\nresource function post hello(@http:Payload json payload) { \n    \n}\n```\n\nAdditionally, the payload parameter type can be a union of `anydata`. Based on the media type, the potential binding\ntype is decided. For example, if the union is defined as `json|xml` and the media type is related to `json`,\nthe deserialization and the binding will proceed according to the type `json`. But if the media type is related to `xml`\nthe process will happen according to the type `xml`.\nIf the given types of the union are not compatible with the media type, an error is returned.\n\n```ballerina\nresource function post hello(@http:Payload json|xml payload) { \n    \n}\n\n```\nIf any of the type is union with `()`(i.e `string?`), then in the absence of the payload, `()` will be assigned as \nthe value without being responded by a `BAD REQUEST` response.\n\nInternally the complete payload is built, therefore the application should have sufficient memory to support the \nprocess. Payload binding is not recommended if the service behaves as a proxy/pass-through where request payload is \nnot accessed.\n\nUser may specify the expected content type in the annotation to shape the resource as described in section [Payload \nbinding parameter](#431-payload-binding-parameter)\n\n##### 2.3.4.5. Header parameter\n\nThe header parameter is to access the inbound request headers The header param is defined with `@http:Header` annotation\nThe type of header param can be defined as follows;\n\n```ballerina\ntype BasicType string|int|float|decimal|boolean;\npublic type HeaderParamType ()|BasicType|BasicType[]|record {| BasicType...; |};\n```\n\nWhen multiple header values are present for the given header, the first header value is returned when the param \ntype is `string` or any of the basic types. To retrieve all the values, use `string[]` type or any array of the\nbasic types. This parameter is not compulsory and not ordered. \n\nThe header param name is considered as the header name during the value retrieval. However, the header annotation name \nfield can be used to define the header name whenever user needs some different variable name for the header. \n\nUser cannot denote the type as a union of pure type, array type, or record type together, that way the resource \ncannot infer a single type to proceed. Hence, returns a compiler error.\n\nIn the absence of a header when the param is defined in the resource signature, listener returns 400 BAD REQUEST unless\nthe type is nilable. \n\n```ballerina\n//Single header value extraction\nresource function post hello1(@http:Header string referer) {\n    \n}\n\n//Multiple header value extraction\nresource function post hello2(@http:Header {name: \"Accept\"} string[] accept) {\n    \n}\n\npublic type RateLimitHeaders record {|\n    string x\\-rate\\-limit\\-id;\n    int x\\-rate\\-limit\\-remaining;\n    string[] x\\-rate\\-limit\\-types;\n|};\n\n//Populate selected headers to a record\nresource function get hello3(@http:Header RateLimitHeaders rateLimitHeaders) {\n}\n```\n\nIf the requirement is to access all the header of the inbound request, it can be achieved through the `http:Headers` \ntyped param in the signature. It does not need the annotation and not ordered.\n\n```ballerina\nresource function get hello3(http:Headers headers) {\n   String|error referer = headers.getHeader(\"Referer\");\n   String[]|error accept = headers.getHeaders(\"Accept\");\n   String[] keys = headers.getHeaderNames();\n}\n```\n\nThe header consists of header name and values. Sometimes user may send header without value(`foo:`). In such \nsituations, when the header param type is nilable, the values returns nil and same happened when the complete header is \nnot present in the request. In order to avoid the missing detail, a service level configuration has introduced naming \n`treatNilableAsOptional`\n\n```ballerina\n@http:ServiceConfig {\n    treatNilableAsOptional : false\n}\nservice /headerparamservice on HeaderBindingIdealEP {\n\n    resource function get test1(@http:Header string? foo) returns json {\n        \n    }\n}\n```\n\n<table>\n<tr>\n<th>  Case </th>\n<th>  Resource argument </th>\n<th>  Header </th>\n<th>  Current Mapping (treatNilableAsOptional=true - Default) </th>\n<th>  Ideal Mapping (treatNilableAsOptional=false) </th>\n</tr>\n<tr>\n<td rowspan=3> 1 </td>\n<td rowspan=3> string foo </td>\n<td> foo:bar </td>\n<td> bar </td>\n<td> bar </td>\n</tr>\n<tr>\n<td> foo:</td>\n<td> Error : no header value found for 'foo' </td>\n<td> Error : no header value found for 'foo' </td>\n</tr>\n<tr>\n<td> No header</td>\n<td> Error : no header value found for 'foo' </td>\n<td> Error : no header value found for 'foo' </td>\n</tr>\n<tr>\n<td rowspan=3> 2 </td>\n<td rowspan=3> string? foo </td>\n<td> foo:bar </td>\n<td> bar </td>\n<td> bar </td>\n</tr>\n<tr>\n<td> foo:</td>\n<td> nil </td>\n<td> nil </td>\n</tr>\n<tr>\n<td> No header</td>\n<td> nil </td>\n<td> Error : no header value found for 'foo' </td>\n</tr>\n</table>\n\n\n#### 2.3.5. Return types\nThe resource function supports anydata, error?, http:Response and http:StatusCodeResponse as return types. \nWhenever user returns a particular output, that will result in an HTTP response to the caller who initiated the \ncall. Therefore, user does not necessarily depend on the `http:Caller` and its remote methods to proceed with the \nresponse. \n\n```ballerina\nresource function XXX NAME_TEMPLATE () returns @http:Payload anydata|http:Response|http:StatusCodeResponse|http:Error? {\n}\n```\n\nIn addition to that the `@http:Payload` annotation can be specified along with anydata return type\nmentioning the content type of the outbound payload.\n\n```ballerina\nresource function get test() returns @http:Payload {mediaType:\"text/id+plain\"} string {\n    return \"world\";\n}\n```\n\nBased on the return types respective header value is added as the `Content-type` of the `http:Response`. \n\n| Type                                                                  | Content Type             |\n|-----------------------------------------------------------------------|--------------------------|\n| ()                                                                    | -                        |\n| string                                                                | text/plain               |\n| xml                                                                   | application/xml          |\n| byte[]                                                                | application/octet-stream |\n| int, float, decimal, boolean                                          | application/json         |\n| map\\<json\\>, table<map\\<json\\>>, map\\<json\\>[], table<map\\<json\\>>)[] | application/json         |\n| http:StatusCodeResponse                                               | application/json         |\n\n##### 2.3.5.1. Status Code Response\n\nThe status code response records are defined in the HTTP module for every HTTP status code. It improves readability & \nhelps OpenAPI spec generation. \n\n```ballerina\ntype Person record {\n   string name;\n};\nresource function put person(string name) returns record {|*http:Created; Person body;|} {\n   Person person = {name:name};\n   return {\n       mediaType: \"application/person+json\",\n       headers: {\n           \"X-Server\": \"myServer\"\n       },\n       body: person\n   };\n}\n```\n\nFollowing is the `http:Ok` definition. Likewise, all the status codes are provided.\n\n```ballerina\npublic type Ok record {\n   readonly StatusOk status;\n   string mediaType;\n   map<string|string[]> headers?;\n   anydata body?;\n};\n\nresource function get greeting() returns http:Ok|http:InternalServerError {\n   http:Ok ok = { body: \"hello world\", headers: { xtest: \"foo\"} };\n   return ok;\n}\n```\n\n##### 2.3.5.2. Return nil\n\nReturn nil from the resource has few meanings. \n\n1. If the resource wants to return nothing, the listener will return 202 ACCEPTED response.\n```ballerina\nresource function post person(@http:Payload Person p) {\n    int age = p.age;\n    io:println(string `Age is: ${age}`);\n}\n```   \n2. If the resource is dealt with the response via http:Caller, then returning () does not lead to subsequent response. \n   Listener aware that the request is already being served.\n```ballerina\nresource function get fruit(string? colour, http:Caller caller) {\n    if colour == \"red\" {\n        error? result = caller->respond(\"Sending apple\");\n        return; // ending the flow, so not 202 response\n    }\n    error? result = caller->respond(\"Sending orange\");\n}\n```   \n3. If the resource is dealt with the success response via http:Caller and return () in the else case, then the \n   response is 500 INTERNAL SERVER ERROR.\n```ballerina\nresource function get fruit(string? colour, http:Caller caller) {\n    if colour == \"red\" {\n        error? result = caller->respond(\"Sending apple\");\n        return; // ending the flow\n    }\n    return; // 500 internal Server Error\n}\n```\n\n##### 2.3.5.3. Default response status codes\n\nTo improve the developer experience for RESTful API development, following default status codes will be used in outbound \nresponse when returning `anydata` directly from a resource function.\n\n| Resource Accessor | Semantics                                                     | Status Code             |\n|-------------------|---------------------------------------------------------------|-------------------------|\n| GET               | Retrieve the resource                                         | 200 OK                  |\n| POST              | Create a new resource                                         | 201 Created             |\n| PUT               | Create a new resource or update an existing resource          | 200 OK                  |\n| PATCH             | Partially update an existing resource                         | 200 OK                  |\n| DELETE            | Delete an existing resource                                   | 200 OK                  |\n| HEAD              | Retrieve headers                                              | 200 OK                  |\n| OPTIONS           | Retrieve permitted communication options                      | 200 OK                  |\n\n#### 2.3.6. Introspection resource\n\nThe introspection resource is internally generated for each service and host the openAPI doc can be generated \n(or retrieved) at runtime when requested from the hosted service itself. In order to get the openAPI doc hosted\nresource path, user can send an OPTIONS request either to one of the resources or the service. The link header\nin the 204 response specifies the location. Then user can send a GET request to the dynamically generated URL in the \nlink header with the relation openapi to get the openAPI definition for the service.\n\nSample service\n```ballerina\nimport ballerina/http;\n\nservice /hello on new http:Listener(9090) {\n    resource function get greeting() returns string{\n        return \"Hello world\";\n    }\n}\n```\n\nOutput of OPTIONS call to usual resource\n```ballerina\ncurl -v localhost:9090/hello/greeting -X OPTIONS\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 9090 (#0)\n> OPTIONS /hello/greeting HTTP/1.1\n> Host: localhost:9090\n> User-Agent: curl/7.64.1\n> Accept: */*\n> \n< HTTP/1.1 204 No Content\n< allow: GET, OPTIONS\n< link: </hello/openapi-doc-dygixywsw>;rel=\"service-desc\"\n< server: ballerina/2.0.0-beta.2.1\n< date: Wed, 18 Aug 2021 14:09:40 +0530\n< \n```\n\nOutput of GET call to introspection resource\n```ballerina\ncurl -v localhost:9090/hello/openapi-doc-dygixywsw\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 9090 (#0)\n> GET /hello/openapi-doc-dygixywsw HTTP/1.1\n> Host: localhost:9090\n> User-Agent: curl/7.64.1\n> Accept: */*\n> \n< HTTP/1.1 200 OK\n< content-type: application/json\n< content-length: 634\n< server: ballerina/2.0.0-beta.2.1\n< date: Wed, 18 Aug 2021 14:22:29 +0530\n< \n{\n  \"openapi\": \"3.0.1\",\n  \"info\": {\n     \"title\": \" hello\",\n     \"version\": \"1.0.0\"\n  },\n  \"servers\": [\n     {\n        \"url\": \"localhost:9090/hello\"\n     }\n  ],\n  \"paths\": {\n     \"/greeting\": {\n        \"get\": {\n           \"operationId\": \"operation1_get_/greeting\",\n           \"responses\": {\n              \"200\": {\n                 \"description\": \"Ok\",\n                 \"content\": {\n                    \"text/plain\": {\n                       \"schema\": {\n                          \"type\": \"string\"\n                       }\n                    }\n                 }\n              }\n           }\n        }\n     }\n  },\n  \"components\": {}\n}\n```\n\nOutput of OPTIONS call to service base path\n\n```ballerina\ncurl -v localhost:9090/hello -X OPTIONS \n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 9090 (#0)\n> OPTIONS /hello HTTP/1.1\n> Host: localhost:9090\n> User-Agent: curl/7.64.1\n> Accept: */*\n> \n< HTTP/1.1 204 No Content\n< allow: GET, OPTIONS\n< link: </hello/openapi-doc-dygixywsw>;rel=\"service-desc\"\n< server: ballerina/2.0.0-beta.2.1\n< date: Thu, 19 Aug 2021 13:47:29 +0530\n< \n* Connection #0 to host localhost left intact\n* Closing connection 0\n```\n\n### 2.4. Client\nA client allows the program to send network messages to a remote process according to the HTTP protocol. The fixed \nremote functions of the client object correspond to distinct network operations defined by the HTTP protocol.\n\nThe client init function requires a valid URL and optional configuration to initialize the client. \n```ballerina\nhttp:Client clientEP = check new (\"http://localhost:9090\", { httpVersion: \"2.0\" });\n```\n\n#### 2.4.1 Client types\nThe client configuration can be used to enhance the client behaviour.\n\n```ballerina\npublic type ClientConfiguration record {|\n    string httpVersion = HTTP_1_1;\n    ClientHttp1Settings http1Settings = {};\n    ClientHttp2Settings http2Settings = {};\n    decimal timeout = 60;\n    string forwarded = \"disable\";\n    FollowRedirects? followRedirects = ();\n    PoolConfiguration? poolConfig = ();\n    CacheConfig cache = {};\n    Compression compression = COMPRESSION_AUTO;\n    ClientAuthConfig? auth = ();\n    CircuitBreakerConfig? circuitBreaker = ();\n    RetryConfig? retryConfig = ();\n    CookieConfig? cookieConfig = ();\n    ResponseLimitConfigs responseLimits = {};\n    ClientSecureSocket? secureSocket = ();\n|};\n```\n\nBased on the config, the client object will be accompanied by following client behaviours. Following clients cannot be\ninstantiated calling `new`, instead user have to enable the config in the `ClientConfiguration`.\n\n##### 2.4.1.1 Security \nProvides secure HTTP remote functions for interacting with HTTP endpoints. This will make use of the authentication\nschemes configured in the HTTP client endpoint to secure the HTTP requests.\n```ballerina\nhttp:Client clientEP = check new(\"https://localhost:9090\",\n    auth = {\n        username: username,\n        password: password\n    },\n    secureSocket = {\n        cert: {\n            path: TRUSTSTORE_PATH,\n            password: \"ballerina\"\n        }\n    }\n);\n```\n\n##### 2.4.1.2 Caching\nAn HTTP caching client uses the HTTP caching layer once `cache` config is enabled.\n```ballerina\nhttp:Client clientEP = check new(\"http://localhost:9090\",\n    cache = {\n        enabled: true, \n        isShared: true \n    }\n);\n```\n\n##### 2.4.1.3 Redirect\nProvide the redirection support for outbound requests internally considering the location header when `followRedirects`\nconfigs are defined.\n```ballerina\nhttp:Client clientEP = check new(\"http://localhost:9090\", \n    followRedirects = { \n        enabled: true, \n        maxCount: 3 \n    }\n);\n```\n\n##### 2.4.1.4 Retry\nProvides the retrying over HTTP requests when `retryConfig` is defined.\n```ballerina\nhttp:Client clientEP = check new(\"http://localhost:9090\",\n    retryConfig = {\n        interval: 3,\n        count: 3,\n        backOffFactor: 0.5\n    }\n);\n```\n\n##### 2.4.1.5 Circuit breaker\nA Circuit Breaker implementation which can be used to gracefully handle network failures.\n```ballerina\nhttp:Client clientEP = check new(\"http://localhost:9090\", \n    circuitBreaker = {\n        rollingWindow: {\n            timeWindow: 60,\n            bucketSize: 20,\n            requestVolumeThreshold: 0\n        },\n        failureThreshold: 0.3,\n        resetTime: 2,\n        statusCodes: [500, 501, 502, 503]\n    }\n);\n```\n\n##### 2.4.1.6 Cookie\nProvides the cookie functionality across HTTP client actions. The support functions defined in the request can be \nused to manipulate cookies.\n```ballerina\nhttp:Client clientEP = check new(\"http://localhost:9090\", \n    cookieConfig = { \n        enabled: true, \n        persistentCookieHandler: myPersistentStore \n    }\n);\n```\n\nFollowing clients can be created separately as it requires different configurations.\n\n##### 2.4.1.7 Load balance\nLoadBalanceClient endpoint provides load balancing functionality over multiple HTTP clients. It uses the\nLoadBalanceClientConfiguration. \n```ballerina\npublic type LoadBalanceClientConfiguration record {|\n    *CommonClientConfiguration;\n    TargetService[] targets = [];\n    LoadBalancerRule? lbRule = ();\n    boolean failover = true;\n|};\n\nhttp:LoadBalanceClient clientEP = check new(\n    targets = [\n        { url: \"http://localhost:8093/LBMock1\" },\n        { url: \"http://localhost:8093/LBMock2\" },\n        { url: \"http://localhost:8093/LBMock3\" }\n    ],\n    timeout = 5\n);\n```\n\n##### 2.4.1.8 Failover\nAn HTTP client endpoint which provides failover support over multiple HTTP clients. It uses the\nFailoverClientConfiguration.\n```ballerina\npublic type FailoverClientConfiguration record {|\n    *CommonClientConfiguration;\n    TargetService[] targets = [];\n    int[] failoverCodes = [501, 502, 503, 504];\n    decimal interval = 0;\n|};\n\nhttp:FailoverClient foBackendEP00 = check new(\n    timeout = 5,\n    failoverCodes = [501, 502, 503],\n    interval = 5,\n    targets = [\n        { url: \"http://localhost:3467/inavalidEP\" },\n        { url: \"http://localhost:8080/echo00\" },\n        { url: \"http://localhost:8080/mockResource\" },\n        { url: \"http://localhost:8080/mockResource\" }\n    ]\n)\n```\n##### 2.4.2. Client action\n\nThe HTTP client contains separate remote function representing each HTTP method such as `get`, `put`, `post`,\n`delete`,`patch`,`head`,`options` and some custom remote functions.\n\n###### 2.4.2.1 Entity body methods\n \nPOST, PUT, DELETE, PATCH methods are considered as entity body methods. These remote functions contains RequestMessage\nas the second parameter to send out the Request or Payload. \n\n```ballerina\npublic type RequestMessage Request|string|xml|json|byte[]|int|float|decimal|boolean|map<json>|table<map<json>>|\n                           (map<json>|table<map<json>>)[]|mime:Entity[]|stream<byte[], io:Error?>|();\n```\n\nBased on the payload types respective header value is added as the `Content-type` of the `http:Request`.\n\n| Type                                                                  | Content Type             |\n|-----------------------------------------------------------------------|--------------------------|\n| ()                                                                    | -                        |\n| string                                                                | text/plain               |\n| xml                                                                   | application/xml          |\n| byte[], stream<byte[], io:Error?>                                     | application/octet-stream |\n| int, float, decimal, boolean                                          | application/json         |\n| map\\<json\\>, table<map\\<json\\>>, map\\<json\\>[], table<map\\<json\\>>)[] | application/json         |\n\nThe header map and the mediaType param are optional for entity body remote functions.\n\n```ballerina\n# The post() function can be used to send HTTP POST requests to HTTP endpoints.\nremote isolated function post(string path, RequestMessage message, map<string|string[]>? headers = (),\n        string? mediaType = (), TargetType targetType = <>)\n        returns targetType|ClientError;\n\n# The put() function can be used to send HTTP PUT requests to HTTP endpoints.\nremote isolated function put(string path, RequestMessage message, map<string|string[]>? headers = (),\n        string? mediaType = (), TargetType targetType = <>)\n        returns targetType|ClientError;\n\n# The patch() function can be used to send HTTP PATCH requests to HTTP endpoints.\nremote isolated function patch(string path, RequestMessage message, map<string|string[]>? headers = (),\n        string? mediaType = (), TargetType targetType = <>)\n        returns targetType|ClientError;\n\n# The delete() function can be used to send HTTP DELETE requests to HTTP endpoints.\nremote isolated function delete(string path, RequestMessage message = (), map<string|string[]>? headers = (),\n        string? mediaType = (), TargetType targetType = <>)\n        returns targetType|ClientError;\n```\n\n```ballerina\nhttp:Client httpClient = check new (\"https://www.example.com\");\nstring response = check httpClient->post(\"/some/endpoint\",\n   {\n       name: \"foo\",\n       age: 25,\n       address: \"area 51\"\n   },\n   headers = {\n       \"my-header\": \"my-header-value\"\n   }\n   mediaType = \"application/json\",\n);\n```\n\n###### 2.4.2.2 Non Entity body methods\n\nGET, HEAD, OPTIONS methods are considered as non entity body methods. These remote functions do not contain \nRequestMessage, but the header map an optional param.\n\n\n```ballerina\n# The head() function can be used to send HTTP HEAD requests to HTTP endpoints.\nremote isolated function head(string path, map<string|string[]>? headers = ()) returns Response|ClientError;\n\n# The get() function can be used to send HTTP GET requests to HTTP endpoints.\nremote isolated function get( string path, map<string|string[]>? headers = (), TargetType targetType = <>)\n        returns  targetType|ClientError;\n\n# The options() function can be used to send HTTP OPTIONS requests to HTTP endpoints.\nremote isolated function options( string path, map<string|string[]>? headers = (), TargetType targetType = <>)\n        returns  targetType|ClientError;\n```\n\n````ballerina\nhttp:Client httpClient = check new (\"https://www.example.com\");\nmap<string|string[]> headers = {\n   \"my-header\": \"my-header-value\",\n   \"header-2\": [\"foo\", \"bar\"]\n};\nstring resp = check httpClient->get(\"/data\", headers);\n````\n\n###### 2.4.2.3 Resource methods\n\nIn addition to the above remote method actions, HTTP client supports executing standard HTTP methods through resource \nmethods. The following are the definitions of those resource methods :\n\n```ballerina\n# The post resource function can be used to send HTTP POST requests to HTTP endpoints.\nresource function post [string ...path](RequestMessage message, map<string|string[]>? headers = (), string? mediaType = (),\n            TargetType targetType = <>, *QueryParams params) returns targetType|ClientError;\n\n# The put resource function can be used to send HTTP PUT requests to HTTP endpoints.            \nresource function put [string ...path](RequestMessage message, map<string|string[]>? headers = (), string? mediaType = (),\n            TargetType targetType = <>, *QueryParams params) returns targetType|ClientError;\n\n# The patch resource function can be used to send HTTP PATCH requests to HTTP endpoints.              \nresource function patch [string ...path](RequestMessage message, map<string|string[]>? headers = (), string? mediaType = (),\n            TargetType targetType = <>, *QueryParams params) returns targetType|ClientError;\n\n# The delete resource function can be used to send HTTP DELETE requests to HTTP endpoints.              \nresource function delete [string ...path](RequestMessage message = (), map<string|string[]>? headers = (), string? mediaType = (),\n            TargetType targetType = <>, *QueryParams params) returns targetType|ClientError;\n\n# The head resource function can be used to send HTTP HEAD requests to HTTP endpoints.              \nresource function head [string ...path](map<string|string[]>? headers = (), *QueryParams params)\n            returns Response|ClientError; \n\n# The get resource function can be used to send HTTP GET requests to HTTP endpoints.              \nresource function get [string ...path](map<string|string[]>? headers = (), TargetType targetType = <>,\n            *QueryParams params) returns targetType|ClientError;\n\n# The options resource function can be used to send HTTP OPTIONS requests to HTTP endpoints.              \nresource function options [string ...path](map<string|string[]>? headers = (), TargetType targetType = <>,\n            *QueryParams params) returns targetType|ClientError;                                               \n```\n\nThe query parameter is passed as field-value pair in the resource method call. The following are examples of such \nresource method calls :\n\n```ballerina\n// Making a GET request\nhttp:Client httpClient = check new (\"https://www.example.com\");\nmap<string|string[]> headers = {\n   \"my-header\": \"my-header-value\",\n   \"header-2\": [\"foo\", \"bar\"]\n};\nstring resp = check httpClient->/date.get(headers, id = 123);\n// Same as the following :\n// string response = check httpClient->get(\"/date?id&123\", headers);\n```\n\n```ballerina\n// Making a POST request\nhttp:Client httpClient = check new (\"https://www.example.com\");\njson payload = {\n   name: \"foo\",\n   age: 25,\n   address: \"area 51\"\n};\nmap<string> headers = { \"my-header\": \"my-header-value\" };\nstring response = check httpClient->/some/endpoint(payload, headers, \"application/json\", name = \"foo\", id = 123);\n// Same as the following :\n// string response = check httpClient->post(\"/some/endpoint?name=foo&id=123\", payload, headers, \"application/json\");\n```\n\n###### 2.4.2.4 Forward/Execute methods\n\nIn addition to the standard HTTP methods, `forward` function can be used to proxy an inbound request using the incoming \nHTTP request method. Also `execute` remote function is useful to send request with custom HTTP verbs such as `move`, \n`copy`, ..etc.\n\n\n```ballerina\n# Invokes an HTTP call with the specified HTTP verb.\nremote isolated function execute(string httpVerb,  string path, RequestMessage message, \n        map<string|string[]>? headers = (), string? mediaType = (), TargetType targetType = <>)\n        returns targetType|ClientError;\n\n# The forward() function can be used to invoke an HTTP call with inbound request's HTTP verb\nremote isolated function forward(string path, Request request, TargetType targetType = <>)\n        returns  targetType|ClientError;\n```\n\n###### 2.4.2.5 HTTP2 additional methods\nFollowing are the HTTP2 client related additional remote functions to deal with promises and responses.\n\n```ballerina\n\n# Submits an HTTP request to a service with the specified HTTP verb.\n# The submit() function does not give out a http:Response as the result.\n# Rather it returns an http:HttpFuture which can be used to do further interactions with the endpoint.\nremote isolated function submit(string httpVerb, string path, RequestMessage message)\n    returns HttpFuture|ClientError;\n\n# Passes the request to actual network call.\nremote isolated function getResponse(HttpFuture httpFuture) returns Response|ClientError;\n\n# Passes the request to actual network call.\nremote isolated function hasPromise(HttpFuture httpFuture) returns boolean;\n\n# Passes the request to actual network call.\nremote isolated function getNextPromise(HttpFuture httpFuture) returns PushPromise|ClientError;\n\n# Passes the request to an actual network call.\nremote isolated function getPromisedResponse(PushPromise promise) returns Response|ClientError;\n\n# Passes the request to actual network call.\nremote isolated function rejectPromise(PushPromise promise);\n```\n\n##### 2.4.3. Client action return types\n\nThe HTTP client remote function supports the contextually expected return types. The client operation is able to \ninfer the expected payload type from the LHS variable type. This is called as client payload binding support where the \ninbound response payload is accessed and parse to the expected type in the method signature. It is easy to access the\npayload directly rather manipulation `http:Response` using its support methods such as `getTextPayload()`, ..etc.\n\nClient data binding supports `anydata` where the payload is deserialized based on the media type before binding it \nto the required type. Similar to the service data binding following table explains the compatible `anydata` types with \neach common media type. In the absence of a standard media type, the binding type is inferred by the payload parameter \ntype itself. If the type is not compatible with the media type, error is returned.\n\n|Ballerina Type | Structure|\"text\" | \"xml\" | \"json\" | \"x-www-form-urlencoded\" | \"octet-stream\"|\n|---------------|----------|-------|-------|--------|-------------------------|---------------|\n|boolean| | ❌ | ❌ | ✅|❌|❌\n| |boolean[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<boolean\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<boolean\\>\\>| ❌ | ❌ | ✅|❌|❌\n|int| | ❌ | ❌ | ✅|❌|❌\n| |int[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<int\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<int\\>\\>| ❌ | ❌ | ✅|❌|❌\nfloat| | ❌ | ❌ | ✅|❌|❌\n| |float[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<float\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<float\\>\\>| ❌ | ❌ | ✅|❌|❌\ndecimal| | ❌ | ❌ | ✅|❌|❌\n| |decimal[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<decimal\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<decimal\\>\\>| ❌ | ❌ | ✅|❌|❌\nbyte[]| | ✅ | ❌ | ✅|❌|✅\n| |byte[][]| ❌ | ❌ | ✅|❌|❌\n| |map\\<byte[]\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<byte[]\\>\\>| ❌ | ❌ | ✅|❌|❌\nstring| |✅|❌|✅|✅|❌\n| |string[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<string\\>| ❌ | ❌ | ✅|✅|❌\n| |table\\<map\\<string\\>\\>| ❌ | ❌ | ✅|❌|❌\nxml| | ❌ | ✅ | ❌|❌|❌\njson| | ❌ | ❌ | ✅|❌|❌\n| |json[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<json\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<json\\>\\>| ❌ | ❌ | ✅|❌|❌\nmap| | ❌ | ❌ | ✅|❌|❌\n| |map[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<map\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<map\\<map\\>\\>| ❌ | ❌ | ✅|❌|❌\nrecord| |❌|❌|✅|❌|❌\n| |record[]| ❌ | ❌ | ✅|❌|❌\n| |map\\<record\\>| ❌ | ❌ | ✅|❌|❌\n| |table\\<record\\>| ❌ | ❌ | ✅|❌|❌\n\n\n```ballerina\nhttp:Client httpClient = check new (\"https://person.free.beeceptor.com\");\njson payload = check httpClient->get(\"/data\");\n```\nIn case of using var as return type, user can pass the typedesc to the targetType argument.\n\n```ballerina\nhttp:Client httpClient = check new (\"https://person.free.beeceptor.com\");\nvar payload = check httpClient->get(\"/data\", targetType = json);\n```\n\nIf any of the type is union with `()`(i.e `string?`), then in the absence of the payload, `()` will be assigned as\nthe value without being responded by a `BAD REQUEST` response.\n\n```ballerina\nstring? payload = check httpClient->get(\"/data\");\n```\n\nWhen the user expects client data binding to happen, the HTTP error responses (4XX, 5XX) will be categorized as an \nerror (http:ClientRequestError, http:RemoteServerError) of the client remote operation. These error types contain \npayload, headers and status code inside the error detail.\n\n```ballerina\npublic type Detail record {\n    int statusCode;\n    map<string[]> headers;\n    anydata body;\n};\n```\nThe error detail is useful when user wants to dig deeper to understand the backend failure. Here the error message \nis the response phrase.\n\n```ballerina\njson|error result = httpClient->post(\"/backend/5XX\", \"payload\");\nif (result is http:RemoteServerError) {\n    int statusCode = result.detail().statusCode;\n    anydata payload = result.detail().body;\n    map<string[]> headers = result.detail().headers;\n}\n```\n\nAdditionally, the client action return type can be a union of `anydata`. Based on the media type, the potential binding\ntype is decided. For example, if the union is defined as `json|xml` and the media type is related to `json`,\nthe deserialization and the binding will proceed according to the type `json`. But if the media type is related to `xml`\nthe process will happen according to the type `xml`.\nIf the given types of the union are not compatible with the media type, an error is returned.\n\n```ballerina\njson|xml payload = check httpClient->get(\"/data\");\n```\n\nIf the type is union with `()`(i.e `string?`), then in the absence of the payload, `()` will be assigned as\nthe value without being responded by a `BAD REQUEST` response.\n\n## 3. Request routing\nBallerina dispatching logic is implemented to uniquely identify a resource based on the request URI and Method.\n\n### 3.1. URI and HTTP method match\n\nThe ballerina dispatcher considers the absolute-resource-path of the service as the base path and the resource \nfunction name as the path of the resource function for the URI path match.\nBallerina dispatching logic depends on the HTTP method of the request in addition to the URI. Therefore, matching only \nthe request path will not be sufficient. Once the dispatcher finds a resource, it checks for the method compatibility \nas well. The accessor name of the resource describes the HTTP method where the name of the remote function implicitly \ndescribes its respective method\n\n### 3.2. Most specific path match\nWhen discovering the resource, the complete path will be considered when figuring out the best match. Perhaps a \npart of the request URI can be matched, yet they won’t be picked unless the longest is matched.\n\n### 3.3. Wild card path match\nThe resource path can contain a template within the bracket along with the type which represents the wild card. \ni.e `[string… s]`.That is some special way to say that if nothing matched, then the wildcard should be invoked. \nWhen the best resource match does not exist, a resource with a wild card path can be stated in the API design to \nget requests dispatched without any failure.  \n\n### 3.4. Path parameter template match\nPathParam is a parameter which allows you to map variable URI path segments into your resource call. Only the \nresource functions allow this functionality where the resource name can have path templates as a path segment with \nvariable type and the identifier within curly braces.\n```ballerina\nresource function /foo/[string bar]() {\n    \n}\n```\nThe value of the variable is extracted from the URI and assigned to the resource name parameter during the run-time \nexecution.\n\n## 4. Annotations\n   \n### 4.1. Service configuration\nThe configurations stated in the http:ServiceConfig  changes the behavior of particular services and applies it to \nall the resources mentioned in the particular services. Some configurations such as Auth, CORS can be overridden by \nresource level configurations. Yet, the service config is useful to cover service level configs.\n\n```ballerina\n# ServiceConfig definition\npublic type HttpServiceConfig record {|\n    string host = \"b7a.default\";\n    CompressionConfig compression = {};\n    Chunking chunking = CHUNKING_AUTO;\n    CorsConfig cors = {};\n    ListenerAuthConfig[] auth?;\n    string mediaTypeSubtypePrefix?;\n    boolean treatNilableAsOptional = true;\n    Interceptor[] interceptors?;\n    byte[] openApiDefinition = [];\n|};\n\n@http:ServiceConfig {\n    chunking: http:CHUNKING_ALWAYS\n}\nservice on testListener {\n    \n}\n```\n\nThe `openApiDefinition` field in http:ServiceConfig annotation serves a unique purpose. It will be automatically \npopulated at compile-time with OpenAPI definition of the particular http:Service if the OpenAPI definition auto \ngeneration is available.\n\n### 4.2. Resource configuration\nThe resource configuration responsible for shaping the resource function. Most of the behaviours are provided from \nthe language itself such as path, HTTP verb as a part of resource function. Some other configs such as CORS, \ncompression, auth are defined in the resource config.\n\n```ballerina\n# ResourceConfig definition\npublic type HttpResourceConfig record {|\n    string name?;\n    string[] consumes = [];\n    string[] produces = [];\n    CorsConfig cors = {};\n    boolean transactionInfectable = true;\n    ListenerAuthConfig[]|Scopes auth?;\n    LinkedTo[] linkedTo?;\n|};\n\n@http:ResourceConfig {\n    produces: [\"application/json\"]\n}\nresource function post test() {\n\n}\n```\n\n### 4.3. Payload annotation\nThe payload annotation has two usages. It is used to decorate the resource function payload parameter and to decorate \nthe resource return type. \n\n```ballerina\npublic type Payload record {|\n    string|string[] mediaType?;\n|}\n```\n\n#### 4.3.1. Payload binding parameter\n\nThe request payload binding is supported in resource functions where users can access it through a resource function \nparameter. The @http:Payload annotation is specially introduced to distinguish the request payload with other \nresource function parameters. The annotation can be used to specify values such as mediaType...etc. Users can \ndefine the potential request payload content type as the mediaType to perform some pre-validations as same as \nConsumes resource config field.\n\n```ballerina\nresource function post hello(@http:Payload {mediaType:[\"application/json\", \"application/ld+json\"]} json payload)  {\n    \n}\n```\n\nDuring the runtime, the request content-type header is matched against the mediaType field value to validate. If the \nvalidation fails, the listener returns an error response with the status code of 415 Unsupported Media Type. \nOtherwise the dispatching moves forward. \n\n#### 4.3.2. Anydata return value info\n\nThe same annotation can be used to specify the MIME type return value when a particular resource function returns \none of the anydata typed values. In this way users can override the default MIME type which the service type has \ndefined based on the requirement. Users can define the potential response payload content type as the mediaType \nto perform some pre-runtime validations in addition to the compile-time validations as same as produces resource \nconfig field.\n\n```ballerina\nresource function post hello() returns @http:Payload{mediaType:\"application/xml\"} xml? {\n    \n}\n```\n\nDuring the runtime, the request accept header is matched against the mediaType field value to validate. If the \nvalidation fails, the listener returns an error response with the status code of 406 Not Acceptable. Otherwise, the \ndispatching moves forward.\n\nThe annotation is not mandatory, so if the media type info is not defined, the following table describes the default \nMIME types assigned to each anydata type.\n\n| Declared return type                                                            | MIME type                |\n|---------------------------------------------------------------------------------|--------------------------|\n| ()                                                                              | (no body)                |\n| xml                                                                             | application/xml          |\n| string                                                                          | text/plain               |\n| byte[]                                                                          | application/octet-stream |\n| map\\<json\\>, table\\<map\\<json\\>\\>, (map\\<json\\> &#124; table\\<map\\<json\\>\\>)[]) | application/json         |\n| int, float, decimal, boolean                                                    | application/json         |\n\nIf anything comes other than above return types will be default to `application/json`.\n\n### 4.4. CallerInfo annotation\n\nThe CallerInfo annotation associated with the `Caller` is to denote the response type.\nIt will ensure that the resource function responds with the right type and provides static type information about\nthe response type that can be used to generate OpenAPI.\n\n```ballerina\nresource function post foo(@http:CallerInfo { respondType: http:Accepted } http:Caller hc) returns error?{\n    Person p = {};\n    hc->respond(Person p);\n}\n```\n\n### 4.5. Header annotation\n\n```ballerina\n\nresource function post hello(@http:Header {name:\"Referer\"} string referer) {\n\n}\n```\n### 4.6. Cache annotation\n\nThis annotation can be used to enable response caching from the resource signature. This allows to set the \n`cache-control`, `etag` and `last-modified` headers in the response.\n\nThe default behavior (`@http:Cache`) is to have `must-revalidate,public,max-age=3600` directives in \n`cache-control` header. In addition to that `etag` and `last-modified` headers will be added.\n\n```ballerina\n@http:Cache {                 // Default Configuration\n    mustRevalidate : true,    // Sets the must-revalidate directive\n    noCache : false,          // Sets the no-cache directive\n    noStore : false,          // Sets the no-store directive \n    noTransform : false,      // Sets the no-transform directive\n    isPrivate : false,        // Sets the private and public directive\n    proxyRevalidate : false,  // Sets the proxy-revalidate directive\n    maxAge : 3600,             // Sets the max-age directive. Default value is 3600 seconds\n    sMaxAge : -1,             // Sets the s-maxage directive\n    noCacheFields : [],       // Optional fields for no-cache directive\n    privateFields : [],       // Optional fields for private directive\n    setETag : true,           // Sets the etag header\n    setLastModified : true    // Sets the last-modified header\n}\n```\nThis annotation can **only** support return types of `anydata` and `SuccessStatusCodeResponse`. (For other return \nvalues cache configuration will not be added through this annotation)\n\n```ballerina\n// Sets the cache-control header as \"public,must-revalidate,max-age=5\". Also sets the etag header.\n// last-modified header will not be set\nresource function get cachingBackEnd(http:Request req) returns @http:Cache{maxAge : 5, \n    setLastModified : false} string {\n\n    return \"Hello, World!!\"\n}\n```\n\n## 5. URL parameters\n### 5.1. Path\nPath params are specified in the resource name itself. Path params can be specified in the types of string, int, \nboolean, decimal and float. During the request runtime the respective path segment is matched and cast into param \ntype. Users can access it within the resource function, and it is very useful when designing APIs with dynamically \nchanging path segments.\n\n### 5.2. Query\nQuery params can be accessed via the resource signature without an annotation or accessed via request functions.\n\n```ballerina\n# Gets the query parameters of the request as a map consisting of a string array.\npublic isolated function getQueryParams() returns map<string[]> {\n    \n}\n\n# Gets the query param value associated with the given key.\npublic isolated function getQueryParamValue(string key) returns string? {\n\n}\n\n# Gets all the query param values associated with the given key.\npublic isolated function getQueryParamValues(string key) returns string[]? {\n\n}\n```\n### 5.3. Matrix\nThe matrix params are one of the URL param which is supported access in ballerina using a function which bound to \nthe request\n\n```ballerina\n# Gets the matrix parameters of the request.\npublic isolated function getMatrixParams(string path) returns map<any> {\n    \n}\n```\n\n## 6. Request and Response\nThe request and the response represent the message/data which travel over the network using HTTP. The request object \nmodels the inbound/outbound message with request oriented properties, headers and payload. Followings are the properties \nassociated with the `http:Request` which get populated for each request during the runtime.\n\n```ballerina\npublic class Request {\n   public string rawPath = \"\";\n   public string method = \"\";\n   public string httpVersion = \"\";\n   public string userAgent = \"\";\n   public string extraPathInfo = \"\";\n   public RequestCacheControl? cacheControl = ();\n   public MutualSslHandshake? mutualSslHandshake = ();\n}\n```\n\nThe header and the payload manipulation can be done using the functions associated to the request.\n\nSame as request, the response object also models the inbound/outbound message with the response oriented properties \nand headers. Followings are the properties associated with the `http:Response` which get populated for each response \nduring the runtime.\n\n```ballerina\npublic class Response {\n    public int statusCode = 200;\n    public string reasonPhrase = \"\";\n    public string server = \"\";\n    public string resolvedRequestedURI = \"\";\n    public ResponseCacheControl? cacheControl = ();\n}\n```\n\nThe header and the payload manipulation can be done using the functions associated to the response.\n\n## 7. Header and Payload\nThe header and payload are the main components of the request and response. In the world of MIME, that is called \nEntity header and Entity body. Ballerina supports multiple payload types and allows convenient functions to access \nheaders along with other properties.\n\n### 7.1. Parse header functions\n\n```ballerina\n# Parses the header value which contains multiple values or parameters.\nparseHeader(string headerValue) returns HeaderValue[]|ClientError  {\n\n}\n```\n\n### 7.2 Links support\nHypermedia As the Engine Of Application State (HATEOAS) is one of the key principles in REST, which brings the \nconnectedness to a set of scattered resources. It also brings direction as to what might user could do next. Similar \nto Web pages REST APIs becomes self-descriptive and dynamic along with this principle.\n\nAs an initial support to HATEOAS, HTTP package has the ability to statically record the connectedness of resources \nthrough `Links` object. `Links` is a map of `Link` objects which represent the connectedness between resources. The \n`Link` record is defines as follows :\n```ballerina\npublic type Link record {\n    # Names the relationship of the linked target to the current representation\n    string rel?;\n    # Target URL\n    string href;\n    # Expected resource representation media types\n    string[] types?;\n    # Allowed resource methods\n    Method[] methods?;\n};\n```\n\nThis `Links` is generated from the `linkedTo` field in the `ResourceConfig` annotation, and added either to the \npayload or as a `Link` header depends on the payload type.\n\n#### 7.2.1 LinkedTo record\nThe `LinkedTo` record is defined as follows :\n```ballerina\npublic type LinkedTo record {|\n    string name;\n    string relation = \"self\";\n    string method?;\n|};\n```\n\nThis record represents a connectedness between two resources. All the fields in the `LinkedTo` record is \n**case-insensitive**. The `relation` field is defaulted to the IANA link relation `self`, and for a specific resource, \nthe linked resources should have a **unique** relation.  \n\nThe linked resource is resolved using the resource link name specified in the `name` field. To \nfind the linked resource, the linked resource should be configured with the same name through `ResourceConfig` \nannotation. Following is a simple example of creating links :\n```ballerina\nservice on new http:Listener(port) {\n\n    @http:ResourceConfig {\n        // Create a link between this resource and \"Payment\" resource\n        linkedTo: [{ name: \"Payment\", rel: \"payment\" }]\n    }\n    resource function post 'order(@http:Payload Order 'order) returns \n            http:Accepted|http:InternalServerError {\n        // some logic\n    }\n    \n    @http:ResourceConfig {\n        name: \"Payment\"\n    }\n    resource function put payment/[string id](@http:Payload Payment payment) returns \n            http:Ok|http:InternalServerError {\n        // some logic\n    }\n}\n```\n\nResource link name can be duplicated only when the resources have the same path. In this case, the `method` of the \nlinked resource should be specified in the `LinkedTo` record to resolve conflicts. Following is an example when we have two \nresources with the same resource link name :\n```ballerina\nservice on new http:Listener(port) {\n\n    @http:ResourceConfig {\n        name: \"Orders\",\n        linkedTo: [\n            { name: \"Orders\", rel: \"edit\",  method: \"PUT\" },\n            { name: \"Orders\", rel: \"remove\",  method: \"DELETE\" }\n        ]\n    }\n    resource function put orders/[string id](@http:Payload Order 'order) returns \n            http:Ok|http:InternalServerError {\n        // some logic\n    }\n    \n    @http:ResourceConfig {\n        name : \"Orders\"\n    }\n    resource function delete orders/[string id]() returns http:Ok|http:InternalServerError {\n        // some logic\n    }\n}\n```\n\n#### 7.2.2 Links in the response\nThe static `Links` generated from the `linkedTo` field will be injected to the payload when the payload media-type is \nJSON, and it is not `readonly`. Suppose the user returns the below record type, the runtime will inject the `Links` \nrecord as in the latter. So the response should be considered as a record with `Links` field.\n\n```ballerina\npublic type 'Order record {|\n    string item_name;\n    string id;\n    string quantity;\n|};\n```\n\n```ballerina\npublic type 'Order record {|\n    *http:Links;\n    string item_name;\n    string id;\n    string quantity;\n|};\n```\n\nFollowing is an example of `Links` in payload :\n```ballerina\nservice on new http:Listener(port) {\n\n    @http:ResourceConfig {\n        linkedTo: [{ name: \"Payment\", rel: \"payment\" }]\n    }\n    resource function get orders/[string id]() returns Order|http:NotFound {\n        // some logic\n    }\n    \n    @http:ResourceConfig {\n        name: \"Payment\"\n    }\n    resource function put payment/[string id](@http:Payload Payment payment) returns \n            http:Ok|http:InternalServerError {\n        // some logic\n    }\n}\n```\nThe response payload to the GET resource will look like this :\n```json\n{\n   \"item_name\": \"latte\",\n   \"quantity\": 2,\n   \"_links\":{\n      \"payment\":{\n         \"rel\": \"payment\",\n         \"href\": \"/payment/{id}\",\n         \"methods\":[\"PUT\"]\n      }\n   }\n}\n```\n\nWhen there is no payload or when `Links` not supported in the payload, the `Links` will be added as a `Link` header. \nFollowing is an example of `Links` in `Link` header:\n```ballerina\nservice on new http:Listener(port) {\n\n    @http:ResourceConfig {\n        linkedTo: [{ name: \"Payment\", rel: \"payment\" }]\n    }\n    resource function post order(@http:Payload Order 'order) returns \n            http:Accepted|http:InternalServerError {\n        // some logic\n        // return http:Accepted without body\n    }\n    \n    @http:ResourceConfig {\n        name: \"Payment\"\n    }\n    resource function put payment/[string id](@http:Payload Payment payment) returns \n            http:Ok|http:InternalServerError {\n        // some logic\n    }\n}\n```\nThe response will have the following header :\n```\nlink: \"</payment/{id}>; rel=\\\"payment\\\"; methods=\\\"\\\"PUT\\\"\\\"\"\n```\n\nThe `Links` will not overwrite the payload or the header if the user has already added the links.\n\n## 8. Interceptor and error handling\n### 8.1 Interceptor\nInterceptor enhances the HTTP package with interceptors. Interceptors typically do small units of work such as logging, header \nmanipulation, state publishing, etc., before resources are invoked. The ability to execute some common logic for all \nthe inbound requests and outbound responses has proven to be highly useful. It typically includes some small unit of \nwork such as the below.\n - Logging\n - Header manipulation\n - Observability\n - Throttling\n - Validating\n - Securing\n\nInterceptors are designed for both request and response flows. There are just service objects which will be executed in\na configured order to intercept request and response. These interceptor services can only have either a resource function \nor a remote function depends on the interceptor type. Moreover, they do not support `ServiceConfig`, `ResourceConfig`\nand `Cache` annotations.\n\n#### 8.1.1 Request interceptor\nFollowing is an example of `RequestInterceptor` written in Ballerina swan-lake. `RequestInterceptor` can only have one \nresource function.\n\n```ballerina\nservice class RequestInterceptor {\n   *http:RequestInterceptor;\n \n   resource function 'default [string… path](http:RequestContext ctx, http:Request req) returns http:NextService|error? {\n       req.setHeader(\"X-requestHeader\", \"RequestInterceptor\");\n       ctx.next();\n   }\n}\n```\n\nSince interceptors work with network activities, it must be either a remote or resource function. In this case resource \nfunctions are used for `RequestInterceptor` as it gives more flexibility. With resource functions interceptors can be engaged \nbased on HTTP method and path.\n\nFor instance consider a scenario where there are two resources: one on path `foo` whereas the other on path `bar`. If the \nuser writes an interceptor as follows, it would only get hit when the request is directed to `foo` resource.\n\n```ballerina\nservice class RequestInterceptor {\n   *http:RequestInterceptor;\n \n   resource function 'default foo(http:RequestContext ctx, http:Request req) returns http:NextService|error? {\n       req.setHeader(\"X-requestHeader\", \"RequestInterceptor\");\n       ctx.next();\n   }\n}\n```\n\n##### 8.1.1.1 Request context  \nFollowing is the rough definition of the interceptor context.\n```ballerina\npublic isolated class RequestContext {\n    private final map<value:Cloneable|isolated object {}> attributes = {};\n\n    public isolated function add(string 'key, value:Cloneable|isolated object {} value) {\n        if value is value:Cloneable {\n            lock {\n                self.attributes['key] = value.clone();\n            }\n        }\n        else {\n            lock {\n                self.attributes['key] = value;\n            }   \n        }\n    }\n\n    public isolated function get(string 'key) returns value:Cloneable|isolated object {} {\n        lock {\n            return self.attributes.get('key);\n        }\n    }\n\n    public isolated function remove(string 'key) {\n        lock {\n            value:Cloneable|isolated object {} _ = self.attributes.remove('key);\n        }\n    }\n\n    public isolated function next() returns NextService|error? = external;\n}\n```\n\n##### 8.1.1.2 next() method  \nHowever, there is an addition when it comes to `RequestContext`. A new method namely, `next()` is introduced to control \nthe execution flow. Users must invoke `next()` method in order to trigger the next interceptor in the pipeline. Then \nthe reference of the retrieved interceptor must be returned from the resource function. Pipeline use this reference to\nexecute the next interceptor. \n\nPreviously, this was controlled by returning a boolean value which is quite cryptic and confusing.\n\n##### 8.1.1.3 Return to respond\nThere is a key difference between interceptors and the final service. Resources in the final service allow returning \nvalues which in turn results in HTTP responses. The same can be done inside the `RequestInterceptors`. However, as \nmentioned above `RequestInterceptor` additionally could return the `NextService|error?` to continue the pipeline which\ndoes not translate into HTTP response. \n\nWhen a `RequestInterceptor` responded with a response, the response interceptor pipeline will get executed immediately.\nIn case of an error, interceptor pipeline execution jumps to the nearest `RequestErrorInterceptor` or \n`ResponseErrorInterceptor` in the pipeline. These error interceptors are special kinds of interceptor which could be \nused to handle errors, and they are not necessarily the last interceptor in the pipeline, they can be anywhere in the \nchain. However, in the case of there is no error interceptors in the pipeline, pipeline returns the internal error \nresponse to the client similar to any HTTP service resource.\n\n#### 8.1.2 Response interceptor\n\nFollowing is an example of `ResponseInterceptor` written in Ballerina swan-lake. `ResponseInterceptor` can only have one\nremote function : `interceptResponse()`.\n\n```ballerina\nservice class ResponseInterceptor {\n   *http:ResponseInterceptor;\n \n   remote function interceptResponse(http:RequestContext ctx, http:Response res) returns http:NextService|error? {\n       res.setHeader(\"X-responseHeader\", \"ResponseInterceptor\");\n       ctx.next();\n   }\n}\n```\n\n`ResponseInterceptor` is different from `RequestInterceptor`. Since it has nothing to do with HTTP methods and paths, \nremote function is used instead of resource function.\n\n##### 8.1.2.1 Return to respond\nThe remote function : `interceptResposne()` allows returning values other than `NextService|error?`. Anyway this will\ncontinue the response interceptor pipeline with the returned response object and calling `RequestContext.next()` is\nredundant in this case.\n\nIn case of an error, interceptor pipeline execution jumps to the nearest `ResponseErrorInterceptor` in the \npipeline. . However, in the case of there is no `ResponseInterceptor` in the pipeline, pipeline returns the internal \nerror response to the client.\n\n#### 8.1.3 Request error interceptor and response error interceptor \nAs mentioned above, these are special kinds of interceptor designed to handle errors. These interceptors can  \nbe placed anywhere in the request or response interceptor chain. The framework automatically adds default \n`RequestErrorInterceptor` and `ResponseErrorInterceptor` which basically prints the error message to the console.\n\nUsers can override these interceptors by defining their own ones as follows. Users don’t have to specifically engage \nthese interceptors as they only have fixed positions and they are always executed. The only additional and mandatory \nargument in this case is error `err`. Moreover, the `RequestErrorInterceptor` resource function can only have\nthe `default` method and default path.\n\n```ballerina\nservice class RequestErrorInterceptor {\n   *http:RequestErrorInterceptor;\n \n   remote function 'default [string… path](http:RequestContext ctx, http:Caller caller,\n                       http:Request req, error err) returns http:NextService|error? {\n       // deal with the error\n   }\n}\n```\n\nThe same works for `ResponseErrorInterceptor`, the difference is it has a remote function : `interceptResponseError()`\nand deals with response object.\n\n```ballerina\nservice class ResponseErrorInterceptor {\n   *http:ResponseErrorInterceptor;\n \n   remote function interceptResponseError(http:RequestContext ctx, http:Response res, error err) \n                       returns http:NextService|error? {\n       // deal with the error\n   }\n}\n```\n\nIn the case of an error returned within an error interceptor, again execution jumps to the nearest error interceptor. \nHowever, if there is no error interceptor to jump to, the internal error response is returned just like in a normal \ninterceptors.\n\n#### 8.1.4 Engaging interceptors\n##### 8.1.4.1 Service level\nInterceptors could get engaged at service level. One reason for this is that users may want to engage two different \ninterceptor chains for each service even though it is attached to the same Listener. At the service level resource \nfunction paths are relative to the service base path.\n```ballerina\n@http:ServiceConfig{\n   interceptors: [requestInterceptor, responseInterceptor]\n}\n```\n\n##### 8.1.4.2 Listener level\nInterceptors could get engaged at Listener level as well. Interceptors engaged at listener level should have resource \nfunction only with default path i.e. these interceptors will get executed for all the services registered on this \nlistener.\n```ballerina\nlistener http:Listener echoListener = new http:Listener(9090, config = {interceptors: [requestInterceptor, responseInterceptor]});\n```\n\n##### 8.1.4.3 Execution order of interceptors\n\n![img.png](_resources/img.png)\nIn the above example blue dashed box represents the `RequestErrorInterceptor` and blue boxes simply represent the \n`RequestInterceptors`, whereas green dashed box represents the `ResponseErrorInterceptor` and green boxes simply represent the \n`ResponseInterceptors`. \n\n`ResponseInterceptors` are executed in the opposite direction of `RequestInterceptors` i.e. `RequestInterceptors`\nare executed head to tail whereas `ResponseInterceptors` are executed tail to head. The new execution order is as follows, \nassuming that there are no error occurred in the pipeline :\n```\nRequestInterceptor  : 1, 2, 4\nResponseInterceptor : 5, 3\n```\n\nHowever, if the user decides to respond at 4 and terminate the cycle, only the `ResponseInterceptor` at 3 gets executed.\nAlso, when the `RequestInterceptor` at 2 returns an error, the execution jumps from 2 to 6 as the nearest Error Interceptor\nis at 6. The same goes to the response path.\n\nThe execution order when interceptors are engaged at both service and listener levels is as follows:\n\n```\nListenerLevel : RequestInterceptors -> ServiceLevel : RequestInterceptors -> TargetService -> \nServiceLevel : ResponseInterceptors -> ListenerLevel : ResponseInterceptors\n```\n\nExecution of interceptors does not depend on the existence of the end service i.e. the interceptors are executed in the\nrelevant order even though the end service does not exist.\n\n#### 8.1.5 Data binding\n`RequestInterceptor` methods support data binding. Which means users can directly access the payload, headers and query\nparameters. In order to get hold of the headers and the payload, users must use @http:Payload and @http:Headers.\n\n### 8.2 Error handling\n\n#### 8.2.1 Error interceptors\n\nError handling is an integral part of any network program. Errors can be returned by many components such as interceptors,\ndispatcher, data-binder, security handlers, etc. These errors are often handled by a default handler and sent back as \n`500 Internal Server Error` with an entity-body. However, this often causes problems because when designing any API \nconsistency matters. Therefore, all the responses must have a consistent format. \n\nAs a result, almost all the real API requires overriding the default error handler and replacing it with their own\nerror handlers. This can be done by error interceptors discussed in [Request error interceptor and response error \ninterceptor](#813-request-error-interceptor-and-response-error-interceptor). These error handlers can be placed \nanywhere in the pipeline. The only mandatory argument in error interceptors is `error`. Just like a main service, it \nis possible to return values from error handlers which will send back as HTTP responses. This overrides the current response\nand results in triggering the next response interceptor. Following is such an example :\n```ballerina\nservice class ResponseErrorInterceptor {\n   *http:ResponseErrorInterceptor;\n \n   remote function interceptResponseError(error err) returns http:NotFound {\n       http:NotFound nf = { body: { msg: err.message()} };\n       return nf;\n   }\n}\n```\n\nThe HTTP module also have a `DefaultErrorInterceptor` which is a `ResponseErrorInterceptor`. This will be added by \nthe listener and will be executed at last when there is an error. Hence, any error which is not handled by other \nerror interceptors will be finally handled by this default error handler. In essence, the internal default error interceptor\nwill look like this :\n```ballerina\nservice class DefaultErrorInterceptor {\n    *http:ResponseErrorInterceptor;\n\n    remote function interceptResponseError(error err) returns http:Response {\n        http:Response res = new;\n        res.setTextPayload(err.message());\n        // By default, the error response is set to 500 - Internal Server Error\n        // However, if the error is an internal error which has a different error\n        // status code (4XX or 5XX) then this 500 status code will be overwritten \n        // by the original status code.\n        res.statusCode = 500;\n        return res;\n    }\n}\n```\n\nIn order to overwrite this default error handling behavior, a custom `ResponseErrorInterceptor` can be placed as the \nfirst interceptor in the listener level configuration which will be executed at last just before the  `DefaultErrorHandler`.\n\n#### 8.2.2 Error types\n\nIn addition to error interceptors, HTTP module provides distinct error types in order to intercept errors and handle \nthem differently. These error types have a hierarchical structure starting from the basic `HttpError`. The following \ntable summarizes the error types which can be intercepted by the error interceptors:\n\n<table>\n<thead>\n  <tr>\n    <th></th>\n    <th>Error</th>\n    <th>Error Type</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td rowspan=\"5\">Executing Interceptors - Interceptor Level</td>\n    <td>500 - no next service to be returned</td>\n    <td rowspan=\"4\">InterceptorReturnError</td>\n  </tr>\n  <tr>\n    <td>500 - request context object does not contain the configured interceptors</td>\n  </tr>\n  <tr>\n    <td>500 - next interceptor service did not match with the configuration</td>\n  </tr>\n  <tr>\n    <td>500 - target service did not match with the configuration</td>\n  </tr>\n  <tr>\n    <td>Other errors occurred during the resource/remote function execution</td>\n    <td><i>Same as the returned error type</i></td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">Finding Service - Listener Level</td>\n    <td>404 - no service has registered for listener</td>\n    <td rowspan=\"3\">ServiceDispatchingError</td>\n  </tr>\n  <tr>\n    <td>404 - no matching service found for path</td>\n  </tr>\n  <tr>\n    <td>400 - Found non-matrix parameter in path</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">Finding Resource - Service Level</td>\n    <td>404 - no matching resource found for path</td>\n     <td rowspan=\"4\">ResourceDispatchingError</td>\n  </tr>\n  <tr>\n    <td>405 - Method not allowed</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">Consumes & Produces - Service Level</td>\n    <td>406 - Not Acceptable</td>\n  </tr>\n  <tr>\n    <td>415 - Unsupported Media Type</td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">Databinding - Service Level</td>\n    <td>400 - Error in casting path param</td>\n    <td>PathParameterBindingError</td>\n  </tr>\n  <tr>\n    <td>400 - no query param value found</td>\n    <td rowspan=\"2\">QueryParameterBindingError</td>\n  </tr>\n  <tr>\n    <td>400 - Error in casting query param </td>\n  </tr>\n  <tr>\n    <td>400 - no header value found</td>\n    <td rowspan=\"2\">HeaderBindingError</td>\n  </tr>\n  <tr>\n    <td>400 - header binding failed </td>\n  </tr>\n  <tr>\n    <td>400 - data binding failed</td>\n    <td>PayloadBindingError</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">Security - Resource Level</td>\n    <td>401 - Unauthorized errors</td>\n    <td>ListenerAuthnError</td>\n  </tr>\n  <tr>\n    <td>403 - Forbidden errors</td>\n    <td>ListenerAuthzError</td>\n  </tr>\n  <tr>\n    <td>Resource execution -  Resource Level</td>\n    <td>500 - Returned errors</td>\n    <td><i>Same as the returned error type</i></td>\n  </tr>\n</tbody>\n</table>\n\n#### 8.2.3 Trace log\nThe HTTP trace logs can be used to monitor the HTTP traffic that goes in and out of Ballerina.\nThe HTTP trace logs are **disabled as default**.\nTo enable trace logs, the log level has to be set to TRACE using the runtime argument:\n`-Cballerina.http.traceLogConsole=true.`\n\nThe HTTP access logs and trace logs are **disabled as default**. To enable, the configurations can be set by the \nfollowing `config.toml` file:\n\nThe configurations can be set in the `config.toml` file for advanced use cases such as specifying the file path to \nsave the trace logs and specifying the hostname and port of a socket service to publish the trace logs.\n\n```toml\n[ballerina.http.traceLogAdvancedConfig]\n# Enable printing trace logs in console\nconsole = true              # Default is false\n# Specify the file path to save the trace logs  \npath = \"testTraceLog.txt\"   # Optional\n# Specify the hostname and port of a socket service to publish the trace logs\nhost = \"localhost\"          # Optional\nport = 8080                 # Optional\n```\n#### 8.2.4 Access log\n\nBallerina supports HTTP access logs for HTTP services. The access log format used is the combined log format.\nThe HTTP access logs are **disabled as default**.\nTo enable access logs, set console=true under the ballerina.http.accessLogConfig in the Config.toml file. Also, \nthe path field can be used to specify the file path to save the access logs.\n\n```toml\n[ballerina.http.accessLogConfig]\n# Enable printing access logs in console\nconsole = true              # Default is false\n# Specify the file path to save the access logs  \npath = \"testAccessLog.txt\"  # Optional\n```\n\n## 9. Security\n\n### 9.1 Authentication and Authorization\n\nThere are two ways to enable authentication and authorization in HTTP.\n\n1. Declarative approach\n2. Imperative approach\n\n#### 9.1.1 Declarative Approach\n\nThis is also known as the configuration-driven approach, which is used for simple use cases, where users have to \nprovide a set of configurations and do not need to be worried more about how authentication and authorization works. \nThe user does not have full control over the configuration-driven approach.\n\nThe service configurations are used to define the authentication and authorization configurations. Users can \nconfigure the configurations needed for different authentication schemes and configurations needed for \nauthorizations of each authentication scheme. Also, the configurations can be provided at the service level. \nThe priority will be given from bottom to top. Then, the auth handler creation and request \nauthentication/authorization is handled internally without user intervention. The requests that succeeded both \nauthentication and/or authorization phases according to the configurations will be passed to the business logic layer.\n\n##### 9.1.1.1 Listener - Basic Auth - File User Store\n\n```ballerina\n@http:ServiceConfig {\n    auth: [\n        {\n            fileUserStoreConfig: {},\n            scopes: [\"admin\"]\n        }\n    ]\n}\nservice /foo on new http:Listener(9090) {\n    resource function get bar() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n```ballerina\n# Config.toml\n\n[[ballerina.auth.users]]\nusername=\"alice\"\npassword=\"alice@123\"\nscopes=[\"developer\"]\n\n[[ballerina.auth.users]]\nusername=\"ldclakmal\"\npassword=\"ldclakmal@123\"\nscopes=[\"developer\", \"admin\"]\n\n[[ballerina.auth.users]]\nusername=\"eve\"\npassword=\"eve@123\"\n```\n\n##### 9.1.1.2. Listener - Basic Auth - LDAP User Store\n\n```ballerina\n@http:ServiceConfig {\n    auth: [\n        {\n            ldapUserStoreConfig: {\n                domainName: \"avix.lk\",\n                connectionUrl: \"ldap://localhost:389\",\n                connectionName: \"cn=admin,dc=avix,dc=lk\",\n                connectionPassword: \"avix123\",\n                userSearchBase: \"ou=Users,dc=avix,dc=lk\",\n                userEntryObjectClass: \"inetOrgPerson\",\n                userNameAttribute: \"uid\",\n                userNameSearchFilter: \"(&(objectClass=inetOrgPerson)(uid=?))\",\n                userNameListFilter: \"(objectClass=inetOrgPerson)\",\n                groupSearchBase: [\"ou=Groups,dc=avix,dc=lk\"],\n                groupEntryObjectClass: \"groupOfNames\",\n                groupNameAttribute: \"cn\",\n                groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",\n                groupNameListFilter: \"(objectClass=groupOfNames)\",\n                membershipAttribute: \"member\",\n                userRolesCacheEnabled: true,\n                connectionPoolingEnabled: false,\n                connectionTimeout: 5,\n                readTimeout: 60\n            },\n            scopes: [\"admin\"]\n        }\n    ]\n}\nservice /foo on new http:Listener(9090) {\n    resource function get bar() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n##### 9.1.1.3 Listener - JWT Auth\n\n```ballerina\n@http:ServiceConfig {\n    auth: [\n        {\n            jwtValidatorConfig: {\n                issuer: \"wso2\",\n                audience: \"ballerina\",\n                signatureConfig: {\n                    certFile: \"/path/to/public.crt\"\n                },\n                scopeKey: \"scp\"\n            },\n            scopes: [\"admin\"]\n        }\n    ]\n}\nservice /foo on new http:Listener(9090) {\n    resource function get bar() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n##### 9.1.1.4 Listener - OAuth2\n\n```ballerina\n@http:ServiceConfig {\n    auth: [\n        {\n            oauth2IntrospectionConfig: {\n                url: \"https://localhost:9445/oauth2/introspect\",\n                tokenTypeHint: \"access_token\",\n                scopeKey: \"scp\",\n                clientConfig: {\n                    customHeaders: {\"Authorization\": \"Basic YWRtaW46YWRtaW4=\"},\n                    secureSocket: {\n                        cert: \"/path/to/public.crt\"\n                    }\n                }\n            },\n            scopes: [\"admin\"]\n        }\n    ]\n}\nservice /foo on new http:Listener(9090) {\n    resource function get bar() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n##### 9.1.1.5 Client - Basic Auth\n\n```ballerina\nhttp:Client c = check new (\"https://localhost:9090\",\n    auth = {\n        username: \"tom\",\n        password: \"123\"\n    }\n);\n\npublic function main() returns error? {\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 9.1.1.6 Client - Bearer Token Auth\n\n```ballerina\nhttp:Client c = check new (\"https://localhost:9090\",\n    auth = {\n        token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiw\" +\n               \"ibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2Q\" +\n               \"T4fwpMeJf36POk6yJV_adQssw5c\"\n    }\n);\n\npublic function main() returns error? {\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 9.1.1.7 Client - Self-Signed JWT\n\n```ballerina\nhttp:Client c = check new (\"https://localhost:9090\",\n    auth = {\n        username: \"ballerina\",\n        issuer: \"wso2\",\n        audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],\n        keyId: \"5a0b754-895f-4279-8843-b745e11a57e9\",\n        jwtId: \"JlbmMiOiJBMTI4Q0JDLUhTMjU2In\",\n        customClaims: {\"scp\": \"admin\"},\n        expTime: 3600,\n        signatureConfig: {\n            config: {\n                keyFile: \"/path/to/private.key\"\n            }\n        }\n    }\n);\n\npublic function main() returns error? {\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 9.1.1.8 Client - Bearer Token OAuth2\n\n```ballerina\nhttp:Client c = check new (\"https://localhost:9090\",\n    auth = {\n        token: \"56ede317-4511-44b4-8579-a08f094ee8c5\"\n    }\n);\n\npublic function main() returns error? {\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 9.1.1.9 Client - Grant Types OAuth2\n\n```ballerina\nhttp:OAuth2ClientCredentialsGrantConfig config = {\n    tokenUrl: \"https://localhost:8080/oauth2/token/authorize\",\n    clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxS\",\n    clientSecret: \"9205371918321623741\"\n};\n\nhttp:Client c = check new (\"https://localhost:9090\", auth = config);\n\npublic function main() returns error? {\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n#### 9.1.2 Imperative Approach\n\nThis is also known as the code-driven approach, which is used for advanced use cases, where users need to be \nworried more about how authentication and authorization work and need to have further customizations. The user has \nfull control of the code-driven approach. The handler creation and authentication/authorization calls are made by \nthe user at the business logic layer.\n\n##### 9.1.2.1 Listener - Basic Auth - File User Store\n\n```ballerina\nhttp:FileUserStoreConfig config = {};\nhttp:ListenerFileUserStoreBasicAuthHandler handler = new (config);\n\nservice /foo on new http:Listener(9090) {\n    resource function post bar(@http:Header string Authorization) returns string|http:Unauthorized|http:Forbidden {\n        auth:UserDetails|http:Unauthorized authn = handler.authenticate(Authorization);\n        if (authn is http:Unauthorized) {\n            return authn;\n        }\n        http:Forbidden? authz = handler.authorize(<auth:UserDetails>authn, \"admin\");\n        if (authz is http:Forbidden) {\n            return authz;\n        }\n        // business logic\n    }\n}\n```\n\n```ballerina\n# Config.toml\n[ballerina.observe]\nenabled=true\nprovider=\"noop\"\n\n[[auth.users]]\nusername=\"admin\"\npassword=\"123\"\nscopes=[\"write\", \"update\"]\n```\n\n##### 9.1.2.2 Listener - Basic Auth - LDAP User Store\n\n```ballerina\nhttp:LdapUserStoreConfig config = {\n    domainName: \"avix.lk\",\n    connectionUrl: \"ldap://localhost:389\",\n    connectionName: \"cn=admin,dc=avix,dc=lk\",\n    connectionPassword: \"avix123\",\n    userSearchBase: \"ou=Users,dc=avix,dc=lk\",\n    userEntryObjectClass: \"inetOrgPerson\",\n    userNameAttribute: \"uid\",\n    userNameSearchFilter: \"(&(objectClass=inetOrgPerson)(uid=?))\",\n    userNameListFilter: \"(objectClass=inetOrgPerson)\",\n    groupSearchBase: [\"ou=Groups,dc=avix,dc=lk\"],\n    groupEntryObjectClass: \"groupOfNames\",\n    groupNameAttribute: \"cn\",\n    groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",\n    groupNameListFilter: \"(objectClass=groupOfNames)\",\n    membershipAttribute: \"member\",\n    userRolesCacheEnabled: true,\n    connectionPoolingEnabled: false,\n    connectionTimeout: 5,\n    readTimeout: 60\n};\nhttp:ListenerLdapUserStoreBasicAuthHandler handler = new (config);\n\nservice /foo on new http:Listener(9090) {\n    resource function post bar(@http:Header string Authorization) returns string|http:Unauthorized|http:Forbidden {\n        auth:UserDetails|http:Unauthorized authn = handler->authenticate(Authorization);\n        if (authn is http:Unauthorized) {\n            return authn;\n        }\n        http:Forbidden? authz = handler->authorize(<auth:UserDetails>authn, \"admin\");\n        if (authz is http:Forbidden) {\n            return authz;\n        }\n        // business logic\n    }\n}\n```\n\n##### 9.1.2.3 Listener - JWT Auth\n\n```ballerina\nhttp:JwtValidatorConfig config = {\n    issuer: \"ballerina\",\n    audience: [\"wso2\"],\n    signatureConfig: {\n        jwksConfig: {\n            url: \"https://localhost:8080/jwks\"\n        }\n    }\n};\nhttp:ListenerJwtAuthHandler handler = new (config);\n\nservice /foo on new http:Listener(9090) {\n    resource function post bar(@http:Header string Authorization) returns string|http:Unauthorized|http:Forbidden {\n        jwt:Payload|http:Unauthorized authn = handler.authenticate(Authorization);\n        if (authn is http:Unauthorized) {\n            return authn;\n        }\n        http:Forbidden? authz = handler.authorize(<jwt:Payload>authn, \"admin\");\n        if (authz is http:Forbidden) {\n            return authz;\n        }\n        // business logic\n    }\n}\n```\n\n##### 9.1.2.4 Listener - OAuth2\n\n```ballerina\nhttp:OAuth2IntrospectionConfig config = {\n    url: \"https://localhost:8080/oauth2/introspect\",\n    tokenTypeHint: \"access_token\"\n};\nhttp:ListenerOAuth2Handler handler = new (config);\n\nservice /foo on new http:Listener(9090) {\n    resource function post bar(@http:Header string authorization) returns string|http:Unauthorized|http:Forbidden {\n        oauth2:IntrospectionResponse|http:Unauthorized|http:Forbidden auth = handler->authorize(authorization, \"admin\");\n        if (auth is http:Unauthorized || auth is http:Forbidden) {\n            return auth;\n        }\n        // business logic\n    }\n}\n```\n\n##### 9.1.2.5 Client - Basic Auth\n\n```ballerina\nhttp:CredentialsConfig config = {\n    username: \"tom\",\n    password: \"123\"\n};\nhttp:ClientBasicAuthHandler handler = new (config);\n\nhttp:Client c = check new (\"https://localhost:9090\");\n\npublic function main() returns error? {\n    http:Request req = new;\n    req = check handler.enrich(req);\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 9.1.2.6 Client - Bearer Token Auth\n\n```ballerina\nhttp:BearerTokenConfig config = {\n    token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFt\" +\n           \"ZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf3\" +\n           \"6POk6yJV_adQssw5c\"\n};\nhttp:ClientBearerTokenAuthHandler handler = new (config);\n\nhttp:Client c = check new (\"https://localhost:9090\");\n\npublic function main() returns error? {\n    http:Request req = new;\n    req = check handler.enrich(req);\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 9.1.2.7. Client - Self-Signed JWT\n\n```ballerina\nhttp:JwtIssuerConfig config = {\n    username: \"admin\",\n    issuer: \"ballerina\",\n    audience: [\"wso2\"],\n    signatureConfig: {\n        config: {\n            keyFile: \"/path/to/private.key\",\n            keyPassword: \"password\"\n        }\n    }\n};\nhttp:ClientSelfSignedJwtAuthHandler handler = new (config);\n\nhttp:Client c = check new (\"https://localhost:9090\");\n\npublic function main() returns error? {\n    http:Request req = new;\n    req = check handler.enrich(req);\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 9.1.2.8. Client - Bearer Token OAuth2\n\n```ballerina\nhttp:BearerTokenConfig config = {\n    token: \"JhbGciOiJIIiwiaWF0IjUzI1NiIsInR5cCI6IkpXVCJ9WIiOiIxMjM0NTY3ODkwI\"\n};\nhttp:ClientBearerTokenAuthHandler handler = new (config);\n\nhttp:Client c = check new (\"https://localhost:9090\");\n\npublic function main() returns error? {\n    http:Request req = new;\n    req = check handler.enrich(req);\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n##### 9.1.2.9. Client - Grant Types OAuth2\n\n```ballerina\nhttp:OAuth2ClientCredentialsGrantConfig config = {\n    tokenUrl: \"https://localhost:8080/oauth2/token/authorize\",\n    clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxS\",\n    clientSecret: \"9205371918321623741\"\n};\nhttp:ClientOAuth2Handler handler = new (config);\n\nhttp:Client c = check new (\"https://localhost:9090\");\n\npublic function main() returns error? {\n    http:Request req = new;\n    req = check handler->enrich(req);\n    json response = check c->get(\"/foo/bar\");\n    // evaluate response\n}\n```\n\n### 9.2 SSL/TLS and Mutual SSL\n\nThe HTTPS listener could connect to or interact with an HTTPS client. The `http:ListenerSecureSocket` configuration\nof the listener exposes the HTTPS connection related configs.\n\n#### 9.2.1 Listener - SSL/TLS\n\n```ballerina\nlistener http:Listener securedEP = new(9090,\n    secureSocket = {\n        key: {\n            certFile: \"/path/to/public.crt\",\n            keyFile: \"/path/to/private.key\"\n        }\n    }\n);\n\nservice /foo on securedEP {\n    resource function get bar() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n#### 9.2.2 Listener - Mutual SSL\n\nThe mutual SSL support which is a certificate-based authentication process in which two parties \n(the client and server) authenticate each other by verifying the digital certificates. It ensures that both \nparties are assured of each other’s identity.\n\n```ballerina\nlistener http:Listener securedEP = new(9090,\n    secureSocket = {\n        key: {\n            certFile: \"/path/to/public.crt\",\n            keyFile: \"/path/to/private.key\"\n        },\n\n        mutualSsl: {\n            verifyClient: http:REQUIRE,\n            cert: \"/path/to/public.crt\"\n        },\n\n        protocol: {\n            name: http:TLS,\n            versions: [\"TLSv1.2\", \"TLSv1.1\"]\n        },\n\n        ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]\n\n    }\n);\nservice /foo on securedEP {\n    resource function get bar() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\n#### 9.2.3 Client - SSL/TLS\n\n```ballerina\nhttp:Client securedEP = check new(\"https://localhost:9090\",\n    secureSocket = {\n        cert: \"/path/to/public.crt\"\n    }\n);\n\npublic function main() returns error? {\n    string response = check securedEP->get(\"/foo/bar\");\n    io:println(response);\n}\n```\n\n#### 9.2.4 Client - Mutual SSL\n\n```ballerina\nhttp:Client securedEP = check new(\"https://localhost:9090\",\n    secureSocket = {\n        key: {\n            certFile: \"/path/to/public.crt\",\n            keyFile: \"/path/to/private.key\"\n        },\n        cert: \"/path/to/public.crt\",\n        protocol: {\n            name: http:TLS\n        },\n        ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]\n\n    }\n);\npublic function main() returns error? {\n    string response = check securedEP->get(\"/foo/bar\");\n    io:println(response);\n}\n```\n\n## 10. Protocol upgrade\n### 10.1. HTTP/2\nThe version 2 of HTTP protocol is supported in both Listener and Client space which could be configured through the \nrespective configuration.\n\n```ballerina\n// Listener declaration\nlistener http:Listener http2ServiceEP = new (7090, config = {httpVersion: \"2.0\"});\n\n// Client declaration\nhttp:Client clientEP = check new (\"http://localhost:7090\", {httpVersion: \"2.0\"});\n```\n\n\nThere are few API level additions when it comes to the HTTP/2 design such as Push promise and promise response.\n#### 10.1.1. Push Promise and Promise Response\nPush Promise and Promise response are the only application level new semantics which are introduced by HTTP2.\n\nOther protocol changes such as streams, messages, frames, request prioritization, flow control, header compression, \netc. are all lower level changes that can be handled by the HTTP listener seamlessly from the user.\n"},"__N_SSG":true}