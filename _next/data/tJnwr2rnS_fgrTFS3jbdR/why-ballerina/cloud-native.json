{"pageProps":{"frontmatter":{"layout":"ballerina-why-ballerina-left-nav-pages-swanlake","title":"Cloud native","description":"See how the Ballerina programming language has built-in language constructs for network interactions and cloud support.","keywords":"ballerina, programming language, cloud, kubernetes, docker","permalink":"/why-ballerina/cloud-native/","active":"cloud-native","intro":"See how the Ballerina programming language has constructs that seamlessly map to network programming concepts such as services and network resources. It also comes with built-in language support to deploy Ballerina applications on the cloud using Docker and Kubernetes.","redirect_from":["/why/from-code-to-cloud/","/why/from-code-to-cloud","/why-ballerina/from-code-to-cloud/","/why-ballerina/from-code-to-cloud","/learn/user-guide/why-ballerina/from-code-to-cloud","/learn/user-guide/why-ballerina/from-code-to-cloud/","/learn/user-guide/why-ballerina/","/learn/user-guide/why-ballerina","/learn/user-guide/why-ballerina/cloud-native","/learn/user-guide/why-ballerina/cloud-native/","/learn/why-ballerina/","/learn/why-ballerina","/learn/why-ballerina/cloud-native/","/learn/why-ballerina/cloud-native","/why-ballerina/cloud-native","/why-ballerina/","/why-ballerina","/why-ballerina/the-network-in-the-language/","/why-ballerina/the-network-in-the-language"]},"content":"\nIn a microservice architecture, smaller services are developed, deployed, and scaled individually. These disaggregated services communicate with each other over the network forcing developers to deal with the [fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) in their application logic. For decades, programming languages have treated networks simply as I/O sources. The sections below demonstrate a few of Ballerina's inherent capabilities to develop distributed services effectively and the cloud-native deployment process that is provided as part of the programming experience. \n\n## Network-friendly type system\n\nBallerina's type system is specifically focused on aiding the development of networked and distributed applications. Ballerina is a `null`-safe language with built-in support for popular wire formats JSON and XML, and seamless conversions between  JSON and user-defined types.\n\n### Get started\n\nThe sample below demonstrates a few simple usages of `json` and `xml` types.\n\n```ballerina\nimport ballerina/io;\n\npublic function main() returns error? {\n    string name = \"Katie Melua\";\n\n    // XML literal.\n    xml album = xml\n    `<Album>\n        <name>Piece By Piece</name>\n        <artist>${name}</artist>\n        <song>Spider's Web</song>\n        <song>Nine Million Bicycles</song>\n    </Album>`;\n    io:println(\"XML Value: \", album);\n\n    // Extract the list of song names from the XML value using a query expression.\n    string[] songs = from var song in album/<song>\n        select song.data();\n    io:println(\"Extracted song names: \", songs);\n\n    // JSON literal.\n    json jAlbum = {\n        \"name\": (album/<name>).data(),\n        \"artist\": name,\n        songs\n    };\n    io:println(\"JSON value: \", jAlbum);\n\n    json artistName = check jAlbum.artist;\n    io:println(\"Album artist: \", artistName);\n}\n```\n\nThe Ballerina source file is compiled and executed in the following manner.\n\n```bash\nbal run xml_json_sample.bal\n```\n\nOutput:\n```bash\nCompiling source\n        xml_json_sample.bal\n\nRunning executable\n\nXML Value: <Album>\n        <name>Piece By Piece</name>\n        <artist>Katie Melua</artist>\n        <song>Spider's Web</song>\n        <song>Nine Million Bicycles</song>\n    </Album>\nExtracted song names: [\"Spider's Web\",\"Nine Million Bicycles\"]\nJSON value: {\"name\":\"Piece By Piece\",\"artist\":\"Katie Melua\",\"songs\":[\"Spider's Web\",\"Nine Million Bicycles\"]}\nAlbum artist: Katie Melua\n```\n\n## Services\n\nServices in Ballerina work with a listener object and can have one or more resource methods that contain application logic. The listener object provides an interface between the network and the service. It receives network messages from a remote process according to the defined protocol (e.g., HTTP, GraphQL).  Next, it translates them into calls on the resource methods of the services that have been attached to the listener object.\n\n### Get started\n\nBelow is a simple Hello World service to get you started.\n\n```ballerina\nimport ballerina/http;\n\nservice on new http:Listener(9090) {\n\n    resource function get greeting() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\nThe Ballerina source file is compiled and executed in the following manner.\n\n```bash\nbal run hello.bal\n```\n\nYou view the output below.\n\n```bash\nCompiling source\n        hello.bal\n\nRunning executable\n\n$ curl http://localhost:9090/greeting\nHello, World!\n```\n\nBallerina services come with built-in concurrency. Every request to a resource method may be handled in a separate strand (a concurrency unit in Ballerina), which gives implicit concurrent behavior to a service.\n\nSome protocols supported out-of-the-box are:\n\n- [HTTP](/learn/by-example/http-client-endpoint)\n- [HTTP 2.0](/learn/by-example/http-1-1-to-2-0-protocol-switch)\n- [gRPC](/learn/by-example/proto-to-ballerina)\n- [NATS](/learn/by-example/nats-basic-pub-sub)\n\n## Async network protocol\n\nIn the request-response paradigm, network calls are blocking calls. However, blocking an OS thread to perform a network interaction is very expensive. That’s why many other languages supported async I/O, and with that, you have to implement complicated logic to handle asynchronous events using techniques such as callbacks and promises. Ballerina’s request-response protocols are implicitly non-blocking and will take care of asynchronous invocations.\n\n### Get started\n\nThe code snippet below shows a call to a simple HTTP GET request endpoint.\n\n```ballerina\nimport ballerina/http;\nimport ballerina/io;\n\npublic function main() returns @tainted error? {\n    http:Client clientEP = check new (\"http://www.mocky.io\");\n    string payload = check clientEP->get(\"/v2/5ae082123200006b00510c3d\");\n    io:println(payload);\n}\n```\n\nAlthough the above `get` operation is seemingly a blocking operation, internally, it does an asynchronous execution using the non-blocking I/O, where the current execution thread is released to the Ballerina runtime scheduler to be used by other Ballerina strands. After the I/O operation ends, the program execution automatically resumes from where it was suspended. This pattern gives you a much more convenient programming model than handling the non-blocking I/O manually while providing maximum performance efficiency.\n\n## Client objects\n\nClient objects allow Ballerina developers to communicate with a remote process that follows a given protocol. The remote methods of the client object correspond to distinct network messages defined by the protocol for the role played by the client object.\n\n### Get started\n\nThe sample below sends out a tweet by invoking the tweet remote method in the twitter client object.\n\n```ballerina\nimport ballerina/io;\nimport ballerinax/twitter;\n\nconfigurable string apiKey = ?;\nconfigurable string apiSecret = ?;\nconfigurable string accessToken = ?;\nconfigurable string accessTokenSecret = ?;\n\n// Twitter package defines this type of endpoint\n// that incorporates the twitter API.\n// We need to initialize it with OAuth data from apps.twitter.com.\n// Instead of providing this confidential data in the code\n// we read it from a configuration file.\ntwitter:Client twitterClient = check new ({\n    apiKey,\n    apiSecret,\n    accessToken,\n    accessTokenSecret\n});\n\npublic function main() returns error? {\n    twitter:Tweet status = check twitterClient->tweet(\"Hello World!\");\n    io:println(\"Tweeted: \", <@untainted>status.id);\n}\n```\n\n## Code to Cloud\n\nNot so long ago, as a developer, you only had to think about writing a program (and tests), building it, and running it. Today, you also need to think about various deployment options such as Docker, Kubernetes, serverless environments, and service meshes. However, this deployment process is not a part of the programming experience.\n\nBallerina provides a unique developer experience to move from code to cloud. The Ballerina compiler can be extended to read the source code and generate artifacts to deploy your code into different clouds. These artifacts can be Dockerfiles, Docker images, Kubernetes YAML files, or serverless functions.\n\n### From code to Kubernetes\n\nKubernetes is the preferred platform for running applications with multiple microservices in production. It can be used for automating deployment and scaling, and the management of containerized applications. Kubernetes defines a set of unique building blocks that need to be defined as YAML files and deployed into the Kubernetes cluster.\n\nHowever, in many cases, creating these YAML files could be out of your comfort zone, and thereby, the Ballerina compiler can create these YAML files while compiling the source code. The code below shows the build option you need to use to do this.\n\nThe following code snippet shows how the Ballerina compiler can generate YAML files to deploy your code to Kubernetes.\n\n```ballerina\nimport ballerina/http;\n\nservice /hello on new http:Listener(9090) {\n    resource function get sayHello() returns string {\n        return \"Hello, World!\";\n    }\n}\n```\n\nBuilding the source with `bal build --cloud=k8s` will generate the Kubernetes YAML files and Docker image that are required to deploy the `hello` application into Kubernetes.\n\nBuilding the source with `bal build --cloud=docker` will generate the Docker image and Dockerfile.\n\n### From code to AWS Lambda\nAWS Lambda is an event-driven, serverless computing platform. Ballerina functions can be deployed in AWS Lambda by annotating a Ballerina function with the `@awslambda:Function` annotation, which should have the `function (awslambda:Context, json) returns json|error` function signature.\n\nThe sample below illustrates a simple echo function with AWS Lambda annotations. \n\n```ballerina\nimport ballerinax/awslambda;\n\n// Annotating a function with the `@awslambda:Function` annotation \n// generates artifact for an AWS Lambda function.\n@awslambda:Function\npublic function echo(awslambda:Context ctx, json input) returns json {\n    return input;\n}\n```\n\n### From code to Azure Functions\nAzure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. Ballerina functions can be deployed in Azure by annotating a Ballerina function with `@azure_functions:Function`.\n\n```ballerina\nimport ballerinax/azure_functions;\n\n// HTTP request/response with no authentication.\n@azure_functions:Function\npublic function hello(@azure_functions:HTTPTrigger {authLevel: \"anonymous\"} string payload)\n                        returns @azure_functions:HTTPOutput string|error {\n    return \"Hello, \" + payload + \"!\";\n}\n```\n\n### CI/CD with GitHub Actions\n\nIn a microservice architecture, continuous integration and continuous delivery (CI/CD) is critical in creating an agile environment to incorporate incremental changes to your system. Different technologies provide this CI/CD functionality, and very recently, GitHub has introduced GitHub Actions, which is now available for general usage. GitHub Actions is a convenient mechanism for implementing CI/CD pipelines using their workflow concept right from your GitHub repositories.\n\nWith the [Ballerina GitHub Action](https://github.com/marketplace/actions/ballerina-action), it is straightforward to create a Ballerina development environment with built-in CI/CD. \n\n<style>\n.nav > li.cVersionItem {\n    display: none !important;\n}\n/**.cBalleinaBreadcrumbs li:nth-child(3) , .cBalleinaBreadcrumbs li:nth-child(2) {\n   display:none !important;\n}**/\n</style>\n","id":"cloud-native","slug":"cloud-native"},"__N_SSG":true}