{"pageProps":{"frontmatter":{"layout":"ballerina-why-ballerina-left-nav-pages-swanlake","title":"Concurrent","description":"Concurrency in Ballerina is enabled by strands, which are lightweight threads.","keywords":"ballerina, ballerina platform, concurrency, workers, strands, threads, lightweight threads","permalink":"/why-ballerina/concurrent/","active":"concurrent","intro":"Concurrency in Ballerina is enabled by strands, which are lightweight threads.","redirect_from":["/learn/user-guide/why-ballerina/concurrent","/learn/user-guide/why-ballerina/concurrent/","/learn/why-ballerina/concurrent","/learn/why-ballerina/concurrent/","/why-ballerina/concurrent"]},"content":"\nBallerina's concurrency model supports both threads and coroutines and has been designed to have a close correspondence with sequence diagrams.\n\nA Ballerina program is executed on one or more threads. A thread can consist of one or more strands, which are language-managed, logical threads of control. Only one strand of a particular thread can run at a time. The strands belonging to a single thread are cooperatively multitasked. Therefore, strands of a single thread behave as coroutines relative to each other.\n\nStrands enable cooperative multitasking by \"yielding\". The runtime scheduler may switch the execution of a strand only when it yields via a `wait` action, a worker receive action, a library function resulting in a blocking call, etc.\n\nA strand is created due to the execution of either a named worker declaration or `start` action.\n\nConcurrent operations in a function can be defined by multiple named workers. A function has a default worker and may additionally contain named workers. A worker executes concurrently with the other workers (function worker and named workers) in the function.\n\n```ballerina\nimport ballerina/io;\n\ntype Person record {|\n    string name;\n    boolean employed;\n|};\n\nfunction process(Person[] members, int[] quantities) {\n    worker w1 {\n        Person[] employedMembers = from Person p in members\n            where p.employed\n            select p;\n        int count = employedMembers.length();\n        count -> w2;\n        string `Employed Members: ${count}` -> function;\n    }\n\n    worker w2 {\n        int total = int:sum(...quantities);\n\n        int employedCount = <- w1;\n\n        int avg = employedCount == 0 ? 0 : total / employedCount;\n        string `Average: ${avg}` -> function;\n    }\n\n    string x = <- w1;\n    io:println(x);\n\n    string y = <- w2;\n    io:println(y);\n}\n```\n\nWorker message passing (via Ballerinaâ€™s `send (->)` and `receive (<-)` actions) is used for communication between workers. The compiler also explicitly verifies that the `send` and `receive` actions are in a consistent state to avoid any deadlock scenarios at runtime.\n\nThe `@strand` annotation can be used on a named worker or start action to make the corresponding strand run on a separate thread.\n\n```ballerina\nimport ballerina/io;\n\ntype Person record {|\n    string name;\n    boolean employed;\n|};\n\nfunction process(Person[] members, int[] quantities) {\n\n    @strand {\n        thread: \"any\"\n    }\n    worker w1 {\n        Person[] employedMembers = from Person p in members\n            where p.employed\n            select p;\n        employedMembers.length() -> function;\n    }\n\n    int quantitiesSum = int:sum(...quantities);\n    int employedMemCount = <- w1;\n\n    io:println(\"Average: \", employedMemCount == 0 ? 0 : quantitiesSum / employedMemCount);\n}\n```\n\nConcurrency in Ballerina works well with sequence diagrams. A function can be viewed as a sequence diagram. Each worker is represented by a separate lifeline (vertical line).\n\nImmutability in the type system can be leveraged to write reliable concurrent programs. Immutability in Ballerina is deep guaranteeing that an immutable structure will always have only immutable values. Therefore, an immutable value can be safely accessed concurrently without using a lock statement.\n\n```ballerina\ntype Details record {|\n    int id;\n    string location?;\n|};\n\nfunction process(map<Details> & readonly entities) {\n    string[] detailsWithLocation = [];\n    string[] detailsWithoutLocation = [];\n\n    foreach var [name, details] in entities.entries() {\n        if details.hasKey(\"location\") {\n            detailsWithLocation.push(name);\n        } else {\n            detailsWithoutLocation.push(name);\n        }\n    }\n\n    // The casts within the workers are safe because the lists were created\n    // based on an immutable map and is therefore guaranteed to have the \n    // exact same entries with the exact same fields.\n    worker w1 {\n        foreach var name in detailsWithoutLocation {\n            persistId(<record {|int id;|} & readonly>entities.get(name));\n        }\n    }\n\n    worker w2 {\n        foreach var name in detailsWithLocation {\n            persistIdWithLocation(\n                <record {|int id; string location;|} & readonly>entities.get(name));\n        }\n    }\n}\n\nfunction persistId(record {|int id;|} rec) {\n\n}\n\nfunction persistIdWithLocation(record {|int id; string location;|} rec) {\n\n}\n```\n\n<style>\n.cBallerinaTocContainer {\n    display: none !important;\n}\n/*.cBalleinaBreadcrumbs li:nth-child(3) , .cBalleinaBreadcrumbs li:nth-child(2) {\n   display:none !important;\n}*/\n</style>\n","id":"concurrent","slug":"concurrent"},"__N_SSG":true}