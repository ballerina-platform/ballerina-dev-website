<div class="release_notes">
<h1>Overview to Ballerina 0.990.0</h1>
<p>Ballerina 0.990.0 consists of significant improvements of the language syntax, which is based on a new specification.</p>
<h1>Highlights</h1>
<ul>
<li>We have introduced changes to the Ballerina type system to encourage data-oriented thinking, to provide the foundation for safe concurrency by introducing immutable values, and to make structural types and mutability work together smoothly.</li>
<li>We have introduced changes to error handling in Ballerina to maintain a consistent policy on normal and abnormal errors throughout the language. </li>
<li>Error handling related changes affects the semantics of concurrency constructs: error types are statically propagated to interacting workers. Workers can now have a statically-typed return value, which may be an error.</li>
<li>Cloning and immutability of structured values contribute to message send/receive safety across workers.</li>
<li>Endpoints and services are the key abstractions in Ballerina that bring network programming to a higher level abstraction when compared to traditional languages. We have introduced significant changes to endpoints and services syntax and semantics.</li>
</ul>
<h1>Breaking Language Changes</h1>
<ul>
<li>
<p>Implicit variable initialization has been removed. Therefore the code <code>int a; io:println(a);</code> that was valid in the previous release will fail with an error: <code>variable 'a' is not initialized</code>.</p>
</li>
<li>
<p>Variables must be initialized explicitly before using them. For more information, refer to variable initialization in the <a href="#whats-new-in-ballerina-09900">What’s new section</a>.  </p>
</li>
<li>
<p>The <code>match</code> statement no longer selects a <code>block</code> statement or an expression to execute based on which pattern a type matches. Now it selects a <code>block</code> statement based on the patterns a value matches. For more information, refer to the <a href="#match-statement">match statement section</a>.</p>
</li>
<li>
<p>The <code>but</code> expression has been removed. You can use type tests instead. For more information, refer to the <a href="#structural-types">structural types section</a>.</p>
</li>
<li>
<p>The error type is no longer a built-in record type. Therefore, you will see syntax errors for error literals in the form of <code>{message: “error message goes here”, cause: e}</code>. From this release onwards, the error type is a structured basic type used only for representing errors. It contains a reason; a string identifier for the category of error, a detail; a frozen mapping providing additional information, and a stack trace. For more information, refer to the <a href="#error-handling">error handling section</a>.</p>
</li>
<li>
<p>The <code>any</code> type no longer includes the <code>error</code> type. The <code>any</code> type is now a union of all types except <code>error</code> type (and its subtypes). This change forces errors to be documented explicitly, even if a function returns any.</p>
</li>
<li>
<p>The <code>map</code> type without type parameter is not allowed from this release onwards. The same applies to <code>future</code> and <code>stream</code> types. For more information refer to the <a href="#structural-types">structural types section</a>.</p>
</li>
<li>
<p>The <code>try-catch-finally</code> and <code>throw</code> statements have been removed from this release. It encourages exception handling mechanism available in languages such as Java, JavaScript, and C++ where they allow mixing both normal errors (which programmers must be aware of and handle) and abnormal errors (which cannot be dealt with and often indicates a program error). For more information, refer to the <a href="#error-handling">error handling section</a>.</p>
</li>
<li>
<p>The <code>check</code> expression semantics has been changed to not throw an error if <code>return</code> type of the enclosing function or resource does not contain the <code>error</code> type.</p>
</li>
<li>
<p>The <code>self</code> keyword has been mandated to access object members within the object definition. The following code will not compile with this Ballerina version.</p>
</li>
</ul>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">type Person object {
    private string name;
    function getName () returns string {
        return name;
    }
};

</code></pre>

<p>Now you need to use <code>self</code> when referring to object members as follows. </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">type Person object {
    private string name;
    function getName () returns string {
    return self.name;
    }
};

</code></pre>

<p>Object constructor syntax has been changed from this release onwards. Here is the old syntax.  </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">type Person object {
    private string name;
    new (name) {
    }
};

</code></pre>

<p>Here is the new syntax. With this change, we have removed the special signature in the constructor that existed in the previous release. </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">type Person object {
     private string name;
     function __init (string name) {
          self.name = name;
     }
};

</code></pre>

<ul>
<li>
<p>For more information, refer to the <a href="#object">object constructor redesign section</a>.</p>
</li>
<li>
<p>An object method can be defined outside of the object definition given that it is not an abstract object and the object method is declared inside the object definition. The qualified name of the method defined outside is composed of the object type name and the method name. The previous syntax was <code>object-type-name::method-name</code> and the new syntax is <code>object-type-name.method-name</code>.</p>
</li>
<li>
<p>Endpoints and services are the key abstractions in Ballerina that bring network programming to a higher level of abstraction when compared to traditional languages. There are two kinds of endpoints: listener endpoints and client endpoints.  We have changed the listener (inbound) endpoint variable definition syntax. Here is the old syntax.</p>
</li>
</ul>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">endpoint http:Listener httpEp {
    port: 9095
};

</code></pre>

<p>Now listener endpoints are Ballerina objects that implement the abstract listener object. Therefore, you can create a new instance of a module-level listener endpoint as follows. For more information, refer to endpoints and services section.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener http:Listener httpEp = new (9095);

</code></pre>

<p>The service and resource definition syntax has been changed. Here is the old syntax.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">service hello bind httpEp {
    hi (endpoint caller, http:Request req) {
        _ = caller-&gt;respond(&quot;Hello, World!&quot;);
    }
}

</code></pre>

<p>Now services are first-class values and are like singleton objects. Resource definition has been modified slightly. Now a resource definition looks like a function definition with the resource qualifier. For more information, refer to standard library syntax section.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">service hello on httpEp {
    resource function hi (http:Caller caller, http:Request req) {
        _ = caller-&gt;respond(&quot;Hello, World!&quot;);
    }
}

</code></pre>

<ul>
<li>
<p>The syntax of defining client endpoints (outbound endpoints) has been simplified. For more information, refer to the <a href="#standard-library">standard library syntax section</a>.</p>
</li>
<li>
<p>The annotations <code>@final</code> and <code>@readonly</code> have been removed from this release onwards. Now you can declare final variables using the <code>final</code> keyword. For example, <code>final int port = readPortFromConfig();</code>.</p>
</li>
<li>
<p>The <code>@doc</code> annotation that was deprecated in previous releases has been removed from this release onwards.</p>
</li>
<li>
<p>The syntax and semantics of functions calls and workers defined in the function body has changed. For more information, refer to the <a href="#concurrency">concurrency section</a>.</p>
</li>
<li>
<p>The <code>fork/join</code> statement has been removed. You can use the new <code>fork</code> statement to start multiple workers in parallel with each other. Each worker name becomes a variable of type <code>future&lt;T&gt;</code> where T is the return type of the worker. You can use the new <code>wait</code> action to wait for one or more workers. For more information on the fork statement, wait action, and other concurrency-related changes, refer to the <a href="#concurrency">concurrency section</a>.</p>
</li>
<li>
<p>The <code>done</code> statement has been removed. Now workers can return values using the <code>return</code> statement.  For more information, refer to the <a href="#concurrency">concurrency section</a>.</p>
</li>
<li>
<p>The <code>await</code> statement has been replaced by the new <code>wait</code> statement. For more information, refer to the <a href="#concurrency">concurrency section</a>.</p>
</li>
<li>
<p>The <code>foreach</code> statement has been changed in a consistent way to match with type binding patterns. Here is the old syntax.</p>
</li>
</ul>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">map&lt;Student&gt; class = { ... }
foreach name, std in class {
    string msg = name + &quot; details: &quot;;
    io:println(msg, std);
}

</code></pre>

<p>Now the <code>foreach</code> statement allows the value to be destructured, while iterating over a sequence. Here is an example.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">foreach (string, Student)  (name, std) in class {
    string msg = name + &quot; details: &quot;;
    io:println(msg, std);
}

</code></pre>

<ul>
<li>
<p>Additionally, <code>list</code> type iteration provides only the value as an argument. It no longer gives the index variable as the first argument. JSON is no longer iterable, instead, use array of JSON (<code>json[]</code>) or map of JSON (<code>map&lt;json&gt;</code>). For more information, refer to the [binding pattern section].  </p>
</li>
<li>
<p>Iterable Operations (<code>foreach</code>, <code>map</code>, <code>filter</code>) signatures have been changed to be consistent with the <code>foreach</code> statement arguments.</p>
</li>
</ul>
<h1>What&rsquo;s new in Ballerina 0.990.0</h1>
<p>This release contains significant changes and new features in areas such as structural types, error handling, concurrency, objects, and endpoints.</p>
<h2>Structural Types</h2>
<p>Ballerina has a structural type system in which compatibility of types and values is determined based on their structure; this is particularly useful in integration scenarios that combine multiple, independently-designed systems. The following changes to the Ballerina type system encourage data-oriented thinking, provides the foundation for safe concurrency by introducing immutable values, makes structural types, and mutability work together smoothly.  </p>
<h3>Typing of mutable structure values</h3>
<p>Ballerina programs use types to categorize values both at compile-time and runtime. Types deal with an abstraction of values, which does not consider storage location or mutability. This abstraction is called a shape. </p>
<p>A type denotes a set of shapes. A type S is a subtype of type T if the set of shapes denoted by S is a subset of the set of shapes denoted by T.</p>
<p>Every value has a corresponding shape. Since shapes do not deal with storage location, they have no concept of identity; shapes therefore represent trees rather graphs. Shapes differ from values only for reference values. For simple values, there is no difference between a shape and a value; the shape of a simple value is just that value. A shape is specific to a basic type: if two values have different basic types, they have different shapes.</p>
<p>There are two important relations between a value and a type:</p>
<ul>
<li>A value looks like a type at a particular point in the execution of a program if its shape at that point is a member of the type.</li>
<li>A value belongs to a type if it looks like the type, and it will necessarily continue to look like the type no matter how the value is mutated.</li>
</ul>
<p>For an immutable value, looking like a type and belonging to a type are the same thing.</p>
<p>When a Ballerina program declares a variable to have a compile-time type, this means that the Ballerina compiler together with the runtime system will ensure that the variable will only ever contain a value that belongs to the type. Ballerina also provides mechanisms that take a value that looks like a type and use it to create a value that belongs to a type. </p>
<p>A container has an inherent type, which is a type descriptor that is part of the container’s runtime value. At runtime, the container prevents any mutation that might lead to the container having a shape that is not a member of its inherent type. Thus, a container value belongs to a type if and only if that type is its inherent type or a subset of its inherent type.</p>
<h3>Pure values</h3>
<p>A value is considered as a pure value if it is a simple value (<code>nil</code>, <code>boolean</code>, <code>int</code>, <code>float</code>, <code>string</code>) or a structured value that contains only pure members. Error values are also considered as structured values. </p>
<h3>anydata type</h3>
<p>The <code>anydata</code> type consists of pure values whose <code>basic</code> type is not <code>error</code>. Thus <code>(anydata|error)</code> contains all pure values. So <code>anydata</code> is equivalent to <code>() | int | float | decimal | string | (anydata|error)[] | map&lt;anydata|error&gt; | xml | table</code>.</p>
<p>Ballerina records are by default open. In the previous release, <code>record {}</code> means <code>record { any … }</code>. With the introduction of pure values now <code>record {}</code> means it is open only to pure values.</p>
<h3>clone() built-in method</h3>
<p>Performs a deep copy of a pure value. It is a no-op operation on simple values and error values. This operation is guaranteed to succeed on pure values and preserves cycles, inherent type, and immutability of values.</p>
<h3>Record type referencing</h3>
<p>Record type referencing is a mechanism for copying the fields from one record type descriptor into another record type descriptor. It is equivalent to defining those fields in the new type descriptor. If the fields have explicit default values specified, those values will be copied as well.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">type Person record {
   string name;
   int age = 25;
   !...
};

type Employee record {
   *Person;  // Referencing the `Person` record
   string company;
   string designation;
   !...
};
</code></pre>

<p>The above Employee type descriptor is equivalent to the following type descriptor:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">type Employee record {
   string name;
   int age = 25;
   string company?;
   string designation;
   !...
};

</code></pre>

<h3>Value equality and reference equality</h3>
<p>From this release onwards, we have changed the semantics of operator <code>==</code> to perform a deep value equality only on <code>anydata</code> values. A compile time error occurs if used for some other purpose. This operator is not allowed on error values.</p>
<p>We have introduced a new operator <code>===</code> that performs reference equality on reference types and is otherwise same as <code>==</code>. The <code>!==</code> operator results in the negation of the result of the <code>===</code> operator.</p>
<h3>Immutable values</h3>
<p>We have introduced immutable values from this release onwards. Immutability is not part of the static type system in the language. It exists only in the runtime. You can use the <code>freeze</code> built-in method to make a structured value frozen at runtime. This method sets the <code>frozen</code> flags in the value. A <code>frozen</code> structured value cannot be modified afterward and any such attempts will results in panics.</p>
<p>The <code>freeze</code> built-in method changes the value to which it is applied to be frozen and returns that value. It works in a similar way to the <code>clone</code> method.</p>
<p>There is a <code>isFrozen()</code> built-in method on all structural basic types that returns <code>true</code> or <code>false</code> depending on whether the value is frozen. </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">person p1 = {name:&quot;John&quot;, age:34};
person p1Frozen = p1.freeze();
boolean b = p1 === p1Frozen; // true

</code></pre>

<h3>Type test expression</h3>
<p>The type test can be used to determine whether a value is of a particular type.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">int|string x = getValue();
if x is string {
   // x is now string after implicit narrowing
   return;
}
// x is now int
</code></pre>

<h3>Type assertions</h3>
<p>Type assertions can be used to assert the inherent type of a value. Assertion fails and results in a panic, if the asserted type is not exactly the storage type.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">
Employee e = { ... };
Person p = e;

Employee e2 = &lt;Employee&gt; p; // successful since storage type is Employee
Person p2 = &lt;Person&gt; p; // panics since storage type is Employee
</code></pre>

<h3>Match statement</h3>
<p>The existing match has been changed in this release from a type match to a value match statement. The match statement is a value switching construct that allows selective code execution based on the value of the expression that is being tested.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">match variable {
    “Bal” =&gt; io:println(“Matched a String with value Bal”);
    0 =&gt; io:println(“Matched an int with value 0”);
    10 =&gt; io:println(“Matched an int with value 10”);
    (15, “Lang”) =&gt; io:println(“Matched a tuple with (15, “Lang” values”);
    false =&gt; io:println(“Matched a boolean with value false”);
    {a: 15, b: “Lang”}=&gt; io:println(“Matched a mapping value”);
    _ =&gt; io:println(“Matched to Default Pattern”);
}

</code></pre>

<p>The <code>match</code> statement can also be used to match the structure of a value by using binding patterns. The matched value will be destructured to new variables within the scope of the match pattern. Here is an example of the structured value match.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">match variable {
    var (var1, var2) =&gt; { // match a tuple value with two members
        io:println(var1);
        io:println(var2);
    }
    var {a: var1, b: var2} =&gt; { //match a mapping value with fields “a” and “b”
        io:println(var1);
        io:println(var2);
    }
    var x =&gt; io:println(“Matched to Default Pattern”); //all values will match
}
</code></pre>

<h3>Dynamically narrowing type</h3>
<p>There are two types of relationships between a value and a type in this section. They are &lsquo;looks like&rsquo; and &lsquo;belongs to&rsquo;. With the introduction of these two relationships, one might want to transform a value that looks like a type into a value that belongs to that type. We have introduced two built-in methods to do that.</p>
<ul>
<li><code>T.stamp(v)</code>: Mutate the value v itself and set its inherent type to T.</li>
<li><code>T.convert(v)</code>: Make copy of the value v and set its inherent type to T.</li>
</ul>
<h2>Error Handling</h2>
<p>Ballerina distinguishes two kinds of errors; normal and abnormal errors. Abnormal errors are unusual occurances and they are usually signs of bugs or programmer errors. It is usually not possible to recover from abnormal errors. Normal errors, on the other hand, are recoverable and they are part of your business logic. </p>
<p>Normal errors can be returned from functions, workers and resources hence have an explicit control flow. They are also statically type checked. Abnormal errors stop the execution of a program unless they are trapped: implicit control flow. Following changes and improvements defines consistent policy on error handling throughout the language. Also, these changes have an impact on concurrency features which is explained in the <a href="#concurrency">concurrency section</a>.</p>
<h3>The error type</h3>
<p>The error type is a structured basic type which is used only for representing errors. A value of error type contains a reason which is a string identifier for the category of error, a detail which is a frozen mapping providing additional information and a stack trace. Error values are made immutable from this release onwards, since they can propagate across concurrent execution blocks. Allowing them to be mutable can be dangerous.</p>
<p>Here is an example for usage of error type. The function <code>getAcctBalance</code> returns a union of <code>decimal</code> and <code>error&lt;string, AccountData&gt;</code> types.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">type AccountData record {
    string accountID;
};

function getAcctBalance(int id)
returns decimal | error&lt;string, AccountData&gt; {...}

</code></pre>

<p>The <code>any</code> type was the union of all types in Ballerina. However, from this release onwards, we have removed the <code>error</code> type from <code>any</code>. This change forces errors to be documented explicitly, even if a function returns <code>any</code>. </p>
<h3>Check expression</h3>
<p>The <code>check</code> expression is a useful unary operator in the language, which allows you to get an error out of the way in arbitrary expressions. If the type of the expression E is <code>T | error</code>, then the type of expression check E will be <code>T</code> if it evaluates to <code>T</code>. If the expression evaluates to error, then the function terminates immediately as if by <code>return E</code>. The <code>check</code> operator forces you to declare error as part of the return type of your function. </p>
<p>In the previous release, check throws the error if the function does not have error type as part of the <code>return</code> type. This causes normal errors to become exceptions or abnormal errors due to negligence of the programmer. </p>
<p>Here is a sample usage of check operator.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">function startHTTPListener() returns Listener | error {
    string strVal = getValue(HTTP_PORT);
    // int.convert() has the type 'int | error'
    int port = check int.convert(strVal);
    ...
}

</code></pre>

<h3>Panic statement</h3>
<p>This is a replacement for the <code>throw</code> statement to allow programmers to create a panic, which causes the execution to stop. Function calls will unwind until the panic is stopped by trapping it and converting it into an error. Stack trace is recorded in the error value at the time of panic. </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">int | error i = int.convert(&quot;4t4&quot;);
if i is error {
    panic i;
}

</code></pre>

<h3>Trap expression</h3>
<p>The <code>trap</code> expression stops a panic and gives access to the error value associated with the panic. This is a replacement for the <code>try-catch</code> statement. In <code>var a = trap E</code>, the type of the variable <code>a</code> will be <code>T | error</code> where <code>T</code> is the type of the expression <code>E</code>.</p>
<h2>Binding Patterns</h2>
<p>Binding patterns are used to support destructuring, which allows different parts of a single structured value each to be assigned to separate variables at the same time. Binding patterns can be used both with or without a type. Using a <code>typed binding pattern</code> will assign the destructured values to new variables, while a <code>destructure assignment binding pattern</code> will assign the destructured values to existing variable references.</p>
<p>This release introduces two binding patterns; tuple binding pattern and record binding pattern.</p>
<p>Tuple binding pattern destructures a <code>tuple</code> value based on the number of members in the <code>tuple</code> value. Here is an example of a tuple binding pattern.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">(int, string) tupleVar = (20, “Ballerina”);
(int, string) (intVariable, stringVariable) = tupleVar; //typed binding pattern
io:println(intVariable + “ “ + stringVariable);
int intVariable2;
string stringVariable2;
(intVariable2, stringVariable2) = tupleVar; //binding pattern with variable references
io:println(intVariable2 + “ “ + stringVariable2);

</code></pre>

<p>Record binding pattern destructures a mapping value based on the presence of a field name. Here is an example of a record binding pattern. In this example a <code>Person</code> typed record with fields <code>name</code> and <code>age</code> will be destructured. The variable name to which the value is to be assigned can be given against a field name following a colon. Omitting a variable name will result in using the same name as the field name.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">Person {name, age: personAge} = getPerson(); //typed binding pattern
io:println(name + “ “ + personAge);
string personName;
int age;
{name: personName, age} = getPerson(); //binding pattern with variable references
io:println(personName + “ “ + age);

</code></pre>

<h2>Concurrency</h2>
<p>Ballerina has built in support for concurrency. <code>worker</code> and <code>start</code> creates new concurrent flows. <code>wait</code>, <code>-&gt;</code> (send), <code>&lt;-</code> (receive), and &lsquo;flush&rsquo; constructs offer flow control and communication between concurrent flows. <code>lock</code> construct can be used to achieve safe concurrent access.</p>
<p>Ballerina execution model is based on &lsquo;strands&rsquo; that are lightweight execution flows. Strands may run parallely and scheduled by the runtime. Strands are represented by <code>futures</code> in the language.</p>
<h3>Start</h3>
<p>Start executes a given function in a new strand, resulting a new <code>future</code>. This <code>future</code> can be used to interact with the concurrent execution flow.</p>
<h3>Workers and Fork</h3>
<p>Workers offer a way to write a concurrent code section inline within an existing function.</p>
<p>A function has one or more workers including an unnamed default worker and other named workers. These workers are peers of each other. The termination of the function is independent of the termination of its named workers. Returning from a named worker terminates that worker, but does not cause a return from the function. Workers have same return declaration as functions which defaults to ()</p>
<p>The workers created by a <code>fork</code> statement are peers of each other: they can exchange messages with each other but not with any other workers. In other respects, workers created by a <code>fork</code> statement behave the same as workers created by a function body.</p>
<h3>Futures and wait</h3>
<p>A <code>future</code> is just a worker that can be waited for outside the function that starts the worker. </p>
<p>A wait-action waits for one or more futures to be terminated and makes available their return value (including any raised errors). Panic in waited-for future should result in panic in <code>wait</code>. Waiting for a future and waiting for a worker are conceptually the same. </p>
<p>Using the future you can (a) cancel the strand (b) wait for the strand return.</p>
<h3>Send Receive and Sync Send</h3>
<p>Send/sync-send will send <code>anydata</code> type information to another worker, in which <code>receive</code> can be used in the other worker to retrieve the message. Compile time analysis guarantees there is a matching receive for each send.</p>
<p>If the data is not available, receive will wait, similarly if the receiver is not reached yet, the sync send will wait. Both sync send and receive will propagate whichever error that happened in the opposing strand to the current strand.</p>
<p><code>flush</code> will wait until all the messages are sent from the current worker to the specified worker. If the receiver failed or panicked, then that error will be propagated to the waiting strand.</p>
<h3>Lock</h3>
<p>Lock can be used to make the concurrent access safe for a set of variables. It creates two phase deadlock-free synchronization guaranteeing unique access to each variable.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">public function invokeWorkers() returns int {
    worker w1 {
        int i = 5;
        i -&gt; w2;
    }
    worker w2 returns int {
        int j = &lt;- w1;
        return j;
    }
    return (wait w2) + 1;
}
</code></pre>

<h2>Variable Initialization</h2>
<h3>Compile time constants</h3>
<p>A compile-time constant is a typed identifier whose value is computed at compile time. Compile time reference values are <code>frozen</code> values. </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">const i = 10;
</code></pre>

<h3>Final variables</h3>
<p>The modified <code>final</code> variable can be applied to a variable declaration to mean that the variable cannot be modified after it has been initialized.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">final int port = getValue();

// Here the type is inferred from the right-hand side expression. 
final var addr = getAddr();
</code></pre>

<h2>Endpoints, Services and Listeners</h2>
<h3>Endpoints</h3>
<p>In Ballerina, endpoints represent an external system that one or more workers interact with. There are two types of endpoints, Listener endpoints or client endpoints.</p>
<p>Previously, both these endpoints were modeled using two object definitions. One defined the life cycle of the endpoint, other defined the actions of the endpoint. Additionally, the endpoint keyword was used to represent endpoint instances and it had its own initialization and assignment syntax.</p>
<p>With this release, the endpoints are declared as client objects. Also, the following are removed from the language.</p>
<ul>
<li>Endpoint declaration e.g., <code>endpoint http:Listener helloWorldEP { port : 9090 }</code></li>
<li>Action invocation statement (only a terminology change).</li>
</ul>
<h3>Client Object</h3>
<p>An object that has a client modifier is a client object type. A method on a client object can have a remote modifier; a method with a remote modifier is called a remote method. A remote method can be called only using a <code>remote method call</code>.  E.g., <code>clientObj-&gt;remoteFunctionName (arguments)</code>. This is previously called <code>action invocation</code>.</p>
<p>E.g.:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">    public type Twitter client object {
        public remote function tweet (string message) returns error? { ... }
    };
</code></pre>

<p>A Client Object variable declaration is allowed only in following places
 - module level as a module level variable.
 - in a function initialization (before any worker declarations or statements).
 - as an argument to the function.</p>
<p>Eg:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">Twitter globalClient = new;

public function tweetSomething(Twitter paramClient)  {
    Twitter localClient= new;
    worker w1 {
        _ = localClient-&gt;tweet(&quot;tweeting  from local client.&quot;);
    }
    worker w2 {
        _ = paramClient-&gt;tweet(&quot;tweeting  from param client.&quot;);
    }
    _ = globalClient -&gt;tweet(&quot;tweeting  from global client&quot;);
}
</code></pre>

<h3>Listeners</h3>
<p>A listener is an object that implements the abstract listener object. It defines the life cycle of the listener.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">public type AbstractListener abstract object {
    public function __start() returns error?;
    public function __stop() returns error?;
    public function __attach(service s, map&lt;any&gt; annotationData) returns error?;
};
</code></pre>

<h3>Module Listeners</h3>
<p>A module listener is a Listener object that is managed as part of the module’s lifecycle. It is like a final global variable but registers itself with the module life cycle. So a module starts all its module listeners after all services have been attached the listeners and stops the listeners when the module stops. Module listeners are created as follows.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener http:Listener httpEp = new (9095);
</code></pre>

<p>Module Listeners can be attached to module service.  With this change, the old endpoint declaration and endpoint bind syntax have been removed from the language. </p>
<h3>Service Types and Values</h3>
<p>There is a new basic type of behavioral value called <code>service</code>, which represents a named collection of resource functions. A type-descriptor <code>service</code> contains all values of <code>basic</code> type service.</p>
<p>Precise service typing is not provided in this version of Ballerina. This will be added in future versions.</p>
<p>A service value can be constructed using the service constructor expression.</p>
<p>Eg: </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">        service myService = @http:ServiceConfig { basePath : &quot;/hello&quot;} service {
                resource function hi (http:Caller caller, http:Request request ) {
                        _ = caller -&gt; respond(self.getHelloWorld());
                }

                function getHelloWorld() returns string {
                        return &quot;hello world ...!&quot;;
                }
        };
</code></pre>

<p><code>resource</code> qualifier is used to represent the resource methods of the service. Resource methods cannot be called using the <code>method call</code> expression. They are intended to invoke in response to an incoming network request. A service’s non-resource methods can be called using a method call expression.</p>
<h3>Module Services</h3>
<p>A module service is a syntax for creating service value at the module level. A module service must have one or more module listeners or anonymous module listeners (created using type new expression) attached. Here is the syntax.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener http:Listener httpEp = new (9095);

@http:ServiceConfig { basePath : &quot;/hello&quot;} 
service MyService on httpEp, new http:Listener (9085) {
    resource function hi (http:Caller caller, http:Request req) {
        _ = caller-&gt;respond(&quot;Hello, World!&quot;);
    }
}
</code></pre>

<p><code>MyService</code> is a service value, which is attached to both <code>httpEP listener</code> and the new HTTP module Listener.  Previously this was referred as a services name, now it is a final module service variable.</p>
<p>Above code is a syntactic sugar and equal to the following code, which runs at module init time. </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">http:Listener httpEp = new http:Listener(9085);

service MyService = @http:ServiceConfig { basePath : &quot;/hello&quot;} service  {
    resource function hi (http:Caller caller, http:Request req) {
        _ = caller-&gt;respond(&quot;Hello, World!&quot;);
    }
};

check httpEp.attach(MyService ); // if fails, module init fails.
http:Listener anonEP = new http:Listener(9085);
check anonEP.__attache(MyService);
check httpEp.__start();
check anonEP.__start();
</code></pre>

<h2>Decimal type</h2>
<p>Decimal type is a basic, simple type in Ballerina. The decimal type corresponds to the 128-bit IEEE 754-2008 decimal (radix 10) floating point number format. A decimal value has 34 decimal digits of significand and an exponent range of −6143 to +6144.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">decimal d = 4.565;
</code></pre>

<p>Defining a decimal variable is very similar to defining a float variable in Ballerina
By default, all the floating point literals will be treated as float values unless otherwise we explicitly state as decimal</p>
<p>Requirements:
To represent high precision and high scale numbers
Current float type (64 bits) may not be adequate in certain cases
Financial and commercial use cases
Currency representations
To resolve floating point precision error problem exists in float type
Floating-point numbers cannot precisely represent all real numbers
Hence, it leads to many erroneous results when performing arithmetic operations
For example, the below boolean expression would result false when the numbers are represented using float type
       0.1 + 0.2 == 0.3 
// Above would result <code>false</code> if the numbers are represented using <code>float</code>
This is because of the non-representability of 0.1 (0.0001100110011..) and 0.2 (0.001100110011..) in binary
 IEEE 754-2008 Decimal128 format resolves this problem by treating the radix 10 when representing the values</p>
<ul>
<li>Basic functionalities</li>
<li>Addition</li>
<li>Multiplication</li>
<li>Division</li>
<li>Subtraction</li>
<li>Modulus</li>
<li>Negation</li>
<li>Type conversions</li>
<li>float → decimal</li>
<li>decimal → float</li>
<li>int → decimal</li>
<li>decimal → int</li>
<li>Comparisons (==, !=, &gt;, &lt;, &gt;=, &lt;=)</li>
</ul>
<h1>Experimental Language Features</h1>
<p>You can unlock experimental language features with the <code>--experimental</code> flag.</p>
<h2>Micro-Transactions</h2>
<h3>Transaction initiator statement</h3>
<p><code>oncommit</code> and <code>onabort</code> function handlers are removed from the transaction statement and are substituted with committed and aborted blocks.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">transaction with retries = 2 {
    _ = testDB-&gt;update(&quot;Insert into Customers (firstName,lastName,registrationID,creditLimit,country)
                            values ('James', 'Clerk', 200, 5000.75, 'USA')&quot;);
    _ = testDB-&gt;update(&quot;Insert into Customers (firstName,lastName,registrationID,creditLimit,country)
                            values ('James', 'Clerk', 200, 5000.75, 'USA')&quot;);
} onretry {
    returnVal = -1;
} committed {
    committedBlockExecuted = true;
} aborted {
    abortedBlockExecuted = true;
}
</code></pre>

<h3>Transaction participants</h3>
<p>Functions and resource functions can be marked as transaction participants using @transactions:Participant {} annotation from the transactions module. This annotation facilitate registering handler functions that are triggered when the transaction initiator commit or abort.</p>
<p>And panic propagating out of such participant is considered as transaction participant failure when deciding to commit the transaction.</p>
<p>With this introduction of transaction participants, nesting transaction blocks are prohibited, both statically and at runtime.</p>
<h4>Local participants</h4>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">@transactions:Participant {
    oncommit:commitFunc,
    onabort:abortFunc
}
public function participantLocal() {
    string trxId = transactions:getCurrentTransactionId();
    io:println(&quot;In transaction participant of: &quot; + trxId);
    // Simulate participant failure.
    error e = error(&quot;An error&quot;);
    panic e;
} 
</code></pre>

<p>The above code will cause the calling transaction to fail due to the panicking of a participant.</p>
<p>If the participantFoo is called without a transaction, all the transaction related annotations will be ignored for that particular call.</p>
<p><code>oncommit</code> and <code>onabort</code> functions should have the signature of <code>function (string trxId)</code></p>
<h4>Remote participants</h4>
<p>Similar to local transactions we can also annotate resource functions so that they are considered transaction participants. Annotated transaction participants are not allowed to have transaction blocks similar to local participants.</p>
<p>Panic in remote participants will result in transaction failure.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">@transactions:Participant {
    oncommit:commitFunc,
    onabort:abortFunc
}
resource function participantRemote(http:Caller ep, http:Request req) {
    Database(ep, req, false);
}

</code></pre>

<h1>Standard Library</h1>
<h2>HTTP Listener/Client</h2>
<p>With endpoints and service syntax changes, HTTP endpoint and service are changed as follows:</p>
<p>HTTP Listener:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener http:Listener httpEp = new(9090, config = {
    secureSocket: {}
});
</code></pre>

<blockquote>
<p><strong>Note</strong>: Listener endpoint port is the first argument which is a required parameter and other listener configurations go under the second argument. </p>
</blockquote>
<p>Service and resource definition:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">service hello on httpEp {
    resource function sayHello(http:Caller caller, http:Request req) {
        _ = caller-&gt;respond(&quot;hello ballerina!&quot;);
    }
}
</code></pre>

<p>Service can get attached to a listener endpoint that is declared inline as follows.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">service hello on new http:Listener(9090) {
    //...
}

</code></pre>

<p>Client endpoint:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">http:Client clientEndpoint = new(&quot;https://localhost:9092&quot;, config = {
    secureSocket: {}
});

</code></pre>

<blockquote>
<p><strong>Note</strong>: URL is the first argument which is compulsory and other endpoint configurations go under the second argument.</p>
</blockquote>
<h2>Load Balancer</h2>
<p>The Load Balancer exposes an abstract object to allow users to customize the routing decision making(load balancing rule) for special purposes. Only one rule is active at any time and it is specified with the lbRule in the <code>LoadBalanceClientEndpointConfiguration</code> record. By default, round robin rule is used as the load balancing strategy.</p>
<p>Load balancer client endpoint syntax goes as follows.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">http:LoadBalanceClient customLoadBalanceClient = new ({
   targets: [
       { url: &quot;http://localhost:8081/mock&quot; },
       { url: &quot;http://localhost:8082/mock&quot; },
       { url: &quot;http://localhost:8083/mock&quot; },
   ],
   lbRule: customLbRule
});

</code></pre>

<h2>TCP client/server</h2>
<p>TCP server and client are completely redesigned with this release. Now users can use the TCP server similar to the WebSocket listener where there are set of predefined resources to invoke based on actions that take place. TCP client can be used to connect to a remote TCP server for data sending purpose. Additionally, callback service can be attached to the client if there is a data retrieval use case.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">import ballerina/socket;

</code></pre>

<p>Listener:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener socket:Listener server = new ({ port:&lt;PORT_NUMBER&gt; });
service echoServer on server {
    resource function onAccept (socket:Caller caller) { }
    resource function onReadReady (socket:Caller caller, byte[] content) { }
    resource function onClose(socket:Caller caller) { }
    resource function onError(socket:Caller caller, error er) { }
}

</code></pre>

<p>Client:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">socket:Client socketClient = new({host: &quot;localhost&quot;, port: 54387, callbackService: ClientService});
byte[] payloadByte = “Hello Ballerina”.toByteArray(&quot;UTF-8&quot;);
_ = socketClient-&gt;write(payloadByte);

service ClientService = service {
    resource function onConnect(socket:Caller caller) { }
    resource function onReadReady (socket:Caller caller, byte[] content) { }
    resource function onClose(socket:Caller caller) { }
    resource function onError(socket:Caller caller, error er) { }
};

</code></pre>

<p><code>socket:Client/socket:Caller</code> has <code>shutdownRead</code> and <code>shutdownWrite</code> functions available in addition to the write.</p>
<h2>MySQL Client</h2>
<p>MySQL client syntax is changed as follows.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">mysql:Client testDB = new({
        host: &quot;localhost&quot;,
        port: 3306,
        name: &quot;testdb&quot;,
        username: &quot;root&quot;,
        password: &quot;root&quot;,
        poolOptions: { maximumPoolSize: 5 },
        dbOptions: { &quot;useSSL&quot;: false }
    });
</code></pre>

<h2>H2 Database Client</h2>
<p>Compile time validation for InMemory, Server and Embedded Mode configurations are introduced along with the
changes in client syntax changes.</p>
<p>Creating a client in H2 Embedded Mode</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">h2:Client testDB = new({
        path: &quot;/home/ballerina/test/&quot;,
        name: &quot;testdb&quot;,
        username: &quot;SA&quot;,
        password: &quot;&quot;,
        poolOptions: { maximumPoolSize: 5 }
    });
</code></pre>

<p>Creating a client in H2 Server Mode</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">h2:Client testDB = new({
        host: &quot;localhost&quot;,
        port: 9092,
        name: &quot;testdb&quot;,
        username: &quot;SA&quot;,
        password: &quot;&quot;,
        poolOptions: { maximumPoolSize: 5 }
    });
</code></pre>

<p>Creating a client in H2 In-Memory Mode</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">h2:Client testDB = new({
        name: &quot;testdb&quot;,
        username: &quot;SA&quot;,
        password: &quot;&quot;,
        poolOptions: { maximumPoolSize: 5 }
    });
</code></pre>

<h2>gRPC</h2>
<p>gRPC is a protocol that is layered over HTTP/2 and enables client and server communication by combination of any supported languages. In gRPC, a client application can directly call methods on a server application on a different machine, making it easier for you to create distributed applications and services.</p>
<p>With endpoints and service syntax changes, gRPC endpoint and service are changed as follows:</p>
<p>Listener (inbound) endpoint:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener grpc:Listener grpcEp = new (9095, config = {
    secureSocket: {}
});

</code></pre>

<blockquote>
<p><strong>Note</strong>: Listener endpoint port is the first argument and other listener configurations go under the second argument. </p>
</blockquote>
<p>Service and resource definition:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">service Hello on grpcEp {
    resource function hi (grpc:Caller caller, string req) {
        _ = caller-&gt;send(&quot;Hello, World!&quot;);
    }
}

</code></pre>

<p>Client endpoint:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">HelloClient helloEp = new(&quot;https://localhost:9090&quot;, config = {
    secureSocket: {}
});

</code></pre>

<blockquote>
<p><strong>Note</strong>: Server URL is the first argument and other endpoint configurations go under the second argument.</p>
</blockquote>
<p>The contract first approach was introduced for gRPC service creation, which means you first define the service contract (.proto file). From the service contract, you generate stub and sample Ballerina service using the built-in proto compiler. Earlier we followed a code first approach to create a gRPC service, but we depreciated it due to a limitation in ensuring backward compatibility. Instead we recommend contract first approach to create a gRPC service.</p>
<h2>WebSocket</h2>
<p>With endpoints and service syntax changes, WebSocket endpoint and service are changed as follows:</p>
<p>WebSocket Listener:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener http:WebSocketListener helloListener = new(9095, config = {secureSocket: {}});
service onTextString on helloListener {
    resource function onText(http:WebSocketCaller caller, string data, boolean finalFrame) {
        var returnVal = caller-&gt;pushText(data);
           }
}

</code></pre>

<p>WebSocket Client:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">http:WebSocketClient wsClientEp = new(REMOTE_BACKEND_URL, config = { callbackService: clientService });
service clientService = @http:WebSocketServiceConfig {} service {
    resource function onText(http:WebSocketClient caller, string text) {
            var returnVal = caller-&gt;pushText(data); 
    }
}

</code></pre>

<h2>WebSub</h2>
<p>WebSub endpoint and service are changed as follows with the new endpoints and service syntax change</p>
<p>Listener:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener websub:Listener websubEP = new(8181);
</code></pre>

<p>Service and resource definition:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">service websubSubscriber on websubEP {
    resource function onNotification(websub:Notification notification) {
        log:printInfo(&quot;WebSub Notification Received&quot;);
    }
}
</code></pre>

<p>WebSub Hub start up function signature is improved to accept parameters under two categories. 
It accepts an <code>http:Listener</code>, on which the hub service will start on, as the first parameter, 
and a <code>HubListenerConfiguration</code> record as a defaultable parameter to specify hub related configuration.  </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">var webSubHub = websub:startHub(new http:Listener(9090), hubConfiguration = {
            leaseSeconds: 86400
    });

</code></pre>

<p>Improved the hub client by extending configuration to have the complete functionality of the HTTP Client.</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">http:ClientEndpointConfig conf = {
    followRedirects: { enabled: true, maxCount: 5 }
}; 

websub:Client websubHubClientEP = new(&quot;https://localhost:9191/websub/hub&quot;, config = conf);

</code></pre>

<h2>Messaging</h2>
<p>The <code>ballerina/jms</code> module provides an API to connect to an external JMS provider like Ballerina Message Broker or ActiveMQ. This module provides different consumer and producer endpoint types for queues and topics. The endpoints prefixed with “Simple” will automatically create a JMS Connection and a JMS Session when the endpoint is initialized. For other endpoints, the developer must explicitly provide a properly initialized JMS Session.</p>
<p>New syntax for JMS message producer and message receiver is as shown below. </p>
<blockquote>
<p><strong>Note</strong>: JMS Connection and session definitions remain unchanged. </p>
</blockquote>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">jms:Connection conn = new({
            initialContextFactory:&lt;provider specific initial context factory&gt;,
            providerUrl: &lt;provider url&gt;
});

jms:Session jmsSession = new(conn, {
            acknowledgementMode: &quot;AUTO_ACKNOWLEDGE&quot;
        });

</code></pre>

<p>JMS message producer definition:</p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">jms:QueueSender queueSender = new({
        session: jmsSession,
        queueName: &quot;MyQueue&quot;
});

</code></pre>

<p>JMS message receiver, service, and resource definition: </p>
<pre class="line-numbers language-ballerina"><code class="language-ballerina">listener jms:QueueReceiver consumerEndpoint = new({
         session: jmsSession,
             queueName: &quot;MyQueue&quot;
});

service jmsListener on consumerEndpoint {
    resource function onMessage(jms:QueueReceiverCaller consumer, jms:Message message) {
    }
}

</code></pre>

<h1>Tooling</h1>
<h2>IDEs and Language Intelligence</h2>
<p>Added test generation code action for services and functions.</p>
<h2>Design View</h2>
<p>API Designer view was added to edit/design HTTP APIs. Use “Show API Designer” command to activate API Design view in VSCode.</p>
<h2>Network logs inspector</h2>
<h2>Compatibility</h2>
<p>Language Core introduces experimental features and in order to support code intelligence such as auto completion in VSCode Plugin. Enable the <code>Allow Experimental</code> setting in the user settings to experience this.</p>
<h1>Other Improvements</h1>
<h2>Extensions</h2>
<h3>Kubernetes</h3>
<p>The <code>ballerinax/kubernetes</code> module now supports generating Istio gateways and Istio virtual services for Ballerina services. These artifacts can be generated with <code>@kubernetes:IstioGateway</code> and <code>@kubernetes:IstioVirtualService</code> annotations, which allow to deploy services seamlessly to Istio.</p>
<p>All artifacts are now generated into a single YAML file by default. This can be overridden by setting <code>singleYAML: false</code> in the <code>@kubernetes:Deployment</code> annotation.</p>
<h1>Performance results</h1>
<p>Please refer Ballerina <a href="https://github.com/ballerina-platform/ballerina-lang/blob/v0.990.0/performance/benchmarks/summary.md">performance test results</a> available in the repository.</p>
<h1>Bug Fixes</h1>
<p>Please refer to <a href="https://github.com/ballerina-platform/ballerina-lang/issues?q=is%3Aissue+milestone%3A0.990.0+is%3Aclosed+label%3AType%2FBug">GitHub milestone issues</a> to view bug fixes</p>
<h1>SPECIFICATION DEVIATIONS IN 0.990.0 RELEASE</h1>
<h2>Values,Type and Variable</h2>
<h3>Nil</h3>
<p>Use of “null” value in a non-JSON related context is not restricted yet.
An array that contains a nil value has an invalid string representation. </p>
<h3>Int</h3>
<p>Binary Literal are allowed as an integer literal. But it is not part of the 0.990.0 language  specification. This support to be removed from the Compiler in future.</p>
<h3>Float and Decimal</h3>
<p>Two NaN values with different bit patterns are not considered as same at the runtime, but the specification mentioned otherwise. 
In Decimal implicit initial value taken as “0” instead of “+0.0”
For floating point, === means the same member of value space. For example,
NaN === NaN, -0.0 !== +0.0 But this validation gives incorrect results at runtime. </p>
<h3>String</h3>
<p>String values are not iterable in this release.</p>
<h3>Record</h3>
<p>A Required field of a record can have a default value. But 0.990.0 language specification does not allow default values. If a record mapping constructor doesn’t have a value given for such field, then the default value is taken. </p>
<h3>Table</h3>
<p>Table values are not iterable using foreach statement.</p>
<h3>Error</h3>
<p>Detail value of an error is not frozen.
The runtime implementation doesn’t enforce the &ldquo;detail&rdquo; value of an error to be a subtype of <code>map&lt;anydata|error&gt;</code>.</p>
<h3>XML</h3>
<p>In an XML sequence, a character set is treated as a single string. However, in the specification, each character item is represented by a string with a single code point.</p>
<h3>Object</h3>
<p>Error handling in the object initialization method is not supported yet. Only nil returning <code>__init</code> methods are allowed.</p>
<p>This prevents using &ldquo;check&rdquo; expression inside the object initialization function.</p>
<p>Similar to record fields, an Object field can have a default value. Built-in Iterator, Iterable, and Collection abstract object type are not supported yet.</p>
<h3>Singleton Types</h3>
<p>Runtime allows float values as a singleton type.</p>
<p>Defining a variable with singleton type is not allowed. E.g., <code>5 a = 5</code></p>
<h3>Anydata</h3>
<p>In the implementation, a structured value that contains an error value is not considered as &ldquo;anydata&rdquo;.</p>
<h3>Const</h3>
<p>An integer constant reference can’t be used to define the length of an array.</p>
<h3>Freeze</h3>
<p>The compiler doesn&rsquo;t do data flow analysis for frozen value. This results in a panic at run-time if a value is updated after a freeze. </p>
<p><code>'freeze()</code> and <code>isFrozen()</code> are not allowed on nil value.</p>
<h3>Functions</h3>
<p>Falling off an end of a function body will not implicitly return () if the function returns an optional type. Explicit return () statement is required.</p>
<h2>Expressions</h2>
<p>In this release, <code>const</code> support is only added for <code>boolean</code> literals, <code>int</code> literals, floating point literals, and <code>string</code> literals.</p>
<p>The current implementation uses different interpolation syntax <code>{{expr}}</code> instead of <code>${expr}</code> in string templates. Decimal division and remainder operations panic if the second operand is <code>0.0;</code>.</p>
<p>Iiterator, unfrozenClone, and stackTrace built-in methods are not supported yet.</p>
<h2>Binding Patterns</h2>
<p>Error binding pattern is not supported in this release.</p>
<h1>Getting Started</h1>
<p>You can download the Ballerina distributions, try samples, and read the documentation at https://ballerina.io. You can also visit the <a href="https://ballerina.io/learn/quick-tour/">Quick Tour</a> to get started. We encourage you to report issues, improvements, and suggestions at the <a href="https://github.com/ballerina-platform/ballerina-lang">Ballerina Github Repository</a>.</p>
</div>