let contentIndex=[{"page":"/community/slack/","name":"Slack","summary":"Ballerina is an open-source project under  and the work of the Ballerina community.We appreciate your help and participation!Click here: Join the Ballerina community to discuss the project with others. You can:Request an invite below. ...","content":"/  / Slack  Ballerina is an open-source project under and the work of the Ballerina community.  We appreciate your help and participation!  Already a team member?  Click here: If not, join us!  Join the Ballerina community to discuss the project with others. You can:    Talk to the core language team and other members of the community.  Learn from others and ask questions.  Share your work and demos.   Request an invite below.   Email Address"},{"page":"/community/","name":"The Ballerina Community","summary":"The Ballerina community has been bootstrapped by  via sponsorship of the design & implementation of the Ballerina platform. Ballerina is a fully open source project with all source code licensed under the  and the specifications licensed under the  license.We warmly welcome all contributors to the community to ...","content":"/ The Ballerina Community  The Ballerina Community  The Ballerina community has been bootstrapped by via sponsorship of the design & implementation of the Ballerina platform. Ballerina is a fully open source project with all source code licensed under the and the specifications licensed under the license.  We warmly welcome all contributors to the community to help establish Ballerina as a truly community-owned resource!    Try out Ballerina   and try out writing Ballerina code on your own.  Seek for help  We are happy to help! Come engage with us on any channel that works for you.    Report issues  Hit a bump on the road? Report an issue in the relevant repo out of the GitHub repos listed below. We want to fix all bugs!    Compiler, runtime, standard library, or tooling: repo  Language specification: repo  Website: repo  Security flaw: send an email to security@ballerina.io. For details, see the .   Help us grow  Getting a language established is like getting a new religion going. If you like the experience so far, help us to spread the word.    Start by starring the . Thank you!  Follow us on Twitter: . Tweet with the “#ballerinalang” hashtag.  Share the wealth by publishing your Ballerina module on so that the whole community can benefit from your work.  Write your own blog and submit it to be published in our .  Buzz us on if you want to organize a local meetup or hackathon. WSO2 will get right on it and help with presentation/training content, logistics, swag, and some funds for munchies.     Contribute to Ballerina  Join us and contribute to the source code to make Ballerina better! To be aware of the ground rules as you start, see the . Happy contributing!"},{"page":"/code-of-conduct.html","name":"Contributor Covenant Code of Conduct","summary":"This code of conduct aims at establishing a baseline standard of behavior to provide a safe and comfortable environment for all members of the Ballerina community who are originated from different backgrounds.We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless ...","content":"/ The Ballerina Code of Conduct  Contributor Covenant Code of Conduct  This code of conduct aims at establishing a baseline standard of behavior to provide a safe and comfortable environment for all members of the Ballerina community who are originated from different backgrounds.  Our pledge  We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.  We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.  Our standards  Examples of behavior that contributes to creating a positive environment for the Ballerina community include:    Demonstrating empathy and kindness toward other people  Being respectful of differing opinions, viewpoints, and experiences  Giving and gracefully accepting constructive feedback  Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience  Focusing on what is best not just for us as individuals, but for the overall community   Examples of unacceptable behavior by participants include:    The use of sexualized language or imagery, and sexual attention or advances of any kind  Trolling, insulting or derogatory comments, and personal or political attacks  Public or private harassment  Publishing others’ private information, such as a physical or email address, without their explicit permission  Other conduct, which could reasonably be considered inappropriate in a professional setting   Our responsibilities  Project maintainers are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.  Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this code of conduct, and will communicate reasons for moderation decisions when appropriate.  Scope  This code of conduct applies both within project spaces and in public spaces, and also applies when an individual is officially representing the project or its community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.  Enforcement  Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the project team responsible for enforcement at legal@wso2.com. All complaints will be reviewed and investigated promptly and fairly.  All project/community leaders are obligated to respect the privacy and security of the reporter of any incident.  Enforcement guidelines  Project/Community leaders will follow the below Community Impact Guidelines in determining the consequences for any action they deem in violation of this code of conduct:  1. Correction     Community Impact Consequence Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. A private, written warning from project/community leaders providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.     2. Warning     Community Impact Consequence A violation through a single incident or series of actions. A warning with consequences for continued behavior. No interaction with the people involved including unsolicited interaction with those enforcing the code of conduct for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.     3. Temporary ban     Community Impact Consequence A serious violation of community standards including sustained inappropriate behavior. A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved including unsolicited interaction with those enforcing the code of conduct is allowed during this period. Violating these terms may lead to a permanent ban.     4. Permanent ban     Community Impact Consequence Demonstrating a pattern of violation of community standards including sustained inappropriate behavior, harassment of an individual, or aggression towards or disparagement of classes of individuals. A permanent ban from any sort of public interaction within the project community.     Attribution  This code of conduct is adapted from the ."},{"page":"/downloads/","name":"Downloads","summary":"After downloading a release for your system, please follow the installation instructions. For more information, see . If you are building from source, follow the .\n     ...","content":"Downloads  After downloading a release for your system, please follow the installation instructions. For more information, see . If you are building from source, follow the .  Current version: 1.2.3 (April 30, 2020)  If you are already using jBallerina version 1.2.0, you can directly execute following command:  $ ballerina dist update  If you are already using the jBallerina version 1.1.0 - 1.2.0, you can directly update your distribution to jBallerina 1.2.3 by executing the below command:  ballerina dist pull jballerina-1.2.3  For further details, see the .  Installation Packages  Stable 1.2.3 (April 30, 2020)  ballerina-windows-installer-x64-1.2.3.msi  ballerina-linux-installer-x64-1.2.3.deb  ballerina-macos-installer-x64-1.2.3.pkg  ballerina-linux-installer-x64-1.2.3.rpm  ballerina-1.2.3.zip  ballerina-1.2.3.vsix  ballerina-metrics-grafana-dashboard-prometheus.json  ballerina-intellij-idea-plugin"},{"page":"/events/","name":"Events","summary":"OnlineSan Diego, California, USAAustin, Texas, USAPortland, Oregano, USASeattle, Washington, USASão Paulo, BrazilVilnius, LithuaniaVilnius, LithuaniaVilnius, LithuaniaSan Jose, California, USASan Francisco, California, USAMountain View, California, USAParis, FranceSan Jose, California, USALondon, UKAustin, Texas, USABern, SwitzerlandColombo, Sri LankaSan Jose, California, USASan Francisco, California, USAColumbus, USAColumbus, USANew York, USALas Vegas, Nevada, USALas Vegas, Nevada, USA ...","content":"/ Events  Events          Upcoming Events    May 7, 2020  Online  Cloud Native Development with Ballerina  Jadd Jennings, Hub Solutions Engineer, Oracle Cloud Solution Hub  Dhvani Sheth, Senior Solutions Engineer, Oracle  May 28, 2020  San Diego, California, USA  Ballerina – An Open-Source, Cloud-Native Programming Language for Microservices  Anjana Fernando, Director of Developer Relations, WSO2  June 22 - 24, 2020  Austin, Texas, USA  Code to Kubernetes: Languages of Infrastructure  Sameera Jayasoma, Senior Director, WSO2  July 13 - 16, 2020  Portland, Oregano, USA  Intensely Simplify Your Microservices Development with Ballerina  Sameera Jayasoma, Senior Director, WSO2  September 28 - 29, 2020  Seattle, Washington, USA  Code to Kubernetes: Languages of Infrastructure  Sameera Jayasoma, Senior Director, WSO2  December 14 - 16, 2020  São Paulo, Brazil  Nuwan Bandara, Senior Director - Solutions Architecture, WSO2  Past Events    March 26, 2020  Vilnius, Lithuania  [Talk] Code to Cloud  Lakmal Warusawithana, Senior Director of Developer Relations, WSO2  March 25, 2020  Vilnius, Lithuania  [Talk] Ballerina: The Cloud-Native and DevOps Friendly Programming Language  Anjana Fernando, Director of Developer Relations, WSO2  March 24, 2020  Vilnius, Lithuania  [Workshop] Ballerina: Cloud Native Middleware as a Programming Language  Anjana Fernando, Director of Developer Relations, WSO2  March 10, 2020  San Jose, California, USA  Ballerinas & Zebras in Kubernetes  Lakmal Warusawithana, Senior Director of Developer Relations, WSO2  February 12 - 16, 2020  San Francisco, California, USA  Conquering Network-Distributed Applications Using the Ballerina Programming Language  Anjana Fernando, Director of Developer Relations, WSO2  December 12, 2019  Mountain View, California, USA  An Introduction to the Ballerina Programming Language  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  December 10 - 11, 2019  Paris, France  Ballerina - A Modern Cloud-based Open Source Programming Language  Paul Fremantle, CTO and Co-founder, WSO2  December 5, 2019  San Jose, California, USA  Ballerina - A Programming Language for Cloud and DevOps  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  November 7, 2019  London, UK  Ballerina — Cloud-native Middleware as a Programming Language  Mauro Niewolski, Senior Solutions Engineer, WSO2  November 5 - 7, 2019  Austin, Texas, USA  Microservices in Practice with Ballerina, Kubernetes and Istio  Lakmal Warusawithana, Senior Director of Developer Relations - CTO Office, WSO2  November 5, 2019  Bern, Switzerland  Ballerina — Cloud-native Middleware as a Programming Language  Paul Fremantle, CTO and Co-founder, WSO2  November 5, 2019  Colombo, Sri Lanka  The better java for Java microservice developers  Sanjiva Weerawarana, Founder and CEO, WSO2  October 8 - 10, 2019  San Jose, California, USA  Efficient Microservices Deployment Pipelines  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  October 8, 2019  San Francisco, California, USA  Ballerina — Cloud-native Middleware as a Programming Language  Sameera Jayasoma, Senior Director, WSO2  September 26, 2019  Columbus, USA  Effective Microservices Development with Ballerina  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  September 26, 2019  Columbus, USA  Ballerina in Real-World Use-Case  Glenn Donaldson & Jim Kittle, Ohio State University  September 24, 2019  New York, USA  Ballerina - Cloud Native Middleware as a Programming Language  Lakmal Warusawithana, Senior Director of Developer Relations - CTO Office, WSO2  September 9 - 12, 2019  Las Vegas, Nevada, USA  Ballerina - Re-inventing Middleware in a Programming Language  Paul Fremantle, CTO and Co-founder, WSO2  September 9 - 12, 2019  Las Vegas, Nevada, USA  Conquering Network Distributed Applications Using the Ballerina Programming Language  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2"},{"page":"/","name":"Ballerina is an open source programming language and platform for cloud-era application programmers to easily write software that just works.","summary":"\"A programming language that doesn't change the way you think about programming is not worth knowing.\" For decades, programming languages have treated networks simply as I/O sources. Ballerina introduces fundamental, new abstractions of client objects, services, resource functions, and listeners to bring networking into the language so that programmers can ...","content":"\"A programming language that doesn't change the way you think about programming is not worth knowing.\" Ballerina is an open source programming language and platform for cloud-era application programmers to easily write software that just works.  Why Ballerina  The Network in the Language  For decades, programming languages have treated networks simply as I/O sources. Ballerina introduces fundamental, new abstractions of client objects, services, resource functions, and listeners to bring networking into the language so that programmers can directly address the as part of their application logic. This facilitates resilient, secure, performant network applications to be within every programmer’s reach.  Sequence Diagrams for Programming  Sequence diagrams have been everyone’s favorite tool to describe how distributed & concurrent programs work. Yet, no current programming language lets you write your logic as a sequence diagram. In Ballerina, every program is a sequence diagram that illustrates distributed and concurrent interactions automatically. The diagram is the code. The code is the diagram.  Structural, Open-by-Default Typing  Static typing is the network application programmer’s development headache and dynamic typing is the reliability engineer’s nightmare. Ballerina’s statically-typed, structural type system that is designed to be network data schema friendly allows application programmers to write code that adheres to the : Be conservative in what you send, be liberal in what you accept.  From Code to Cloud  In the cloud-era, running a program is no longer just a matter of compiling and executing but rather it is about compiling, building the image, pushing the image, configuring container orchestration, and .. eventually running. Ballerina brings the entire program execution process to the hands of the developer with extensible metadata that gets compiled to runnable programs for all major cloud platforms. You code, we cloud!  Batteries Included  Today’s network is democratized! HTTPS to HTTP/2 to WebSockets to WebSub to AMQP to JSON to XML to ProtoBuf to gRPC to OpenAPI to plain old bytes - Ballerina has it all in the standard library and toolchain to help developers rapidly build applications. At development time, Ballerina covers documentation, testing, sharing, versioning, and more. We plumb, you build!  Developer First  Programs in the real world are written once and read tens to hundreds of times. Whenever possible, Ballerina prioritizes programmer convenience & productivity with familiarity, clearer abstractions, and easier concepts over uber system performance. Today, hardware is cheap, we programmers are not and time to market is everything."},{"page":"/learn/api-docs/ballerina/auth/objects/InboundAuthProvider.html","name":"Object - : InboundAuthProvider","summary":"Represents the inbound Auth provider, which could be used to authenticate endpoints. The auth:InboundAuthProvider acts\nas the interface for ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  InboundAuthProvider  Represents the inbound Auth provider, which could be used to authenticate endpoints. The auth:InboundAuthProvider acts as the interface for all the inbound authentication providers. Any type of implementation such as JWT, OAuth2, LDAP, JDBC, file-based etc. should be object-wise similar.   Methods  Authenticates the user based on the user credentials (i.  authenticate (string credential)  returns boolean | Authenticates the user based on the user credentials (i.e., the username/password) or a token such as JWT or OAuth2.   Parameters  credential string The string credential value   Return Type (boolean | )  true if the authentication is successful, false otherwise, or else an auth:Error in case of an error"},{"page":"/learn/api-docs/ballerina/auth/objects/InboundBasicAuthProvider.html","name":"Object - : InboundBasicAuthProvider","summary":"Represents the configuration file based inbound Basic Auth provider, which is an implementation of the\nauth:InboundAuthProvider interface.\n(? basicAuthConfig)Basic Auth ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  InboundBasicAuthProvider  Represents the configuration file based inbound Basic Auth provider, which is an implementation of the auth:InboundAuthProvider interface.  auth:InboundBasicAuthProvider inboundBasicAuthProvider = new;  A user is denoted by a section in the Ballerina configuration file. The password and the scopes assigned to the user are denoted as keys under the relevant user section as shown below.  [b7a.users.<username>]  password=\"<password>\"  scopes=\"<comma_separated_scopes>\"    Constructor __init(? basicAuthConfig)   basicAuthConfig ? ()  Basic Auth provider configurations   Methods  Attempts to authenticate the base64-encoded username:password credentials.  Fields  basicAuthConfig  The Basic Auth provider configurations   authenticate (string credential)  returns boolean | Attempts to authenticate the base64-encoded username:password credentials.  boolean|auth:Error authenticationResult = inboundBasicAuthProvider.authenticate(\"<credential>\");    Parameters  credential string Base64-encoded username:password value   Return Type (boolean | )  true if the authentication is successful, false otherwise, or else an auth:Error occurred while authenticating the credentials"},{"page":"/learn/api-docs/ballerina/auth/objects/OutboundAuthProvider.html","name":"Object - : OutboundAuthProvider","summary":"Represents the outbound Auth provider, which could be used to authenticate external endpoints. Any type of\nimplementation such as ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  OutboundAuthProvider  Represents the outbound Auth provider, which could be used to authenticate external endpoints. Any type of implementation such as JWT, OAuth2, LDAP, JDBC, file-based etc. should be object-wise similar to the auth:OutboundAuthProvider object.   Methods  Generates an authentication token for the outbound request with outbound Auth providers such as JWT and OAuth2.  Inspects the incoming data and generates the authentication token as needed.  generateToken ()  returns string | Generates an authentication token for the outbound request with outbound Auth providers such as JWT and OAuth2.   Return Type (string | )  The token as a string or else an auth:Error occurred when generating the token   inspect (map data)  returns string | | () Inspects the incoming data and generates the authentication token as needed. For example, if the incoming data indicates that it needs to regenerate the token because the previously-generated token is invalid, this method will generate it.   Parameters  data map Map of data, which is extracted from the HTTP response   Return Type (string | | ())  The token as a string, an auth:Error occurred when generating the token, or else () if nothing is to be returned"},{"page":"/learn/api-docs/ballerina/auth/objects/OutboundBasicAuthProvider.html","name":"Object - : OutboundBasicAuthProvider","summary":"Represents the outbound Basic Auth authenticator, which is an implementation of the auth:OutboundAuthProvider interface.\nThis uses the usernames and ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  OutboundBasicAuthProvider  Represents the outbound Basic Auth authenticator, which is an implementation of the auth:OutboundAuthProvider interface. This uses the usernames and passwords provided by the Ballerina configurations to authenticate external endpoints.  auth:OutboundBasicAuthProvider outboundBasicAuthProvider = new({  username: \"tom\",  password: \"123\"  });    Constructor __init(? credential)   credential ? ()  Credential configurations   Methods  Generates a token for Basic authentication.  Inspects the incoming data and generates the token for Basic authentication.  Fields  credential  ?  auth:Credential configurations   generateToken ()  returns string | Generates a token for Basic authentication.  string|auth:Error token = outboundBasicAuthProvider.generateToken();    Return Type (string | )  The generated token or else an auth:Error occurred during the validation   inspect (map data)  returns string | | () Inspects the incoming data and generates the token for Basic authentication.   Parameters  data map Map of the data, which is extracted from the HTTP response.   Return Type (string | | ())  The token as a string, an auth:Error occurred when generating the token, or else () if nothing is to be returned"},{"page":"/learn/api-docs/ballerina/auth/","name":"Module : auth","summary":"This module provides the default authentication provider configurations, which can be extended to create new authentication providers.For information on the operations, which you can perform with this module, see the below Objects. For examples on the usage of the operations, see the  and . ...","content":"v1.2.2  All Modules  Module : auth  Module Overview This module provides the default authentication provider configurations, which can be extended to create new authentication providers. For information on the operations, which you can perform with this module, see the below Objects. For examples on the usage of the operations, see the and .    Records Represents the inbound Basic Authentication configurations.  Represents the Basic Authentication configurations, which are used by the HTTP endpoint.  Record type to hold the details of an error.  Objects Represents the inbound Auth provider, which could be used to authenticate endpoints.  Represents the configuration file based inbound Basic Auth provider, which is an implementation of the auth:InboundAuthProvider interface.  Represents the outbound Auth provider, which could be used to authenticate external endpoints.  Represents the outbound Basic Auth authenticator, which is an implementation of the auth:OutboundAuthProvider interface.  Functions Checks whether the scopes of the user match the scopes of the resource.  Extracts the username and the password from the base64-encoded username:password value.  Sets the authentication-related values (scheme, auth token) to the authentication context of the invocation context.  Sets the authentication-related values (user ID, username, scopes, claims) to the principal of the invocation context.  Constants Represents the Auth error reason.  Default charset to be used with password hashing.  Prefix used to denote special configuration values.  Prefix used to denote that the config value is a SHA-256 hash.  Prefix used to denote that the config value is a SHA-384 hash.  Prefix used to denote that the config value is a SHA-512 hash.  Prefix used to denote Basic Authentication scheme.  The prefix used to denote the Bearer Authentication scheme.  Errors Represents the Auth error type with details."},{"page":"/learn/api-docs/ballerina/auth/functions.html","name":"Functions -","summary":"(string[] | string[][] resourceScopes, string[] userScopes, string authzCacheKey, ? positiveAuthzCache, ? negativeAuthzCache)Checks whether the scopes of the user match the scopes of the resource.\nScopes of the resourceScopes of the userAuthorization cache keyThe cache:Cache for positive authorizationsThe cache:Cache for negative authorizationstrue if there is a match between the resource and user ...","content":"Functions  v1.2.2  All Modules  Functions - Checks whether the scopes of the user match the scopes of the resource.  Extracts the username and the password from the base64-encoded username:password value.  Sets the authentication-related values (scheme, auth token) to the authentication context of the invocation context.  Sets the authentication-related values (user ID, username, scopes, claims) to the principal of the invocation context.  checkForScopeMatch (string[] | string[][] resourceScopes, string[] userScopes, string authzCacheKey, ? positiveAuthzCache, ? negativeAuthzCache)  returns boolean Checks whether the scopes of the user match the scopes of the resource.   Parameters  resourceScopes string[] | string[][] Scopes of the resource   userScopes string[] Scopes of the user   authzCacheKey string Authorization cache key   positiveAuthzCache ? The cache:Cache for positive authorizations   negativeAuthzCache ? The cache:Cache for negative authorizations   Return Type (boolean)  true if there is a match between the resource and user scopes or else false otherwise   extractUsernameAndPassword (string credential)  returns [string, string] | Extracts the username and the password from the base64-encoded username:password value.  [string, string]|auth:Error [username, password] = auth:extractUsernameAndPassword(\"<credential>\");    Parameters  credential string Base64-encoded username:password value   Return Type ([string, string] | )  A string tuple with the extracted username and password or else an auth:Error occurred while extracting credentials   setAuthenticationContext Sets the authentication-related values (scheme, auth token) to the authentication context of the invocation context.  auth:setAuthenticationContext(\"jwt\", \"<credential>\");    Parameters  scheme string Auth scheme (JWT, LDAP, OAuth2, Basic, etc.)   authToken string Auth token (credential)   setPrincipal Sets the authentication-related values (user ID, username, scopes, claims) to the principal of the invocation context.   Parameters  userId string? (default ())  User ID of the authenticated user   username string? (default ())  Username of the authenticated user   scopes string[]? (default ())  Authenticated user scopes   claims map? (default ())  Claims of the authenticated user"},{"page":"/learn/api-docs/ballerina/auth/records/BasicAuthConfig.html","name":"Record - : BasicAuthConfig","summary":"Represents the inbound Basic Authentication configurations.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : BasicAuthConfig  Represents the inbound Basic Authentication configurations.   Fields  tableName  string  The table name specified in the user-store TOML configuration"},{"page":"/learn/api-docs/ballerina/auth/records/Credential.html","name":"Record - : Credential","summary":"Represents the Basic Authentication configurations, which are used by the HTTP endpoint.\n\n       ...","content":"Records  v1.2.2  All Modules  Record - : Credential  Represents the Basic Authentication configurations, which are used by the HTTP endpoint.   Fields  username  string  Username for Basic authentication   password  string  Password for Basic authentication"},{"page":"/learn/api-docs/ballerina/auth/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/cache/functions.html","name":"Functions -","summary":"Adds a node to the start of the provided linked list.\nLinked list to which the provided node should be addedThe node, which should be added to the provided linked listAdds a node to the end of the provided linked list.\nLinked list to which the provided node should be addedThe node, ...","content":"Functions  v1.2.2  All Modules  Functions - Adds a node to the start of the provided linked list.  Adds a node to the end of the provided linked list.  Clears the provided linked list.  Removes a node from the provided linked list.  Removes the last node from the provided linked list.  addFirst Adds a node to the start of the provided linked list.   Parameters  list Linked list to which the provided node should be added   node The node, which should be added to the provided linked list   addLast Adds a node to the end of the provided linked list.   Parameters  list Linked list to which the provided node should be added   node The node, which should be added to the provided linked list   clear Clears the provided linked list.   Parameters  list Linked list which should be cleared   remove Removes a node from the provided linked list.   Parameters  list Linked list from which the provided node should be removed   node The node, which should be removed from the provided linked list   removeLast ( list)  returns ? Removes the last node from the provided linked list.   Parameters  list Linked list from which the last node should be removed   Return Type (?)  Last node of the provided linked list or () if the last node is empty"},{"page":"/learn/api-docs/ballerina/cache/","name":"Module : cache","summary":"This module provides APIs for handle caching in Ballerina. It consists of a default implementation based on the map data structure. It also provides a default cache eviction policy object, which is based on the LRU eviction algorithm.The cache:AbstractCache object has the common APIs for the caching functionalities. Custom implementations ...","content":"v1.2.2  All Modules  Module : cache  Module Overview This module provides APIs for handle caching in Ballerina. It consists of a default implementation based on the map data structure. It also provides a default cache eviction policy object, which is based on the LRU eviction algorithm. The cache:AbstractCache object has the common APIs for the caching functionalities. Custom implementations of the cache can be done with different data storages like file, database, etc. with the structural equivalency to the cache:AbstractCacheObject object. public type AbstractCache abstract object {  public function put(string key, any value, int maxAgeInSeconds) returns Error?;  public function get(string key) returns any|Error;  public function invalidate(string key) returns Error?;  public function invalidateAll() returns Error?;  public function hasKey(string key) returns boolean;  public function keys() returns string[];  public function size() returns int;  public function capacity() returns int; };  The cache:AbstractEvictionPolicy object has the common APIs for the cache eviction functionalities. Custom implementations of the eviction policy can be done by maintaining the cache:LinkedList data structure according to the eviction algorithm. public type AbstractEvictionPolicy abstract object {  public function get(LinkedList list, Node node);  public function put(LinkedList list, Node node);  public function remove(LinkedList list, Node node);  public function replace(LinkedList list, Node newNode, Node oldNode);  public function clear(LinkedList list);  public function evict(LinkedList list) returns Node?; };  The Ballerina Cache module provides the cache:Cache object, which is a map data structure based implementation of the cache:AbstractCache object. It is not recommended to insert () as the value of the cache since it doesn't make sense to cache a nil. Also, it provides the cache:LruEvictionPolicy object, which is based on the LRU eviction algorithm. While initializing the cache:Cache, you need to pass the following parameters as the cache configurations.  capacity - Maximum number of entries allowed for the cache evictionPolicy - The policy to define the cache eviction algorithm evictionFactor - The factor by which the entries will be evicted once the cache is full defaultMaxAgeInSeconds - Freshness time of all the cache entries in seconds. This value can be overwritten by the maxAgeInSeconds property when inserting an entry to the cache. '-1' means the entries are valid forever. cleanupIntervalInSeconds - The interval time of the timer task, which cleans the cache entries This is an optional parameter.  For a better user experience, the above-mentioned configuration is initialized with the below default values: public type CacheConfig record {|  int capacity = 100;  AbstractEvictionPolicy evictionPolicy = new LruEvictionPolicy();  float evictionFactor = 0.25;  int defaultMaxAgeInSeconds = -1;  int cleanupIntervalInSeconds?; |};  There are 2 mandatory scenarios and 1 optional scenario in which a cache entry gets removed from the cache and maintains the freshness of the cache entries. The 2 independent factors (i.e., eviction policy and freshness time of the cache entry) governs the 3 scenarios.  When using the get API, if the returning cache entry has expired, it gets removed. When using the put API, if the cache size has reached its capacity, the number of entries get removed based on the 'eviction policy' and the 'eviction factor'. If cleanupIntervalInSeconds (optional property) is configured, the timer task will remove the expired cache entries based on the configured interval.  The main benefit of using the cleanupIntervalInSeconds (optional) property is that the developer can optimize the memory usage while adding some additional CPU costs and vice versa. The default behaviour is the CPU-optimized method. The concept of the default cache:Cache object is based on the Ballerina map data structure and the cache:LinkedList data structure. The key of the map entry would be a string and the value of the map entry would be a node of the linked list. public type Node record {|  any value;  Node? prev = ();  Node? next = (); |};  While using the cache, a cache:CacheEntry record will be created and added as the value of the cache:Node record. The cache:Node record will be inserted into the map data structure with the provided string key. type CacheEntry record {|  string key;  any data;  int expTime; |};  A linked list is used for the eviction of the cache. According to the user-configured eviction policy, when inserting / updating / retrieving cache entries, the linked list will be updated. Therefore, when an eviction happens, cache entries can be removed efficiently without iterating the complete map data structure. Example: If the eviction policy is LRU, the MRU item will always be the head of the linked list. When an eviction happens, nodes from the tail will be deleted without iterating the map. Furthermore, you can implement custom caching implementations based on different cache storage mechanisms (file, database. etc.) and different eviction policies (MRU, FIFO, etc.). Ballerina provides a \"map-based cache\" as the default cache implementation. For information on the operations, which you can perform with the cache module, see the below Functions. For examples on the usage of the operations, see Records Represents configurations for the cache:Cache object.  Record type to hold the details of an error.  Represents a linked list, which is used to govern the cache eviction policy.  Represents a structure to keep data and references to the adjacent nodes of the linked list.  Objects The cache:AbstractCache object is used for custom implementations of the Ballerina cache.  The cache:AbstractEvictionPolicy Ballerina object is used for custom implementations of the eviction policy for a Ballerina cache object.  The cache:Cache object, which is used for all the cache-related operations.  The cache:LruEvictionPolicy object consists of the LRU eviction algorithm related operations based on a linked list data structure.  Functions Adds a node to the start of the provided linked list.  Adds a node to the end of the provided linked list.  Clears the provided linked list.  Removes a node from the provided linked list.  Removes the last node from the provided linked list.  Constants Represents the reason for the cache:Error.  Errors Represents the Cache error type with details."},{"page":"/learn/api-docs/ballerina/cache/objects/AbstractCache.html","name":"Object - : AbstractCache","summary":"The cache:AbstractCache object is used for custom implementations of the Ballerina cache.\nAny custom cache implementation should be object-wise ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  AbstractCache  The cache:AbstractCache object is used for custom implementations of the Ballerina cache. Any custom cache implementation should be object-wise similar.   Methods  Adds the given key value pair to the cache.  Returns the cached value associated with the provided key.  Discards a cached value from the cache.  Discards all the cached values from the cache.  Checks whether the given key has an associated cache value.  Returns all keys from the cache.  Returns the current size of the cache.  Returns the capacity of the cache.  put (string key, any value, int maxAgeInSeconds)  returns ? Adds the given key value pair to the cache. If the cache previously contained a value associated with the key, the old value is replaced by the new value.   Parameters  key string Key of the value to be cached   value any Value to be cached   maxAgeInSeconds int (default -1)  The time in seconds during which the cache entry is valid. '-1' means, the entry is valid forever   Return Type (?)  () if successfully added to the cache or Error if any error occurred while inserting the entry to the cache   get (string key)  returns any | Returns the cached value associated with the provided key.   Parameters  key string The key used to retrieve the cached value   Return Type (any | )  The cached value associated with the given key or an Error if the provided cache key is not available or if any error occurred while retrieving from the cache   invalidate (string key)  returns ? Discards a cached value from the cache.   Parameters  key string Key of the cache entry which needs to be discarded   Return Type (?)  () if successfully discarded or an Error if the provided cache key is not available or if any error occurred while discarding from the cache   invalidateAll ()  returns ? Discards all the cached values from the cache.   Return Type (?)  () if successfully discarded all or an Error if any error occurred while discarding all from the cache   hasKey (string key)  returns boolean Checks whether the given key has an associated cache value.   Parameters  key string The key to be checked   Return Type (boolean)  true if an associated cache value is available for the provided key or false if there is not a cache value associated with the provided key   keys ()  returns string[] Returns all keys from the cache.   Return Type (string[])  Array of all the keys from the cache   size ()  returns int Returns the current size of the cache.   Return Type (int)  The size of the cache   capacity ()  returns int Returns the capacity of the cache.   Return Type (int)  The capacity of the cache"},{"page":"/learn/api-docs/ballerina/cache/objects/AbstractEvictionPolicy.html","name":"Object - : AbstractEvictionPolicy","summary":"The cache:AbstractEvictionPolicy Ballerina  object is used for custom implementations of the eviction policy for a\nBallerina cache object. ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  AbstractEvictionPolicy  The cache:AbstractEvictionPolicy Ballerina object is used for custom implementations of the eviction policy for a Ballerina cache object. Any custom eviction policy implementation should be object-wise similar.   Methods  Updates the linked list based on the get operation.  Updates the linked list based on the put operation.  Updates the linked list based on the remove operation.  Updates the linked list based on the replace operation.  Updates the linked list based on the clear operation.  Updates the linked list based on the evict operation.  get Updates the linked list based on the get operation.   Parameters  list Linked list data structure, which is used to govern the eviction policy   node Node of the linked list, which is retrieved   put Updates the linked list based on the put operation.   Parameters  list Linked list data structure, which is used to govern the eviction policy   node Node of the linked list, which is added newly   remove Updates the linked list based on the remove operation.   Parameters  list Linked list data structure, which is used to govern the eviction policy   node Node of the linked list, which is deleted   replace Updates the linked list based on the replace operation.   Parameters  list Linked list data structure, which is used to govern the eviction policy   newNode Node of the linked list, which will be replacing the oldNode   oldNode Node of the linked list, which will be replaced by the newNode   clear Updates the linked list based on the clear operation.   Parameters  list Linked list data structure, which is used to govern the eviction policy   evict ( list)  returns ? Updates the linked list based on the evict operation.   Parameters  list Linked list data structure, which is used to govern the eviction policy   Return Type (?)  The Node, which is evicted from the linked list or () if nothing to be evicted"},{"page":"/learn/api-docs/ballerina/cache/objects/Cache.html","name":"Object - : Cache","summary":"The cache:Cache object, which is used for all the cache-related operations. It is not recommended to insert ()\nas ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  Cache  The cache:Cache object, which is used for all the cache-related operations. It is not recommended to insert () as the value of the cache since it doesn't make any sense to cache a nil.   Constructor __init( cacheConfig)   cacheConfig {}  Configurations for the cache:Cache object   Methods  Adds the given key value pair to the cache.  Returns the cached value associated with the provided key.  Discards a cached value from the cache.  Discards all the cached values from the cache.  Checks whether the given key has an associated cached value.  Returns a list of all the keys from the cache.  Returns the size of the cache.  Returns the capacity of the cache.  put (string key, any value, int maxAgeInSeconds)  returns ? Adds the given key value pair to the cache. If the cache previously contained a value associated with the provided key, the old value wil be replaced by the newly-provided value.   Parameters  key string Key of the value to be cached   value any Value to be cached. Value should not be ()   maxAgeInSeconds int (default -1)  The time in seconds for which the cache entry is valid. If the value is '-1', the entry is valid forever.   Return Type (?)  () if successfully added to the cache or Error if a () value is inserted to the cache.   get (string key)  returns any | Returns the cached value associated with the provided key.   Parameters  key string Key of the cached value, which should be retrieved   Return Type (any | )  The cached value associated with the provided key or an Error if the provided cache key is not exisiting in the cache or any error occurred while retrieving the value from the cache.   invalidate (string key)  returns ? Discards a cached value from the cache.   Parameters  key string Key of the cache value, which needs to be discarded from the cache   Return Type (?)  () if successfully discarded the value or an Error if the provided cache key is not present in the cache or if any error occurred while discarding the value from the cache.   invalidateAll ()  returns ? Discards all the cached values from the cache.   Return Type (?)  () if successfully discarded all the values from the cache or an Error if any error occurred while discarding all the values from the cache.   hasKey (string key)  returns boolean Checks whether the given key has an associated cached value.   Parameters  key string The key to be checked in the cache   Return Type (boolean)  true if a cached value is available for the provided key or false if there is no cached value associated for the given key   keys ()  returns string[] Returns a list of all the keys from the cache.   Return Type (string[])  Array of all the keys from the cache   size ()  returns int Returns the size of the cache.   Return Type (int)  The size of the cache   capacity ()  returns int Returns the capacity of the cache.   Return Type (int)  The capacity of the cache"},{"page":"/learn/api-docs/ballerina/cache/objects/LruEvictionPolicy.html","name":"Object - : LruEvictionPolicy","summary":"The cache:LruEvictionPolicy object consists of the LRU eviction algorithm related operations based on a linked\nlist data structure.\n\n  ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  LruEvictionPolicy  The cache:LruEvictionPolicy object consists of the LRU eviction algorithm related operations based on a linked list data structure.   Methods  Updates the linked list based on the get operation related to the LRU eviction algorithm.  Updates the linked list based on the put operation related to the LRU eviction algorithm.  Updates the linked list based on the remove operation related to the LRU eviction algorithm.  Updates the linked list based on the replace operation related to the LRU eviction algorithm.  Updates the linked list based on the clear operation related to the LRU eviction algorithm.  Updates the linked list based on the evict operation.  get Updates the linked list based on the get operation related to the LRU eviction algorithm.   Parameters  list Linked list data structure, which is used to govern the eviction policy   node Node of the linked list, which is retrieved   put Updates the linked list based on the put operation related to the LRU eviction algorithm.   Parameters  list Linked list data structure, which is used to govern the eviction policy   node Node of the linked list, which is added newly   remove Updates the linked list based on the remove operation related to the LRU eviction algorithm.   Parameters  list Linked list data structure, which is used to govern the eviction policy   node Node of the linked list, which is deleted   replace Updates the linked list based on the replace operation related to the LRU eviction algorithm.   Parameters  list Linked list data structure, which is used to govern the eviction policy   newNode Node of the linked list, which will be replacing the oldNode   oldNode Node of the linked list, which will be replaced by the newNode   clear Updates the linked list based on the clear operation related to the LRU eviction algorithm.   Parameters  list Linked list data structure, which is used to govern the eviction policy   evict ( list)  returns ? Updates the linked list based on the evict operation.   Parameters  list Linked list data structure, which is used to govern the eviction policy   Return Type (?)  The Node, which is evicted from the linked list or () if nothing to be evicted"},{"page":"/learn/api-docs/ballerina/cache/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error.   cause  error  Any other error, which causes this error."},{"page":"/learn/api-docs/ballerina/cache/records/CacheConfig.html","name":"Record - : CacheConfig","summary":"Represents configurations for the cache:Cache object.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : CacheConfig  Represents configurations for the cache:Cache object.   Fields  capacity  int  (default 100) Maximum number of entries allowed in the cache   evictionPolicy  (default ) The policy, which defines the cache eviction algorithm   evictionFactor  float  (default 0.25) The factor by which the entries will be evicted once the cache is full   defaultMaxAgeInSeconds  int  (default -1) The default value in seconds which all the cache entries are valid. '-1' means, the entries are valid forever. This will be overwritten by the the maxAgeInSeconds property set when inserting item to the cache   cleanupIntervalInSeconds  int  Interval of the timer task, which will clean up the cache"},{"page":"/learn/api-docs/ballerina/cache/records/Node.html","name":"Record - : Node","summary":"Represents a structure to keep data and references to the adjacent nodes of the linked list.\n\n   ...","content":"Records  v1.2.2  All Modules  Record - : Node  Represents a structure to keep data and references to the adjacent nodes of the linked list.   Fields  value  any  Value to be stored in the linked list node   prev  ?  (default ()) Previous node of the linked list   next  ?  (default ()) Next node of the linked list"},{"page":"/learn/api-docs/ballerina/cache/records/LinkedList.html","name":"Record - : LinkedList","summary":"Represents a linked list, which is used to govern the cache eviction policy.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : LinkedList  Represents a linked list, which is used to govern the cache eviction policy.   Fields  head  ?  The first node of the linked list   tail  ?  The last node of the linked list"},{"page":"/learn/api-docs/ballerina/config/","name":"Module : config","summary":"This module provides the Config API to read configurations from environment variables, TOML files, and command-line parameters and build a consolidated set of configurations.The precedence order for configuration lookup is as follows:This configuration resolution happens at the start of the program execution. Configurations can be set programmatically as well.The Config ...","content":"v1.2.2  All Modules  Module : config  Module Overview This module provides the Config API to read configurations from environment variables, TOML files, and command-line parameters and build a consolidated set of configurations. The precedence order for configuration lookup is as follows:  CLI arguments (used with the --) Environment variables Configuration files in the TOML format  This configuration resolution happens at the start of the program execution. Configurations can be set programmatically as well. The Config API provides the capability to feed sensitive data (e.g., passwords) to Ballerina programs securely by encrypting them. Setting configurations To specify a configuration file explicitly, the --b7a.config.file=<path to configuration file> property can be used. If this property is not set when running a project, Ballerina looks for a ballerina.conf file in the project root. When running a single file or a .jar, it's picked from the same directory in which the .jar or source resides. The path to the configuration file can either be an absolute or a relative path. ballerina run my-program.bal --b7a.config.file=/path/to/conf/file/custom-config-file-name.conf A configuration file should conform to the TOML format. Ballerina only supports the following features of TOML: value types (string, int, float and boolean), tables, and nested tables. Given below is a sample: [b7a.http.tracelog] console=true path=\"./trace.log\"  [b7a.http.accesslog] console=true path=\"./access.log\"  A key given inside a bracket forms a namespace. Any configuration that is specified between two such keys belongs to the namespace of the first of these keys. To access a configuration in a namespace, the fully qualified key should be given (e.g., b7a.http.tracelog.path). The following types can be given through a configuration file: string, int, float, and boolean. If the configuration value is not an int, float, or a boolean, it is considered a string and should always be quoted. The same configs can be set using CLI parameters as follows. ballerina run my-program.bal --b7a.http.tracelog.console=true --b7a.http.tracelog.path=./trace.log  --b7a.http.accesslog.console=true --b7a.http.accesslog.path=./access.log  Configurations in a file can be overridden by environment variables. To override a particular configuration, an environment variable that matches the configuration key must be set. As periods are not allowed in environment variables, periods in a configuration key should be replaced by underscores. // In Linux and Mac. $ export b7a_http_tracelog_path=”./trace.log” $ export b7a_http_accesslog_path=”./access.log”  // In Windows. $ set(x) b7a_http_tracelog_path=”./trace.log” $ set(x) b7a_http_accesslog_path=”./access.log”  If the configurations need to be shared during runtime, they can be set using the setConfig() function. config:setConfig(\"john.country\", \"USA\");  Reading configurations The API provides functions to read configurations in their original type. Check function descriptors for example usages. A set of configurations belonging to a particular namespace can be retrieved as a map using the getAsMap() function. Here is an example: [b7a.http.tracelog] console=true path=\"./trace.log\" host=\"@env:{TRACE_LOG_READER_HOST}\" port=5757  [b7a.http.accesslog] console=true path=\"./access.log\"  The configurations for HTTP trace logs can be retrieved as a map as follows: // Reads a configuration section as a map. // Here, the map’s key-value pairs represent config key-value pairs. map<anydata> serverAlphaMap = config:getAsMap(\"b7a.http.tracelog\");  In the above configuration file, the host is specified as @env:{TRACE_LOG_READER_HOST}. When resolving the configurations, Ballerina looks for a variable named TRACE_LOG_READER_HOST in the environment variables and maps b7a.http.tracelog.host to its value. If the specified environment variable does not exist, it will will treat @env:{TRACE_LOG_READER_HOST} as a normal string value. Securing configuration values Sensitive values can be encrypted using the encrypt command as follows: $ ballerina encrypt Enter value: Enter secret: Re-enter secret to verify: Add the following to the runtime config: @encrypted:{JqlfWNWKM6gYiaGnS0Hse1J9F/v48gUR0Kxfa5gwjcM=}  Or add the following to the runtime command-line: -e<param>=@encrypted:{JqlfWNWKM6gYiaGnS0Hse1J9F/v48gUR0Kxfa5gwjcM=}  This encrypted value can then be placed in a configuration file or provided as a CLI parameter. [admin] password=”@encrypted:{JqlfWNWKM6gYiaGnS0Hse1J9F/v48gUR0Kxfa5gwjcM=}”  Reading config files with encrypted values When trying to run a Ballerina program with a configuration file or CLI parameters that contain encrypted values, Ballerina will first check to see if the b7a.config.secret configuration is set. This configuration is used to set the path to a file containing the secret required to decrypt the configurations. If it is set, the secret is read, and the secret file is deleted. If a secret file is not provided, the user is prompted to enter the secret. Values are decrypted only on demand when an encrypted value is looked up using the getAsString() function. $ ballerina run program.bal ballerina: enter secret for config value decryption:  Note: The same config file cannot contain values that are encrypted using different secrets.    Functions Checks whether the given key is in the configuration registry.  Retrieves the specified configuration value as an array.  Retrieves the specified configuration value as a boolean.  Retrieves the specified configuration value as a float.  Retrieves the specified configuration value as an int.  Retrieves the specified configuration value as a map.  Retrieves the specified configuration value as a string.  Sets the specified key/value pair as a configuration."},{"page":"/learn/api-docs/ballerina/config/functions.html","name":"Functions -","summary":"(string key)Checks whether the given key is in the configuration registry.\nThe configuration key to be looked-upReturns true if the key is present; if not returs false(string key)Retrieves the specified configuration value as an array.\nThe key of the configuration to be retrievedConfiguration value mapped with the given key. If there is ...","content":"Functions  v1.2.2  All Modules  Functions - Checks whether the given key is in the configuration registry.  Retrieves the specified configuration value as an array.  Retrieves the specified configuration value as a boolean.  Retrieves the specified configuration value as a float.  Retrieves the specified configuration value as an int.  Retrieves the specified configuration value as a map.  Retrieves the specified configuration value as a string.  Sets the specified key/value pair as a configuration.  contains (string key)  returns boolean Checks whether the given key is in the configuration registry.  boolean configAvailable = config:contains(\"host\");    Parameters  key string The configuration key to be looked-up   Return Type (boolean)  Returns true if the key is present; if not returs false   getAsArray (string key)  returns anydata[] Retrieves the specified configuration value as an array.  int[]|error ports = int[].constructFrom(config:getAsArray(\"ports\"));    Parameters  key string The key of the configuration to be retrieved   Return Type (anydata[])  Configuration value mapped with the given key. If there is no mapping, an empty array will be returned   getAsBoolean (string key, boolean defaultValue)  returns boolean Retrieves the specified configuration value as a boolean.  boolean cachingEnabled = config:getAsBoolean(\"http.caching_enabled\");    Parameters  key string The key of the configuration to be retrieved   defaultValue boolean (default false)  The default value to be used in case there is no mapping for the provided key   Return Type (boolean)  Configuration value mapped with the given key   getAsFloat (string key, float defaultVal)  returns float Retrieves the specified configuration value as a float.  float evictionFactor = config:getAsFloat(\"http.eviction_factor\");    Parameters  key string The key of the configuration to be retrieved   defaultVal float (default 0.0)  The default value to be used in case there is no mapping for the provided key   Return Type (float)  Configuration value mapped with the given key   getAsInt (string key, int defaultValue)  returns int Retrieves the specified configuration value as an int.  int port = config:getAsInt(\"http.port\");    Parameters  key string The key of the configuration to be retrieved   defaultValue int (default 0)  The default value to be used in case there is no mapping for the provided key   Return Type (int)  Configuration value mapped with the given key   getAsMap (string key)  returns map Retrieves the specified configuration value as a map.  map<anydata> configValue = config:getAsMap(\"http.listenerConfig\");    Parameters  key string The key of the configuration to be retrieved   Return Type (map)  Configuration value mapped with the given key. If there is no mapping, an empty map will be returned   getAsString (string key, string defaultValue)  returns string Retrieves the specified configuration value as a string.  string host = config:getAsString(\"http.host\");    Parameters  key string The key of the configuration to be retrieved   defaultValue string The default value to be used in case there is no mapping for the provided key   Return Type (string)  Configuration value mapped with the given key   setConfig Sets the specified key/value pair as a configuration.  config:setConfig(\"john.country\", \"USA\");    Parameters  key string The key of the configuration value to be set   value string | int | float | boolean The configuration value to be set"},{"page":"/learn/api-docs/ballerina/crypto/records/Certificate.html","name":"Record - : Certificate","summary":"X509 public key certificate information.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : Certificate  X509 public key certificate information.   Fields  version0  int  Version number   serial  int  Serial number   issuer  string  Issuer name   subject  string  Subject name   notBefore  Not before validity period of certificate   notAfter  Not after validity period of certificate   signature  byte[]  Raw signature bits   signingAlgorithm  string  Signature algorithm"},{"page":"/learn/api-docs/ballerina/crypto/","name":"Module : crypto","summary":"This module provides the necessary utilities that are required to hash content using different hashing mechanisms and algorithms.For information on the operations, which you can perform with this module, see the below Functions. For an example on the usage of the operations, see the . ...","content":"v1.2.2  All Modules  Module : crypto  Module Overview This module provides the necessary utilities that are required to hash content using different hashing mechanisms and algorithms. For information on the operations, which you can perform with this module, see the below Functions. For an example on the usage of the operations, see the .    Records X509 public key certificate information.  Record type to hold the details of an error.  Key store related configurations.  Private key used in cryptographic operations.  Public key used in cryptographic operations.  Trust store related configurations.  Functions Returns the Hex-encoded CRC32B value for the provided element.  Reads a private key from the provided PKCS#12 archive file.  Reads a public key from the provided PKCS#12 archive file.  Returns the AES-CBC-decrypted value for the given AES-CBC-encrypted data.  Returns the AES-ECB-decrypted value for the given AES-ECB-encrypted data.  Returns the AES-GCM-decrypted value for the given AES-GCM-encrypted data.  Returns the RSA-decrypted value for the given RSA-encrypted data.  Returns the AES-CBC-encrypted value for the given data.  Returns the AES-ECB-encrypted value for the given data.  Returns the AES-GCM-encrypted value for the given data.  Returns the RSA-encrypted value for the given data.  Returns the MD5 hash of the given data.  Returns the SHA-1 hash of the given data.  Returns the SHA-256 hash of the given data.  Returns the SHA-384 hash of the given data.  Returns the SHA-512 hash of the given data.  Returns the HMAC using the MD-5 hash function of the given data.  Returns the HMAC using the SHA-1 hash function of the given data.  Returns the HMAC using the SHA-256 hash function of the given data.  Returns the HMAC using the SHA-384 hash function of the given data.  Returns the HMAC using the SHA-512 hash function of the given data.  Returns the RSA-MD5-based signature value for the given data.  Returns the RSA-SHA1-based signature value for the given data.  Returns the RSA-SHA256-based signature value for the given data.  Returns the RSA-SHA384-based signature value for the given data.  Returns the RSA-SHA512-based signature value for the given data.  Verifies the RSA-MD5-based signature.  Verifies the RSA-SHA1-based signature.  Verifies the RSA-SHA256-based signature.  Verifies the RSA-SHA384-based signature.  Verifies the RSA-SHA512-based signature.  Constants The RSA algorithm.  No padding.  The PKCS1 padding mode.  The PKCS5 padding mode.  The OAEPwithMD5andMGF1 padding mode.  The OAEPWithSHA1AndMGF1 padding mode.  The OAEPWithSHA256AndMGF1 padding mode.  The OAEPwithSHA384andMGF1 padding mode.  The OAEPwithSHA512andMGF1 padding mode.  The Crypto error reason.  Types Padding algorithms supported by AES encryption and decryption.  The key algorithms supported by the Crypto module.  Padding algorithms supported with RSA encryption and decryption.  Errors The Crypto error type with details."},{"page":"/learn/api-docs/ballerina/crypto/functions.html","name":"Functions -","summary":"(byte[] input)Returns the Hex-encoded CRC32B value for the provided element.\nValue for checksum generationThe generated checksum( |  keyStore, string keyAlias, string keyPassword)Reads a private key from the provided PKCS#12 archive file.\nKey store or Trust store configurationsKey aliasKey passwordReference to the private key or else a crypto:Error if the private key ...","content":"Functions  v1.2.2  All Modules  Functions - Returns the Hex-encoded CRC32B value for the provided element.  Reads a private key from the provided PKCS#12 archive file.  Reads a public key from the provided PKCS#12 archive file.  Returns the AES-CBC-decrypted value for the given AES-CBC-encrypted data.  Returns the AES-ECB-decrypted value for the given AES-ECB-encrypted data.  Returns the AES-GCM-decrypted value for the given AES-GCM-encrypted data.  Returns the RSA-decrypted value for the given RSA-encrypted data.  Returns the AES-CBC-encrypted value for the given data.  Returns the AES-ECB-encrypted value for the given data.  Returns the AES-GCM-encrypted value for the given data.  Returns the RSA-encrypted value for the given data.  Returns the MD5 hash of the given data.  Returns the SHA-1 hash of the given data.  Returns the SHA-256 hash of the given data.  Returns the SHA-384 hash of the given data.  Returns the SHA-512 hash of the given data.  Returns the HMAC using the MD-5 hash function of the given data.  Returns the HMAC using the SHA-1 hash function of the given data.  Returns the HMAC using the SHA-256 hash function of the given data.  Returns the HMAC using the SHA-384 hash function of the given data.  Returns the HMAC using the SHA-512 hash function of the given data.  Returns the RSA-MD5-based signature value for the given data.  Returns the RSA-SHA1-based signature value for the given data.  Returns the RSA-SHA256-based signature value for the given data.  Returns the RSA-SHA384-based signature value for the given data.  Returns the RSA-SHA512-based signature value for the given data.  Verifies the RSA-MD5-based signature.  Verifies the RSA-SHA1-based signature.  Verifies the RSA-SHA256-based signature.  Verifies the RSA-SHA384-based signature.  Verifies the RSA-SHA512-based signature.  crc32b (byte[] input)  returns string Returns the Hex-encoded CRC32B value for the provided element.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  string checksum = crypto:crc32b(data);    Parameters  input byte[] Value for checksum generation   Return Type (string)  The generated checksum   decodePrivateKey ( | keyStore, string keyAlias, string keyPassword)  returns | Reads a private key from the provided PKCS#12 archive file.  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey|crypto:Error privateKey = crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");    Parameters  keyStore | Key store or Trust store configurations   keyAlias string Key alias   keyPassword string Key password   Return Type ( | )  Reference to the private key or else a crypto:Error if the private key was unreadable   decodePublicKey ( | keyStore, string keyAlias)  returns | Reads a public key from the provided PKCS#12 archive file.  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PublicKey|crypto:Error publicKey = crypto:decodePublicKey(keyStore, \"keyAlias\");    Parameters  keyStore | Key store or Trust store configurations   keyAlias string Key alias   Return Type ( | )  Reference to the public key or else a crypto:Error if the private key was unreadable   decryptAesCbc (byte[] input, byte[] key, byte[] iv, padding)  returns byte[] | Returns the AES-CBC-decrypted value for the given AES-CBC-encrypted data.  string dataString = \"Hello Ballerina!\";  byte[] data = dataString.toBytes();  byte[16] key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  key[i] = <byte>math:randomInRange(0, 255);  }  byte[16] initialVector = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  initialVector[i] = <byte>math:randomInRange(0, 255);  }  byte[] cipherText = checkpanic crypto:encryptAesCbc(data, key, initialVector);  byte[]|crypto:Error plainText = crypto:decryptAesCbc(cipherText, key, initialVector);    Parameters  input byte[] The content to be decrypted   key byte[] Encryption key   iv byte[] Initialization vector   padding (default PKCS5)  The padding   Return Type (byte[] | )  Decrypted data or else a crypto:Error if the key is invalid   decryptAesEcb (byte[] input, byte[] key, padding)  returns byte[] | Returns the AES-ECB-decrypted value for the given AES-ECB-encrypted data.  string dataString = \"Hello Ballerina!\";  byte[] data = dataString.toBytes();  byte[16] key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  key[i] = <byte>math:randomInRange(0, 255);  }  byte[] cipherText = checkpanic crypto:encryptAesEcb(data, key);  byte[]|crypto:Error plainText = crypto:decryptAesEcb(cipherText, key);    Parameters  input byte[] The content to be decrypted   key byte[] Encryption key   padding (default PKCS5)  The padding   Return Type (byte[] | )  Decrypted data or else a crypto:Error if the key is invalid   decryptAesGcm (byte[] input, byte[] key, byte[] iv, padding, int tagSize)  returns byte[] | Returns the AES-GCM-decrypted value for the given AES-GCM-encrypted data.  string dataString = \"Hello Ballerina!\";  byte[] data = dataString.toBytes();  byte[16] key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  key[i] = <byte>math:randomInRange(0, 255);  }  byte[16] initialVector = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  initialVector[i] = <byte>math:randomInRange(0, 255);  }  byte[] cipherText = checkpanic crypto:encryptAesGcm(data, key, initialVector);  byte[]|crypto:Error plainText = crypto:decryptAesGcm(cipherText, key, initialVector);    Parameters  input byte[] The content to be decrypted   key byte[] Encryption key   iv byte[] Initialization vector   padding (default PKCS5)  The padding   tagSize int (default 128)  Tag size   Return Type (byte[] | )  Decrypted data or else a crypto:Error if the key is invalid   decryptRsaEcb (byte[] input, | key, padding)  returns byte[] | Returns the RSA-decrypted value for the given RSA-encrypted data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PublicKey publicKey = checkpanic crypto:decodePublicKey(keyStore, \"keyAlias\");  crypto:PrivateKey privateKey = checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[] cipherText = checkpanic crypto:encryptRsaEcb(data, publicKey);  byte[]|crypto:Error plainText = checkpanic crypto:decryptRsaEcb(cipherText, privateKey);    Parameters  input byte[] The content to be decrypted   key | Private or public key used for encryption   padding (default PKCS1)  The padding   Return Type (byte[] | )  Decrypted data or else a crypto:Error if the key is invalid   encryptAesCbc (byte[] input, byte[] key, byte[] iv, padding)  returns byte[] | Returns the AES-CBC-encrypted value for the given data.  string dataString = \"Hello Ballerina!\";  byte[] data = dataString.toBytes();  byte[16] key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  key[i] = <byte>math:randomInRange(0, 255);  }  byte[16] initialVector = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  initialVector[i] = <byte>math:randomInRange(0, 255);  }  byte[]|crypto:Error cipherText = crypto:encryptAesCbc(data, key, initialVector);    Parameters  input byte[] The content to be encrypted   key byte[] Encryption key   iv byte[] Initialization vector   padding (default PKCS5)  The padding   Return Type (byte[] | )  Encrypted data or else a crypto:Error if the key is invalid   encryptAesEcb (byte[] input, byte[] key, padding)  returns byte[] | Returns the AES-ECB-encrypted value for the given data.  string dataString = \"Hello Ballerina!\";  byte[] data = dataString.toBytes();  byte[16] key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  key[i] = <byte>math:randomInRange(0, 255);  }  byte[]|crypto:Error cipherText = crypto:encryptAesEcb(data, key);    Parameters  input byte[] The content to be encrypted   key byte[] Encryption key   padding (default PKCS5)  The padding   Return Type (byte[] | )  Encrypted data or else a crypto:Error if the key is invalid   encryptAesGcm (byte[] input, byte[] key, byte[] iv, padding, int tagSize)  returns byte[] | Returns the AES-GCM-encrypted value for the given data.  string dataString = \"Hello Ballerina!\";  byte[] data = dataString.toBytes();  byte[16] key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  key[i] = <byte>math:randomInRange(0, 255);  }  byte[16] initialVector = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0...15 {  initialVector[i] = <byte>math:randomInRange(0, 255);  }  byte[]|crypto:Error cipherText = crypto:encryptAesGcm(data, key, initialVector);    Parameters  input byte[] The content to be encrypted   key byte[] Encryption key   iv byte[] Initialization vector   padding (default PKCS5)  The padding   tagSize int (default 128)  Tag size   Return Type (byte[] | )  Encrypted data or else a crypto:Error if the key is invalid   encryptRsaEcb (byte[] input, | key, padding)  returns byte[] | Returns the RSA-encrypted value for the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PublicKey publicKey = checkpanic crypto:decodePublicKey(keyStore, \"keyAlias\");  byte[]|crypto:Error cipherText = crypto:encryptRsaEcb(data, publicKey);    Parameters  input byte[] The content to be encrypted   key | Private or public key used for encryption   padding (default PKCS1)  The padding   Return Type (byte[] | )  Encrypted data or else a crypto:Error if the key is invalid   hashMd5 (byte[] input)  returns byte[] Returns the MD5 hash of the given data.  string dataString = \"Hello Ballerina\";  byte[] data = dataString.toBytes();  byte[] hash = crypto:hashMd5(data);    Parameters  input byte[] Value to be hashed   Return Type (byte[])  Hashed output   hashSha1 (byte[] input)  returns byte[] Returns the SHA-1 hash of the given data.  string dataString = \"Hello Ballerina\";  byte[] data = dataString.toBytes();  byte[] hash = crypto:hashSha1(data);    Parameters  input byte[] Value to be hashed   Return Type (byte[])  Hashed output   hashSha256 (byte[] input)  returns byte[] Returns the SHA-256 hash of the given data.  string dataString = \"Hello Ballerina\";  byte[] data = dataString.toBytes();  byte[] hash = crypto:hashSha256(data);    Parameters  input byte[] Value to be hashed   Return Type (byte[])  Hashed output   hashSha384 (byte[] input)  returns byte[] Returns the SHA-384 hash of the given data.  string dataString = \"Hello Ballerina\";  byte[] data = dataString.toBytes();  byte[] hash = crypto:hashSha384(data);    Parameters  input byte[] Value to be hashed   Return Type (byte[])  Hashed output   hashSha512 (byte[] input)  returns byte[] Returns the SHA-512 hash of the given data.  string dataString = \"Hello Ballerina\";  byte[] data = dataString.toBytes();  byte[] hash = crypto:hashSha512(data);    Parameters  input byte[] Value to be hashed   Return Type (byte[])  Hashed output   hmacMd5 (byte[] input, byte[] key)  returns byte[] Returns the HMAC using the MD-5 hash function of the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  string keyString = \"some-secret\";  byte[] key = keyString.toBytes();  byte[] hmac = crypto:hmacMd5(data, key);    Parameters  input byte[] Value to be hashed   key byte[] Key used for HMAC generation   Return Type (byte[])  HMAC output   hmacSha1 (byte[] input, byte[] key)  returns byte[] Returns the HMAC using the SHA-1 hash function of the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  string keyString = \"some-secret\";  byte[] key = keyString.toBytes();  byte[] hmac = crypto:hmacSha1(data, key);    Parameters  input byte[] Value to be hashed   key byte[] Key used for HMAC generation   Return Type (byte[])  HMAC output   hmacSha256 (byte[] input, byte[] key)  returns byte[] Returns the HMAC using the SHA-256 hash function of the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  string keyString = \"some-secret\";  byte[] key = keyString.toBytes();  byte[] hmac = crypto:hmacSha256(data, key);    Parameters  input byte[] Value to be hashed   key byte[] Key used for HMAC generation   Return Type (byte[])  HMAC output   hmacSha384 (byte[] input, byte[] key)  returns byte[] Returns the HMAC using the SHA-384 hash function of the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  string keyString = \"some-secret\";  byte[] key = keyString.toBytes();  byte[] hmac = crypto:hmacSha384(data, key);    Parameters  input byte[] Value to be hashed   key byte[] Key used for HMAC generation   Return Type (byte[])  HMAC output   hmacSha512 (byte[] input, byte[] key)  returns byte[] Returns the HMAC using the SHA-512 hash function of the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  string keyString = \"some-secret\";  byte[] key = keyString.toBytes();  byte[] hmac = crypto:hmacSha512(data, key);    Parameters  input byte[] Value to be hashed   key byte[] Key used for HMAC generation   Return Type (byte[])  HMAC output   signRsaMd5 (byte[] input, privateKey)  returns byte[] | Returns the RSA-MD5-based signature value for the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey =  checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[]|crypto:Error signature = crypto:signRsaMd5(data, privateKey);    Parameters  input byte[] The content to be signed   privateKey Private key used for signing   Return Type (byte[] | )  The generated signature or else a crypto:Error if the private key is invalid   signRsaSha1 (byte[] input, privateKey)  returns byte[] | Returns the RSA-SHA1-based signature value for the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey =  checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[]|crypto:Error signature = crypto:signRsaSha1(data, privateKey);    Parameters  input byte[] The content to be signed   privateKey Private key used for signing   Return Type (byte[] | )  The generated signature or else a crypto:Error if the private key is invalid   signRsaSha256 (byte[] input, privateKey)  returns byte[] | Returns the RSA-SHA256-based signature value for the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey =  checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[]|crypto:Error signature = crypto:signRsaSha256(data, privateKey);    Parameters  input byte[] The content to be signed   privateKey Private key used for signing   Return Type (byte[] | )  The generated signature or else a crypto:Error if the private key is invalid   signRsaSha384 (byte[] input, privateKey)  returns byte[] | Returns the RSA-SHA384-based signature value for the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey =  checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[]|crypto:Error signature = crypto:signRsaSha384(data, privateKey);    Parameters  input byte[] The content to be signed   privateKey Private key used for signing   Return Type (byte[] | )  The generated signature or else a crypto:Error if the private key is invalid   signRsaSha512 (byte[] input, privateKey)  returns byte[] | Returns the RSA-SHA512-based signature value for the given data.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey =  checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[]|crypto:Error signature = crypto:signRsaSha512(data, privateKey);    Parameters  input byte[] The content to be signed   privateKey Private key used for signing   Return Type (byte[] | )  The generated signature or else a crypto:Error if the private key is invalid   verifyRsaMd5Signature (byte[] data, byte[] signature, publicKey)  returns boolean | Verifies the RSA-MD5-based signature.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey = checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[] signature = checkpanic crypto:signRsaMd5(data, privateKey);  crypto:PublicKey publicKey = checkpanic crypto:decodePublicKey(keyStore, \"keyAlias\");  boolean|crypto:Error validity = crypto:verifyRsaMd5Signature(data, signature, publicKey);    Parameters  data byte[] The content to be verified   signature byte[] Signature value   publicKey Public key used for verification   Return Type (boolean | )  Validity of the signature or else a crypto:Error if the public key is invalid   verifyRsaSha1Signature (byte[] data, byte[] signature, publicKey)  returns boolean | Verifies the RSA-SHA1-based signature.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey = checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[] signature = checkpanic crypto:signRsaMd5(data, privateKey);  crypto:PublicKey publicKey = checkpanic crypto:decodePublicKey(keyStore, \"keyAlias\");  boolean|crypto:Error validity = crypto:verifyRsaSha1Signature(data, signature, publicKey);    Parameters  data byte[] The content to be verified   signature byte[] Signature value   publicKey Public key used for verification   Return Type (boolean | )  Validity of the signature or else a crypto:Error if the public key is invalid   verifyRsaSha256Signature (byte[] data, byte[] signature, publicKey)  returns boolean | Verifies the RSA-SHA256-based signature.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey = checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[] signature = checkpanic crypto:signRsaMd5(data, privateKey);  crypto:PublicKey publicKey = checkpanic crypto:decodePublicKey(keyStore, \"keyAlias\");  boolean|crypto:Error validity = crypto:verifyRsaSha256Signature(data, signature, publicKey);    Parameters  data byte[] The content to be verified   signature byte[] Signature value   publicKey Public key used for verification   Return Type (boolean | )  Validity of the signature or else a crypto:Error if the public key is invalid   verifyRsaSha384Signature (byte[] data, byte[] signature, publicKey)  returns boolean | Verifies the RSA-SHA384-based signature.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey = checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[] signature = checkpanic crypto:signRsaMd5(data, privateKey);  crypto:PublicKey publicKey = checkpanic crypto:decodePublicKey(keyStore, \"keyAlias\");  boolean|crypto:Error validity = crypto:verifyRsaSha384Signature(data, signature, publicKey);    Parameters  data byte[] The content to be verified   signature byte[] Signature value   publicKey Public key used for verification   Return Type (boolean | )  Validity of the signature or else a crypto:Error if the public key is invalid   verifyRsaSha512Signature (byte[] data, byte[] signature, publicKey)  returns boolean | Verifies the RSA-SHA512-based signature.  string stringData = \"Hello Ballerina\";  byte[] data = stringData.toBytes();  crypto:KeyStore keyStore = {  path: \"/home/ballerina/keystore.p12\",  password: \"keystorePassword\"  };  crypto:PrivateKey privateKey = checkpanic crypto:decodePrivateKey(keyStore, \"keyAlias\", \"keyPassword\");  byte[] signature = checkpanic crypto:signRsaMd5(data, privateKey);  crypto:PublicKey publicKey = checkpanic crypto:decodePublicKey(keyStore, \"keyAlias\");  boolean|crypto:Error validity = crypto:verifyRsaSha512Signature(data, signature, publicKey);    Parameters  data byte[] The content to be verified   signature byte[] Signature value   publicKey Public key used for verification   Return Type (boolean | )  Validity of the signature or else a crypto:Error if the public key is invalid"},{"page":"/learn/api-docs/ballerina/crypto/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/crypto/records/KeyStore.html","name":"Record - : KeyStore","summary":"Key store related configurations.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : KeyStore  Key store related configurations.   Fields  path  string  Path to the key store file   password  string  Key store password"},{"page":"/learn/api-docs/ballerina/crypto/records/PrivateKey.html","name":"Record - : PrivateKey","summary":"Private key used in cryptographic operations.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : PrivateKey  Private key used in cryptographic operations.   Fields  algorithm  Key algorithm"},{"page":"/learn/api-docs/ballerina/crypto/records/PublicKey.html","name":"Record - : PublicKey","summary":"Public key used in cryptographic operations.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : PublicKey  Public key used in cryptographic operations.   Fields  algorithm  Key algorithm   certificate  Public key certificate"},{"page":"/learn/api-docs/ballerina/crypto/records/TrustStore.html","name":"Record - : TrustStore","summary":"Trust store related configurations.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : TrustStore  Trust store related configurations.   Fields  path  string  Path to the key store file   password  string  Key store password"},{"page":"/learn/api-docs/ballerina/email/clients/PopClient.html","name":"Clients - : PopClient","summary":"Represents a POP Client, which interacts with a POP Server.\n(string host, string username, string password,  clientConfig)Host of the POP ClientUsername of the POP ClientPassword of the POP ClientConfigurations for the POP Client(string folder)Reads a message.\nFolder to read emails. The default value is INBOXAnemail:Email if reading the message is successful, ...","content":"Clients  v1.2.2  All Modules  Clients - :  PopClient  Represents a POP Client, which interacts with a POP Server.    Constructor __init(string host, string username, string password, clientConfig)   host string Host of the POP Client   username string Username of the POP Client   password string Password of the POP Client   clientConfig {}  Configurations for the POP Client   Remote Methods  Reads a message.  email:Email|email:Error? emailResponse = popClient->read();    read (string folder)  returns | | () Reads a message.  email:Email|email:Error? emailResponse = popClient->read();    Parameters  folder string (default DEFAULT_FOLDER)  Folder to read emails. The default value is INBOX   Return Type ( | | ())  Anemail:Email if reading the message is successful, () if there are no emails in the specified folder, or else an email:Error if the recipient failed to receive the message"},{"page":"/learn/api-docs/ballerina/email/clients/SmtpClient.html","name":"Clients - : SmtpClient","summary":"Represents an SMTP Client, which interacts with an SMTP Server.\n(string host, string username, string password,  clientConfig)Host of the SMTP ClientUsername of the SMTP ClientPassword of the SMTP ClientConfigurations for SMTP Client( email)Sends a message.\nAn email:Email message, which needs to be sent to the recipientAn email:SendError if failed to send ...","content":"Clients  v1.2.2  All Modules  Clients - :  SmtpClient  Represents an SMTP Client, which interacts with an SMTP Server.    Constructor __init(string host, string username, string password, clientConfig)   host string Host of the SMTP Client   username string Username of the SMTP Client   password string Password of the SMTP Client   clientConfig {}  Configurations for SMTP Client   Remote Methods  Sends a message.  email:Error? response = smtpClient->send(email);    send ( email)  returns ? Sends a message.  email:Error? response = smtpClient->send(email);    Parameters  email An email:Email message, which needs to be sent to the recipient   Return Type (?)  An email:SendError if failed to send the message to the recipient or else ()"},{"page":"/learn/api-docs/ballerina/email/clients/ImapClient.html","name":"Clients - : ImapClient","summary":"Represents an IMAP Client, which interacts with an IMAP Server.\n(string host, string username, string password,  clientConfig)Host of the IMAP ClientUsername of the IMAP ClientPassword of the IMAP ClientConfigurations for the IMAP Client(string folder)Reads a message.\nFolder to read emails. The default value is INBOXAnemail:Email if reading the message is successful, ...","content":"Clients  v1.2.2  All Modules  Clients - :  ImapClient  Represents an IMAP Client, which interacts with an IMAP Server.    Constructor __init(string host, string username, string password, clientConfig)   host string Host of the IMAP Client   username string Username of the IMAP Client   password string Password of the IMAP Client   clientConfig {}  Configurations for the IMAP Client   Remote Methods  Reads a message.  email:Email|email:Error emailResponse = imapClient->read();    read (string folder)  returns | | () Reads a message.  email:Email|email:Error emailResponse = imapClient->read();    Parameters  folder string (default DEFAULT_FOLDER)  Folder to read emails. The default value is INBOX   Return Type ( | | ())  Anemail:Email if reading the message is successful, () if there are no emails in the specified folder, or else an email:Error if the recipient failed to receive the message"},{"page":"/learn/api-docs/ballerina/email/","name":"Module : email","summary":"This module contains functions to perform email operations such as sending and reading emails using the SMTP, POP3, and IMAP4 protocols.This module supports the following three client types.To send an email using the SMTP protocol, you must first create an email:SmtpClient object. The code for creating an email:SmtpClient can be ...","content":"v1.2.2  All Modules  Module : email  Module Overview This module contains functions to perform email operations such as sending and reading emails using the SMTP, POP3, and IMAP4 protocols. Client This module supports the following three client types.  email:SmtpClient - The client, which supports sending an email using the SMTP protocol. email:PopClient - The client, which supports receiving an email using the POP3 protocol. email:ImapClient - The client, which supports receiving an email using the IMAP4 protocol.  SMTP Client To send an email using the SMTP protocol, you must first create an email:SmtpClient object. The code for creating an email:SmtpClient can be found below. Creating a client The following code creates an SMTP client, which connects to the default port(465) and enables SSL. email:SmtpClient smtpClient = new (\"smtp.email.com\",  \"sender@email.com\",  \"pass123\");  The port number of the server and/or the SSL support can also be configured by passing the following configurations. email:SmtpConfig smtpConfig = {  port: 465, // Can use ports, 465, 587 or 25  enableSsl: true // Set true to enable SSL (SMTPS connections) };  email:SmtpClient smtpClient = new (\"smtp.email.com\",  \"sender@email.com\",  \"pass123\",  smtpConfig);  Sending an email Once the email:SmtpClient is created, an email can be sent using the SMTP protocol through that client. Samples for this operation can be found below. email:Email email = {  to: [\"receiver1@email.com\", \"receiver2@email.com\"],  cc: [\"receiver3@email.com\", \"receiver4@email.com\"],  bcc: [\"receiver5@email.com\"],  subject: \"Sample Email\",  body: \"This is a sample email.\",  'from: \"author@email.com\",  sender: \"sender@email.com\",  replyTo: [\"replyTo1@email.com\", \"replyTo2@email.com\"] };  email:Error? response = smtpClient->send(email);  POP3 Client To receive an email using the POP3 protocol, you must first create an email:PopClient object. The code for creating an email:PopClient can be found below. Creating a client The following code creates a POP3 client, which connects to the default port(995) and enables SSL. email:PopClient|email:Error popClient = new (\"pop.email.com\",  \"reader@email.com\",  \"pass456\");  The port number of the server and/or the SSL support can also be configured by passing the following configurations. email:PopConfig popConfig = {  port: 995,  enableSsl: true };  email:PopClient|email:Error popClient = new (\"pop.email.com\",  \"reader@email.com\",  \"pass456\",  popConfig);  Receiving an email Once the email:PopClient is created, emails can be received using the POP3 protocol through that client. Samples for this operation can be found below. email:Email|email:Error? emailResponse = popClient->read();  IMAP4 Client To receive an email using the IMAP4 protocol, you must first create an email:ImapClient object. The code for creating an email:ImapClient can be found below. Creating a client The following code creates an IMAP4 client, which connects to the default port(993) and enables SSL. email:ImapClient|email:Error imapClient = new (\"imap.email.com\",  \"reader@email.com\",  \"pass456\");  The port number of the server and/or the SSL support can also be configured by passing the following configurations. email:ImapConfig imapConfig = {  port: 993,  enableSsl: true };  email:ImapClient|email:Error imapClient = new (\"imap.email.com\",  \"reader@email.com\",  \"pass456\",  imapConfig);  Receiving an email Once the email:ImapClient is created, emails can be received using the IMAP4 protocol through that client. Samples for this operation can be found below. email:Email|email:Error emailResponse = imapClient->read();  For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operation, see the .    Records The details of an error.  Email message properties.  Configuration of the IMAP Endpoint.  Configuration of the POP Endpoint.  Configuration of the SMTP Endpoint.  Clients Represents an IMAP Client, which interacts with an IMAP Server.  Represents a POP Client, which interacts with a POP Server.  Represents an SMTP Client, which interacts with an SMTP Server.  Constants Default folder to read emails.  Represents the reason for the email sending related errors.  Represents the reason for the server access failure errors.  Represents the reason for the email receipt related errors.  Types Represents email related errors.  Errors Represents an error that occurs when the email store access fails.  Represents an error that occurs an email read operation fails.  Represents an error that occurs when sending an email fails."},{"page":"/learn/api-docs/ballerina/email/records/Detail.html","name":"Record - : Detail","summary":"The details of an error.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : Detail  The details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/email/records/ImapConfig.html","name":"Record - : ImapConfig","summary":"Configuration of the IMAP Endpoint.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : ImapConfig  Configuration of the IMAP Endpoint.   Fields  port  int  (default 993) Port number of the IMAP server   enableSsl  boolean  (default true) If set to true, use SSL to connect and use the SSL port by default. The default value is true for the \"imaps\" protocol and false for the \"imap\" protocol."},{"page":"/learn/api-docs/ballerina/email/records/Email.html","name":"Record - : Email","summary":"Email message properties.\n\n            \n    ...","content":"Records  v1.2.2  All Modules  Record - : Email  Email message properties.   Fields  to  string[]  TO address list   cc  string[]  CC address list   bcc  string[]  BCC address list   subject  string  Subject of email   body  string  Body of the email message   from  string  From address   sender  string  Sender's address   replyTo  string[]  Reply To addresses   attachments  []  Email attachements"},{"page":"/learn/api-docs/ballerina/email/records/PopConfig.html","name":"Record - : PopConfig","summary":"Configuration of the POP Endpoint.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : PopConfig  Configuration of the POP Endpoint.   Fields  port  int  (default 995) Port number of the POP server   enableSsl  boolean  (default true) If set to true, use SSL to connect and use the SSL port by default. The default value is true for the \"pop3s\" protocol and false for the \"pop3\" protocol."},{"page":"/learn/api-docs/ballerina/email/records/SmtpConfig.html","name":"Record - : SmtpConfig","summary":"Configuration of the SMTP Endpoint.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : SmtpConfig  Configuration of the SMTP Endpoint.   Fields  port  int  (default 465) Port number of the SMTP server   enableSsl  boolean  (default true) If set to true, use SSL to connect and use the SSL port by default. The default value is true for the \"smtps\" protocol and false for the \"smtp\" protocol."},{"page":"/learn/api-docs/ballerina/encoding/functions.html","name":"Functions -","summary":"(string input)Decodes the Base64 URL encoded string into a byte array.\nValue to be decodedDecoded output or else a mime:Error if the input is not a valid Base64 URL encoded value(string uriComponent, string charset)Decodes the given URI component into a string using the provided charset.\nURI component to be decodedCharacter set to ...","content":"Functions  v1.2.2  All Modules  Functions - Decodes the Base64 URL encoded string into a byte array.  Decodes the given URI component into a string using the provided charset.  Returns the Base64 URL encoded string value of the given byte array.  Encodes the given URI component into a string using the provided charset.  decodeBase64Url (string input)  returns byte[] | Decodes the Base64 URL encoded string into a byte array.  byte[]|encoding:Error urlDecodedValue = encoding:decodeBase64Url(\"SGVsbMO2IFfDtnJsZEBCYWxsZXJpbmE\");    Parameters  input string Value to be decoded   Return Type (byte[] | )  Decoded output or else a mime:Error if the input is not a valid Base64 URL encoded value   decodeUriComponent (string uriComponent, string charset)  returns string | Decodes the given URI component into a string using the provided charset.  string encodedUrl = \"http://www.domain.com/?param1=http%3A%2F%2Fxyz.com%2F%3Fa%3D12%26b%3D55¶m2=99\";  string|encoding:Error decodedUriComponent = encoding:decodeUriComponent(encodedUrl, \"UTF-8\");    Parameters  uriComponent string URI component to be decoded   charset string Character set to be used in decoding the URI   Return Type (string | )  The string value of the decoded URI component or an Error that occurred during decoding   encodeBase64Url (byte[] input)  returns string Returns the Base64 URL encoded string value of the given byte array.  string query = \"Hellö Wörld@Ballerina\";  string urlEncodedValue = encoding:encodeBase64Url(query.toBytes());    Parameters  input byte[] Byte array to be encoded   Return Type (string)  Encoded output   encodeUriComponent (string uriComponent, string charset)  returns string | Encodes the given URI component into a string using the provided charset.  string urlValue = \"param1=http://xyz.com/?a=12&b=55¶m2=99\";  string|encoding:Error encodedUriComponent = encoding:encodeUriComponent(urlValue, \"UTF-8\");    Parameters  uriComponent string URI component to be encoded   charset string Character set to be used in encoding the URI   Return Type (string | )  The string value of the encoded URI component or an Error that occurred during encoding"},{"page":"/learn/api-docs/ballerina/encoding/","name":"Module : encoding","summary":"This module provides the necessary utilities, which are required to encode and decode content using different URL encoding mechanisms and algorithms.For information on the operations, which you can perform with this module, see the below Functions. ...","content":"v1.2.2  All Modules  Module : encoding  Module Overview This module provides the necessary utilities, which are required to encode and decode content using different URL encoding mechanisms and algorithms. For information on the operations, which you can perform with this module, see the below Functions.    Records Record type to hold the details of an error.  Functions Decodes the Base64 URL encoded string into a byte array.  Decodes the given URI component into a string using the provided charset.  Returns the Base64 URL encoded string value of the given byte array.  Encodes the given URI component into a string using the provided charset.  Constants Represents the Encoding error code.  Errors Represents the Encoding error type with details."},{"page":"/learn/api-docs/ballerina/encoding/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/file/","name":"Module : file Directory Listener","summary":"This module contains functions to perform file system based operations such as create, delete, rename the\nfile/directory, and retrieve metadata of the file.For an example on the usage of the operations, see the .The Directory Listener is used to listen to a directory in the local file system. It notifies when ...","content":"v1.2.2  All Modules  Module : file  Module Overview This module contains functions to perform file system based operations such as create, delete, rename the file/directory, and retrieve metadata of the file. For an example on the usage of the operations, see the . Directory Listener The Directory Listener is used to listen to a directory in the local file system. It notifies when new files are created in the directory or when the existing files are deleted or modified. For an example on the usage of the operations, see the .    Records Record type to hold the details of an error.  Represents an event which will trigger when there is a changes to listining direcotry.  Represents configurations that required for directory listener.  Objects FileInfo record contains metadata information of a file.  Listeners Represents the directory listener endpoint, which is used to listen to a directory in the local file system.  Functions Copy the file/directory in the old path to the new path.  Creates a new directory with the specified file name.  Creates a file in the specified file path.  Reports whether the file or directory exists in the given the path.  Returns the current working directory.  Returns the metadata information of the file specified in the file path.  Reads the directory and returns a list of files and directories inside the specified directory.  Removes the specified file or directory.  Renames(Moves) the old path with the new path.  Returns the default directory to use for temporary files.  Constants Identifies invalid operation error.  Identifies permission error.  Identifies file system error.  Identifies file not found error.  Types Represents file system related errors.  Errors Represents an error that occurs when the file/directory does not exist at the given filepath.  Represents an error that occurs when a file system operation fails.  Represents an error that occurs when a file system operation is denied due to invalidity.  Represents an error that occurs when a file system operation is denied, due to the absence of file permission."},{"page":"/learn/api-docs/ballerina/file/functions.html","name":"Functions -","summary":"(string sourcePath, string destinationPath, boolean replaceExisting)Copy the file/directory in the old path to the new path.\nIf a file already exists in the new path, this replaces that file.\nString value of the old file pathString value of the new file pathFlag to replace if the file already exists in the destination ...","content":"Functions  v1.2.2  All Modules  Functions - Copy the file/directory in the old path to the new path.  Creates a new directory with the specified file name.  Creates a file in the specified file path.  Reports whether the file or directory exists in the given the path.  Returns the current working directory.  Returns the metadata information of the file specified in the file path.  Reads the directory and returns a list of files and directories inside the specified directory.  Removes the specified file or directory.  Renames(Moves) the old path with the new path.  Returns the default directory to use for temporary files.  copy (string sourcePath, string destinationPath, boolean replaceExisting)  returns ? Copy the file/directory in the old path to the new path. If a file already exists in the new path, this replaces that file.  file:Error? results = file:copy(\"/A/B/C\", \"/A/B/D\", true);    Parameters  sourcePath string String value of the old file path   destinationPath string String value of the new file path   replaceExisting boolean (default false)  Flag to replace if the file already exists in the destination path   Return Type (?)  An file:Error if failed to rename   createDir (string dir, boolean parentDirs)  returns string | Creates a new directory with the specified file name. If the parentDirs flag is true, it creates a directory in the specified path with any necessary parents.  string | error results = file:createDir(\"foo/bar\");    Parameters  dir string Directory name   parentDirs boolean (default false)  Indicates whether the createDir should create non-existing parent directories   Return Type (string | )  Absolute path value of the created directory or else an file:Error if failed   createFile (string path)  returns string | Creates a file in the specified file path. Truncates if the file already exists in the given path.  string | error results = file:createFile(\"bar.txt\");    Parameters  path string String value of the file path   Return Type (string | )  Absolute path value of the created file or else an file:Error if failed   exists (string path)  returns boolean Reports whether the file or directory exists in the given the path.  boolean result = file:exists(\"foo/bar.txt\");    Parameters  path string String value of the file path   Return Type (boolean)  True if the path is absolute or else false   getCurrentDirectory ()  returns string Returns the current working directory.  string dirPath = file:getCurrentDirectory();    Return Type (string)  Current working directory or else an empty string if the current working directory cannot be determined   getFileInfo (string path)  returns | Returns the metadata information of the file specified in the file path.  file:FileInfo | error result = file:getFileInfo(\"foo/bar.txt\");    Parameters  path string String value of the file path.   Return Type ( | )  The FileInfo instance with the file metadata or else an file:Error   readDir (string path, int maxDepth)  returns [] | Reads the directory and returns a list of files and directories inside the specified directory.  file:FileInfo[] | error results = file:readDir(\"foo/bar\");    Parameters  path string String value of the directory path.   maxDepth int (default -1)  The maximum number of directory levels to visit. -1 to indicate that all levels should be visited   Return Type ([] | )  The FileInfo array or else an file:Error if there is an error while changing the mode.   remove (string path, boolean recursive)  returns ? Removes the specified file or directory. If the recursive flag is true, it removes the path and any children it contains.  file:Error? results = file:remove(\"foo/bar.txt\");    Parameters  path string String value of the file/directory path   recursive boolean (default false)  Indicates whether the remove should recursively remove all the files inside the given directory   Return Type (?)  An file:Error if failed to remove   rename (string oldPath, string newPath)  returns ? Renames(Moves) the old path with the new path. If the new path already exists and it is not a directory, this replaces the file.  file:error? results = file:rename(\"/A/B/C\", \"/A/B/D\");    Parameters  oldPath string String value of the old file path   newPath string String value of the new file path   Return Type (?)  An file:Error if failed to rename   tempDir ()  returns string Returns the default directory to use for temporary files.  string results = file:tempDir();    Return Type (string)  Temporary directory location"},{"page":"/learn/api-docs/ballerina/file/listeners/Listener.html","name":"Listener - : Listener","summary":"Represents the directory listener endpoint, which is used to listen to a directory in the local file system.\n( listenerConfig)The ListenerConfig record with the directory details()Stops the file:Listener gracefully.\n() or else error upon failure to stop the listener()Stops the file:Listener forcefully.\n() or else error upon failure to stop the listener(service s)Stops ...","content":"Listeners  v1.2.2  All Modules  Listener - : Listener Represents the directory listener endpoint, which is used to listen to a directory in the local file system.    Constructor __init( listenerConfig)   listenerConfig The ListenerConfig record with the directory details   Methods  Stops the file:Listener gracefully.  Stops the file:Listener forcefully.  Stops listening to the directory and detaches the service from the file:Listener.  LifeCycle Methods  Starts the file:Listener.  Binds a service to the file:Listener.  Methods  __gracefulStop ()  returns error? Stops the file:Listener gracefully.   Return Type (error?)  () or else error upon failure to stop the listener   __immediateStop ()  returns error? Stops the file:Listener forcefully.   Return Type (error?)  () or else error upon failure to stop the listener   __detach (service s)  returns error? Stops listening to the directory and detaches the service from the file:Listener.   Parameters  s service Type descriptor of the service   Return Type (error?)  () or else error upon failure to detach to the service   LifeCycle Methods  __start ()  returns error? Starts the file:Listener.   Return Type (error?)  () or else error upon failure to start the listener   __attach (service s, string? name)  returns error? Binds a service to the file:Listener.   Parameters  s service Type descriptor of the service   name string? (default ())  Name of the service   Return Type (error?)  () or else error upon failure to attach to the service"},{"page":"/learn/api-docs/ballerina/file/records/ListenerConfig.html","name":"Record - : ListenerConfig","summary":"Represents configurations that required for directory listener.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : ListenerConfig  Represents configurations that required for directory listener.   Fields  path  string?  (default ()) Directory path which need to listen   recursive  boolean  (default false) Recursively monitor all sub folders or not in the given direcotry path"},{"page":"/learn/api-docs/ballerina/file/objects/FileInfo.html","name":"Object - : FileInfo","summary":"FileInfo record contains metadata information of a file.\nThis record is returned by getFileInfo function is os module.\n\n  ...","content":"Objects  >  v1.2.2  All Modules  Object - :  FileInfo  FileInfo record contains metadata information of a file. This record is returned by getFileInfo function is os module.   Constructor __init(string name, int size, modifiedTime, boolean dir, string path)   name string Name of the file   size int Size of the file (in bytes)   modifiedTime The last modified time of the file   dir boolean Whether the file is a directory or not   path string Absolute path of the file   Methods  Returns the file name.  Returns the file size.  Returns the last-modified time of the file.  Returns whether the file is a directory or not.  Returns the absolute file path.  getName ()  returns string Returns the file name.   Return Type (string)  the file name   getSize ()  returns int Returns the file size.   Return Type (int)  the file size   getLastModifiedTime ()  returns Returns the last-modified time of the file.   Return Type ()  Last-modified time of the file   isDir ()  returns boolean Returns whether the file is a directory or not.   Return Type (boolean)  File is a directory or not   getPath ()  returns string Returns the absolute file path.   Return Type (string)  The file path"},{"page":"/learn/api-docs/ballerina/file/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error.   cause  error  Any other error, which causes this error."},{"page":"/learn/api-docs/ballerina/file/records/FileEvent.html","name":"Record - : FileEvent","summary":"Represents an event which will trigger when there is a changes to listining direcotry.\n\n     ...","content":"Records  v1.2.2  All Modules  Record - : FileEvent  Represents an event which will trigger when there is a changes to listining direcotry.   Fields  name  string  Absolute file URI for triggerd event   operation  string  Triggered event action. This can be create, delete or modify"},{"page":"/learn/api-docs/ballerina/filepath/","name":"Module : filepath","summary":"This module provides a platform-independent API for working with file paths.For information on the operations, which you can perform with this module, see the below Functions. ...","content":"v1.2.2  All Modules  Module : filepath  Module Overview This module provides a platform-independent API for working with file paths. For information on the operations, which you can perform with this module, see the below Functions.  For an example on the usage of the operations, see the .     Records A record type defined to be used as the \"error detail\" in the errors defined in this module.  Functions Retrieves the absolute path from the provided location.  Joins any number of path elements into a single path.  Retrieves the extension of the file path.  Retrieves the base name of the file from the provided location, which is the last element of the path.  Returns the path variable's separating character for paths of the underlying operating system.  Returns the path separator of the underlying operating system.  Reports whether the path is absolute.  Reports whether the filename is reserved.  Reports whether the complete filename (not just a substring of it) matches the provided Glob pattern.  Returns the shortest path name equivalent to the given path.  Returns the enclosing parent directory.  Returns a relative path, which is logically equivalent to the target path when joined to the base path with an intervening separator.  Returns the filepath after the evaluation of any symbolic links.  Splits a list of paths joined by the OS-specific path separator.  Constants Identifies file not found error.  Identifies no link error.  Identifies io error.  Identifies security error.  Identifies invalid path error.  Identifies invalid pattern error.  Identifies relative path error.  Identifies unc path error.  Identifies generic error.  Types Represents filepath related errors.  Errors Represents error occur when the file/directory does not exist at the given filepath.  Represents generic error for filepath   Represents IO error occur when trying to access the file at the given filepath.  Represents error occur when the given file path is invalid.  Represent error occur when the given pattern is not a valid filepath pattern.  Represents error occur when the file at the given filepath is not a symbolic link.  Represents an error that occurs when the given target filepath cannot be derived relative to the base filepath.  Represents security error occur when trying to access the file at the given filepath.  Represents error occur in the UNC path."},{"page":"/learn/api-docs/ballerina/filepath/functions.html","name":"Functions -","summary":"(string path)Retrieves the absolute path from the provided location.\nString value of the file path free from potential malicious codesThe absolute path reference or else a filepath:Error if the path cannot be derived(string[] parts)Joins any number of path elements into a single path.\nString values of the file path partsString value of ...","content":"Functions  v1.2.2  All Modules  Functions - Retrieves the absolute path from the provided location.  Joins any number of path elements into a single path.  Retrieves the extension of the file path.  Retrieves the base name of the file from the provided location, which is the last element of the path.  Returns the path variable's separating character for paths of the underlying operating system.  Returns the path separator of the underlying operating system.  Reports whether the path is absolute.  Reports whether the filename is reserved.  Reports whether the complete filename (not just a substring of it) matches the provided Glob pattern.  Returns the shortest path name equivalent to the given path.  Returns the enclosing parent directory.  Returns a relative path, which is logically equivalent to the target path when joined to the base path with an intervening separator.  Returns the filepath after the evaluation of any symbolic links.  Splits a list of paths joined by the OS-specific path separator.  absolute (string path)  returns string | Retrieves the absolute path from the provided location.  string|filepath:Error absolutePath = filepath:absolute(<@untainted> \"test.txt\");    Parameters  path string String value of the file path free from potential malicious codes   Return Type (string | )  The absolute path reference or else a filepath:Error if the path cannot be derived   build (string[] parts)  returns string | Joins any number of path elements into a single path.  string|filepath:Error path = filepath:build(\"/\", \"foo\", \"bar\");    Parameters  parts string[] String values of the file path parts   Return Type (string | )  String value of the file path or else a filepath:Error if the parts are invalid   extension (string path)  returns string | Retrieves the extension of the file path. The extension is the suffix beginning at the final dot in the final element of the path. It is empty if there is no dot.  string|filepath:Error extension = filepath:extension(\"path.bal\");    Parameters  path string String value of the file path   Return Type (string | )  The extension of the file, an empty string if there is no extension, or else a filepath:Error if the path is invalid   filename (string path)  returns string | Retrieves the base name of the file from the provided location, which is the last element of the path. Trailing path separators are removed before extracting the last element.  string|filepath:Error name = filepath:filename(\"/A/B/C.txt\");    Parameters  path string String value of file path   Return Type (string | )  The name of the file or else a filepath:Error if the path is invalid   getPathListSeparator ()  returns string Returns the path variable's separating character for paths of the underlying operating system.  string pathListSeparator = filepath:getPathListSeparator();    Return Type (string)  String value of the path list separator   getPathSeparator ()  returns string Returns the path separator of the underlying operating system.  string pathSeparator = filepath:getPathSeparator();    Return Type (string)  String value of the path separator   isAbsolute (string path)  returns boolean | Reports whether the path is absolute. A path is absolute if it is independent of the current directory. On Unix, a path is absolute if it starts with the root. On Windows, a path is absolute if it has a prefix and starts with the root: c:\\windows.  boolean|filepath:Error isAbsolute = filepath:isAbsolute(\"/A/B/C\");    Parameters  path string String value of the file path   Return Type (boolean | )  true if path is absolute, false otherwise, or else an filepath:Error occurred if the path is invalid   isReservedName (string name)  returns boolean Reports whether the filename is reserved. Reserved words only exist in Windows.  boolean|filepath:Error path = filepath:isReservedName(\"abc.txt\");    Parameters  name string Filename   Return Type (boolean)  True if the path is a Windows reserved name or else false otherwise   matches (string path, string pattern)  returns boolean | Reports whether the complete filename (not just a substring of it) matches the provided Glob pattern. An error is returned if the pattern is malformed.  boolean|filepath:Error matches = filepath:matches(\"a/b/c.java\", \"glob:*.{java,class}\");    Parameters  path string String value of the file path   pattern string String value of the target file path   Return Type (boolean | )  true if the filename of the path matches with the pattern, false otherwise, or else an filepath:Error if the path or pattern is invalid   normalize (string path)  returns string | Returns the shortest path name equivalent to the given path. Replace the multiple separator elements with a single one. Eliminate each \".\" path name element (the current directory). Eliminate each inner \"..\" path name element (the parent directory).  string|filepath:Error normalizedPath = filepath:normalize(\"foo/../bar\");    Parameters  path string String value of the file path   Return Type (string | )  Normalized file path or else a filepath:Error if the path is invalid   parent (string path)  returns string | Returns the enclosing parent directory. If the path is empty, parent returns \".\". The returned path does not end in a separator unless it is the root directory.  string|filepath:Error parentPath = filepath:parent(\"/A/B/C.txt\");    Parameters  path string String value of the file/directory path   Return Type (string | )  Path of the parent directory or else a filepath:Error if an error occurred while getting the parent directory   relative (string base, string target)  returns string | Returns a relative path, which is logically equivalent to the target path when joined to the base path with an intervening separator. An error is returned if the target path cannot be made relative to the base path.  string|filepath:Error relativePath = filepath:relative(\"a/b/c\", \"a/c/d\");    Parameters  base string String value of the base file path   target string String value of the target file path   Return Type (string | )  The extension of the file, empty string otherwise, or else an filepath:Error occurred if at least one path is invalid   resolve (string path)  returns string | Returns the filepath after the evaluation of any symbolic links. If the path is relative, the result will be relative to the current directory unless one of the components is an absolute symbolic link. Resolves normalising the calls on the result.  string|filepath:Error resolvedPath = filepath:resolve(\"a/b/c\");    Parameters  path string Security-validated string value of the file path   Return Type (string | )  Resolved file path or else a filepath:Error if the path is invalid   split (string path)  returns string[] | Splits a list of paths joined by the OS-specific path separator.  string[]|filepath:Error parts = filepath:split(\"/A/B/C\");    Parameters  path string String value of the file path   Return Type (string[] | )  String array of the part components or else a filepath:Error if the path is invalid"},{"page":"/learn/api-docs/ballerina/filepath/records/Detail.html","name":"Record - : Detail","summary":"A record type defined to be used as the \"error detail\" in the errors defined in this module.\n\n ...","content":"Records  v1.2.2  All Modules  Record - : Detail  A record type defined to be used as the \"error detail\" in the errors defined in this module.   Fields  message  string  A message describing the error in detail   cause  error  The error, which caused this error (if any)"},{"page":"/learn/api-docs/ballerina/grpc/clients/StreamingClient.html","name":"Clients - : StreamingClient","summary":"Provides the gRPC streaming client actions for interacting with the gRPC server.\n(anydata res)Sends the request message to the server.\nThe inbound request messageA grpc:Error if an error occurs while sending the response or else ()()Informs the server when the caller has sent all the messages.\nA grpc:Error if an error occurs while ...","content":"Clients  v1.2.2  All Modules  Clients - :  StreamingClient  Provides the gRPC streaming client actions for interacting with the gRPC server.    Remote Methods  Sends the request message to the server.  grpc:Error? err = caller->send(message);    Informs the server when the caller has sent all the messages.  grpc:Error? result = caller->complete();    Sends an error message to the server.  grpc:Error? result = streamingClient->sendError(grpc:ABORTED, \"Operation aborted\");    send (anydata res)  returns ? Sends the request message to the server.  grpc:Error? err = caller->send(message);    Parameters  res anydata The inbound request message   Return Type (?)  A grpc:Error if an error occurs while sending the response or else ()   complete ()  returns ? Informs the server when the caller has sent all the messages.  grpc:Error? result = caller->complete();    Return Type (?)  A grpc:Error if an error occurs while sending the response or else ()   sendError (int statusCode, string message)  returns ? Sends an error message to the server.  grpc:Error? result = streamingClient->sendError(grpc:ABORTED, \"Operation aborted\");    Parameters  statusCode int Error status code   message string Error message   Return Type (?)  A grpc:Error if an error occurs while sending the response or else ()"},{"page":"/learn/api-docs/ballerina/grpc/clients/Client.html","name":"Clients - : Client","summary":"The gRPC client endpoint provides the capability for initiating contact with a remote gRPC service. The API it\nprovides includes functions to send request/error messages.\n(string url, ? config)The server URL(string methodID, anydata payload, ? headers)Calls when executing a blocking call with a gRPC service.\nRemote service method IDRequest message. The message type ...","content":"Clients  v1.2.2  All Modules  Clients - :  Client  The gRPC client endpoint provides the capability for initiating contact with a remote gRPC service. The API it provides includes functions to send request/error messages.    Constructor __init(string url, ? config)   url string The server URL   config ? ()  The grpc:ClientConfiguration of the endpoint    Remote Methods  Calls when executing a blocking call with a gRPC service.  [anydata, grpc:Headers]|grpc:Error result = grpcClient->blockingExecute(\"HelloWorld/hello\", req, headers);    Calls when executing a non-blocking call with a gRPC service.  grpc:Error? result = grpcClient->nonBlockingExecute(\"HelloWorld/hello\", req, msgListener, headers);    Calls when executing a streaming call with a gRPC service.  grpc:StreamingClient|grpc:Error result = grpcClient->streamingExecute(\"HelloWorld/lotsOfGreetings\", msgListener, headers);    Methods  Calls when initializing the client endpoint with the service descriptor data extracted from the proto file.  blockingExecute (string methodID, anydata payload, ? headers)  returns [anydata, ] | Calls when executing a blocking call with a gRPC service.  [anydata, grpc:Headers]|grpc:Error result = grpcClient->blockingExecute(\"HelloWorld/hello\", req, headers);    Parameters  methodID string Remote service method ID   payload anydata Request message. The message type varies with the remote service method parameter   headers ? (default ())  Optional headers parameter. The header value are passed only if needed. The default value is ()   Return Type ([anydata, ] | )  The response message and headers if executed successfully or else a grpc:Error   nonBlockingExecute (string methodID, anydata payload, service listenerService, ? headers)  returns ? Calls when executing a non-blocking call with a gRPC service.  grpc:Error? result = grpcClient->nonBlockingExecute(\"HelloWorld/hello\", req, msgListener, headers);    Parameters  methodID string Remote service method ID   payload anydata Request message. The message type varies with the remote service method parameter   listenerService service Call back listener service. This service listens to the response message from the service   headers ? (default ())  Optional headers parameter. The header values are passed only if needed. The default value is ()   Return Type (?)  A grpc:Error if an error occurs while sending the request or else ()   streamingExecute (string methodID, service listenerService, ? headers)  returns | Calls when executing a streaming call with a gRPC service.  grpc:StreamingClient|grpc:Error result = grpcClient->streamingExecute(\"HelloWorld/lotsOfGreetings\", msgListener, headers);    Parameters  methodID string Remote service method ID   listenerService service Call back listener service. This service listens to the response message from the service   headers ? (default ())  Optional headers parameter. The header values are passed only if needed. The default value is ()   Return Type ( | )  A grpc:StreamingClient object if executed successfully or else ()   initStub ( clientEndpoint, string stubType, string descriptorKey, map descriptorMap)  returns ? Calls when initializing the client endpoint with the service descriptor data extracted from the proto file.  grpc:Error? result = grpcClient.initStub(self, \"blocking\", ROOT_DESCRIPTOR, getDescriptorMap());    Parameters  clientEndpoint Client endpoint   stubType string Service Stub type. Possible values: blocking, nonblocking   descriptorKey string Key of the proto descriptor   descriptorMap map Proto descriptor map with all the dependent descriptors   Return Type (?)  A grpc:Error if an error occurs while initializing the stub or else ()"},{"page":"/learn/api-docs/ballerina/grpc/clients/Caller.html","name":"Clients - : Caller","summary":"Provides the gRPC remote functions for interacting with caller.\n\n                    \n                    The remote ...","content":"Clients  v1.2.2  All Modules  Clients - :  Caller  Provides the gRPC remote functions for interacting with caller.    Remote Methods  Sends the outbound response to the caller.  grpc:Error? err = caller->send(message, headers);    Informs the caller, when the server has sent all the messages.  grpc:Error? result = caller->complete();    Sends a server error to the caller.  grpc:Error? result = caller->sendError(grpc:ABORTED, \"Operation aborted\", headers);    Methods  Returns the unique identification of the caller.  Checks whether the connection is closed by the caller.  Fields  remoteDetails  (default {}) The remote details   local  (default {}) The local details   send (anydata res, ? headers)  returns ? Sends the outbound response to the caller.  grpc:Error? err = caller->send(message, headers);    Parameters  res anydata The outbound response message    headers ? (default ())  Optional headers parameter. The header values are passed only if needed. The default value is ()    Return Type (?)  A grpc:Error if an error occurs while sending the response or else ()    complete ()  returns ? Informs the caller, when the server has sent all the messages.  grpc:Error? result = caller->complete();    Return Type (?)  A grpc:Error if an error occurs while sending the response or else ()   sendError (int statusCode, string message, ? headers)  returns ? Sends a server error to the caller.  grpc:Error? result = caller->sendError(grpc:ABORTED, \"Operation aborted\", headers);    Parameters  statusCode int Error status code   message string Error message   headers ? (default ())  Optional headers parameter. The header values are passed only if needed. The default value is ()   Return Type (?)  A grpc:Error if an error occurs while sending the response or else ()   getId ()  returns int Returns the unique identification of the caller.  int result = caller.getId();    Return Type (int)  caller ID   isCancelled ()  returns boolean Checks whether the connection is closed by the caller.  boolean result = caller.isCancelled();    Return Type (boolean)  True if the caller has already closed the connection or else false"},{"page":"/learn/api-docs/ballerina/grpc/","name":"Module : grpc","summary":"This module provides support for the gRPC messaging protocol. gRPC is an inter-process communication technology that allows you to connect, invoke and operate distributed heterogeneous applications as easily as making a local function call. The gRPC protocol is layered over HTTP/2 and It uses Protocol Buffers for marshaling/unmarshaling messages. This ...","content":"v1.2.2  All Modules  Module : grpc  Module Overview This module provides support for the gRPC messaging protocol. gRPC is an inter-process communication technology that allows you to connect, invoke and operate distributed heterogeneous applications as easily as making a local function call. The gRPC protocol is layered over HTTP/2 and It uses Protocol Buffers for marshaling/unmarshaling messages. This makes gRPC, highly efficient on wire and a simple service definition framework. When you develop a gRPC application the first thing you do is define a service definition using Protocol Buffers. Protocol buffers This is a mechanism to serialize the structured data introduced by Google and used by the gRPC framework. Defining the service using Protocol Buffers includes defining remote methods in the service and defining message types that are sent across the network. A sample service definition is shown below. syntax = \"proto3\";  service Helloworld {  rpc hello(HelloRequest) returns (HelloResponse); }  message HelloRequest {  string name = 1; }  message HelloResponse {  string message = 1; }  gRPC allows client applications to directly call the server-side methods using the auto-generated stubs. Protocol Buffer compiler is used to generate the stubs for the specified language. In Ballerina, the stubs are generated using the built-in proto compiler. For the guide on how to generate Ballerina code for Protocol Buffers definition, see . For examples on the usage of the operation, see the . gRPC Communication Patterns The common communication pattern between client and server is simple request-response style communication. However, with gRPC, you can leverage different inter-process communication patterns other than the simple request-response pattern. This module supports four fundamental communication patterns used in gRPC-based applications: simple RPC(unary RPC), server-side streaming, client-side streaming, and bidirectional streaming. Simple RPC (Unary RPC) In this pattern, the client invokes a remote function of a server and sends a single request to the server. The server sends a single response in return to the client along with status details. Users can invoke in both blocking and non-blocking manner. rpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue);  Creating the server The code snippet given below contains a service that sends a response to each request. // The gRPC service is attached to the listener. service HelloWorld on new grpc:Listener(9090) {  // A resource that accepts a string message.  resource function hello(grpc:Caller caller, string name) {  // Send the response to the client.  grpc:Error? err = caller->send(\"Hi \" + name + \"! Greetings from gRPC service!\");   // After sending the response, call ‘complete()’ to indicate that the response was completely sent.  grpc:Error? result = caller->complete();  } }  Creating the client The code snippet given below calls the above service in a blocking manner using an auto-generated Ballerina stub. // Use ‘BlockingClient’ to execute the call in the blocking mode. HelloWorldBlockingClient blockingClient = new(\"http://localhost:9090\");  // Create gRPC headers. grpc:Headers headers = new; headers.setEntry(\"id\", \"newrequest1\");  // Call the method in the service using a client stub. [string, grpc:Headers]|grpc:Error responseFromServer = blockingClient->hello(\"Ballerina\", headers);  For examples on the usage of the operation, see and Server streaming RPC In server-side streaming RPC, the sends back a sequence of responses after getting the client's request message. After sending all the server responses, the server marks the end of the stream by sending the server status details. Users can invoke in a non-blocking manner. rpc lotsOfReplies (google.protobuf.StringValue)  returns (stream google.protobuf.StringValue);  Creating the server The code snippet given below contains a service that sends a sequence of responses to each request. // The gRPC service is attached to the listener. service HelloWorld on new grpc:Listener(9090) {  // Set the Streaming Annotation to ‘true’. It specifies that the resource is capable of  // sending multiple responses per request.  @grpc:ResourceConfig { streaming: true }  resource function lotsOfReplies(grpc:Caller caller, string name) {  string[] greets = [\"Hi\", \"Welcome\"];  // Send multiple responses to the client.  foreach string greet in greets {  grpc:Error? err = caller->send(greet + \" \" + name + \"! Greetings from Ballerina service\");  }  // Once the messages are sent to the server, call ‘complete()’ to indicate that the request was completely sent.  grpc:Error? result = caller->complete();  } }  Creating the client The code snippet given below calls the above service using the auto-generated Ballerina client stub and listens to the multiple responses from the server.  // Client endpoint configurations.  HelloWorldClient helloworldClient = new(\"http://localhost:9090\");   // Execute the service streaming call by registering a message listener.  grpc:Error? result = helloworldClient->lotsOfReplies (\"Ballerina\", HelloWorldMessageListener);  // Define a listener service to receive the messages from the server. service HelloWorldMessageListener = service {   // This resource method is invoked when the service receives a message.  resource function onMessage(string message) {  }  // This resource method is invoked if an error is returned.  resource function onError(error err) {  }   // Invoke this resource when the server sends all the responses to the request.  resource function onComplete() {  } }  For examples on the usage of the operation, see the . Client streaming RPC In client streaming RPC, the client sends multiple messages to the server instead of a single request. The server sends back a single response to the client. rpc lotsOfGreetings (stream google.protobuf.StringValue)  returns (google.protobuf.StringValue);  Creating the server The code snippet given below contains a service that receives a sequence of requests from the client and a single response in return. // The gRPC service is attached to the listener. @grpc:ServiceConfig {  name: \"HelloWorld\",  clientStreaming: true } service HelloWorld on new grpc:Listener(9090) { //This `resource` is triggered when a new caller connection is initialized. resource function onOpen(grpc:Caller caller) { }  //This `resource` is triggered when the caller sends a request message to the service. resource function onMessage(grpc:Caller caller, string name) { }  //This `resource` is triggered when the server receives an error message from the caller. resource function onError(grpc:Caller caller, error err) { }  //This `resource` is triggered when the caller sends a notification to the server to indicate that it has finished sending messages. resource function onComplete(grpc:Caller caller) {  grpc:Error? err = caller->send(\"Ack\"); } }  Creating the client The code snippet given below calls the above service using the auto-generated Ballerina client stub and sends multiple request messages from the server.  // Client endpoint configurations.  HelloWorldClient helloworldClient = new(\"http://localhost:9090\");   // Execute the service streaming call by registering a message listener.  grpc:StreamingClient|grpc:Error ep = helloworldClient->lotsOfGreetings(HelloWorldMessageListener);  // Send multiple messages to the server. string[] greets = [\"Hi\", \"Hey\", \"GM\"]; foreach string greet in greets {  grpc:Error? connErr = ep->send(greet + \" \" + \"Ballerina\"); }  // Once all the messages are sent, the server notifies the caller with a `complete` message. grpc:Error? result = ep->complete(); ...  // Define a listener service to receive the messages from the server. service HelloWorldMessageListener = service {   // This resource method is invoked when the service receives a message.  resource function onMessage(string message) {  }  // This resource method is invoked if an error is returned.  resource function onError(error err) {  }   // Invoke this resource when the server sends all the responses to the request.  resource function onComplete() {  } }  For examples on the usage of the operation, see the . Bidirectional Streaming RPC In bidirectional streaming RPC, the client is sending a request to the server as a stream of messages. The server also responds with a stream of messages. rpc chat (stream ChatMessage)  returns (stream google.protobuf.StringValue);  Creating the server The code snippet given below includes a service that handles bidirectional streaming. // Set the ‘clientStreaming’ and ‘serverStreaming’ to true. It specifies that the service supports bidirectional streaming. @grpc:ServiceConfig {  name: \"Chat\",  clientStreaming: true,  serverStreaming: true } service Chat on new grpc:Listener(9090) {   //This `resource` is triggered when a new caller connection is initialized.  resource function onOpen(grpc:Caller caller) {  }   //This `resource` is triggered when the caller sends a request message to the `service`.  resource function onMessage(grpc:Caller caller, ChatMessage chatMsg) {  grpc:Error? err = caller->send(string `${chatMsg.name}: ${chatMsg.message}`);  }   //This `resource` is triggered when the server receives an error message from the caller.  resource function onError(grpc:Caller caller, error err) {  }   //This `resource` is triggered when the caller sends a notification to the server to indicate that it has finished sending messages.  resource function onComplete(grpc:Caller caller) {  } }  Creating the client The code snippet given below calls the above service using the auto-generated Ballerina client stub and sends multiple request messages to the server and receives multiple responses from the server.  // Client endpoint configurations.  ChatClient chatClient = new(\"http://localhost:9090\");   // Execute the service streaming call by registering a message listener.  grpc:StreamingClient|grpc:Error ep = = chatClient->chat(ChatMessageListener);  // Send multiple messages to the server. string[] greets = [\"Hi\", \"Hey\", \"GM\"]; foreach string greet in greets {  ChatMessage mes = {name: \"Ballerina\", message: greet};  grpc:Error? connErr = ep->send(mes); }  // Once all the messages are sent, the server notifies the caller with a `complete` message. grpc:Error? result = ep->complete(); ...  // Define a listener service to receive the messages from the server. service ChatMessageListener = service {   // This resource method is invoked when the service receives a message.  resource function onMessage(string message) {  }  // This resource method is invoked if an error is returned.  resource function onError(error err) {  }   // Invoke this resource when the server sends all the responses to the request.  resource function onComplete() {  } }  For examples on the usage of the operation, see the . Advanced Use cases Using the TLS protocol The Ballerina gRPC module allows the use TLS in communication. This setting expects a secure socket to be set in the connection configuration as shown below. Configuring TLS in server side // Server endpoint configuration with the SSL configurations. listener grpc:Listener ep = new (9090, {  host: \"localhost\",  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  service HelloWorld on ep {  }  Configuring TLS in client side  // Client endpoint configuration with SSL configurations.  HelloWorldBlockingClient helloWorldClient = new (\"https://localhost:9090\", {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  });  For examples on the usage of the operation, see the .    Records Represents client endpoint configuration.  The details of a gRPC error.  Service resource configuration.  Service configuration.  Represents the gRPC server endpoint configuration.  OcspStapling record represents options related to check whether a certificate is revoked or not.  Configures the SSL/TLS options to be used for HTTP service.  Presents a read-only view of the local address.  Configurations for managing the gRPC client connection pool.  Protocols record represents SSL/TLS protocol related options to be used for HTTP client/service invocation.  Presents a read-only view of the remote address.  Represents grpc client retry functionality configurations.  Provides the configurations for facilitating secure communication with a remote HTTP endpoint.  Service descriptor data generated at the compile time.  ValidateCert record represents options related to check whether a certificate is revoked or not.  Objects Represents the abstract gRPC client endpoint.  Provides the actions to read/write header values in a gRPC request/response message.  Clients Provides the gRPC remote functions for interacting with caller.  The gRPC client endpoint provides the capability for initiating contact with a remote gRPC service.  Provides the gRPC streaming client actions for interacting with the gRPC server.  Listeners Represents server listener where one or more services can be registered.  Functions Prepare the error as a gRPC-specific Error.  Constants The gRPC error status code: 0 OK.  The gRPC error status code: 1 Canceled.  The gRPC error status code: 2 Unknown.  The gRPC error status code: 3 Invalid Argument.  The gRPC error status code: 4 Deadline Exceeded.  The gRPC error status code: 5 Not Found.  The gRPC error status code: 6 Already Exists.  The gRPC error status code: 7 Permission Denied.  The gRPC error status code: 8 Resource Exhausted.  The gRPC error status code: 9 Failed Precondition.  The gRPC error status code: 10 Aborted.  The gRPC error status code: 11 Out of Range.  The gRPC error status code: 12 Unimplemented.  The gRPC error status code: 13 Internal.  The gRPC error status code: 14 Unavailable.  The gRPC error status code: 15 Data Loss.  The gRPC error status code: 16 Unauthenticated.  When service behaves as a HTTP gateway inbound request/response accept-encoding option is set as the outbound request/response accept-encoding/content-encoding option.  Always set accept-encoding/content-encoding in outbound request/response.  Never set accept-encoding/content-encoding header in outbound request/response.  Represents the reason of the cancelled error.  Represents the reason of the unknown error.  Represents the reason of the invalid argument error.  Represents the reason of the deadline exceeded error.  Represents the reason of the not found error.  Represents the reason of the already exists error.  Represents the reason of the permission denied error.  Represents the reason of the unauthenticated error.  Represents the reason of the resource exhausted error.  Represents the reason of the failed precondition error.  Represents the reason of the aborted error.  Represents the reason of the out of range error.  Represents the reason of the unimplemented error.  Represents the reason of the internal error.  Represents the reason of the unavailable error.  Represents the reason of the data loss error.  Represents the reason of all the retry attempts failed scenario.  Annotations Service resource configuration annotation.  Service configuration annotation.  Service descriptor annotation.  Types Options to compress using gzip or deflate.  Represents gRPC related errors.  Represents gRPC related error types.  Represents all the resiliency-related errors.  Represents the reason of all the resiliency-related error.  Errors Represents error occur when operation is aborted.  Represents error occur when attempt to create an entity which already exists.  Represents error scenario where the maximum retry attempts are done and still received an error.  Represents the operation canceled(typically by the caller) error.  Represents unrecoverable data loss or corruption erros.  Represents operation expired before completion error.  Represents error occur when operation is rejected because the system is not in a state required for the operation's execution.  Represents internal error.  Represents client specified an invalid argument error.  Represents requested entity (e.  Represents error occur when specified value is out of range.  Represents error occur when the caller does not have permission to execute the specified operation.  Represents error occur when the resource is exhausted.  Represents unknown error.  Represents error occur when the request does not have valid authentication credentials for the operation.  Represents error occur when the service is currently unavailable.  Represents error occur when operation is not implemented or not supported/enabled in this service."},{"page":"/learn/api-docs/ballerina/grpc/functions.html","name":"Functions -","summary":"( errorType, string message, error? cause)Prepare the error as a gRPC-specific Error.\nThe error typeThe error messageThe error instanceThe prepared grpc:Error instance ...","content":"Functions  v1.2.2  All Modules  Functions - Prepare the error as a gRPC-specific Error.  prepareError ( errorType, string message, error? cause)  returns Prepare the error as a gRPC-specific Error.   Parameters  errorType The error type   message string The error message   cause error? The error instance   Return Type ()  The prepared grpc:Error instance"},{"page":"/learn/api-docs/ballerina/grpc/listeners/Listener.html","name":"Listener - : Listener","summary":"Represents server listener where one or more services can be registered. so that ballerina program can offer\nservice through this listener.\n(int port, ? config)Listener portThe grpc:ListenerConfiguration of the endpoint()Stops the service listener gracefully. Already-accepted requests will be served before the connection closure.\nAn error if an error occurred during the listener stopping ...","content":"Listeners  v1.2.2  All Modules  Listener - : Listener Represents server listener where one or more services can be registered. so that ballerina program can offer service through this listener.    Constructor __init(int port, ? config)   port int Listener port   config ? ()  The grpc:ListenerConfiguration of the endpoint   Methods  Stops the service listener gracefully.  Stops the registered service.  Detaches an HTTP or WebSocket service from the listener.  LifeCycle Methods  Starts the registered service.  Gets called every time a service attaches itself to this endpoint - also happens at module init time.  Methods  __gracefulStop ()  returns error? Stops the service listener gracefully. Already-accepted requests will be served before the connection closure.  error? result = listenerEp.__gracefulStop();    Return Type (error?)  An error if an error occurred during the listener stopping process or else ()   __immediateStop ()  returns error? Stops the registered service.  error? result = listenerEp.__immediateStop();    Return Type (error?)  An error if an error occurs while stopping the server or else ()   __detach (service s)  returns error? Detaches an HTTP or WebSocket service from the listener. Note that detaching a WebSocket service would not affect the functionality of the existing connections.  error? result = listenerEp.__detach(helloService);    Parameters  s service The service to be detached   Return Type (error?)  An error if occurred during detaching of a service or else ()   LifeCycle Methods  __start ()  returns error? Starts the registered service.  error? result = listenerEp.__start();    Return Type (error?)  An error if an error occurs while starting the server or else ()   __attach (service s, string? name)  returns error? Gets called every time a service attaches itself to this endpoint - also happens at module init time.  error? result = listenerEp.__attach(helloService);    Parameters  s service The type of the service to be registered   name string? (default ())  Name of the service   Return Type (error?)  An error if encounters an error while attaching the service or else ()"},{"page":"/learn/api-docs/ballerina/grpc/objects/AbstractClientEndpoint.html","name":"Object - : AbstractClientEndpoint","summary":"Represents the abstract gRPC client endpoint. This abstract object is used in client endpoints generated by the\nProtocol Buffer ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  AbstractClientEndpoint  Represents the abstract gRPC client endpoint. This abstract object is used in client endpoints generated by the Protocol Buffer tool."},{"page":"/learn/api-docs/ballerina/grpc/records/ClientConfiguration.html","name":"Record - : ClientConfiguration","summary":"Represents client endpoint configuration.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : ClientConfiguration  Represents client endpoint configuration.   Fields  timeoutInMillis  int  (default 60000) The maximum time to wait (in milliseconds) for a response before closing the connection   poolConfig  ?  (default ()) Connection pool configuration   secureSocket  ?  (default ()) SSL/TLS related options   compression  (default COMPRESSION_AUTO) Specifies the way of handling compression (accept-encoding) header   retryConfiguration  ?  (default ()) Configures the retry functionality"},{"page":"/learn/api-docs/ballerina/grpc/records/GrpcServiceConfig.html","name":"Record - : GrpcServiceConfig","summary":"Service configuration.\n\n            \n     ...","content":"Records  v1.2.2  All Modules  Record - : GrpcServiceConfig  Service configuration.   Fields  name  string  Service name. This applies only for the dynamic service registration.   requestType  typedesc  Request message type of the resource. This is an optional field. If it is not specified, the request type is derived from the input argument of the resource   responseType  typedesc  Response message type of the resource. This is an optional field. If it is not specified, the response type is derived from the value passed to the send() expression   clientStreaming  boolean  (default false) Client streaming flag. This applies only for client streaming and bidirectional streaming. The flag should be set to true if the service is defined as client/bidirectional streaming   serverStreaming  boolean  (default false) Server streaming flag. This applies only for bidirectional streaming. The flag should be set to true if the service is defined as bidirectional streaming"},{"page":"/learn/api-docs/ballerina/grpc/objects/Headers.html","name":"Object - : Headers","summary":"Provides the actions to read/write header values in a gRPC request/response message.\n\n       ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  Headers  Provides the actions to read/write header values in a gRPC request/response message.   Methods  Checks whether the requested header exists.  Returns the header value with the specified header name.  Gets all the transport headers with the specified header name.  Sets the value of a transport header.  Adds the specified key/value pair as an HTTP header to the request.  Removes a transport header from the request.  Removes all the transport headers from the message.  exists (string headerName)  returns boolean Checks whether the requested header exists.  boolean result = headers.exists(\"content-type\");    Parameters  headerName string The header name   Return Type (boolean)  True if header exists or else false   get (string headerName)  returns string? Returns the header value with the specified header name. If there are more than one header values for the specified header name, the first value is returned.  string? result = headers.get(\"content-type\");    Parameters  headerName string The header name   Return Type (string?)  First header value if exists or else ()   getAll (string headerName)  returns string[] Gets all the transport headers with the specified header name.  string[] result = headers.getAll(\"content-type\");    Parameters  headerName string The header name   Return Type (string[])  Header value array   setEntry Sets the value of a transport header.  headers.setEntry(\"content-type\", \"application/grpc\")    Parameters  headerName string The header name   headerValue string The header value   addEntry Adds the specified key/value pair as an HTTP header to the request.  headers.addEntry(\"content-type\", \"application/grpc\")    Parameters  headerName string The header name   headerValue string The header value   remove Removes a transport header from the request.  headers.remove(\"content-type\")    Parameters  headerName string The header name   removeAll Removes all the transport headers from the message.  headers.removeAll()"},{"page":"/learn/api-docs/ballerina/grpc/records/Detail.html","name":"Record - : Detail","summary":"The details of a gRPC error.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : Detail  The details of a gRPC error.   Fields  message  string  Specific error message for the error   cause  error  Cause of the error if this error occurred due to another error (probably from another module)"},{"page":"/learn/api-docs/ballerina/grpc/records/GrpcResourceConfig.html","name":"Record - : GrpcResourceConfig","summary":"Service resource configuration. This should be set only for server streaming services.\n\n       ...","content":"Records  v1.2.2  All Modules  Record - : GrpcResourceConfig  Service resource configuration. This should be set only for server streaming services.   Fields  streaming  boolean  (default false) Server streaming flag. This flag should be set to true to specify that the resource is capable of sending multiple responses per request.   requestType  typedesc  Request message type of the resource. This is an optional field. If it is not specified, request type is derived from input argument of the resource.   responseType  typedesc  Response message type of the resource. This is an optional field. If it is not specified, response type is derived from the value passed to the send() expression."},{"page":"/learn/api-docs/ballerina/grpc/records/ListenerConfiguration.html","name":"Record - : ListenerConfiguration","summary":"Represents the gRPC server endpoint configuration.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : ListenerConfiguration  Represents the gRPC server endpoint configuration.   Fields  host  string  (default 0.0.0.0) The server hostname   secureSocket  ?  (default ()) The SSL configurations for the client endpoint   timeoutInMillis  int  (default DEFAULT_LISTENER_TIMEOUT) Period of time in milliseconds that a connection waits for a read/write operation. Use value 0 to disable the timeout"},{"page":"/learn/api-docs/ballerina/grpc/records/ListenerOcspStapling.html","name":"Record - : ListenerOcspStapling","summary":"OcspStapling record represents options related to check whether a certificate is revoked or not.\n\n     ...","content":"Records  v1.2.2  All Modules  Record - : ListenerOcspStapling  OcspStapling record represents options related to check whether a certificate is revoked or not.   Fields  enable  boolean  (default false) The status of OcspStapling   cacheSize  int  (default 0) Maximum size of the cache   cacheValidityPeriod  int  (default 0) Time duration of cache validity period"},{"page":"/learn/api-docs/ballerina/grpc/records/ListenerSecureSocket.html","name":"Record - : ListenerSecureSocket","summary":"Configures the SSL/TLS options to be used for HTTP service.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : ListenerSecureSocket  Configures the SSL/TLS options to be used for HTTP service.   Fields  trustStore  ?  (default ()) Configures the trust store to be used   keyStore  ?  (default ()) Configures the key store to be used   certFile  string  A file containing the certificate of the server   keyFile  string  A file containing the private key of the server   keyPassword  string  Password of the private key if it is encrypted   trustedCertFile  string  A file containing a list of certificates or a single certificate that the server trusts   protocol  ?  (default ()) SSL/TLS protocol related options   certValidation  ?  (default ()) Certificate validation against CRL or OCSP related options   ciphers  string[]  (default [TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256]) List of ciphers to be used (e.g.: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA)   sslVerifyClient  string  The type of client certificate verification. (e.g.: \"require\" or \"optional\")   shareSession  boolean  (default true) Enable/disable new SSL session creation   ocspStapling  ?  (default ()) Enable/disable OCSP stapling   handshakeTimeoutInSeconds  int  SSL handshake time out   sessionTimeoutInSeconds  int  SSL session time out"},{"page":"/learn/api-docs/ballerina/grpc/records/Local.html","name":"Record - : Local","summary":"Presents a read-only view of the local address.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : Local  Presents a read-only view of the local address.   Fields  host  string  The local host name/IP   port  int  (default 0) The local port"},{"page":"/learn/api-docs/ballerina/grpc/records/PoolConfiguration.html","name":"Record - : PoolConfiguration","summary":"Configurations for managing the gRPC client connection pool.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : PoolConfiguration  Configurations for managing the gRPC client connection pool.   Fields  maxActiveConnections  int  (default config:getAsInt(b7a.http.pool.maxActiveConnections, -1)) Max active connections per route(host:port). The default value is -1, which indicates unlimited   maxIdleConnections  int  (default config:getAsInt(b7a.http.pool.maxIdleConnections, 1000)) Maximum number of idle connections allowed per pool   waitTimeInMillis  int  (default config:getAsInt(b7a.http.pool.waitTimeInMillis, 60000)) Maximum amount of time the client should wait for an idle connection before it sends an error when the pool is exhausted   maxActiveStreamsPerConnection  int  (default config:getAsInt(b7a.http.pool.maxActiveStreamsPerConnection, 50)) Maximum active streams per connection. This only applies to HTTP/2"},{"page":"/learn/api-docs/ballerina/grpc/records/Protocols.html","name":"Record - : Protocols","summary":"Protocols record represents SSL/TLS protocol related options to be used for HTTP client/service invocation.\n\n     ...","content":"Records  v1.2.2  All Modules  Record - : Protocols  Protocols record represents SSL/TLS protocol related options to be used for HTTP client/service invocation.   Fields  name  string  SSL Protocol to be used. eg TLS1.2   versions  string[]  (default []) SSL/TLS protocols to be enabled. eg TLSv1,TLSv1.1,TLSv1.2"},{"page":"/learn/api-docs/ballerina/grpc/records/Remote.html","name":"Record - : Remote","summary":"Presents a read-only view of the remote address.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : Remote  Presents a read-only view of the remote address.   Fields  host  string  The remote host name/IP   port  int  (default 0) The remote port"},{"page":"/learn/api-docs/ballerina/grpc/records/RetryConfiguration.html","name":"Record - : RetryConfiguration","summary":"Represents grpc client retry functionality configurations.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : RetryConfiguration  Represents grpc client retry functionality configurations.   Fields  retryCount  int  Maximum number of retry attempts in an failure scenario   intervalInMillis  int  Initial interval between retry attempts   maxIntervalInMillis  int  Maximum interval between two retry attempts   backoffFactor  int  Retry interval will be multiplied by this factor, in between retry attempts   errorTypes  []  (default [INTERNAL_ERROR]) Error reasons which should be considered as failure scenarios to retry"},{"page":"/learn/api-docs/ballerina/grpc/records/SecureSocket.html","name":"Record - : SecureSocket","summary":"Provides the configurations for facilitating secure communication with a remote HTTP endpoint.\n\n       ...","content":"Records  v1.2.2  All Modules  Record - : SecureSocket  Provides the configurations for facilitating secure communication with a remote HTTP endpoint.   Fields  disable  boolean  (default false) Disable the SSL validation   trustStore  ?  (default ()) Configurations associated with the TrustStore   keyStore  ?  (default ()) Configurations associated with the KeyStore   certFile  string  A file containing the certificate of the client   keyFile  string  A file containing the private key of the client   keyPassword  string  Password of the private key if it is encrypted   trustedCertFile  string  A file containing a list of certificates or a single certificate that the client trusts   protocol  ?  (default ()) SSL/TLS protocol related options   certValidation  ?  (default ()) Certificate validation against CRL or OCSP related options   ciphers  string[]  (default []) List of ciphers to be used eg: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA   verifyHostname  boolean  (default true) Enable/disable host name verification   shareSession  boolean  (default true) Enable/disable new SSL session creation   ocspStapling  boolean  (default false) Enable/disable OCSP stapling   handshakeTimeoutInSeconds  int  SSL handshake time out   sessionTimeoutInSeconds  int  SSL session time out"},{"page":"/learn/api-docs/ballerina/grpc/records/ServiceDescriptorData.html","name":"Record - : ServiceDescriptorData","summary":"Service descriptor data generated at the compile time. This is for internal use.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : ServiceDescriptorData  Service descriptor data generated at the compile time. This is for internal use.   Fields  descriptor  string  Service descriptor, which should be set at the compile time   descMap  map  (default {}) Service dependent descriptor map, which should be set at the compile time"},{"page":"/learn/api-docs/ballerina/grpc/records/ValidateCert.html","name":"Record - : ValidateCert","summary":"ValidateCert record represents options related to check whether a certificate is revoked or not.\n\n     ...","content":"Records  v1.2.2  All Modules  Record - : ValidateCert  ValidateCert record represents options related to check whether a certificate is revoked or not.   Fields  enable  boolean  (default false) The status of validateCertEnabled   cacheSize  int  (default 0) Maximum size of the cache   cacheValidityPeriod  int  (default 0) Time duration of cache validity period"},{"page":"/learn/api-docs/ballerina/http/clients/CircuitBreakerClient.html","name":"Clients - : CircuitBreakerClient","summary":"A Circuit Breaker implementation which can be used to gracefully handle network failures.\n(string url,  config,  circuitBreakerInferredConfig,  httpClient,  circuitHealth)The URL of the target serviceThe configurations of the client endpoint associated with this CircuitBreaker instanceConfigurations derived from the http:CircuitBreakerConfigThe underlying HttpActions instance, which will be making the actual ...","content":"Clients  v1.2.2  All Modules  Clients - :  CircuitBreakerClient  A Circuit Breaker implementation which can be used to gracefully handle network failures.    Constructor __init(string url, config, circuitBreakerInferredConfig, httpClient, circuitHealth)   url string The URL of the target service   config The configurations of the client endpoint associated with this CircuitBreaker instance   circuitBreakerInferredConfig Configurations derived from the http:CircuitBreakerConfig   httpClient The underlying HttpActions instance, which will be making the actual network calls   circuitHealth The circuit health monitor   Methods  The POST remote function implementation of the Circuit Breaker.  The HEAD remote function implementation of the Circuit Breaker.  The PUT remote function implementation of the Circuit Breaker.  This wraps the CircuitBreakerClient.  The PATCH remote function implementation of the Circuit Breaker.  The DELETE remote function implementation of the Circuit Breaker.  The GET remote function implementation of the Circuit Breaker.  The OPTIONS remote function implementation of the Circuit Breaker.  This wraps the CircuitBreakerClient.  Submits an HTTP request to a service with the specified HTTP verb.  Retrieves the http:Response for a previously-submitted request.  Circuit breaking is not supported.  Retrieves the next available http:PushPromise for a previously-submitted request.  Retrieves the promised server push Response message.  Circuit breaking is not supported.  Force the circuit into a closed state in which it will allow requests regardless of the error percentage until the failure threshold exceeds.  Force the circuit into a open state in which it will suspend all requests until resetTimeInMillis interval exceeds.  Provides the http:CircuitState of the circuit breaker.  Fields  url  string  The URL of the target service   config  The configurations of the client endpoint associated with this CircuitBreaker instance   circuitBreakerInferredConfig  Configurations derived from CircuitBreakerConfig   httpClient  The underlying HttpActions instance which will be making the actual network calls   circuitHealth  The circuit health monitor   currentCircuitState  (default CB_CLOSED_STATE) The current state the circuit is in   post (string path, message)  returns | The POST remote function implementation of the Circuit Breaker. This wraps the CircuitBreakerClient.post() function of the underlying HTTP remote functions provider.   Parameters  path string Resource path   message A Request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   head (string path, message)  returns | The HEAD remote function implementation of the Circuit Breaker. This wraps the CircuitBreakerClient.head() function of the underlying HTTP remote functions provider.   Parameters  path string Resource path   message (default ())  A Request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   put (string path, message)  returns | The PUT remote function implementation of the Circuit Breaker. This wraps the CircuitBreakerClient.put() function of the underlying HTTP remote functions provider.   Parameters  path string Resource path   message A Request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   execute (string httpVerb, string path, message)  returns | This wraps the CircuitBreakerClient.post() function of the underlying HTTP remote functions provider. The CircuitBreakerClient.execute() function can be used to invoke an HTTP call with the given HTTP verb.   Parameters  httpVerb string HTTP verb to be used for the request   path string Resource path   message A Request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   patch (string path, message)  returns | The PATCH remote function implementation of the Circuit Breaker. This wraps the CircuitBreakerClient.patch() function of the underlying HTTP remote functions provider.   Parameters  path string Resource path   message A Request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   delete (string path, message)  returns | The DELETE remote function implementation of the Circuit Breaker. This wraps the CircuitBreakerClient.delete() function of the underlying HTTP remote functions provider.   Parameters  path string Resource path   message (default ())  A Request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   get (string path, message)  returns | The GET remote function implementation of the Circuit Breaker. This wraps the CircuitBreakerClient.get() function of the underlying HTTP remote functions provider.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   options (string path, message)  returns | The OPTIONS remote function implementation of the Circuit Breaker. This wraps the CircuitBreakerClient.options() function of the underlying HTTP remote functions provider.   Parameters  path string Resource path   message (default ())  An optional HTTP Request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   forward (string path, request)  returns | This wraps the CircuitBreakerClient.forward() function of the underlying HTTP remote functions provider. The Forward remote function can be used to forward an incoming request to an upstream service as it is.   Parameters  path string Resource path   request A Request struct   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   submit (string httpVerb, string path, message)  returns | Submits an HTTP request to a service with the specified HTTP verb. The CircuitBreakerClient.submit() function does not give out a Response as the result. Rather it returns an http:HttpFuture which can be used to do further interactions with the endpoint.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:HttpFuture that represents an asynchronous service invocation or else an http:ClientError if the submission fails   getResponse ( httpFuture)  returns | Retrieves the http:Response for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean Circuit breaking is not supported. The default value is the CircuitBreakerClient.hasPromise() function of the underlying HTTP remote functions provider.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | Retrieves the next available http:PushPromise for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Retrieves the promised server push Response message.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised http:Response message or else an http:ClientError if the invocation fails   rejectPromise Circuit breaking is not supported. The default value is the CircuitBreakerClient.rejectPromise() function of the underlying HTTP remote functions provider.   Parameters  promise The http:PushPromise to be rejected   forceClose Force the circuit into a closed state in which it will allow requests regardless of the error percentage until the failure threshold exceeds.   forceOpen Force the circuit into a open state in which it will suspend all requests until resetTimeInMillis interval exceeds.   getCurrentState ()  returns Provides the http:CircuitState of the circuit breaker.   Return Type ()  The current http:CircuitState of the circuit breaker"},{"page":"/learn/api-docs/ballerina/http/clients/Caller.html","name":"Clients - : Caller","summary":"The caller actions for responding to client requests.\n\n                    \n                    The remote address\n ...","content":"Clients  v1.2.2  All Modules  Clients - :  Caller  The caller actions for responding to client requests.    Remote Methods  Sends the outbound response to the caller.   Pushes a promise to the caller.   Sends a promised push response to the caller.   Sends an upgrade request with custom headers.   Cancels the handshake.   Sends a 100-continue response to the caller.   Sends a redirect response to the user with the specified redirection status code.   Sends the outbound response to the caller with the status 200 OK.   Sends the outbound response to the caller with the status 201 Created.   Sends the outbound response to the caller with the status 202 Accepted.   Sends the outbound response to the caller with the status 204 No Content. If the given response contains a body that will be removed.  http:ListenerError? err = caller->noContent();    Sends the outbound response to the caller with the status 400 Bad Request.  http:ListenerError? err = caller->badRequest();    Sends the outbound response to the caller with the status 404 Not Found.  http:ListenerError? err = caller->notFound();    Sends the outbound response to the caller with the status 500 Internal Server Error.  http:ListenerError? err = caller->internalServerError();    Methods  Gets the hostname from the remote address.  Fields  remoteAddress  (default {}) The remote address   localAddress  (default {}) The local address   protocol  string  The protocol associated with the service endpoint   respond ( message)  returns ? Sends the outbound response to the caller.   Parameters  message (default ())  The outbound response or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type (?)  An http:ListenerError if failed to respond or else ()   promise ( promise)  returns ? Pushes a promise to the caller.   Parameters  promise Push promise message   Return Type (?)  An http:ListenerError in case of failures   pushPromisedResponse ( promise, response)  returns ? Sends a promised push response to the caller.   Parameters  promise Push promise message   response The outbound response   Return Type (?)  An http:ListenerError in case of failures while responding with the promised response   acceptWebSocketUpgrade (map headers)  returns | Sends an upgrade request with custom headers.   Parameters  headers map A map of custom headers for handshake   Return Type ( | )  An http:WebSocketCaller instance or else an http:WebSocketError on failure to upgrade   cancelWebSocketUpgrade (int status, string reason)  returns ? Cancels the handshake.   Parameters  status int Error Status code for cancelling the upgrade and closing the connection. This error status code need to be 4xx or 5xx else the default status code would be 400.   reason string Reason for cancelling the upgrade   Return Type (?)  An error if an error occurs during cancelling the upgrade or nil   continue ()  returns ? Sends a 100-continue response to the caller.   Return Type (?)  An http:ListenerError if failed to send the 100-continue response or else ()   redirect ( response, code, string[] locations)  returns ? Sends a redirect response to the user with the specified redirection status code.   Parameters  response Response to be sent to the caller   code The redirect status code to be sent   locations string[] An array of URLs to which the caller can redirect to   Return Type (?)  An http:ListenerError if failed to send the redirect response or else ()   ok ( message)  returns ? Sends the outbound response to the caller with the status 200 OK.   Parameters  message (default ())  The outbound response or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type (?)  An http:ListenerError if failed to respond or else ()   created (string uri, message)  returns ? Sends the outbound response to the caller with the status 201 Created.   Parameters  uri string Represents the most specific URI for the newly created resource   message (default ())  The outbound response or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]. This message is optional.   Return Type (?)  An http:ListenerError if failed to respond or else ()   accepted ( message)  returns ? Sends the outbound response to the caller with the status 202 Accepted.   Parameters  message (default ())  The outbound response or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]. This message is optional.   Return Type (?)  An http:ListenerError if failed to respond or else ()   noContent (? message)  returns ? Sends the outbound response to the caller with the status 204 No Content. If the given response contains a body that will be removed.  http:ListenerError? err = caller->noContent();    Parameters  message ? (default ())  The outbound response, which is optional   Return Type (?)  An http:ListenerError if failed to respond or else ()   badRequest ( message)  returns ? Sends the outbound response to the caller with the status 400 Bad Request.  http:ListenerError? err = caller->badRequest();    Parameters  message (default ())  The outbound response or any payload of type string, xml, json, byte[], io:ByteChannel, or mime:Entity[]   Return Type (?)  An http:ListenerError if failed to respond or else ()   notFound ( message)  returns ? Sends the outbound response to the caller with the status 404 Not Found.  http:ListenerError? err = caller->notFound();    Parameters  message (default ())  The outbound response or any payload of type string, xml, json, byte[], io:ByteChannel, or mime:Entity[]   Return Type (?)  An http:ListenerError if failed to respond or else ()   internalServerError ( message)  returns ? Sends the outbound response to the caller with the status 500 Internal Server Error.  http:ListenerError? err = caller->internalServerError();    Parameters  message (default ())  The outbound response or any payload of type string, xml, json, byte[], io:ByteChannel, or mime:Entity[]   Return Type (?)  An http:ListenerError if failed to respond or else ()   getRemoteHostName ()  returns string? Gets the hostname from the remote address. This method may trigger a DNS reverse lookup if the address was created with a literal IP address.  string? remoteHost = caller.getRemoteHostName();    Return Type (string?)  The hostname of the address or else () if it is unresolved"},{"page":"/learn/api-docs/ballerina/http/clients/Client.html","name":"Clients - : Client","summary":"The HTTP client provides the capability for initiating contact with a remote HTTP service. The API it\nprovides includes functions for the standard HTTP methods, forwarding a received request and sending requests\nusing custom HTTP verbs.\n(string url, ? config)URL of the target serviceThe configurations to be used when initializing the client\n  ...","content":"Clients  v1.2.2  All Modules  Clients - :  Client  The HTTP client provides the capability for initiating contact with a remote HTTP service. The API it provides includes functions for the standard HTTP methods, forwarding a received request and sending requests using custom HTTP verbs.    Constructor __init(string url, ? config)   url string URL of the target service   config ? ()  The configurations to be used when initializing the client   Remote Methods  The Client.post() function can be used to send HTTP POST requests to HTTP endpoints.   The Client.head() function can be used to send HTTP HEAD requests to HTTP endpoints.   The Client.put() function can be used to send HTTP PUT requests to HTTP endpoints.   Invokes an HTTP call with the specified HTTP verb.   The Client.patch() function can be used to send HTTP PATCH requests to HTTP endpoints.   The Client.delete() function can be used to send HTTP DELETE requests to HTTP endpoints.   The Client.get() function can be used to send HTTP GET requests to HTTP endpoints.   The Client.options() function can be used to send HTTP OPTIONS requests to HTTP endpoints.   The Client.forward() function can be used to invoke an HTTP call with inbound request's HTTP verb   Submits an HTTP request to a service with the specified HTTP verb. The Client->submit() function does not give out a http:Response as the result. Rather it returns an http:HttpFuture which can be used to do further interactions with the endpoint.   This just pass the request to actual network call.   This just pass the request to actual network call.   This just pass the request to actual network call.   Passes the request to an actual network call.   This just pass the request to actual network call.   Methods  Retrieves the cookie store of the client.  Fields  url  string  Target service url   config  (default {}) The configurations associated with the client   httpClient  Chain of different HTTP clients which provides the capability for initiating contact with a remote HTTP service in resilient manner   cookieStore  ?  (default ) Stores the cookies of the client   post (string path, message)  returns | The Client.post() function can be used to send HTTP POST requests to HTTP endpoints.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   head (string path, message)  returns | The Client.head() function can be used to send HTTP HEAD requests to HTTP endpoints.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   put (string path, message)  returns | The Client.put() function can be used to send HTTP PUT requests to HTTP endpoints.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   execute (string httpVerb, string path, message)  returns | Invokes an HTTP call with the specified HTTP verb.   Parameters  httpVerb string HTTP verb value   path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   patch (string path, message)  returns | The Client.patch() function can be used to send HTTP PATCH requests to HTTP endpoints.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   delete (string path, message)  returns | The Client.delete() function can be used to send HTTP DELETE requests to HTTP endpoints.   Parameters  path string Resource path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   get (string path, message)  returns | The Client.get() function can be used to send HTTP GET requests to HTTP endpoints.   Parameters  path string Request path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   options (string path, message)  returns | The Client.options() function can be used to send HTTP OPTIONS requests to HTTP endpoints.   Parameters  path string Request path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   forward (string path, request)  returns | The Client.forward() function can be used to invoke an HTTP call with inbound request's HTTP verb   Parameters  path string Request path   request An HTTP inbound request message   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   submit (string httpVerb, string path, message)  returns | Submits an HTTP request to a service with the specified HTTP verb. The Client->submit() function does not give out a http:Response as the result. Rather it returns an http:HttpFuture which can be used to do further interactions with the endpoint.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:HttpFuture that represents an asynchronous service invocation or else an http:ClientError if the submission fails   getResponse ( httpFuture)  returns | This just pass the request to actual network call.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:Response message or else an http: ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean This just pass the request to actual network call.   Parameters  httpFuture The http:HttpFuture relates to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | This just pass the request to actual network call.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Passes the request to an actual network call.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised http:Response message or else an http:ClientError if the invocation fails   rejectPromise This just pass the request to actual network call.   Parameters  promise The Push Promise to be rejected   getCookieStore ()  returns ? Retrieves the cookie store of the client.   Return Type (?)  The cookie store related to the client"},{"page":"/learn/api-docs/ballerina/http/clients/HttpCachingClient.html","name":"Clients - : HttpCachingClient","summary":"An HTTP caching client implementation which takes an HttpActions instance and wraps it with an HTTP caching layer.\n(string url,  config,  cacheConfig)The URL of the HTTP endpoint to connect toThe configurations for the client endpoint associated with the caching clientThe configurations for the HTTP cache to be used with ...","content":"Clients  v1.2.2  All Modules  Clients - :  HttpCachingClient  An HTTP caching client implementation which takes an HttpActions instance and wraps it with an HTTP caching layer.    Constructor __init(string url, config, cacheConfig)   url string The URL of the HTTP endpoint to connect to   config The configurations for the client endpoint associated with the caching client   cacheConfig The configurations for the HTTP cache to be used with the caching client   Remote Methods  Responses returned for POST requests are not cacheable. Therefore, the requests are simply directed to the origin server. Responses received for POST requests invalidate the cached responses for the same resource.   Responses for HEAD requests are cacheable and as such, will be routed through the HTTP cache. Only if a suitable response cannot be found will the request be directed to the origin server.   Responses returned for PUT requests are not cacheable. Therefore, the requests are simply directed to the origin server. In addition, PUT requests invalidate the currently stored responses for the given path.   Invokes an HTTP call with the specified HTTP method. This is not a cacheable operation, unless the HTTP method used is GET or HEAD.   Responses returned for PATCH requests are not cacheable. Therefore, the requests are simply directed to the origin server. Responses received for PATCH requests invalidate the cached responses for the same resource.   Responses returned for DELETE requests are not cacheable. Therefore, the requests are simply directed to the origin server. Responses received for DELETE requests invalidate the cached responses for the same resource.   Responses for GET requests are cacheable and as such, will be routed through the HTTP cache. Only if a suitable response cannot be found will the request be directed to the origin server.   Responses returned for OPTIONS requests are not cacheable. Therefore, the requests are simply directed to the origin server. Responses received for OPTIONS requests invalidate the cached responses for the same resource.   Forward remote function can be used to invoke an HTTP call with inbound request's HTTP method. Only inbound requests of GET and HEAD HTTP method types are cacheable.   Submits an HTTP request to a service with the specified HTTP verb.   Retrieves the http:Response for a previously-submitted request.   Checks whether an http:PushPromise exists for a previously-submitted request.   Retrieves the next available http:PushPromise for a previously-submitted request.   Retrieves the promised server push http:Response message.   Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Fields  url  string  The URL of the remote HTTP endpoint   config  (default {}) The configurations of the client endpoint associated with this CachingActions instance   httpClient  The underlying HttpActions instance which will be making the actual network calls   cache  The cache storage for the HTTP responses   cacheConfig  (default {}) Configurations for the underlying cache storage and for controlling the HTTP caching behaviour   post (string path, message)  returns | Responses returned for POST requests are not cacheable. Therefore, the requests are simply directed to the origin server. Responses received for POST requests invalidate the cached responses for the same resource.   Parameters  path string Resource path   message HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   head (string path, message)  returns | Responses for HEAD requests are cacheable and as such, will be routed through the HTTP cache. Only if a suitable response cannot be found will the request be directed to the origin server.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   put (string path, message)  returns | Responses returned for PUT requests are not cacheable. Therefore, the requests are simply directed to the origin server. In addition, PUT requests invalidate the currently stored responses for the given path.   Parameters  path string Resource path   message An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   execute (string httpMethod, string path, message)  returns | Invokes an HTTP call with the specified HTTP method. This is not a cacheable operation, unless the HTTP method used is GET or HEAD.   Parameters  httpMethod string HTTP method to be used for the request   path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   patch (string path, message)  returns | Responses returned for PATCH requests are not cacheable. Therefore, the requests are simply directed to the origin server. Responses received for PATCH requests invalidate the cached responses for the same resource.   Parameters  path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   delete (string path, message)  returns | Responses returned for DELETE requests are not cacheable. Therefore, the requests are simply directed to the origin server. Responses received for DELETE requests invalidate the cached responses for the same resource.   Parameters  path string Resource path   message (default ())  An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   get (string path, message)  returns | Responses for GET requests are cacheable and as such, will be routed through the HTTP cache. Only if a suitable response cannot be found will the request be directed to the origin server.   Parameters  path string Request path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   options (string path, message)  returns | Responses returned for OPTIONS requests are not cacheable. Therefore, the requests are simply directed to the origin server. Responses received for OPTIONS requests invalidate the cached responses for the same resource.   Parameters  path string Request path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   forward (string path, request)  returns | Forward remote function can be used to invoke an HTTP call with inbound request's HTTP method. Only inbound requests of GET and HEAD HTTP method types are cacheable.   Parameters  path string Request path   request The HTTP request to be forwarded   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   submit (string httpVerb, string path, message)  returns | Submits an HTTP request to a service with the specified HTTP verb.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An HttpFuture that represents an asynchronous service invocation, or an error if the submission fails   getResponse ( httpFuture)  returns | Retrieves the http:Response for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  A http:Response message, or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean Checks whether an http:PushPromise exists for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture relates to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | Retrieves the next available http:PushPromise for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture relates to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Retrieves the promised server push http:Response message.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised HTTP http:Response message or else an http:ClientError if the invocation fails   rejectPromise Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Parameters  promise The Push Promise to be rejected"},{"page":"/learn/api-docs/ballerina/http/clients/FailoverClient.html","name":"Clients - : FailoverClient","summary":"An HTTP client endpoint which provides failover support over multiple HTTP clients.\n( failoverClientConfig)The configurations of the client endpoint associated with this Failover instance.\n                    \n        ...","content":"Clients  v1.2.2  All Modules  Clients - :  FailoverClient  An HTTP client endpoint which provides failover support over multiple HTTP clients.    Constructor __init( failoverClientConfig)   failoverClientConfig The configurations of the client endpoint associated with this Failover instance.   Remote Methods  The POST remote function implementation of the Failover Connector.   The HEAD remote function implementation of the Failover Connector.   The PATCH remote function implementation of the Failover Connector.   The PUT remote function implementation of the Failover Connector.   The OPTIONS remote function implementation of the Failover Connector.   Invokes an HTTP call using the incoming request's HTTP method.   Invokes an HTTP call with the specified HTTP method.   The DELETE remote function implementation of the Failover Connector.   The GET remote function implementation of the Failover Connector.   Submits an HTTP request to a service with the specified HTTP verb. The FailoverClient.submit() function does not return an http:Response as the result. Rather it returns an http:HttpFuture which can be used for subsequent interactions with the HTTP endpoint.   Retrieves the http:Response for a previously-submitted request.   Checks whether an http:PushPromise exists for a previously-submitted request.   Retrieves the next available http:PushPromise for a previously-submitted request.   Retrieves the promised server push http:Response message.   Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Fields  failoverClientConfig  The configurations for the failover client endpoint   failoverInferredConfig  Configurations derived from FailoverConfig   succeededEndpointIndex  int  Index of the CallerActions[] array which given a successful response   post (string path, message)  returns | The POST remote function implementation of the Failover Connector.   Parameters  path string Resource path   message HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   head (string path, message)  returns | The HEAD remote function implementation of the Failover Connector.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   patch (string path, message)  returns | The PATCH remote function implementation of the Failover Connector.   Parameters  path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   put (string path, message)  returns | The PUT remote function implementation of the Failover Connector.   Parameters  path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   options (string path, message)  returns | The OPTIONS remote function implementation of the Failover Connector.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   forward (string path, request)  returns | Invokes an HTTP call using the incoming request's HTTP method.   Parameters  path string Resource path   request An HTTP request   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   execute (string httpVerb, string path, message)  returns | Invokes an HTTP call with the specified HTTP method.   Parameters  httpVerb string HTTP method to be used for the request   path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   delete (string path, message)  returns | The DELETE remote function implementation of the Failover Connector.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   get (string path, message)  returns | The GET remote function implementation of the Failover Connector.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   submit (string httpVerb, string path, message)  returns | Submits an HTTP request to a service with the specified HTTP verb. The FailoverClient.submit() function does not return an http:Response as the result. Rather it returns an http:HttpFuture which can be used for subsequent interactions with the HTTP endpoint.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:HttpFuture that represents an asynchronous service invocation or else an http:ClientError if the submission fails   getResponse ( httpFuture)  returns | Retrieves the http:Response for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean Checks whether an http:PushPromise exists for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | Retrieves the next available http:PushPromise for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Retrieves the promised server push http:Response message.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised http:Response message or else an http:ClientError if the invocation fails   rejectPromise Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Parameters  promise The Push Promise to be rejected"},{"page":"/learn/api-docs/ballerina/http/clients/HttpClient.html","name":"Clients - : HttpClient","summary":"Provides the HTTP actions for interacting with an HTTP server. Apart from the standard HTTP methods,\nHttpClient.forward() and HttpClient.execute() functions are provided. More complex and specific endpoint types\ncan be created by wrapping this generic HTTP actions implementation.\n(string url, ? config)URL of the target serviceThe configurations to be used when initializing the ...","content":"Clients  v1.2.2  All Modules  Clients - :  HttpClient  Provides the HTTP actions for interacting with an HTTP server. Apart from the standard HTTP methods, HttpClient.forward() and HttpClient.execute() functions are provided. More complex and specific endpoint types can be created by wrapping this generic HTTP actions implementation.    Constructor __init(string url, ? config)   url string URL of the target service   config ? ()  The configurations to be used when initializing the client   Remote Methods  The HttpClient.post() function can be used to send HTTP POST requests to HTTP endpoints.   The HttpClient.head() function can be used to send HTTP HEAD requests to HTTP endpoints.   The HttpClient.put() function can be used to send HTTP PUT requests to HTTP endpoints.   Invokes an HTTP call with the specified HTTP verb.   The HttpClient.patch() function can be used to send HTTP PATCH requests to HTTP endpoints.   The HttpClient.delete() function can be used to send HTTP DELETE requests to HTTP endpoints.   The HttpClient.get() function can be used to send HTTP GET requests to HTTP endpoints.   The HttpClient.options() function can be used to send HTTP OPTIONS requests to HTTP endpoints.   The HttpClient.forward() function can be used to invoke an HTTP call with inbound request's HTTP verb   Submits an HTTP request to a service with the specified HTTP verb. The HttpClient->submit() function does not give out an http:Response as the result. Rather, it returns an http:HttpFuture which can be used to do further interactions with the endpoint.   Retrieves the http:Response for a previously-submitted request.   Checks whether an http:PushPromise exists for a previously-submitted request.   Retrieves the next available http:PushPromise for a previously-submitted request.   Retrieves the promised server push http:Response message.   Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Fields  config  (default {}) The configurations associated with the HttpClient   url  string  The URL of the remote HTTP endpoint   post (string path, message)  returns | The HttpClient.post() function can be used to send HTTP POST requests to HTTP endpoints.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   head (string path, message)  returns | The HttpClient.head() function can be used to send HTTP HEAD requests to HTTP endpoints.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response for the request or else an http:ClientError if failed to establish communication with the upstream server   put (string path, message)  returns | The HttpClient.put() function can be used to send HTTP PUT requests to HTTP endpoints.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response for the request or else an http:ClientError if failed to establish communication with the upstream server   execute (string httpVerb, string path, message)  returns | Invokes an HTTP call with the specified HTTP verb.   Parameters  httpVerb string HTTP verb value   path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response for the request or else an http:ClientError if failed to establish communication with the upstream server   patch (string path, message)  returns | The HttpClient.patch() function can be used to send HTTP PATCH requests to HTTP endpoints.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or else an http:ClientError if failed to establish communication with the upstream server   delete (string path, message)  returns | The HttpClient.delete() function can be used to send HTTP DELETE requests to HTTP endpoints.   Parameters  path string Resource path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response for the request or else an http:ClientError if failed to establish communication with the upstream server   get (string path, message)  returns | The HttpClient.get() function can be used to send HTTP GET requests to HTTP endpoints.   Parameters  path string Request path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response for the request or else an http:ClientError if failed to establish communication with the upstream server   options (string path, message)  returns | The HttpClient.options() function can be used to send HTTP OPTIONS requests to HTTP endpoints.   Parameters  path string Request path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or else an http:ClientError if failed to establish communication with the upstream server   forward (string path, request)  returns | The HttpClient.forward() function can be used to invoke an HTTP call with inbound request's HTTP verb   Parameters  path string Request path   request An HTTP inbound request message   Return Type ( | )  An http:Response for the request or else an http:ClientError if failed to establish communication with the upstream server   submit (string httpVerb, string path, message)  returns | Submits an HTTP request to a service with the specified HTTP verb. The HttpClient->submit() function does not give out an http:Response as the result. Rather, it returns an http:HttpFuture which can be used to do further interactions with the endpoint.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:HttpFuture that represents an asynchronous service invocation, or else an http:ClientError if the submission fails   getResponse ( httpFuture)  returns | Retrieves the http:Response for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean Checks whether an http:PushPromise exists for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | Retrieves the next available http:PushPromise for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Retrieves the promised server push http:Response message.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised http:Response message or else an http:ClientError if the invocation fails   rejectPromise Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Parameters  promise The Push Promise to be rejected"},{"page":"/learn/api-docs/ballerina/http/clients/HttpSecureClient.html","name":"Clients - : HttpSecureClient","summary":"Provides secure HTTP remote functions for interacting with HTTP endpoints. This will make use of the authentication\nschemes configured in the HTTP client endpoint to secure the HTTP requests.\n(string url,  config)URL of the target serviceThe configurations to be used when initializing the client\n        ...","content":"Clients  v1.2.2  All Modules  Clients - :  HttpSecureClient  Provides secure HTTP remote functions for interacting with HTTP endpoints. This will make use of the authentication schemes configured in the HTTP client endpoint to secure the HTTP requests.    Constructor __init(string url, config)   url string URL of the target service   config The configurations to be used when initializing the client   Remote Methods  This wraps the HttpSecureClient.post() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This wraps the HttpSecureClient.head() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This wraps the HttpSecureClient.put() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This wraps the HttpSecureClient.execute() function of the underlying HTTP remote functions provider. Add relevant authentication headers o the request and send the request to actual network call.   This wraps the HttpSecureClient.patch() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This wraps the HttpSecureClient.delete() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This wraps the HttpSecureClient.get() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This wraps the HttpSecureClient.options() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This wraps the HttpSecureClient.forward() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This wraps the HttpSecureClient.submit() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   This just passes the request to the actual network call.   Passes the request to an actual network call.   Passes the request to an actual network call.   Passes the request to an actual network call.   Passes the request to an actual network call.   Fields  url  string  The URL of the remote HTTP endpoint   config  (default {}) The configurations of the client endpoint associated with this HttpActions instance   httpClient  The underlying HttpActions instance, which will make the actual network calls   post (string path, message)  returns | This wraps the HttpSecureClient.post() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The inbound response message or the error if one occurred while attempting to fulfill the HTTP request   head (string path, message)  returns | This wraps the HttpSecureClient.head() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  path string Resource path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The inbound response message or the error if one occurred while attempting to fulfill the HTTP request   put (string path, message)  returns | This wraps the HttpSecureClient.put() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The inbound response message or an error occurred while attempting to fulfill the HTTP request   execute (string httpVerb, string path, message)  returns | This wraps the HttpSecureClient.execute() function of the underlying HTTP remote functions provider. Add relevant authentication headers o the request and send the request to actual network call.   Parameters  httpVerb string HTTP verb value   path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The inbound response message or an error occurred while attempting to fulfill the HTTP request   patch (string path, message)  returns | This wraps the HttpSecureClient.patch() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The inbound response message or an error occurred while attempting to fulfill the HTTP request   delete (string path, message)  returns | This wraps the HttpSecureClient.delete() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The inbound response message or the error if one occurred while attempting to fulfill the HTTP request   get (string path, message)  returns | This wraps the HttpSecureClient.get() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  path string Request path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The inbound response message or the error if one occurred while attempting to fulfill the HTTP request   options (string path, message)  returns | This wraps the HttpSecureClient.options() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  path string Request path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The inbound response message or the error if one occurred while attempting to fulfill the HTTP request   forward (string path, request)  returns | This wraps the HttpSecureClient.forward() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  path string Request path   request An HTTP inbound request message   Return Type ( | )  The inbound response message or the error if one occurred while attempting to fulfill the HTTP request   submit (string httpVerb, string path, message)  returns | This wraps the HttpSecureClient.submit() function of the underlying HTTP remote functions provider. Add relevant authentication headers to the request and send the request to actual network call.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:HttpFuture that represents an asynchronous service invocation, or else an http:ClientError if the submission fails   getResponse ( httpFuture)  returns | This just passes the request to the actual network call.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean Passes the request to an actual network call.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | Passes the request to an actual network call.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Passes the request to an actual network call.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised http:Response message or else an http:ClientError if the invocation fails   rejectPromise Passes the request to an actual network call.   Parameters  promise The Push Promise to be rejected"},{"page":"/learn/api-docs/ballerina/http/clients/LoadBalanceClient.html","name":"Clients - : LoadBalanceClient","summary":"LoadBalanceClient endpoint provides load balancing functionality over multiple HTTP clients.\n( loadBalanceClientConfig)The configurations for the load balance client endpoint\n                    \n             ...","content":"Clients  v1.2.2  All Modules  Clients - :  LoadBalanceClient  LoadBalanceClient endpoint provides load balancing functionality over multiple HTTP clients.    Constructor __init( loadBalanceClientConfig)   loadBalanceClientConfig The configurations for the load balance client endpoint   Remote Methods  The POST remote function implementation of the LoadBalancer Connector.   The HEAD remote function implementation of the LoadBalancer Connector.   The PATCH remote function implementation of the LoadBalancer Connector.   The PUT remote function implementation of the Load Balance Connector.   The OPTIONS remote function implementation of the LoadBalancer Connector.   The FORWARD remote function implementation of the LoadBalancer Connector.   The EXECUTE remote function implementation of the LoadBalancer Connector. The Execute remote function can be used to invoke an HTTP call with the given HTTP verb.   The DELETE remote function implementation of the LoadBalancer Connector.   The GET remote function implementation of the LoadBalancer Connector.   The submit implementation of the LoadBalancer Connector.   The getResponse implementation of the LoadBalancer Connector.   The hasPromise implementation of the LoadBalancer Connector.   The getNextPromise implementation of the LoadBalancer Connector.   The getPromisedResponse implementation of the LoadBalancer Connector.   The rejectPromise implementation of the LoadBalancer Connector.   Fields  loadBalanceClientConfig  The configurations for the load balance client endpoint   loadBalanceClientsArray  ?[]  Array of HTTP clients for load balancing   lbRule  Load balancing rule   failover  boolean  Whether to fail over in case of a failure   post (string path, message)  returns | The POST remote function implementation of the LoadBalancer Connector.   Parameters  path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   head (string path, message)  returns | The HEAD remote function implementation of the LoadBalancer Connector.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   patch (string path, message)  returns | The PATCH remote function implementation of the LoadBalancer Connector.   Parameters  path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   put (string path, message)  returns | The PUT remote function implementation of the Load Balance Connector.   Parameters  path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   options (string path, message)  returns | The OPTIONS remote function implementation of the LoadBalancer Connector.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   forward (string path, request)  returns | The FORWARD remote function implementation of the LoadBalancer Connector.   Parameters  path string Resource path   request An optional HTTP request   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   execute (string httpVerb, string path, message)  returns | The EXECUTE remote function implementation of the LoadBalancer Connector. The Execute remote function can be used to invoke an HTTP call with the given HTTP verb.   Parameters  httpVerb string HTTP method to be used for the request   path string Resource path   message An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   delete (string path, message)  returns | The DELETE remote function implementation of the LoadBalancer Connector.   Parameters  path string Resource path   message (default ())  An HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   get (string path, message)  returns | The GET remote function implementation of the LoadBalancer Connector.   Parameters  path string Resource path   message (default ())  An optional HTTP request or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response or an http:ClientError if failed to fulfill the request   submit (string httpVerb, string path, message)  returns | The submit implementation of the LoadBalancer Connector.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:HttpFuture that represents an asynchronous service invocation or else an http:ClientError if the submission fails   getResponse ( httpFuture)  returns | The getResponse implementation of the LoadBalancer Connector.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean The hasPromise implementation of the LoadBalancer Connector.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | The getNextPromise implementation of the LoadBalancer Connector.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | The getPromisedResponse implementation of the LoadBalancer Connector.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised http:Response message or else an http:ClientError if the invocation fails   rejectPromise The rejectPromise implementation of the LoadBalancer Connector.   Parameters  promise The Push Promise to be rejected"},{"page":"/learn/api-docs/ballerina/http/clients/RedirectClient.html","name":"Clients - : RedirectClient","summary":"Provides redirect functionality for HTTP client remote functions.\n(string url,  config,  redirectConfig,  httpClient)Target service urlHTTP ClientConfiguration to be used for HTTP client invocationConfigurations associated with redirectHTTP client for outbound HTTP requests\n                  ...","content":"Clients  v1.2.2  All Modules  Clients - :  RedirectClient  Provides redirect functionality for HTTP client remote functions.    Constructor __init(string url, config, redirectConfig, httpClient)   url string Target service url   config HTTP ClientConfiguration to be used for HTTP client invocation   redirectConfig Configurations associated with redirect   httpClient HTTP client for outbound HTTP requests   Remote Methods  The RedirectClient.forward() function is used to invoke an HTTP call with inbound request's HTTP verb.   The RedirectClient.execute() sends an HTTP request to a service with the specified HTTP verb. Redirect will be performed only for HTTP methods.   Submits an HTTP request to a service with the specified HTTP verb. The RedirectClient.submit() function does not give out a Response as the result, rather it returns an HttpFuture which can be used to do further interactions with the endpoint.   Methods  If the received response for the RedirectClient.  If the received response for the RedirectClient.  If the received response for the RedirectClient.  If the received response for the RedirectClient.  If the received response for the RedirectClient.  If the received response for the RedirectClient.  If the received response for the RedirectClient.  Retrieves the http:Response for a previously-submitted request.  Checks whether an http:PushPromise exists for a previously-submitted request.  Retrieves the next available http:PushPromise for a previously-submitted request.  Retrieves the promised server push http:Response message.  Rejects an http:PushPromise.  Fields  url  string  Target service url   config  HTTP ClientConfiguration to be used for HTTP client invocation   redirectConfig  Configurations associated with redirect   httpClient  HTTP client for outbound HTTP requests   currentRedirectCount  int  (default 0) Current redirect count of the HTTP client   forward (string path, request)  returns | The RedirectClient.forward() function is used to invoke an HTTP call with inbound request's HTTP verb.   Parameters  path string Resource path   request An HTTP inbound request message   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   execute (string httpVerb, string path, message)  returns | The RedirectClient.execute() sends an HTTP request to a service with the specified HTTP verb. Redirect will be performed only for HTTP methods.   Parameters  httpVerb string The HTTP verb value   path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   submit (string httpVerb, string path, message)  returns | Submits an HTTP request to a service with the specified HTTP verb. The RedirectClient.submit() function does not give out a Response as the result, rather it returns an HttpFuture which can be used to do further interactions with the endpoint.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:HttpFuture that represents an asynchronous service invocation or else an http:ClientError if the submission fails   get (string path, message)  returns | If the received response for the RedirectClient.get() remote function is redirect eligible, redirect will be performed automatically by this RedirectClient.get() function.   Parameters  path string Resource path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   post (string path, message)  returns | If the received response for the RedirectClient.post() remote function is redirect eligible, redirect will be performed automaticallyby this RedirectClient.post() function.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   head (string path, message)  returns | If the received response for the RedirectClient.head() remote function is redirect eligible, redirect will be performed automatically by this RedirectClient.head() function.   Parameters  path string Resource path   message (default ())  An optional HTTP outbound request message or or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   put (string path, message)  returns | If the received response for the RedirectClient.put() remote function is redirect eligible, redirect will be performed automatically by this RedirectClient.put() function.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   patch (string path, message)  returns | If the received response for the RedirectClient.patch() remote function is redirect eligible, redirect will be performed automatically by this RedirectClient.patch() function.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   delete (string path, message)  returns | If the received response for the RedirectClient.delete() remote function is redirect eligible, redirect will be performed automatically by this RedirectClient.delete() function.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   options (string path, message)  returns | If the received response for the RedirectClient.options() remote function is redirect eligible, redirect will be performed automatically by this RedirectClient.options() function.   Parameters  path string Resource path   message (default ())  An optional HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   getResponse ( httpFuture)  returns | Retrieves the http:Response for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean Checks whether an http:PushPromise exists for a previously-submitted request.   Parameters  httpFuture The HttpFuture relates to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | Retrieves the next available http:PushPromise for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Retrieves the promised server push http:Response message.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised http:Response message or else an http:ClientError if the invocation fails   rejectPromise Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Parameters  promise The Push Promise to be rejected"},{"page":"/learn/api-docs/ballerina/http/clients/RetryClient.html","name":"Clients - : RetryClient","summary":"Provides the HTTP remote functions for interacting with an HTTP endpoint. This is created by wrapping the HTTP client\nto provide retrying over HTTP requests.\n(string url,  config,  retryInferredConfig,  httpClient)Target service urlHTTP ClientConfiguration to be used for HTTP client invocationDerived set of configurations associated with retryHTTP client for outbound ...","content":"Clients  v1.2.2  All Modules  Clients - :  RetryClient  Provides the HTTP remote functions for interacting with an HTTP endpoint. This is created by wrapping the HTTP client to provide retrying over HTTP requests.    Constructor __init(string url, config, retryInferredConfig, httpClient)   url string Target service url   config HTTP ClientConfiguration to be used for HTTP client invocation   retryInferredConfig Derived set of configurations associated with retry   httpClient HTTP client for outbound HTTP requests   Remote Methods  The RetryClient.post() function wraps the underlying HTTP remote functions in a way to provide retrying functionality for a given endpoint to recover from network level failures.   The RetryClient.head() function wraps the underlying HTTP remote functions in a way to provide retrying functionality for a given endpoint to recover from network level failures.   The RetryClient.put() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   The RetryClient.forward() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint with inbound request's HTTP verb to recover from network level failures.   The RetryClient.execute() sends an HTTP request to a service with the specified HTTP verb. The function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   The RetryClient.patch() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   The RetryClient.delete() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   The RetryClient.get() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   The RetryClient.options() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Submits an HTTP request to a service with the specified HTTP verb. The RetryClient.submit() function does not give out a http:Response as the result. Rather it returns an http:HttpFuture, which can be used to do further interactions with the endpoint.   Retrieves the http:Response for a previously submitted request.   Checks whether an http:PushPromise exists for a previously-submitted request.   Retrieves the next available http:PushPromise for a previously-submitted request.   Retrieves the promised server push http:Response message.   Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Fields  url  string  Target service url   config  HTTP ClientConfiguration to be used for HTTP client invocation   retryInferredConfig  Derived set of configurations associated with retry   httpClient  Chain of different HTTP clients which provides the capability for initiating contact with a remote HTTP service in resilient manner.   post (string path, message)  returns | The RetryClient.post() function wraps the underlying HTTP remote functions in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   head (string path, message)  returns | The RetryClient.head() function wraps the underlying HTTP remote functions in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   put (string path, message)  returns | The RetryClient.put() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   forward (string path, request)  returns | The RetryClient.forward() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint with inbound request's HTTP verb to recover from network level failures.   Parameters  path string Resource path   request An HTTP inbound request message   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   execute (string httpVerb, string path, message)  returns | The RetryClient.execute() sends an HTTP request to a service with the specified HTTP verb. The function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Parameters  httpVerb string The HTTP verb value   path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   patch (string path, message)  returns | The RetryClient.patch() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   delete (string path, message)  returns | The RetryClient.delete() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:Response message, or else an http:ClientError if the invocation fails   get (string path, message)  returns | The RetryClient.get() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   options (string path, message)  returns | The RetryClient.options() function wraps the underlying HTTP remote function in a way to provide retrying functionality for a given endpoint to recover from network level failures.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   submit (string httpVerb, string path, message)  returns | Submits an HTTP request to a service with the specified HTTP verb. The RetryClient.submit() function does not give out a http:Response as the result. Rather it returns an http:HttpFuture, which can be used to do further interactions with the endpoint.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type ( | )  An http:HttpFuture that represents an asynchronous service invocation or else an http:ClientError if the submission fails   getResponse ( httpFuture)  returns | Retrieves the http:Response for a previously submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:Response message or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean Checks whether an http:PushPromise exists for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | Retrieves the next available http:PushPromise for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An http:PushPromise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Retrieves the promised server push http:Response message.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised http:Response message or else an http:ClientError if the invocation fails   rejectPromise Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Parameters  promise The Push Promise to be rejected"},{"page":"/learn/api-docs/ballerina/http/clients/WebSocketCaller.html","name":"Clients - : WebSocketCaller","summary":"Represents a WebSocket caller.\n(string | json | xml | boolean | int | float | byte | byte[] data, boolean finalFrame)Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\nwill be lost.\nData to be sent. If it is a byte[], it ...","content":"Clients  v1.2.2  All Modules  Clients - :  WebSocketCaller  Represents a WebSocket caller.    Remote Methods  Pushes text to the connection. If an error occurs while sending the text message to the connection, that message will be lost.   Pushes binary data to the connection. If an error occurs while sending the binary message to the connection, that message will be lost.   Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.   Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that frame will be lost.   Closes the connection.   Methods  Sets a connection related attribute.  Gets connection related attribute if any.  Removes connection related attribute if any.  Gives the connection id associated with this connection.  Gives the subprotocol if any that is negotiated with the client.  Gives the secured status of the connection.  Gives the open or closed status of the connection.  pushText (string | json | xml | boolean | int | float | byte | byte[] data, boolean finalFrame)  returns ? Pushes text to the connection. If an error occurs while sending the text message to the connection, that message will be lost.   Parameters  data string | json | xml | boolean | int | float | byte | byte[] Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending   finalFrame boolean (default true)  Set to true if this is a final frame of a (long) message   Return Type (?)  An error if an error occurs when sending   pushBinary (byte[] data, boolean finalFrame)  returns ? Pushes binary data to the connection. If an error occurs while sending the binary message to the connection, that message will be lost.   Parameters  data byte[] Binary data to be sent   finalFrame boolean (default true)  Set to true if this is a final frame of a (long) message   Return Type (?)  An error if an error occurs when sending   ping (byte[] data)  returns ? Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.   Parameters  data byte[] Binary data to be sent   Return Type (?)  An error if an error occurs when sending   pong (byte[] data)  returns ? Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that frame will be lost.   Parameters  data byte[] Binary data to be sent   Return Type (?)  An error if an error occurs when sending   close (int? statusCode, string? reason, int timeoutInSeconds)  returns ? Closes the connection.   Parameters  statusCode int? (default 1000)  Status code for closing the connection   reason string? (default ())  Reason for closing the connection   timeoutInSeconds int (default 60)  Time to wait for the close frame to be received from the remote endpoint before closing the connection. If the timeout exceeds, then the connection is terminated even though a close frame is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits until a close frame is received. If WebSocket frame is received from the remote endpoint within the waiting period, the connection is terminated immediately.   Return Type (?)  An error if an error occurs when sending   setAttribute Sets a connection related attribute.   Parameters  key string The key, which identifies the attribute   value any The value of the attribute   getAttribute (string key)  returns any Gets connection related attribute if any.   Parameters  key string The key to identify the attribute   Return Type (any)  The attribute related to the given key or nil   removeAttribute (string key)  returns any Removes connection related attribute if any.   Parameters  key string The key to identify the attribute   Return Type (any)  The attribute related to the given key or nil   getConnectionId ()  returns string Gives the connection id associated with this connection.   Return Type (string)  The unique ID associated with the connection   getNegotiatedSubProtocol ()  returns string? Gives the subprotocol if any that is negotiated with the client.   Return Type (string?)  The subprotocol if any negotiated with the client or nil   isSecure ()  returns boolean Gives the secured status of the connection.   Return Type (boolean)  true if the connection is secure   isOpen ()  returns boolean Gives the open or closed status of the connection.   Return Type (boolean)  true if the connection is open"},{"page":"/learn/api-docs/ballerina/http/clients/WebSocketClient.html","name":"Clients - : WebSocketClient","summary":"Represents a WebSocket client endpoint.\n(string url, ? config)URL of the target serviceThe configurations to be used when initializing the client(string | json | xml | boolean | int | float | byte | byte[] data, boolean finalFrame)Pushes text to the connection. If an error occurs while sending the text message ...","content":"Clients  v1.2.2  All Modules  Clients - :  WebSocketClient  Represents a WebSocket client endpoint.    Constructor __init(string url, ? config)   url string URL of the target service   config ? ()  The configurations to be used when initializing the client   Remote Methods  Pushes text to the connection. If an error occurs while sending the text message to the connection, that message will be lost.   Pushes binary data to the connection. If an error occurs while sending the binary message to the connection, that message will be lost.   Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.   Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that frame will be lost.   Closes the connection.   Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the WebSocketListener, it can be called only in the upgrade or onOpen resources.   Methods  Initializes the endpoint.  Sets a connection-related attribute.  Gets connection-related attributes if any.  Removes connection related attribute if any.  Gives the connection id associated with this connection.  Gives the subprotocol if any that is negotiated with the client.  Gives the secured status of the connection.  Gives the open or closed status of the connection.  Gives the HTTP response if any received for the client handshake request.  pushText (string | json | xml | boolean | int | float | byte | byte[] data, boolean finalFrame)  returns ? Pushes text to the connection. If an error occurs while sending the text message to the connection, that message will be lost.   Parameters  data string | json | xml | boolean | int | float | byte | byte[] Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending   finalFrame boolean (default true)  Set to true if this is a final frame of a (long) message   Return Type (?)  An error if an error occurs when sending   pushBinary (byte[] data, boolean finalFrame)  returns ? Pushes binary data to the connection. If an error occurs while sending the binary message to the connection, that message will be lost.   Parameters  data byte[] Binary data to be sent   finalFrame boolean (default true)  Set to true if this is a final frame of a (long) message   Return Type (?)  An error if an error occurs when sending   ping (byte[] data)  returns ? Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.   Parameters  data byte[] Binary data to be sent   Return Type (?)  An error if an error occurs when sending   pong (byte[] data)  returns ? Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that frame will be lost.   Parameters  data byte[] Binary data to be sent   Return Type (?)  An error if an error occurs when sending   close (int? statusCode, string? reason, int timeoutInSeconds)  returns ? Closes the connection.   Parameters  statusCode int? (default 1000)  Status code for closing the connection   reason string? (default ())  Reason for closing the connection   timeoutInSeconds int (default 60)  Time to wait for the close frame to be received from the remote endpoint before closing the connection. If the timeout exceeds, then the connection is terminated even though a close frame is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection waits until a close frame is received. If the WebSocket frame is received from the remote endpoint within the waiting period, the connection is terminated immediately.   Return Type (?)  An error if an error occurs while closing the WebSocket connection   ready ()  returns ? Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the WebSocketListener, it can be called only in the upgrade or onOpen resources.   Return Type (?)  an error if an error occurs while checking the connection state   initEndpoint Initializes the endpoint.   setAttribute Sets a connection-related attribute.   Parameters  key string The key, which identifies the attribute   value any The value of the attribute   getAttribute (string key)  returns any Gets connection-related attributes if any.   Parameters  key string The key to identify the attribute   Return Type (any)  The attribute related to the given key or nil   removeAttribute (string key)  returns any Removes connection related attribute if any.   Parameters  key string The key to identify the attribute   Return Type (any)  The attribute related to the given key or nil   getConnectionId ()  returns string Gives the connection id associated with this connection.   Return Type (string)  The unique ID associated with the connection   getNegotiatedSubProtocol ()  returns string? Gives the subprotocol if any that is negotiated with the client.   Return Type (string?)  The subprotocol if any negotiated with the client or nil   isSecure ()  returns boolean Gives the secured status of the connection.   Return Type (boolean)  true if the connection is secure   isOpen ()  returns boolean Gives the open or closed status of the connection.   Return Type (boolean)  true if the connection is open   getHttpResponse ()  returns ? Gives the HTTP response if any received for the client handshake request.   Return Type (?)  The HTTP response received from the client handshake request"},{"page":"/learn/api-docs/ballerina/http/clients/WebSocketFailoverClient.html","name":"Clients - : WebSocketFailoverClient","summary":"A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n( config)The WebSocketFailoverClientConfiguration of the endpoint(string | json | xml | boolean | int | float | byte | byte[] data, boolean finalFrame)Pushes text to the connection. If an error occurs while sending the text message to the connection, ...","content":"Clients  v1.2.2  All Modules  Clients - :  WebSocketFailoverClient  A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.    Constructor __init( config)   config The WebSocketFailoverClientConfiguration of the endpoint   Remote Methods  Pushes text to the connection. If an error occurs while sending the text message to the connection, that message will be lost.   Pushes binary data to the connection. If an error occurs while sending the binary message to the connection, that message will be lost.   Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.   Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that frame will be lost.   Closes the connection.   Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the WebSocketListener, it can be called only in the upgrade or onOpen resources.   Methods  Sets a connection-related attribute.  Gets connection-related attributes if any.  Removes connection-related attributes if any.  Gives the connection ID associated with this connection.  Gives the subprotocol if any that is negotiated with the client.  Gives the secured status of the connection.  Gives the open or closed status of the connection.  Gives any HTTP response of the client handshake request if received.  pushText (string | json | xml | boolean | int | float | byte | byte[] data, boolean finalFrame)  returns ? Pushes text to the connection. If an error occurs while sending the text message to the connection, that message will be lost.   Parameters  data string | json | xml | boolean | int | float | byte | byte[] Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending   finalFrame boolean (default true)  Set to true if this is a final frame of a (long) message   Return Type (?)  An error if an error occurs when sending   pushBinary (byte[] data, boolean finalFrame)  returns ? Pushes binary data to the connection. If an error occurs while sending the binary message to the connection, that message will be lost.   Parameters  data byte[] Binary data to be sent   finalFrame boolean (default true)  Set to true if this is a final frame of a (long) message   Return Type (?)  An error if an error occurs when sending   ping (byte[] data)  returns ? Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.   Parameters  data byte[] Binary data to be sent   Return Type (?)  An error if an error occurs when sending   pong (byte[] data)  returns ? Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that frame will be lost.   Parameters  data byte[] Binary data to be sent   Return Type (?)  An error if an error occurs when sending   close (int? statusCode, string? reason, int timeoutInSeconds)  returns ? Closes the connection.   Parameters  statusCode int? (default 1000)  Status code for closing the connection   reason string? (default ())  Reason for closing the connection   timeoutInSeconds int (default 60)  Time to wait for the close frame to be received from the remote endpoint before closing the connection. If the timeout exceeds, then the connection is terminated even though a close frame is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection waits until a close frame is received. If the WebSocket frame is received from the remote endpoint within the waiting period, the connection is terminated immediately.   Return Type (?)  An error if an error occurs while closing the webSocket connection   ready ()  returns ? Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the WebSocketListener, it can be called only in the upgrade or onOpen resources.   Return Type (?)  An error if an error occurs while checking the connection state   init setAttribute Sets a connection-related attribute.   Parameters  key string The key to identify the attribute   value any The value of the attribute   getAttribute (string key)  returns any Gets connection-related attributes if any.   Parameters  key string The key to identify the attribute   Return Type (any)  The attribute related to the given key or nil   removeAttribute (string key)  returns any Removes connection-related attributes if any.   Parameters  key string The key to identify the attribute   Return Type (any)  The attribute related to the given key or nil   getConnectionId ()  returns string Gives the connection ID associated with this connection.   Return Type (string)  The unique ID associated with the connection   getNegotiatedSubProtocol ()  returns string? Gives the subprotocol if any that is negotiated with the client.   Return Type (string?)  Returns the subprotocol if any that is negotiated with the client or nil   isSecure ()  returns boolean Gives the secured status of the connection.   Return Type (boolean)  Returns true if the connection is secure   isOpen ()  returns boolean Gives the open or closed status of the connection.   Return Type (boolean)  Returns true if the connection is open   getHttpResponse ()  returns ? Gives any HTTP response of the client handshake request if received.   Return Type (?)  Returns the HTTP response received for the client handshake request"},{"page":"/learn/api-docs/ballerina/http/functions.html","name":"Functions -","summary":"(string url,  config,  cacheConfig)Creates an HTTP client capable of caching HTTP responses.\nThe URL of the HTTP endpoint to connectThe configurations for the client endpoint associated with the caching clientThe configurations for the HTTP cache to be used with the caching clientAn http:HttpCachingClient instance, which wraps the base http:Client ...","content":"Functions  v1.2.2  All Modules  Functions - Creates an HTTP client capable of caching HTTP responses.  Creates an HTTP client capable of securing HTTP requests with authentication.  Extracts the Authorization header value from the request.  The HEAD remote function implementation of the Circuit Breaker.  Parses the given header value to extract its value and parameter map.  createHttpCachingClient (string url, config, cacheConfig)  returns | Creates an HTTP client capable of caching HTTP responses.   Parameters  url string The URL of the HTTP endpoint to connect   config The configurations for the client endpoint associated with the caching client   cacheConfig The configurations for the HTTP cache to be used with the caching client   Return Type ( | )  An http:HttpCachingClient instance, which wraps the base http:Client with a caching layer or else an http:ClientError   createHttpSecureClient (string url, config)  returns | Creates an HTTP client capable of securing HTTP requests with authentication.   Parameters  url string Base URL   config Client endpoint configurations   Return Type ( | )  Created secure HTTP client   extractAuthorizationHeaderValue ( req)  returns string Extracts the Authorization header value from the request.   Parameters  req The Request instance   Return Type (string)  Value of the Authorization header   invokeEndpoint (string path, outRequest, requestAction, httpClient, string verb)  returns HttpResponse | The HEAD remote function implementation of the Circuit Breaker. This wraps the head function of the underlying HTTP remote function provider.   Parameters  path string Resource path   outRequest A Request struct   requestAction HttpOperation related to the request   httpClient HTTP client which uses to call the relevant functions   verb string HTTP verb used for submit method   Return Type (HttpResponse | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   parseHeader (string headerValue)  returns [string, map] | Parses the given header value to extract its value and parameter map.   Parameters  headerValue string The header value   Return Type ([string, map] | )  A tuple containing the value and its parameter map or else an http:ClientError if the header parsing fails"},{"page":"/learn/api-docs/ballerina/http/","name":"Module : http","summary":"This module provides an implementation for connecting and interacting with HTTP, HTTP2, and WebSocket endpoints. The module facilitates two types of network entry points as ‘Client’ and ‘Listener’.The Client is used to connect to and interact with HTTP endpoints. They support connection pooling and can be configured to have a ...","content":"v1.2.2  All Modules  Module : http  Module Overview This module provides an implementation for connecting and interacting with HTTP, HTTP2, and WebSocket endpoints. The module facilitates two types of network entry points as ‘Client’ and ‘Listener’. Client The Client is used to connect to and interact with HTTP endpoints. They support connection pooling and can be configured to have a maximum number of active connections that can be made with the remote endpoint. The Client activates connection eviction after a given idle period and also supports follow-redirects so that the users do not have to manually handle 3xx HTTP status codes. The Client handles resilience in multiple ways such as load balancing, circuit breaking, endpoint timeouts, and a retry mechanism. Load balancing is used in the round robin or failover manner. When a failure occurs in the remote service, the client connections might wait for some time before a timeout occurs. Awaiting requests consume resources in the system. Circuit Breakers are used to trip after a certain number of failed requests to the remote service. Once a circuit breaker trips, it does not allow the client to send requests to the remote service for a period of time. The Ballerina circuit breaker supports tripping on HTTP error status codes and I/O errors. Failure thresholds can be configured based on a sliding window (e.g., 5 failures within 10 seconds). Client endpoints also support a retry mechanism that allows a client to resend failed requests periodically for a given number of times. The Client supports Server Name Indication (SNI), Certificate Revocation List (CRL), Online Certificate Status Protocol (OCSP), and OCSP Stapling for SSL/TLS connections. They also support HTTP2, keep-alive, chunking, HTTP caching, data compression/decompression, and authentication/authorization. A Client can be defined using the URL of the remote service that the client needs to connect with, as shown below: http:Client clientEndpoint = new(\"https://my-simple-backend.com\");  The defined Client endpoint can be used to call a remote service as follows: // Send a GET request to the specified endpoint. var response = clientEndpoint->get(\"/get?id=123\");  For more information, see , , . Listener A Service represents a collection of network-accessible entry points and can be exposed via a Listener endpoint. A resource represents one such entry point and can have its own path, HTTP methods, body format, 'consumes' and 'produces' content types, CORS headers, etc. In resources, http:caller and http:Request are mandatory parameters while path and body are optional. When a Service receives a request, it is dispatched to the best-matched resource. A Listener endpoint can be defined as follows: // Attributes associated with the `Listener` endpoint are defined here. listener http:Listener helloWorldEP = new(9090);  Then a Service can be defined and attached to the above Listener endpoint as shown below: // By default, Ballerina assumes that the service is to be exposed via HTTP/1.1. @http:ServiceConfig { basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {   // All resource functions are invoked with arguments of server connector and request.  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/{name}\",  body: \"message\"  }  resource function sayHello(http:Caller caller, http:Request req, string name, string message) {  http:Response res = new;  // A util method that can be used to set string payload.  res.setPayload(\"Hello, World! I’m \" + <@untainted> name + \". \" + <@untainted> message);  // Sends the response back to the client.  var result = caller->respond(res);  if (result is http:ListenerError) {  error err = result;  log:printError(\"Error sending response\", err = err);  }  } }  See , , , Listener endpoints can be exposed via SSL. They support Mutual SSL, Hostname Verification, and Application Layer Protocol Negotiation (ALPN) for HTTP2. Listener endpoints also support Certificate Revocation List (CRL), Online Certificate Status Protocol (OCSP), OCSP Stapling, HTTP2, keep-alive, chunking, HTTP caching, data compression/decompression, and authentication/authorization. For more information, see . For more information, see , . WebSocket This module also provides support for WebSockets. There are two types of WebSocket endpoints: WebSocketClient and WebSocketListener. Both endpoints support all WebSocket frames. The WebSocketClient has a callback service. There are two types of services for WebSockets. The service of the server has the WebSockerCaller as the resource parameter and the callback service of the client has WebSocketClient as the resource parameter. The WebSocket services have a fixed set of resources that do not have a resource config. The incoming messages are passed to these resources. WebSocket upgrade: During a WebSocket upgrade, the initial message received is an HTTP request. To intercept this request and perform the upgrade explicitly with custom headers, the user must create an HTTP resource with WebSocket-specific configurations as follows: @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/{name}\",  upgradeService: chatApp  } } resource function upgrader(http:Caller caller, http:Request req, string name) { }  The upgradeService is a server callback service. onOpen resource: As soon as the WebSocket handshake is completed and the connection is established, the onOpen resource is dispatched. This resource is only available in the service of the server. onText resource: The received text messages are dispatched to this resource. onBinary resource: The received binary messages are dispatched to this resource. onPing and onPong resources: The received ping and pong messages are dispatched to these resources respectively. onIdleTimeout: This resource is dispatched when the idle timeout is reached. The idleTimeout has to be configured either in the WebSocket service or the client configuration. onClose: This resource is dispatched when a close frame with a statusCode and a reason is received. onError: This resource is dispatched when an error occurs in the WebSocket connection. This will always be preceded by a connection closure with an appropriate close frame. For more information, see , , , . Logging This module supports two types of logs:  HTTP access logs: These are standard HTTP access logs that are formatted using the combined log format and logged at the INFO level. Logs can be published to the console or a file using the following configurations:  b7a.http.accesslog.console=true b7a.http.accesslog.path=<path_to_log_file>   HTTP trace logs: These are detailed logs of requests coming to/going out of and responses coming to/going out of service endpoints or a client endpoints. Trace logs can be published to the console, to a file or to a network socket using the following set of configurations:  b7a.http.tracelog.console=true b7a.http.tracelog.path=<path_to_log_file> b7a.http.tracelog.host=<host_name> b7a.http.tracelog.port=<port>    To publish logs to a socket, both the host and port configurations must be provided. See , Records Represents a discrete sub-part of the time window (Bucket).  Provides a set of configurations for controlling the caching behaviour of the endpoint.  Provides a set of configurations for controlling the behaviour of the Circuit Breaker.  Derived set of configurations from the CircuitBreakerConfig.  Maintains the health of the Circuit Breaker.  Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint.  Provides settings related to HTTP/1.  Provides settings related to HTTP/2 protocol.  Provides configurations for facilitating secure communication with a remote HTTP endpoint.  Common client configurations for the next level clients.  A record for providing configurations for content compression.  Client configuration for cookies.  Configurations for CORS support.  Holds the details of an HTTP error   Provides a set of HTTP related configurations and failover related configurations.  Provides a set of configurations for controlling the failover behaviour of the endpoint.  Represents the inferred failover configurations passed into the failover client.  Provides configurations for controlling the endpoint's behaviour in response to HTTP redirect related responses.  Configuration for an HTTP resource.  Contains the configurations for an HTTP service.  Defines a timeout error occurred during service invocation.  Authentication configurations for the listener.  Provides a set of configurations for HTTP service endpoints.  Provides settings related to HTTP/1.  A record for providing configurations for certificate revocation status checks.  Configures the SSL/TLS options to be used for HTTP service.  Represents an error occurred in an remote function of the Load Balance connector.  The configurations related to the load balance client endpoint.  Presents a read-only view of the local address.  A record for providing mutual SSL handshake results.  The OutboundAuthConfig record can be used to configure the authentication mechanism used by the HTTP endpoint.  Configurations for managing HTTP client connection pool.  A record for configuring SSL/TLS protocol and version to be used.  Proxy server configurations to be used with the HTTP client endpoint.  Presents a read-only view of the remote address.  Configures the authentication scheme for a resource.  Provides configurations for controlling the retrying behavior in failure scenarios.  Derived set of configurations from the RetryConfig.  Represents a rolling window in the Circuit Breaker.  Configures the authentication scheme for a service.  Represents a single service and its related configurations.  A record for providing configurations for certificate revocation status checks.  Configurations for service versioning.  Configurations for a WebSocket service.  Configurations for the WebSocket client endpoint.  Configurations for the WebSocket client endpoint.  Retry configurations for WebSocket.  Resource configuration to upgrade from HTTP to WebSocket.  Objects Representation of the Authentication filter.  Representation of the Authorization filter.  Representation of Authorization Handler for HTTP.  Defines the Basic Auth header handler for inbound and outbound HTTP traffic.  Representation of the Bearer Auth header handler for both inbound and outbound HTTP traffic.  Represents a Cookie.  Provides the cookie functionality across HTTP client actions.  Represents the cookie store.  Represents a default persistent cookie handler, which stores persistent cookies in a CSV file.  Representation of request filter Context.  Implements a cache for storing HTTP responses.  Represents a 'future' that returns as a result of an asynchronous HTTP request submission.  The representation of an inbound authentication handler for HTTP traffic.  Implementation of round robin load balancing strategy.  LoadBalancerRule provides a required interfaces to implement different algorithms.  The representation of an outbound authentication handler for HTTP traffic.  The representation of a persistent cookie handler for managing persistent cookies.  Represents an HTTP/2 PUSH_PROMISE frame.  Represents an HTTP request.  Configures the cache control directives for an http:Request.  Abstract Representation of a HTTP Request Filter.  Represents an HTTP response.  Configures cache control directives for an http:Response.  Abstract Representation of a HTTP Response Filter.  Clients The caller actions for responding to client requests.  A Circuit Breaker implementation which can be used to gracefully handle network failures.  The HTTP client provides the capability for initiating contact with a remote HTTP service.  An HTTP client endpoint which provides failover support over multiple HTTP clients.  An HTTP caching client implementation which takes an HttpActions instance and wraps it with an HTTP caching layer.  Provides the HTTP actions for interacting with an HTTP server.  Provides secure HTTP remote functions for interacting with HTTP endpoints.  LoadBalanceClient endpoint provides load balancing functionality over multiple HTTP clients.  Provides redirect functionality for HTTP client remote functions.  Provides the HTTP remote functions for interacting with an HTTP endpoint.  Represents a WebSocket caller.  Represents a WebSocket client endpoint.  A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.  Listeners This is used for creating HTTP server endpoints.  Mock server endpoint which does not open a listening port.  Functions Creates an HTTP client capable of caching HTTP responses.  Creates an HTTP client capable of securing HTTP requests with authentication.  Extracts the Authorization header value from the request.  The HEAD remote function implementation of the Circuit Breaker.  Parses the given header value to extract its value and parameter map.  Constants Represents the Authorization header name.  Indicates that the authentication credentials should be sent via the Authentication header.  Indicates that the Authentication credentials should be sent via the body of the POST request.  Indicates that the authentication credentials should not be sent.  Indicates the status code.  Forces the cache to validate a cached response with the origin server before serving.  Instructs the cache to not store a response in non-volatile storage.  Instructs intermediaries not to transform the payload.  When used in requests, max-age implies that clients are not willing to accept responses whose age is greater than max-age.  Indicates that the client is willing to accept responses which have exceeded their freshness lifetime by no more than the specified number of seconds.  Indicates that the client is only accepting responses whose freshness lifetime >= current age + min-fresh.  Indicates that the client is only willing to accept a cached response.  Indicates that once the response has become stale, it should not be reused for subsequent requests without validating with the origin server.  Indicates that any cache may store the response.  Indicates that the response is intended for a single user and should not be stored by shared caches.  Has the same semantics as must-revalidate, except that this does not apply to private caches.  In shared caches, s-maxage overrides the max-age or expires header field.  Setting this as the max-stale directives indicates that the max-stale directive does not specify a limit.  This is a more restricted mode of RFC 7234.  Caching behaviour is as specified by the RFC 7234 specification.  Constant for the http error code   Represents multipart primary type   Constant for the HTTP FORWARD method   Constant for the HTTP GET method   Constant for the HTTP POST method   Constant for the HTTP DELETE method   Constant for the HTTP OPTIONS method   Constant for the HTTP PUT method   Constant for the HTTP PATCH method   Constant for the HTTP HEAD method   constant for the HTTP SUBMIT method   Constant for the identify not an HTTP Operation   If the payload is less than 8KB, content-length header is set in the outbound request/response, otherwise chunking header is set in the outbound request/response.  Always set chunking header in the response.  Never set the chunking header even if the payload is larger than 8KB in the outbound request/response.  When service behaves as a HTTP gateway inbound request/response accept-encoding option is set as the outbound request/response accept-encoding/content-encoding option.  Always set accept-encoding/content-encoding in outbound request/response.  Never set accept-encoding/content-encoding header in outbound request/response.  Represents the HTTP redirect status code 300 - Multiple Choices.  Represents the HTTP redirect status code 301 - Moved Permanently.  Represents the HTTP redirect status code 302 - Found.  Represents the HTTP redirect status code 303 - See Other.  Represents the HTTP redirect status code 304 - Not Modified.  Represents the HTTP redirect status code 305 - Use Proxy.  Represents the HTTP redirect status code 307 - Temporary Redirect.  Represents the HTTP redirect status code 308 - Permanent Redirect.  Represents the reason string for the http:FailoverAllEndpointsFailedError   Represents the reason string for the http:FailoverActionFailedError   Represents the reason string for the http:UpstreamServiceUnavailableError   Represents the reason string for the http:AllLoadBalanceEndpointsFailedError   Represents the reason string for the http:AllRetryAttemptsFailed   Represents the reason string for the http:IdleTimeoutError   Represents the reason string for the http:AuthenticationError   Represents the reason string for the http:AuthorizationError   Represents the reason string for the http:InitializingOutboundRequestError   Represents the reason string for the http:WritingOutboundRequestHeadersError   Represents the reason string for the http:WritingOutboundRequestBodyError   Represents the reason string for the http:InitializingInboundResponseError   Represents the reason string for the http:ReadingInboundResponseBodyError   Represents the reason string for the http:ReadingInboundResponseBodyError   Represents the reason string for the http:InitialingInboundRequestError   Represents the reason string for the http:ReadingInboundRequestHeadersError   Represents the reason string for the http:ReadingInboundRequestBodyError   Represents the reason string for the http:InitializingOutboundResponseError   Represents the reason string for the http:WritingOutboundResponseHeadersError   Represents the reason string for the http:WritingOutboundResponseBodyError   Represents the reason string for the http:Initiating100ContinueResponseError   Represents the reason string for the http:Writing100ContinueResponseError   Represents the reason string for the http:InvalidCookieError   Error reason for generic client error   Represents the reason string for the http:GenericListenerError   Represents the reason string for the http:UnsupportedActionError   Represents the reason string for the http:Http2ClientError   Represents the reason string for the http:MaximumWaitTimeExceededError   Represents the reason string for the http:SslError   Represents the reason string for the http:CookieHandlingError   HTTP header key age.  HTTP header key authorization   HTTP header key cache-control.  HTTP header key content-length.  HTTP header key content-type.  HTTP header key date.  HTTP header key etag.  HTTP header key expect.  HTTP header key expires.  HTTP header key if-match   HTTP header key if-modified-since.  HTTP header key if-none-match.  HTTP header key if-range   HTTP header key if-unmodified-since   HTTP header key last-modified.  HTTP header key location.  HTTP header key pragma.  HTTP header key server.  HTTP header key warning.  HTTP header key transfer-encoding.  HTTP header key connection.  HTTP header key upgrade.  Mutual SSL handshake is successful.  Mutual SSL handshake has failed.  Not a mutual ssl connection.  Represents the open state of the circuit.  Represents the half-open state of the circuit.  Represents the closed state of the circuit.  The HTTP response status code: 100 Continue   The HTTP response status code: 101 Switching Protocols   The HTTP response status code: 200 OK   The HTTP response status code: 201 Created   The HTTP response status code: 202 Accepted   The HTTP response status code: 203 Non Authoritative Information   The HTTP response status code: 204 No Content   The HTTP response status code: 205 Reset Content   The HTTP response status code: 206 Partial Content   The HTTP response status code: 300 Multiple Choices   The HTTP response status code: 301 Moved Permanently   The HTTP response status code: 302 Found   The HTTP response status code: 303 See Other   The HTTP response status code: 304 Not Modified   The HTTP response status code: 305 Use Proxy   The HTTP response status code: 307 Temporary Redirect   The HTTP response status code: 308 Permanent Redirect   The HTTP response status code: 400 Bad Request   The HTTP response status code: 401 Unauthorized   The HTTP response status code: 402 Payment Required   The HTTP response status code: 403 Forbidden   The HTTP response status code: 404 Not Found   The HTTP response status code: 405 Method Not Allowed   The HTTP response status code: 406 Not Acceptable   The HTTP response status code: 407 Proxy Authentication Required   The HTTP response status code: 408 Request Timeout   The HTTP response status code: 409 Conflict   The HTTP response status code: 410 Gone   The HTTP response status code: 411 Length Required   The HTTP response status code: 412 Precondition Failed   The HTTP response status code: 413 Payload Too Large   The HTTP response status code: 414 URI Too Long   The HTTP response status code: 415 Unsupported Media Type   The HTTP response status code: 416 Range Not Satisfiable   The HTTP response status code: 417 Expectation Failed   The HTTP response status code: 426 Upgrade Required   The HTTP response status code: 500 Internal Server Error   The HTTP response status code: 501 Not Implemented   The HTTP response status code: 502 Bad Gateway   The HTTP response status code: 503 Service Unavailable   The HTTP response status code: 504 Gateway Timeout   The HTTP response status code: 505 HTTP Version Not Supported   Decides to keep the connection alive or not based on the connection header of the client request }   Keeps the connection alive irrespective of the connection header value }   Closes the connection irrespective of the connection header value }   Constant for the service name reference.  Constant for the resource name reference.  Constant for the request method reference.  Error reason for failures during connection closure   Error reason for WebSocket handshake failures   Error reason for exceeding maximum frame size   Error reason for other side breaking the protocol   Error reason for connection failures   Error reason for invalid continuation frame   Error reason for errors not captured by the specific errors   Annotations The annotation which is used to configure an HTTP resource.  The annotation which is used to configure an HTTP service.  The annotation which is used to configure a WebSocket service.  Types Used for configuring the caching behaviour.  Defines the possible values for the chunking configuration in HTTP services and clients.  A finite type for modeling the states of the Circuit Breaker.  Defines the Auth error types that returned from client   Defines the possible client error types   Options to compress using gzip or deflate.  Specifies how to send the authentication credentials when exchanging tokens.  Defines the HTTP operations related to circuit breaker, failover and load balancer.  Defines the supported HTTP protocols.  Represents inbound auth handler patterns.  Defines the listener error types that returned while receiving inbound request   Defines the client error types that returned while receiving inbound response   Defines the possible values for the keep-alive configuration in service and client endpoints.  Defines the possible listener error types   Defines the possible values for the mutual ssl status.  Defines the client error types that returned while sending outbound request   Defines the listener error types that returned while sending outbound response   Defines the HTTP redirect codes as a type.  The types of messages that are accepted by HTTP client when sending out the outbound request.  Defines the resiliency error types that returned from client   The types of messages that are accepted by HTTP listener when sending out the outbound response.  Represents scopes patterns.  The union of all the WebSocket related errors   Errors Represents a client error that occurred due to all the load balance endpoint failure   Represents a client error that occurred due to all the the retry attempts failure   Represents a listener error that occurred due to inbound request authentication failure   Represents a listener error that occurred due to inbound request authorization failure   Represents a cookie error that occurred when using the cookies   Represents a client error that occurred due to failover action failure   Represents a client error that occurred due to all the failover endpoint failure   Represents a generic client error   Represents a generic listener error   Represents an HTTP/2 client generic error   Represents the error that triggered upon a request/response idle timeout   Represents a listener error that occurred due to inbound request initialization failure   Represents a client error that occurred due to inbound response initialization failure   Represents a client error that occurred due to outbound request initialization failure   Represents a listener error that occurred due to outbound response initialization failure   Represents an error that occurred due to 100 continue response initialization failure   Represents a cookie error that occurred when sending cookies in the response   Represents a client error that occurred exceeding maximum wait time   Represents a listener error that occurred while writing the inbound request entity body   Represents a listener error that occurred while reading inbound request headers   Represents a client error that occurred while reading inbound response entity body   Represents a client error that occurred while reading inbound response headers   Represents a client error that occurred due to SSL failure   Represents a client error that occurred due to unsupported action invocation   Represents a client error that occurred due to upstream service unavailability   Represents an error that occurred while writing 100 continue response   Represents a client error that occurred while writing outbound request entity body   Represents a client error that occurred while writing outbound request headers   Represents a listener error that occurred while writing outbound response entity body   Represents a listener error that occurred while writing outbound response headers   Raised during failures in connection closure   Raised during connection failures   Raised for errors not captured by the specific errors   Raised when an out of order/invalid continuation frame is received   Raised during the handshake when the WebSocket upgrade fails   Raised when receiving a frame with a payload exceeding the maximum size   Raised when the other side breaks the protocol"},{"page":"/learn/api-docs/ballerina/http/listeners/Listener.html","name":"Listener - : Listener","summary":"This is used for creating HTTP server endpoints. An HTTP server endpoint is capable of responding to\nremote callers. The Listener is responsible for initializing the endpoint using the provided configurations.\n(int port, ? config)Listening port of the HTTP service listener()Stops the service listener gracefully. Already-accepted requests will be served before connection ...","content":"Listeners  v1.2.2  All Modules  Listener - : Listener This is used for creating HTTP server endpoints. An HTTP server endpoint is capable of responding to remote callers. The Listener is responsible for initializing the endpoint using the provided configurations.    Constructor __init(int port, ? config)   port int Listening port of the HTTP service listener   config ? ()  Methods  Stops the service listener gracefully.  Stops the service listener immediately.  Detaches a Http or WebSocket service from the listener.  Gets invoked during module initialization to initialize the endpoint.  LifeCycle Methods  Starts the registered service programmatically.  Attaches a service to the listener.  Methods  __gracefulStop ()  returns error? Stops the service listener gracefully. Already-accepted requests will be served before connection closure.   Return Type (error?)  An error if an error occurred during the listener stopping process   __immediateStop ()  returns error? Stops the service listener immediately. It is not implemented yet.   Return Type (error?)  An error if an error occurred during the listener stop process   __detach (service s)  returns error? Detaches a Http or WebSocket service from the listener. Note that detaching a WebSocket service would not affect The functionality of the existing connections.   Parameters  s service The service to be detached   Return Type (error?)  An error if one occurred during detaching of a service or else ()   init Gets invoked during module initialization to initialize the endpoint.   Parameters  c Configurations for HTTP service endpoints   initEndpoint ()  returns error? Return Type (error?)  LifeCycle Methods  __start ()  returns error? Starts the registered service programmatically.   Return Type (error?)  An error if an error occurred during the listener starting process   __attach (service s, string? name)  returns error? Attaches a service to the listener.   Parameters  s service The service that needs to be attached   name string? (default ())  Name of the service   Return Type (error?)  An error an error occurred during the service attachment process or else nil"},{"page":"/learn/api-docs/ballerina/http/listeners/MockListener.html","name":"Listener - : MockListener","summary":"Mock server endpoint which does not open a listening port.\n(int port, ? config)()()(service s)()(service s, string? name)()()(service s)()(service s, string? name) ...","content":"Listeners  v1.2.2  All Modules  Listener - : MockListener Mock server endpoint which does not open a listening port.    Constructor __init(int port, ? config)   port int config ? ()  Methods  LifeCycle Methods  Methods  __gracefulStop ()  returns error? Return Type (error?)  __immediateStop ()  returns error? Return Type (error?)  __detach (service s)  returns error? Parameters  s service Return Type (error?)  init Parameters  c initEndpoint ()  returns error? Return Type (error?)  register (service s, string? name)  returns error? Parameters  s service name string? Return Type (error?)  start ()  returns error? Return Type (error?)  gracefulStop ()  returns error? Return Type (error?)  detach (service s)  returns error? Parameters  s service Return Type (error?)  LifeCycle Methods  __start ()  returns error? Return Type (error?)  __attach (service s, string? name)  returns error? Parameters  s service name string? (default ())  Return Type (error?)"},{"page":"/learn/api-docs/ballerina/http/objects/BasicAuthHandler.html","name":"Object - : BasicAuthHandler","summary":"Defines the Basic Auth header handler for inbound and outbound HTTP traffic.\n\n       ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  BasicAuthHandler  Defines the Basic Auth header handler for inbound and outbound HTTP traffic.   Constructor __init( | authProvider)   authProvider | The auth:InboundAuthProvider instance or the auth:OutboundAuthProvider instance   Methods  Checks if the provided request can be authenticated with the Basic Auth header.  Authenticates the incoming request with the use of the credentials passed as the Basic Auth header.  Prepares the request with the Basic Auth header.  Inspects the request and response and calls the Auth provider for inspection.  Fields  authProvider  | The AuthProvider instance   canProcess ( req)  returns boolean Checks if the provided request can be authenticated with the Basic Auth header.   Parameters  req The http:Request instance   Return Type (boolean)  true if authentication is successful or else false   process ( req)  returns boolean | Authenticates the incoming request with the use of the credentials passed as the Basic Auth header.   Parameters  req The http:Request instance   Return Type (boolean | )  true if it is possible to authenticate with Basic Auth, false otherwise, or else an http:AuthenticationError in case of an error   prepare ( req)  returns | Prepares the request with the Basic Auth header.   Parameters  req The http:Request instance   Return Type ( | )  The updated http:Request instance or else an http:AuthenticationError in case of an error   inspect ( req, resp)  returns | | () Inspects the request and response and calls the Auth provider for inspection.   Parameters  req The http:Request instance   resp The http:Response instance   Return Type ( | | ())  The updated http:Request instance or the http:AuthenticationError in case of an error or else () if nothing is to be returned"},{"page":"/learn/api-docs/ballerina/http/objects/AuthzFilter.html","name":"Object - : AuthzFilter","summary":"Representation of the Authorization filter.\n\n            ( authzHandler, ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  AuthzFilter  Representation of the Authorization filter.   Constructor __init( authzHandler, ? scopes)   authzHandler The http:AuthzHandler instance for handling authorization   scopes ? An array of scopes or an array consisting of arrays of scopes   Methods  Filter function implementation which tries to authorize the request.  Fields  authzHandler  AuthzHandler instance for handling authorization   scopes  ?  An array of scopes or an array consisting of arrays of scopes   filterRequest ( caller, request, context)  returns boolean Filter function implementation which tries to authorize the request.   Parameters  caller Caller for outbound HTTP responses   request An inbound HTTP request message   context The http:FilterContext instance   Return Type (boolean)  A flag to indicate if the request flow should be continued(true) or aborted(false)"},{"page":"/learn/api-docs/ballerina/http/objects/AuthnFilter.html","name":"Object - : AuthnFilter","summary":"Representation of the Authentication filter.\n\n            ( authHandlers)An ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  AuthnFilter  Representation of the Authentication filter.   Constructor __init( authHandlers)   authHandlers An array of authentication handlers or an array consisting of arrays of authentication handlers   Methods  The request filter method, which attempts to authenticate the request.  Fields  authHandlers  An array of authentication handlers or an array consisting of arrays of authentication handlers   filterRequest ( caller, request, context)  returns boolean The request filter method, which attempts to authenticate the request.   Parameters  caller Caller for outbound HTTP responses   request An inbound HTTP request message   context The http:FilterContext instance   Return Type (boolean)  A flag to indicate if the request flow should be continued(true) or aborted(false)"},{"page":"/learn/api-docs/ballerina/http/objects/AuthzHandler.html","name":"Object - : AuthzHandler","summary":"Representation of Authorization Handler for HTTP.\n\n            (? ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  AuthzHandler  Representation of Authorization Handler for HTTP.   Constructor __init(? positiveAuthzCache, ? negativeAuthzCache)   positiveAuthzCache ? The cache:Cache instance, which holds positive authorizations   negativeAuthzCache ? The cache:Cache instance, which holds negative authorizations   Fields  positiveAuthzCache  ?  The cache:Cache instance, which holds positive authorizations   negativeAuthzCache  ?  The cache:Cache instance, which holds negative authorizations"},{"page":"/learn/api-docs/ballerina/http/objects/BearerAuthHandler.html","name":"Object - : BearerAuthHandler","summary":"Representation of the Bearer Auth header handler for both inbound and outbound HTTP traffic.\n\n     ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  BearerAuthHandler  Representation of the Bearer Auth header handler for both inbound and outbound HTTP traffic.   Constructor __init( | authProvider)   authProvider | The auth:InboundAuthProvider instance or the auth:OutboundAuthProvider instance   Methods  Checks if the request can be authenticated with the Bearer Auth header.  Authenticates the incoming request with the use of credentials passed as the Bearer Auth header.  Prepares the request with the Bearer Auth header.  Inspects the request and response and calls the Auth provider for inspection.  Fields  authProvider  | The InboundAuthProvider instance or the OutboundAuthProvider instance   canProcess ( req)  returns boolean Checks if the request can be authenticated with the Bearer Auth header.   Parameters  req The http:Request instance   Return Type (boolean)  true if it can be authenticated or else false   process ( req)  returns boolean | Authenticates the incoming request with the use of credentials passed as the Bearer Auth header.   Parameters  req The http:Request instance   Return Type (boolean | )  true if authenticated successfully, false otherwise, or else an http:AuthenticationError in case of an error   prepare ( req)  returns | Prepares the request with the Bearer Auth header.   Parameters  req Thehttp:Request instance   Return Type ( | )  The updated http:Request instance or else an http:AuthenticationError in case of an error   inspect ( req, resp)  returns | | () Inspects the request and response and calls the Auth provider for inspection.   Parameters  req The http:Request instance   resp The http:Response instance   Return Type ( | | ())  The updated http:Request instance, an http:AuthenticationError in case of an error, or else () if nothing is to be returned"},{"page":"/learn/api-docs/ballerina/http/objects/CookieClient.html","name":"Object - : CookieClient","summary":"Provides the cookie functionality across HTTP client actions.\n\n           ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  CookieClient  Provides the cookie functionality across HTTP client actions.   Constructor __init(string url, config, cookieConfig, httpClient, ? cookieStore)   url string Target service URL   config HTTP Client Configuration to be used for the HTTP client invocation   cookieConfig Configurations associated with the cookies   httpClient HTTP client for outbound HTTP requests   cookieStore ? Stores the cookies of the client   Methods  The CookieClient.  The CookieClient.  The CookieClient.  The CookieClient.  The CookieClient.  The CookieClient.  The CookieClient.  The CookieClient.  The CookieClient.  Submits an HTTP request to a service with the specified HTTP verb.  Retrieves the http:Response for a previously-submitted request.  Checks whether an http:PushPromise exists for a previously-submitted request.  Retrieves the next available http:PushPromise for a previously-submitted request.  Retrieves the promised server push http:Response message.  Rejects an http:PushPromise.  Fields  url  string  Target service URL   config  HTTP Client Configuration to be used for the HTTP client invocation   cookieConfig  Configurations associated with the cookies   httpClient  HTTP client for outbound HTTP requests   cookieStore  ?  (default ) Stores the cookies of the client   get (string path, message)  returns | The CookieClient.get() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  path string Request path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   post (string path, message)  returns | The CookieClient.post() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   head (string path, message)  returns | The CookieClient.head() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   put (string path, message)  returns | The CookieClient.put() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   forward (string path, request)  returns | The CookieClient.forward() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  path string Request path   request An HTTP inbound request message   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   execute (string httpVerb, string path, message)  returns | The CookieClient.execute() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  httpVerb string HTTP verb value   path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   patch (string path, message)  returns | The CookieClient.patch() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  path string Resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   delete (string path, message)  returns | The CookieClient.delete() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  path string Resource path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   options (string path, message)  returns | The CookieClient.options() function wraps the underlying HTTP remote functions in a way to provide the cookie functionality for a given endpoint.   Parameters  path string Request path   message (default ())  An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  The response for the request or an http:ClientError if failed to establish communication with the upstream server   submit (string httpVerb, string path, message)  returns | Submits an HTTP request to a service with the specified HTTP verb. The CookieClient.submit() function does not produce a Response as the result. Rather, it returns an HttpFuture, which can be used to do further interactions with the endpoint.   Parameters  httpVerb string The HTTP verb value   path string The resource path   message An HTTP outbound request message or any payload of type string, xml, json, byte[], io:ReadableByteChannel or mime:Entity[]   Return Type ( | )  An HttpFuture, which represents an asynchronous service invocation or else an http:ClientError if the submission fails   getResponse ( httpFuture)  returns | Retrieves the http:Response for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture relates to a previous asynchronous invocation   Return Type ( | )  An HTTP response message or else an http:ClientError if the invocation fails   hasPromise ( httpFuture)  returns boolean Checks whether an http:PushPromise exists for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type (boolean)  A boolean, which represents whether an http:PushPromise exists   getNextPromise ( httpFuture)  returns | Retrieves the next available http:PushPromise for a previously-submitted request.   Parameters  httpFuture The http:HttpFuture related to a previous asynchronous invocation   Return Type ( | )  An HTTP Push Promise message or else an http:ClientError if the invocation fails   getPromisedResponse ( promise)  returns | Retrieves the promised server push http:Response message.   Parameters  promise The related http:PushPromise   Return Type ( | )  A promised HTTP http:Response message or else an http:ClientError if the invocation fails   rejectPromise Rejects an http:PushPromise. When an http:PushPromise is rejected, there is no chance of fetching a promised response using the rejected promise.   Parameters  promise The Push Promise to be rejected"},{"page":"/learn/api-docs/ballerina/http/objects/Cookie.html","name":"Object - : Cookie","summary":"Represents a Cookie.\n\n            (string name, string value)Name ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  Cookie  Represents a Cookie.   Constructor __init(string name, string value)   name string Name of the http:Cookie   value string Value of the http:Cookie   Methods  Checks the persistance of the cookie.  Checks the validity of the attributes of the cookie.  Fields  name  string?  (default ()) Name of the cookie   value  string?  (default ()) Value of the cookie   domain  string?  (default ()) Host to which the cookie will be sent   path  string?  (default ()) URI path to which the cookie belongs   expires  string?  (default ()) Maximum lifetime of the cookie represented as the date and time at which the cookie expires   maxAge  int  (default 0) Maximum lifetime of the cookie represented as the number of seconds until the cookie expires   httpOnly  boolean  (default false) Cookie is sent only to HTTP requests   secure  boolean  (default false) Cookie is sent only to secure channels   createdTime  (default time:currentTime()) At what time the cookie was created   lastAccessedTime  (default time:currentTime()) Last-accessed time of the cookie   hostOnly  boolean  (default false) Cookie is sent only to the requested host   isPersistent ()  returns boolean Checks the persistance of the cookie.   Return Type (boolean)  false if the cookie will be discarded at the end of the \"session\" or else true.   isValid ()  returns boolean | Checks the validity of the attributes of the cookie.   Return Type (boolean | )  true if the attributes of the cookie are in the correct format or else an http:InvalidCookieError"},{"page":"/learn/api-docs/ballerina/http/objects/CookieStore.html","name":"Object - : CookieStore","summary":"Represents the cookie store.\n\n            (? persistentCookieHandler)( cookie, ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  CookieStore  Represents the cookie store.   Constructor __init(? persistentCookieHandler)   persistentCookieHandler ? ()  Methods  Adds a cookie to the cookie store according to the rules in Adds an array of cookies.  Gets the relevant cookies for the given URL and the path according to the rules in Gets all the cookies in the cookie store.  Gets all the cookies, which have the given name as the name of the cookie.  Gets all the cookies, which have the given name as the domain of the cookie.  Removes a specific cookie.  Removes cookies, which match with the given domain.  Removes all expired cookies.  Removes all the cookies.  addCookie ( cookie, cookieConfig, string url, string requestPath)  returns ? Adds a cookie to the cookie store according to the rules in .   Parameters  cookie Cookie to be added   cookieConfig Configurations associated with the cookies   url string Target service URL   requestPath string Resource path   Return Type (?)  An http:CookieHandlingError if there is any error occurred when adding a cookie or else ()   addCookies Adds an array of cookies.   Parameters  cookiesInResponse [] Cookies to be added   cookieConfig Configurations associated with the cookies   url string Target service URL   requestPath string Resource path   getCookies (string url, string requestPath)  returns [] Gets the relevant cookies for the given URL and the path according to the rules in .   Parameters  url string URL of the request URI   requestPath string Path of the request URI   Return Type ([])  Array of the matched cookies stored in the cookie store   getAllCookies ()  returns [] Gets all the cookies in the cookie store.   Return Type ([])  Array of all the cookie objects   getCookiesByName (string cookieName)  returns [] Gets all the cookies, which have the given name as the name of the cookie.   Parameters  cookieName string Name of the cookie   Return Type ([])  Array of all the matched cookie objects   getCookiesByDomain (string domain)  returns [] Gets all the cookies, which have the given name as the domain of the cookie.   Parameters  domain string Name of the domain   Return Type ([])  Array of all the matched cookie objects   removeCookie (string name, string domain, string path)  returns ? Removes a specific cookie.   Parameters  name string Name of the cookie to be removed   domain string Domain of the cookie to be removed   path string Path of the cookie to be removed   Return Type (?)  An http:CookieHandlingError if there is any error occurred during the removal of the cookie or else ()   removeCookiesByDomain (string domain)  returns ? Removes cookies, which match with the given domain.   Parameters  domain string Domain of the cookie to be removed   Return Type (?)  An http:CookieHandlingError if there is any error occurred during the removal of cookies by domain or else ()   removeExpiredCookies ()  returns ? Removes all expired cookies.   Return Type (?)  An http:CookieHandlingError if there is any error occurred during the removal of expired cookies or else ()   removeAllCookies ()  returns ? Removes all the cookies.   Return Type (?)  An http:CookieHandlingError if there is any error occurred during the removal of all the cookies or else ()"},{"page":"/learn/api-docs/ballerina/http/objects/CsvPersistentCookieHandler.html","name":"Object - : CsvPersistentCookieHandler","summary":"Represents a default persistent cookie handler, which stores persistent cookies in a CSV file.\n\n     ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  CsvPersistentCookieHandler  Represents a default persistent cookie handler, which stores persistent cookies in a CSV file.   Constructor __init(string fileName)   fileName string Methods  Adds a persistent cookie to the cookie store.  Gets all the persistent cookies.  Removes a specific persistent cookie.  Removes all persistent cookies.  storeCookie ( cookie)  returns ? Adds a persistent cookie to the cookie store.   Parameters  cookie Cookie to be added   Return Type (?)  An http:CookieHandlingError if there is any error occurred during the storing process of the cookie or else ()   getAllCookies ()  returns [] | Gets all the persistent cookies.   Return Type ([] | )  Array of persistent cookies stored in the cookie store or else an http:CookieHandlingError if one occurred during the retrieval of the cookies   removeCookie (string name, string domain, string path)  returns ? Removes a specific persistent cookie.   Parameters  name string Name of the persistent cookie to be removed   domain string Domain of the persistent cookie to be removed   path string Path of the persistent cookie to be removed   Return Type (?)  An http:CookieHandlingError if there is any error occurred during the removal of the cookie or else ()   removeAllCookies ()  returns ? Removes all persistent cookies.   Return Type (?)  An http:CookieHandlingError if there is any error occurred during the removal of all the cookies or else ()"},{"page":"/learn/api-docs/ballerina/http/objects/FilterContext.html","name":"Object - : FilterContext","summary":"Representation of request filter Context.\n\n            (service serviceRef, ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  FilterContext  Representation of request filter Context.   Constructor __init(service serviceRef, string serviceName, string resourceName)   serviceRef service The service to which the context is applied   serviceName string Name of the service   resourceName string Name of the resource function   Methods  Gets the service to which the http:FilerContext is applied.  Gets the service name to which the http:FilerContext is applied.  Gets the resource function name to which the http:FilerContext is applied.  Fields  attributes  map  (default {}) Attributes to share between filters   getService ()  returns service Gets the service to which the http:FilerContext is applied.   Return Type (service)  service of the context   getServiceName ()  returns string Gets the service name to which the http:FilerContext is applied.   Return Type (string)  Name of the service   getResourceName ()  returns string Gets the resource function name to which the http:FilerContext is applied.   Return Type (string)  Name of the resource function"},{"page":"/learn/api-docs/ballerina/http/objects/HttpCache.html","name":"Object - : HttpCache","summary":"Implements a cache for storing HTTP responses. This cache complies with the caching policy set when configuring\nHTTP caching ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  HttpCache  Implements a cache for storing HTTP responses. This cache complies with the caching policy set when configuring HTTP caching in the HTTP client endpoint.   Constructor __init( cacheConfig)   cacheConfig The configurations for the HTTP cache   Fields  cache  The underlying cache used for storing HTTP responses   policy  (default CACHE_CONTROL_AND_VALIDATORS) Gives the user some control over the caching behaviour. By default, this is set to CACHE_CONTROL_AND_VALIDATORS. The default behaviour is to allow caching only when the cache-control header and either the etag or last-modified header are present.   isShared  boolean  (default false) Specifies whether the HTTP caching layer should behave as a public cache or a private cache"},{"page":"/learn/api-docs/ballerina/http/objects/HttpFuture.html","name":"Object - : HttpFuture","summary":"Represents a 'future' that returns as a result of an asynchronous HTTP request submission.\nThis can be used as ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  HttpFuture  Represents a 'future' that returns as a result of an asynchronous HTTP request submission. This can be used as a reference to fetch the results of the submission."},{"page":"/learn/api-docs/ballerina/http/objects/InboundAuthHandler.html","name":"Object - : InboundAuthHandler","summary":"The representation of an inbound authentication handler for HTTP traffic.\n\n         ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  InboundAuthHandler  The representation of an inbound authentication handler for HTTP traffic.   Methods  Checks if the request can be authenticated with the relevant InboundAuthHandler implementation.  Tries to authenticate the request with the relevant InboundAuthHandler implementation.  canProcess ( req)  returns boolean Checks if the request can be authenticated with the relevant InboundAuthHandler implementation.   Parameters  req The http:Request instance   Return Type (boolean)  true if it can be authenticated or else false   process ( req)  returns boolean | Tries to authenticate the request with the relevant InboundAuthHandler implementation.   Parameters  req The http:Request instance   Return Type (boolean | )  true if it authenticated successfully, false otherwise, or else an http:AuthenticationError in case of errors"},{"page":"/learn/api-docs/ballerina/http/objects/LoadBalancerRoundRobinRule.html","name":"Object - : LoadBalancerRoundRobinRule","summary":"Implementation of round robin load balancing strategy.\n\n            ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  LoadBalancerRoundRobinRule  Implementation of round robin load balancing strategy.   Methods  Provides an HTTP client, which is chosen according to the round robin algorithm.  Fields  index  int  (default 0) Keep tracks the current point of the Client[]   getNextClient (?[] loadBalanceCallerActionsArray)  returns | Provides an HTTP client, which is chosen according to the round robin algorithm.   Parameters  loadBalanceCallerActionsArray ?[] Array of HTTP clients, which needs to be load balanced   Return Type ( | )  Chosen http:Client from the algorithm or else an http:ClientError for a failure in the algorithm implementation"},{"page":"/learn/api-docs/ballerina/http/objects/LoadBalancerRule.html","name":"Object - : LoadBalancerRule","summary":"LoadBalancerRule provides a required interfaces to implement different algorithms.\n\n          ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  LoadBalancerRule  LoadBalancerRule provides a required interfaces to implement different algorithms.   Methods  Provides an HTTP client which is chosen according to the algorithm.  getNextClient (?[] loadBalanceCallerActionsArray)  returns | Provides an HTTP client which is chosen according to the algorithm.   Parameters  loadBalanceCallerActionsArray ?[] Array of HTTP clients which needs to be load balanced   Return Type ( | )  Chosen Client from the algorithm or an http:ClientError for the failure in the algorithm implementation"},{"page":"/learn/api-docs/ballerina/http/objects/OutboundAuthHandler.html","name":"Object - : OutboundAuthHandler","summary":"The representation of an outbound authentication handler for HTTP traffic.\n\n         ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  OutboundAuthHandler  The representation of an outbound authentication handler for HTTP traffic.   Methods  Prepares the request with the relevant authentication requirements.  Inspects the request and response and evaluates what is to be done.  prepare ( req)  returns | Prepares the request with the relevant authentication requirements.   Parameters  req The http:Request instance   Return Type ( | )  The updated http:Request instance or else an http:AuthenticationError in case of an error   inspect ( req, resp)  returns | | () Inspects the request and response and evaluates what is to be done.   Parameters  req The http:Request instance   resp The http:Response instance   Return Type ( | | ())  The updated http:Request instance, an http:AuthenticationError in case of an error, or else () if nothing is to be returned"},{"page":"/learn/api-docs/ballerina/http/objects/PersistentCookieHandler.html","name":"Object - : PersistentCookieHandler","summary":"The representation of a persistent cookie handler for managing persistent cookies.\n\n        ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  PersistentCookieHandler  The representation of a persistent cookie handler for managing persistent cookies.   Methods  Adds a persistent cookie to the cookie store.  Gets all persistent cookies.  Removes a specific persistent cookie.  Removes all persistent cookies.  storeCookie ( cookie)  returns ? Adds a persistent cookie to the cookie store.   Parameters  cookie Cookie to be added   Return Type (?)  An http:CookieHandlingError if there is any error occurred during the storing process of the cookie or else ()   getAllCookies ()  returns [] | Gets all persistent cookies.   Return Type ([] | )  Array of persistent cookies stored in the cookie store or else an http:CookieHandlingError if one occurred during the retrieval of the cookies   removeCookie (string name, string domain, string path)  returns ? Removes a specific persistent cookie.   Parameters  name string Name of the persistent cookie to be removed   domain string Domain of the persistent cookie to be removed   path string Path of the persistent cookie to be removed   Return Type (?)  An http:CookieHandlingError if there is one occurred during the removal of the cookie or else ()   removeAllCookies ()  returns ? Removes all persistent cookies.   Return Type (?)  An http:CookieHandlingError if there is one occurred during the removal of all the cookies or else ()"},{"page":"/learn/api-docs/ballerina/http/objects/PushPromise.html","name":"Object - : PushPromise","summary":"Represents an HTTP/2 PUSH_PROMISE frame.\n\n            (string path, ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  PushPromise  Represents an HTTP/2 PUSH_PROMISE frame.   Constructor __init(string path, string method)   path string /  The resource path   method string GET  The HTTP method   Methods  Checks whether the requested header exists.  Returns the header value with the specified header name.  Gets transport headers from the PushPromise.  Adds the specified key/value pair as an HTTP header to the http:PushPromise.  Sets the value of a transport header in the http:PushPromise.  Removes a transport header from the http:PushPromise.  Removes all transport headers from the Phttp:ushPromise.  Gets all transport header names from the http:PushPromise.  Fields  path  string  The resource path   method  string  The HTTP method   hasHeader (string headerName)  returns boolean Checks whether the requested header exists.   Parameters  headerName string The header name   Return Type (boolean)  A boolean representing the existence of a given header   getHeader (string headerName)  returns string Returns the header value with the specified header name. If there are more than one header value for the specified header name, the first value is returned.   Parameters  headerName string The header name   Return Type (string)  The header value, or null if there is no such header   getHeaders (string headerName)  returns string[] Gets transport headers from the PushPromise.   Parameters  headerName string The header name   Return Type (string[])  The array of header values   addHeader Adds the specified key/value pair as an HTTP header to the http:PushPromise.   Parameters  headerName string The header name   headerValue string The header value   setHeader Sets the value of a transport header in the http:PushPromise.   Parameters  headerName string The header name   headerValue string The header value   removeHeader Removes a transport header from the http:PushPromise.   Parameters  headerName string The header name   removeAllHeaders Removes all transport headers from the Phttp:ushPromise.   getHeaderNames ()  returns string[] Gets all transport header names from the http:PushPromise.   Return Type (string[])  An array of all transport header names"},{"page":"/learn/api-docs/ballerina/http/objects/Request.html","name":"Object - : Request","summary":"Represents an HTTP request.\n\n            \n   ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  Request  Represents an HTTP request.   Methods  Sets the provided Entity to the request.  Gets the query parameters of the request as a map consisting of a string array.  Gets the query param value associated with the given key.  Gets all the query param values associated with the given key.  Gets the matrix parameters of the request.  Gets the Entity associated with the request.  Checks whether the requested header key exists in the header map.  Returns the value of the specified header.  Gets all the header values to which the specified header key maps to.  Sets the specified header to the request.  Adds the specified header to the request.  Removes the specified header from the request.  Removes all the headers from the request.  Gets all the names of the headers of the request.  Checks whether the client expects a 100-continue response.  Sets the content-type header to the request.  Gets the type of the payload of the request (i.  Extracts json payload from the request.  Extracts xml payload from the request.  Extracts text payload from the request.  Gets the request payload as a ByteChannel except in the case of multiparts.  Gets the request payload as a byte[].  Gets the form parameters from the HTTP request as a map when content type is application/x-www-form-urlencoded.  Extracts body parts from the request.  Sets a json as the payload.  Sets an xml as the payload.  Sets a string as the payload.  Sets a byte[] as the payload.  Set multiparts as the payload.  Sets the content of the specified file as the entity body of the request.  Sets a ByteChannel as the payload.  Sets the request payload.  Adds cookies to the request.  Gets cookies from the request.  Fields  rawPath  string  Resource path of the request URL   method  string  The HTTP request method   httpVersion  string  The HTTP version supported by the client   userAgent  string  The user-agent. This value is used when setting the user-agent header   extraPathInfo  string  The part of the URL, which matched to '*' if the request is dispatched to a wildcard resource   cacheControl  ?  (default ) The cache-control directives for the request. This needs to be explicitly initialized if intending on utilizing HTTP caching.   mutualSslHandshake  ?  (default ()) A record providing mutual ssl handshake results.   setEntity Sets the provided Entity to the request.   Parameters  e The Entity to be set to the request   getQueryParams ()  returns map Gets the query parameters of the request as a map consisting of a string array.   Return Type (map)  String array map of the query params   getQueryParamValue (string key)  returns string? Gets the query param value associated with the given key.   Parameters  key string Represents the query param key   Return Type (string?)  The query param value associated with the given key as a string. If multiple param values are present, then the first value is returned. () is returned if no key is found.   getQueryParamValues (string key)  returns string[]? Gets all the query param values associated with the given key.   Parameters  key string Represents the query param key   Return Type (string[]?)  All the query param values associated with the given key as a string[]. () is returned if no key is found.   getMatrixParams (string path)  returns map Gets the matrix parameters of the request.   Parameters  path string Path to the location of matrix parameters   Return Type (map)  A map of matrix parameters which can be found for the given path   getEntity ()  returns | Gets the Entity associated with the request.   Return Type ( | )  The Entity of the request. An http:ClientError is returned, if entity construction fails   hasHeader (string headerName)  returns boolean Checks whether the requested header key exists in the header map.   Parameters  headerName string The header name   Return Type (boolean)  Returns true if the specified header key exists   getHeader (string headerName)  returns string Returns the value of the specified header. If the specified header key maps to multiple values, the first of these values is returned.   Parameters  headerName string The header name   Return Type (string)  The first header value for the specified header name. Panic if the header is not found. Use the Request.hasHeader() beforehand to check the existence of a header.   getHeaders (string headerName)  returns string[] Gets all the header values to which the specified header key maps to.   Parameters  headerName string The header name   Return Type (string[])  The header values the specified header key maps to. Panic if the header is not found. Use the Request.hasHeader() beforehand to check the existence of a header.   setHeader Sets the specified header to the request. If a mapping already exists for the specified header key, the existing header value is replaced with the specified header value.   Parameters  headerName string The header name   headerValue string The header value   addHeader Adds the specified header to the request. Existing header values are not replaced.   Parameters  headerName string The header name   headerValue string The header value   removeHeader Removes the specified header from the request.   Parameters  key string The header name   removeAllHeaders Removes all the headers from the request.   getHeaderNames ()  returns string[] Gets all the names of the headers of the request.   Return Type (string[])  An array of all the header names   expects100Continue ()  returns boolean Checks whether the client expects a 100-continue response.   Return Type (boolean)  Returns true if the client expects a 100-continue response   setContentType (string contentType)  returns error? Sets the content-type header to the request.   Parameters  contentType string Content type value to be set as the content-type header   Return Type (error?)  Nil if successful, error in case of invalid content-type   getContentType ()  returns string Gets the type of the payload of the request (i.e: the content-type header value).   Return Type (string)  The content-type header value as a string   getJsonPayload ()  returns json | Extracts json payload from the request. If the content type is not JSON, an http:ClientError is returned.   Return Type (json | )  The json payload or http:ClientError in case of errors   getXmlPayload ()  returns xml | Extracts xml payload from the request. If the content type is not XML, an http:ClientError is returned.   Return Type (xml | )  The xml payload or http:ClientError in case of errors   getTextPayload ()  returns string | Extracts text payload from the request. If the content type is not of type text, an http:ClientError is returned.   Return Type (string | )  The text payload or http:ClientError in case of errors   getByteChannel ()  returns | Gets the request payload as a ByteChannel except in the case of multiparts. To retrieve multiparts, use Request.getBodyParts().   Return Type ( | )  A byte channel from which the message payload can be read or http:ClientError in case of errors   getBinaryPayload ()  returns byte[] | Gets the request payload as a byte[].   Return Type (byte[] | )  The byte[] representation of the message payload or http:ClientError in case of errors   getFormParams ()  returns map | Gets the form parameters from the HTTP request as a map when content type is application/x-www-form-urlencoded.   Return Type (map | )  The map of form params or http:ClientError in case of errors   getBodyParts ()  returns [] | Extracts body parts from the request. If the content type is not a composite media type, an error is returned.   Return Type ([] | )  The body parts as an array of entities or else an http:ClientError if there were any errors constructing the body parts from the request   setJsonPayload Sets a json as the payload.   Parameters  payload json The json payload   contentType string (default application/json)  The content type of the payload. Set this to override the default content-type header value for json   setXmlPayload Sets an xml as the payload.   Parameters  payload xml The xml payload   contentType string (default application/xml)  The content type of the payload. Set this to override the default content-type header value for xml   setTextPayload Sets a string as the payload.   Parameters  payload string The string payload   contentType string (default text/plain)  The content type of the payload. Set this to override the default content-type header value for string   setBinaryPayload Sets a byte[] as the payload.   Parameters  payload byte[] The byte[] payload   contentType string (default application/octet-stream)  The content type of the payload. Set this to override the default content-type header value for byte[]   setBodyParts Set multiparts as the payload.   Parameters  bodyParts [] The entities which make up the message body   contentType string (default multipart/form-data)  The content type of the top level message. Set this to override the default content-type header value   setFileAsPayload Sets the content of the specified file as the entity body of the request.   Parameters  filePath string Path to the file to be set as the payload   contentType string (default application/octet-stream)  The content type of the specified file. Set this to override the default content-type header value   setByteChannel Sets a ByteChannel as the payload.   Parameters  payload A ByteChannel through which the message payload can be read   contentType string (default application/octet-stream)  The content type of the payload. Set this to override the default content-type header value   setPayload Sets the request payload. Note that any string value is set as text/plain. To send a JSON-compatible string, set the content-type header to application/json or use the setJsonPayload method instead.   Parameters  payload string | xml | json | byte[] | | [] Payload can be of type string, xml, json, byte[], ByteChannel, or Entity[] (i.e., a set of body parts).   addCookies Adds cookies to the request.   Parameters  cookiesToAdd [] Represents the cookies to be added   getCookies ()  returns [] Gets cookies from the request.   Return Type ([])  An array of cookie objects, which are included in the request"},{"page":"/learn/api-docs/ballerina/http/objects/RequestCacheControl.html","name":"Object - : RequestCacheControl","summary":"Configures the cache control directives for an http:Request.\n\n           ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  RequestCacheControl  Configures the cache control directives for an http:Request.   Methods  Builds the cache control directives string from the current http:RequestCacheControl configurations.  Fields  noCache  boolean  (default false) Sets the no-cache directive   noStore  boolean  (default false) Sets the no-store directive   noTransform  boolean  (default false) Sets the no-transform directive   onlyIfCached  boolean  (default false) Sets the only-if-cached directive   maxAge  int  (default -1) Sets the max-age directive   maxStale  int  (default -1) Sets the max-stale directive   minFresh  int  (default -1) Sets the min-fresh directive   buildCacheControlDirectives ()  returns string Builds the cache control directives string from the current http:RequestCacheControl configurations.   Return Type (string)  The cache control directives string to be used in the cache-control header"},{"page":"/learn/api-docs/ballerina/http/objects/RequestFilter.html","name":"Object - : RequestFilter","summary":"Abstract Representation of a HTTP Request Filter.\nThis filter will be applied before the request is dispatched to the ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  RequestFilter  Abstract Representation of a HTTP Request Filter. This filter will be applied before the request is dispatched to the relevant resource. Any RequestFilter implementation should be structurally similar to or implement the RequestFilter object.   Methods  Request filter function.  filterRequest ( caller, request, context)  returns boolean Request filter function. If a false is returned the response should have been sent from this function as it will not be dispatched to the next filter or the resource.   Parameters  caller The http caller   request An inbound HTTP request message   context A filter context   Return Type (boolean)  True if the filter succeeds"},{"page":"/learn/api-docs/ballerina/http/objects/Response.html","name":"Object - : Response","summary":"Represents an HTTP response.\n\n            \n   ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  Response  Represents an HTTP response.   Methods  Gets the Entity associated with the response.  Sets the provided Entity to the response.  Checks whether the requested header key exists in the header map.  Returns the value of the specified header.  Adds the specified header to the response.  Gets all the header values to which the specified header key maps to.  Sets the specified header to the response.  Removes the specified header from the response.  Removes all the headers from the response.  Gets all the names of the headers of the response.  Sets the content-type header to the response.  Gets the type of the payload of the response (i.  Extract json payload from the response.  Extracts xml payload from the response.  Extracts text payload from the response.  Gets the response payload as a ByteChannel, except in the case of multiparts.  Gets the response payload as a byte[].  Extracts body parts from the response.  Sets the etag header for the given payload.  Sets the current time as the last-modified header.  Sets a json as the payload.  Sets an xml as the payload   Sets a string as the payload.  Sets a byte[] as the payload.  Set multiparts as the payload.  Sets the content of the specified file as the entity body of the response.  Sets a ByteChannel as the payload.  Sets the response payload.  Adds the cookie to response.  Deletes the cookies in the client's cookie store.  Gets cookies from the response.  Fields  statusCode  int  (default 200) The response status code   reasonPhrase  string  The status code reason phrase   server  string  The server header   resolvedRequestedURI  string  The ultimate request URI that was made to receive the response when redirect is on   cacheControl  ?  (default ) The cache-control directives for the response. This needs to be explicitly initialized if intending on utilizing HTTP caching. For incoming responses, this will already be populated if the response was sent with cache-control directives   getEntity ()  returns | Gets the Entity associated with the response.   Return Type ( | )  The Entity of the response. An http:ClientError is returned, if entity construction fails   setEntity Sets the provided Entity to the response.   Parameters  e The Entity to be set to the response   hasHeader (string headerName, position)  returns boolean Checks whether the requested header key exists in the header map.   Parameters  headerName string The header name   position (default mime:LEADING)  Represents the position of the header as an optional parameter   Return Type (boolean)  true if the specified header key exists   getHeader (string headerName, position)  returns string Returns the value of the specified header. If the specified header key maps to multiple values, the first of these values is returned.   Parameters  headerName string The header name   position (default mime:LEADING)  Represents the position of the header as an optional parameter. If the position is mime:TRAILING, the entity-body of the Response must be accessed initially.   Return Type (string)  The first header value for the specified header name. Panic if the header is not found. Use the Response.hasHeader() beforehand to check the existence of a header.   addHeader Adds the specified header to the response. Existing header values are not replaced.   Parameters  headerName string The header name   headerValue string The header value   position (default mime:LEADING)  Represents the position of the header as an optional parameter. If the position is mime:TRAILING, the entity-body of the Response must be accessed initially.   getHeaders (string headerName, position)  returns string[] Gets all the header values to which the specified header key maps to.   Parameters  headerName string The header name   position (default mime:LEADING)  Represents the position of the header as an optional parameter. If the position is mime:TRAILING, the entity-body of the Response must be accessed initially.   Return Type (string[])  The header values the specified header key maps to. Panic if the header is not found. Use the Response.hasHeader() beforehand to check the existence of a header.   setHeader Sets the specified header to the response. If a mapping already exists for the specified header key, the existing header value is replaced with the specified header value.   Parameters  headerName string The header name   headerValue string The header value   position (default mime:LEADING)  Represents the position of the header as an optional parameter. If the position is mime:TRAILING, the entity-body of the Response must be accessed initially.   removeHeader Removes the specified header from the response.   Parameters  key string The header name   position (default mime:LEADING)  Represents the position of the header as an optional parameter. If the position is mime:TRAILING, the entity-body of the Response must be accessed initially.   removeAllHeaders Removes all the headers from the response.   Parameters  position (default mime:LEADING)  Represents the position of the header as an optional parameter. If the position is mime:TRAILING, the entity-body of the Response must be accessed initially.   getHeaderNames ( position)  returns string[] Gets all the names of the headers of the response.   Parameters  position (default mime:LEADING)  Represents the position of the header as an optional parameter. If the position is mime:TRAILING, the entity-body of the Response must be accessed initially.   Return Type (string[])  An array of all the header names   setContentType Sets the content-type header to the response.   Parameters  contentType string Content type value to be set as the content-type header   getContentType ()  returns string Gets the type of the payload of the response (i.e: the content-type header value).   Return Type (string)  Returns the content-type header value as a string   getJsonPayload ()  returns json | Extract json payload from the response. If the content type is not JSON, an http:ClientError is returned.   Return Type (json | )  The json payload or http:ClientError in case of errors   getXmlPayload ()  returns xml | Extracts xml payload from the response.   Return Type (xml | )  The xml payload or http:ClientError in case of errors   getTextPayload ()  returns string | Extracts text payload from the response.   Return Type (string | )  The string representation of the message payload or http:ClientError in case of errors   getByteChannel ()  returns | Gets the response payload as a ByteChannel, except in the case of multiparts. To retrieve multiparts, use Response.getBodyParts().   Return Type ( | )  A byte channel from which the message payload can be read or http:ClientError in case of errors   getBinaryPayload ()  returns byte[] | Gets the response payload as a byte[].   Return Type (byte[] | )  The byte[] representation of the message payload or http:ClientError in case of errors   getBodyParts ()  returns [] | Extracts body parts from the response. If the content type is not a composite media type, an error is returned.   Return Type ([] | )  The body parts as an array of entities or else an http:ClientError if there were any errors in constructing the body parts from the response   setETag Sets the etag header for the given payload. The ETag is generated using a CRC32 hash function.   Parameters  payload json | xml | string | byte[] The payload for which the ETag should be set   setLastModified Sets the current time as the last-modified header.   setJsonPayload Sets a json as the payload.   Parameters  payload json The json payload   contentType string (default application/json)  The content type of the payload. Set this to override the default content-type header value for json   setXmlPayload Sets an xml as the payload   Parameters  payload xml The xml payload   contentType string (default application/xml)  The content type of the payload. Set this to override the default content-type header value for xml   setTextPayload Sets a string as the payload.   Parameters  payload string The string payload   contentType string (default text/plain)  The content type of the payload. Set this to override the default content-type header value for string   setBinaryPayload Sets a byte[] as the payload.   Parameters  payload byte[] The byte[] payload   contentType string (default application/octet-stream)  The content type of the payload. Set this to override the default content-type header value for byte[]   setBodyParts Set multiparts as the payload.   Parameters  bodyParts [] The entities which make up the message body   contentType string (default multipart/form-data)  The content type of the top level message. Set this to override the default content-type header value   setFileAsPayload Sets the content of the specified file as the entity body of the response.   Parameters  filePath string Path to the file to be set as the payload   contentType string (default application/octet-stream)  The content type of the specified file. Set this to override the default content-type header value   setByteChannel Sets a ByteChannel as the payload.   Parameters  payload A ByteChannel through which the message payload can be read   contentType string (default application/octet-stream)  The content type of the payload. Set this to override the default content-type header value   setPayload Sets the response payload.   Parameters  payload string | xml | json | byte[] | | [] Payload can be of type string, xml, json, byte[], ByteChannel or Entity[] (i.e: a set of body parts)   addCookie Adds the cookie to response.   Parameters  cookie The cookie, which is added to response   removeCookiesFromRemoteStore Deletes the cookies in the client's cookie store.   Parameters  cookiesToRemove [] Cookies to be deleted   getCookies ()  returns [] Gets cookies from the response.   Return Type ([])  An array of cookie objects, which are included in the response"},{"page":"/learn/api-docs/ballerina/http/objects/ResponseCacheControl.html","name":"Object - : ResponseCacheControl","summary":"Configures cache control directives for an http:Response.\n\n            ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  ResponseCacheControl  Configures cache control directives for an http:Response.   Methods  Builds the cache control directives string from the current http:ResponseCacheControl configurations.  Fields  mustRevalidate  boolean  (default false) Sets the must-revalidate directive   noCache  boolean  (default false) Sets the no-cache directive   noStore  boolean  (default false) Sets the no-store directive   noTransform  boolean  (default false) Sets the no-transform directive   isPrivate  boolean  (default false) Sets the private and public directives   proxyRevalidate  boolean  (default false) Sets the proxy-revalidate directive   maxAge  int  (default -1) Sets the max-age directive   sMaxAge  int  (default -1) Sets the s-maxage directive   noCacheFields  string[]  (default []) Optional fields for the no-cache directive. Before sending a listed field in a response, it must be validated with the origin server.   privateFields  string[]  (default []) Optional fields for the private directive. A cache can omit the fields specified and store the rest of the response.   buildCacheControlDirectives ()  returns string Builds the cache control directives string from the current http:ResponseCacheControl configurations.   Return Type (string)  The cache control directives string to be used in the cache-control header"},{"page":"/learn/api-docs/ballerina/http/objects/ResponseFilter.html","name":"Object - : ResponseFilter","summary":"Abstract Representation of a HTTP Response Filter.\nThis filter will be applied in the response path.\nAny ResponseFilter implementation should ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  ResponseFilter  Abstract Representation of a HTTP Response Filter. This filter will be applied in the response path. Any ResponseFilter implementation should be structurally similar to or implement the ResponseFilter object.   Methods  Response filter function.  filterResponse ( response, context)  returns boolean Response filter function. If a false is returned a 500 Internal Server Error would be sent to the client.   Parameters  response An outbound HTTP response message   context A filter context   Return Type (boolean)  True if the filter succeeds"},{"page":"/learn/api-docs/ballerina/http/records/Bucket.html","name":"Record - : Bucket","summary":"Represents a discrete sub-part of the time window (Bucket).\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Bucket  Represents a discrete sub-part of the time window (Bucket).   Fields  totalCount  int  (default 0) Total number of requests received during the sub-window time frame   failureCount  int  (default 0) Number of failed requests during the sub-window time frame   rejectedCount  int  (default 0) Number of rejected requests during the sub-window time frame   lastUpdatedTime  The time that the Bucket is last updated."},{"page":"/learn/api-docs/ballerina/http/records/CacheConfig.html","name":"Record - : CacheConfig","summary":"Provides a set of configurations for controlling the caching behaviour of the endpoint.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : CacheConfig  Provides a set of configurations for controlling the caching behaviour of the endpoint.   Fields  enabled  boolean  (default false) Specifies whether HTTP caching is enabled. Caching is disabled by default.   isShared  boolean  (default false) Specifies whether the HTTP caching layer should behave as a public cache or a private cache   capacity  int  (default 8388608) The capacity of the cache   evictionFactor  float  (default 0.2) The fraction of entries to be removed when the cache is full. The value should be between 0 (exclusive) and 1 (inclusive).   policy  (default CACHE_CONTROL_AND_VALIDATORS) Gives the user some control over the caching behaviour. By default, this is set to CACHE_CONTROL_AND_VALIDATORS. The default behaviour is to allow caching only when the cache-control header and either the etag or last-modified header are present."},{"page":"/learn/api-docs/ballerina/http/records/CircuitBreakerConfig.html","name":"Record - : CircuitBreakerConfig","summary":"Provides a set of configurations for controlling the behaviour of the Circuit Breaker.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : CircuitBreakerConfig  Provides a set of configurations for controlling the behaviour of the Circuit Breaker.   Fields  rollingWindow  (default {}) The http:RollingWindow options of the CircuitBreaker   failureThreshold  float  (default 0.0) The threshold for request failures. When this threshold exceeds, the circuit trips The threshold should be a value between 0 and 1   resetTimeInMillis  int  (default 0) The time period(in milliseconds) to wait before attempting to make another request to the upstream service   statusCodes  int[]  (default []) Array of HTTP response status codes which are considered as failures"},{"page":"/learn/api-docs/ballerina/http/records/CircuitHealth.html","name":"Record - : CircuitHealth","summary":"Maintains the health of the Circuit Breaker.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : CircuitHealth  Maintains the health of the Circuit Breaker.   Fields  lastRequestSuccess  boolean  (default false) Whether last request is success or not   totalRequestCount  int  (default 0) Total request count received within the RollingWindow   lastUsedBucketId  int  (default 0) ID of the last bucket used in Circuit Breaker calculations   startTime  (default time:currentTime()) Circuit Breaker start time   lastRequestTime  The time that the last request received   lastErrorTime  The time that the last error occurred   lastForcedOpenTime  The time that circuit forcefully opened at last   totalBuckets  ?[]  (default []) The discrete time buckets into which the time window is divided"},{"page":"/learn/api-docs/ballerina/http/records/CircuitBreakerInferredConfig.html","name":"Record - : CircuitBreakerInferredConfig","summary":"Derived set of configurations from the CircuitBreakerConfig.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : CircuitBreakerInferredConfig  Derived set of configurations from the CircuitBreakerConfig.   Fields  failureThreshold  float  (default 0.0) The threshold for request failures. When this threshold exceeds, the circuit trips. The threshold should be a value between 0 and 1   resetTimeInMillis  int  (default 0) The time period(in milliseconds) to wait before attempting to make another request to the upstream service   statusCodes  boolean[]  (default []) Array of HTTP response status codes which are considered as failures   noOfBuckets  int  (default 0) Number of buckets derived from the RollingWindow   rollingWindow  (default {}) The http:RollingWindow options provided in the http:CircuitBreakerConfig"},{"page":"/learn/api-docs/ballerina/http/records/ClientConfiguration.html","name":"Record - : ClientConfiguration","summary":"Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint.\nFollowing fields are ...","content":"Records  v1.2.2  All Modules  Record - : ClientConfiguration  Provides a set of configurations for controlling the behaviours when communicating with a remote HTTP endpoint. Following fields are inherited from the other configuration records in addition to the Client specific configs.      httpVersion - Copied from CommonClientConfiguration http1Settings - Copied from CommonClientConfiguration http2Settings - Copied from CommonClientConfiguration timeoutInMillis - Copied from CommonClientConfiguration forwarded - Copied from CommonClientConfiguration followRedirects - Copied from CommonClientConfiguration poolConfig - Copied from CommonClientConfiguration cache - Copied from CommonClientConfiguration compression - Copied from CommonClientConfiguration auth - Copied from CommonClientConfiguration circuitBreaker - Copied from CommonClientConfiguration retryConfig - Copied from CommonClientConfiguration cookieConfig - Copied from CommonClientConfiguration     Fields  secureSocket  ?  (default ()) SSL/TLS related options"},{"page":"/learn/api-docs/ballerina/http/records/ClientHttp1Settings.html","name":"Record - : ClientHttp1Settings","summary":"Provides settings related to HTTP/1.x protocol.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : ClientHttp1Settings  Provides settings related to HTTP/1.x protocol.   Fields  keepAlive  (default KEEPALIVE_AUTO) Specifies whether to reuse a connection for multiple requests   chunking  (default CHUNKING_AUTO) The chunking behaviour of the request   proxy  ?  (default ()) Proxy server related options"},{"page":"/learn/api-docs/ballerina/http/records/ClientSecureSocket.html","name":"Record - : ClientSecureSocket","summary":"Provides configurations for facilitating secure communication with a remote HTTP endpoint.\n\n        ...","content":"Records  v1.2.2  All Modules  Record - : ClientSecureSocket  Provides configurations for facilitating secure communication with a remote HTTP endpoint.   Fields  disable  boolean  (default false) Disable ssl validation.   trustStore  ?  (default ()) Configurations associated with TrustStore   keyStore  ?  (default ()) Configurations associated with KeyStore   certFile  string  A file containing the certificate of the client   keyFile  string  A file containing the private key of the client   keyPassword  string  Password of the private key if it is encrypted   trustedCertFile  string  A file containing a list of certificates or a single certificate that the client trusts   protocol  ?  (default ()) SSL/TLS protocol related options   certValidation  ?  (default ()) Certificate validation against CRL or OCSP related options   ciphers  string[]  (default []) List of ciphers to be used eg: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA   verifyHostname  boolean  (default true) Enable/disable host name verification   shareSession  boolean  (default true) Enable/disable new SSL session creation   ocspStapling  boolean  (default false) Enable/disable OCSP stapling   handshakeTimeoutInSeconds  int  SSL handshake time out   sessionTimeoutInSeconds  int  SSL session time out"},{"page":"/learn/api-docs/ballerina/http/records/ClientHttp2Settings.html","name":"Record - : ClientHttp2Settings","summary":"Provides settings related to HTTP/2 protocol.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : ClientHttp2Settings  Provides settings related to HTTP/2 protocol.   Fields  http2PriorKnowledge  boolean  (default false) Configuration to enable HTTP/2 prior knowledge"},{"page":"/learn/api-docs/ballerina/http/records/CommonClientConfiguration.html","name":"Record - : CommonClientConfiguration","summary":"Common client configurations for the next level clients.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : CommonClientConfiguration  Common client configurations for the next level clients.   Fields  httpVersion  string  (default HTTP_1_1) The HTTP version understood by the client   http1Settings  (default {}) Configurations related to HTTP/1.x protocol   http2Settings  (default {}) Configurations related to HTTP/2 protocol   timeoutInMillis  int  (default 60000) The maximum time to wait (in milliseconds) for a response before closing the connection   forwarded  string  (default disable) The choice of setting forwarded/x-forwarded header   followRedirects  ?  (default ()) Configurations associated with Redirection   poolConfig  ?  (default ()) Configurations associated with request pooling   cache  (default {}) HTTP caching related configurations   compression  (default COMPRESSION_AUTO) Specifies the way of handling compression (accept-encoding) header   auth  ?  (default ()) HTTP authentication-related configurations   circuitBreaker  ?  (default ()) Configurations associated with the behaviour of the Circuit Breaker   retryConfig  ?  (default ()) Configurations associated with retrying   cookieConfig  ?  (default ()) Configurations associated with cookies"},{"page":"/learn/api-docs/ballerina/http/records/CookieConfig.html","name":"Record - : CookieConfig","summary":"Client configuration for cookies.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : CookieConfig  Client configuration for cookies.   Fields  enabled  boolean  (default false) User agents provide users with a mechanism for disabling or enabling cookies   maxCookiesPerDomain  int  (default 50) Maximum number of cookies per domain, which is 50   maxTotalCookieCount  int  (default 3000) Maximum number of total cookies allowed to be stored in cookie store, which is 3000   blockThirdPartyCookies  boolean  (default true) User can block cookies from third party responses and refuse to send cookies for third party requests, if needed   persistentCookieHandler  To manage persistent cookies, users are provided with a mechanism for specifying a persistent cookie store with their own mechanism which references the persistent cookie handler or specifying the CSV persistent cookie handler. If not specified any, only the session cookies are used"},{"page":"/learn/api-docs/ballerina/http/records/CompressionConfig.html","name":"Record - : CompressionConfig","summary":"A record for providing configurations for content compression.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : CompressionConfig  A record for providing configurations for content compression.   Fields  enable  (default COMPRESSION_AUTO) The status of compression   contentTypes  string[]  (default []) Content types which are allowed for compression"},{"page":"/learn/api-docs/ballerina/http/records/CorsConfig.html","name":"Record - : CorsConfig","summary":"Configurations for CORS support.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : CorsConfig  Configurations for CORS support.   Fields  allowHeaders  string[]  (default []) The array of allowed headers by the service   allowMethods  string[]  (default []) The array of allowed methods by the service   allowOrigins  string[]  (default []) The array of origins with which the response is shared by the service   exposeHeaders  string[]  (default []) The whitelisted headers which clients are allowed to access   allowCredentials  boolean  (default false) Specifies whether credentials are required to access the service   maxAge  int  (default -1) The maximum duration to cache the preflight from client side"},{"page":"/learn/api-docs/ballerina/http/records/Detail.html","name":"Record - : Detail","summary":"Holds the details of an HTTP error\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Holds the details of an HTTP error   Fields  message  string  Specific error message for the error   cause  error  Cause of the error; If this error occurred due to another error (Probably from another module)"},{"page":"/learn/api-docs/ballerina/http/records/FailoverConfig.html","name":"Record - : FailoverConfig","summary":"Provides a set of configurations for controlling the failover behaviour of the endpoint.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : FailoverConfig  Provides a set of configurations for controlling the failover behaviour of the endpoint.   Fields  failoverCodes  int[]  (default []) Array of HTTP response status codes for which the failover mechanism triggers   intervalInMillis  int  (default 0) Failover delay intervalInMillis in milliseconds"},{"page":"/learn/api-docs/ballerina/http/records/FailoverClientConfiguration.html","name":"Record - : FailoverClientConfiguration","summary":"Provides a set of HTTP related configurations and failover related configurations.\nFollowing fields are inherited from the other configuration ...","content":"Records  v1.2.2  All Modules  Record - : FailoverClientConfiguration  Provides a set of HTTP related configurations and failover related configurations. Following fields are inherited from the other configuration records in addition to the failover client specific configs.      httpVersion - Copied from CommonClientConfiguration http1Settings - Copied from CommonClientConfiguration http2Settings - Copied from CommonClientConfiguration timeoutInMillis - Copied from CommonClientConfiguration forwarded - Copied from CommonClientConfiguration followRedirects - Copied from CommonClientConfiguration poolConfig - Copied from CommonClientConfiguration cache - Copied from CommonClientConfiguration compression - Copied from CommonClientConfiguration auth - Copied from CommonClientConfiguration circuitBreaker - Copied from CommonClientConfiguration retryConfig - Copied from CommonClientConfiguration cookieConfig - Copied from CommonClientConfiguration     Fields  targets  []  (default []) The upstream HTTP endpoints among which the incoming HTTP traffic load should be sent on failover   failoverCodes  int[]  (default [501, 502, 503, 504]) Array of HTTP response status codes for which the failover behaviour should be triggered   intervalInMillis  int  (default 0) Failover delay interval in milliseconds"},{"page":"/learn/api-docs/ballerina/http/records/FailoverInferredConfig.html","name":"Record - : FailoverInferredConfig","summary":"Represents the inferred failover configurations passed into the failover client.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : FailoverInferredConfig  Represents the inferred failover configurations passed into the failover client.   Fields  failoverClientsArray  ?[]  (default []) Array of HTTP Clients that needs to be Failover   failoverCodesIndex  boolean[]  (default []) An indexed array of HTTP response status codes for which the failover mechanism triggers   failoverInterval  int  (default 0) Failover delay interval in milliseconds"},{"page":"/learn/api-docs/ballerina/http/records/FollowRedirects.html","name":"Record - : FollowRedirects","summary":"Provides configurations for controlling the endpoint's behaviour in response to HTTP redirect related responses.\n\n     ...","content":"Records  v1.2.2  All Modules  Record - : FollowRedirects  Provides configurations for controlling the endpoint's behaviour in response to HTTP redirect related responses.   Fields  enabled  boolean  (default false) Enable/disable redirection   maxCount  int  (default 5) Maximum number of redirects to follow"},{"page":"/learn/api-docs/ballerina/http/records/HttpTimeoutError.html","name":"Record - : HttpTimeoutError","summary":"Defines a timeout error occurred during service invocation.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : HttpTimeoutError  Defines a timeout error occurred during service invocation.   Fields  message  string  An explanation on what went wrong   cause  error?  (default ()) The error which caused the HttpTimeoutError   statusCode  int  (default 0) HTTP status code"},{"page":"/learn/api-docs/ballerina/http/records/HttpResourceConfig.html","name":"Record - : HttpResourceConfig","summary":"Configuration for an HTTP resource.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : HttpResourceConfig  Configuration for an HTTP resource.   Fields  methods  string[]  (default []) The array of allowed HTTP methods   path  string  The path of resource   body  string  Inbound request entity body name which declared in signature   consumes  string[]  (default []) The media types which are accepted by resource   produces  string[]  (default []) The media types which are produced by resource   cors  (default {}) The cross origin resource sharing configurations for the resource. If not set, the resource will inherit the CORS behaviour of the enclosing service.   transactionInfectable  boolean  (default true) Allow to participate in the distributed transactions if value is true   webSocketUpgrade  ?  (default ()) Annotation to define HTTP to WebSocket upgrade   auth  Authentication Configs to secure the resource"},{"page":"/learn/api-docs/ballerina/http/records/HttpServiceConfig.html","name":"Record - : HttpServiceConfig","summary":"Contains the configurations for an HTTP service.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : HttpServiceConfig  Contains the configurations for an HTTP service.   Fields  host  string  (default b7a.default) Domain name of the service   basePath  string  Service base path   compression  (default {}) The status of compression   chunking  (default CHUNKING_AUTO) Configures the chunking behaviour for the service   cors  (default {}) The cross origin resource sharing configurations for the service   versioning  (default {}) The version of the service to be used   auth  Authentication configurations for secure the service"},{"page":"/learn/api-docs/ballerina/http/records/ListenerAuth.html","name":"Record - : ListenerAuth","summary":"Authentication configurations for the listener.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : ListenerAuth  Authentication configurations for the listener.   Fields  authHandlers  An array of inbound authentication handlers or an array consisting of arrays of inbound authentication handlers An array is used to indicate that at least one of the authentication handlers should be successfully authenticated. An array consisting of arrays is used to indicate that at least one authentication handler from the sub-arrays should be successfully authenticated.   scopes  An array of scopes or an array consisting of arrays of scopes. An array is used to indicate that at least one of the scopes should be successfully authorized. An array consisting of arrays is used to indicate that at least one scope from the sub-arrays should successfully be authorized   positiveAuthzCache  ?  (default ) The cache:Cache object for positive authorizations   negativeAuthzCache  ?  (default ) The cache:Cache object for negative authorizations   mandateSecureSocket  boolean  (default true) Specify whether secure socket configurations are mandatory or not   position  int  (default 0) The authn/authz filter position of the filter array. The position values starts from 0 and it is set to 0 implicitly   enableAuthzFilter  boolean  (default true) Specify whether authz filter engagement is needed or not"},{"page":"/learn/api-docs/ballerina/http/records/ListenerOcspStapling.html","name":"Record - : ListenerOcspStapling","summary":"A record for providing configurations for certificate revocation status checks.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : ListenerOcspStapling  A record for providing configurations for certificate revocation status checks.   Fields  enable  boolean  (default false) The status of OCSP stapling   cacheSize  int  (default 0) Maximum size of the cache   cacheValidityPeriod  int  (default 0) The time period for which a cache entry is valid"},{"page":"/learn/api-docs/ballerina/http/records/ListenerHttp1Settings.html","name":"Record - : ListenerHttp1Settings","summary":"Provides settings related to HTTP/1.x protocol.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : ListenerHttp1Settings  Provides settings related to HTTP/1.x protocol.   Fields  keepAlive  (default KEEPALIVE_AUTO) Can be set to either KEEPALIVE_AUTO, which respects the connection header, or KEEPALIVE_ALWAYS, which always keeps the connection alive, or KEEPALIVE_NEVER, which always closes the connection   maxPipelinedRequests  int  (default MAX_PIPELINED_REQUESTS) Defines the maximum number of requests that can be processed at a given time on a single connection. By default 10 requests can be pipelined on a single cinnection and user can change this limit appropriately.   maxUriLength  int  (default 4096) Maximum allowed length for a URI. Exceeding this limit will result in a 414 - URI Too Long response.   maxHeaderSize  int  (default 8192) Maximum allowed size for headers. Exceeding this limit will result in a 413 - Payload Too Large response.   maxEntityBodySize  int  (default -1) Maximum allowed size for the entity body. By default it is set to -1 which means there is no restriction maxEntityBodySize, On the Exceeding this limit will result in a 413 - Payload Too Large response."},{"page":"/learn/api-docs/ballerina/http/records/ListenerConfiguration.html","name":"Record - : ListenerConfiguration","summary":"Provides a set of configurations for HTTP service endpoints.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : ListenerConfiguration  Provides a set of configurations for HTTP service endpoints.   Fields  host  string  (default 0.0.0.0) The host name/IP of the endpoint   http1Settings  (default {}) Configurations related to HTTP/1.x protocol   secureSocket  ?  (default ()) The SSL configurations for the service endpoint. This needs to be configured in order to communicate through HTTPS.   httpVersion  string  (default 1.1) Highest HTTP version supported by the endpoint   filters  | []  (default []) If any pre-processing needs to be done to the request before dispatching the request to the resource, filters can applied   timeoutInMillis  int  (default DEFAULT_LISTENER_TIMEOUT) Period of time in milliseconds that a connection waits for a read/write operation. Use value 0 to disable timeout   auth  Listener authenticaton configurations   server  string?  (default ()) The server name which should appear as a response header   webSocketCompressionEnabled  boolean  (default true) Enable support for compression in WebSocket"},{"page":"/learn/api-docs/ballerina/http/records/ListenerSecureSocket.html","name":"Record - : ListenerSecureSocket","summary":"Configures the SSL/TLS options to be used for HTTP service.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : ListenerSecureSocket  Configures the SSL/TLS options to be used for HTTP service.   Fields  trustStore  ?  (default ()) Configures the trust store to be used   keyStore  ?  (default ()) Configures the key store to be used   certFile  string  A file containing the certificate of the server   keyFile  string  A file containing the private key of the server   keyPassword  string  Password of the private key if it is encrypted   trustedCertFile  string  A file containing a list of certificates or a single certificate that the server trusts   protocol  ?  (default ()) SSL/TLS protocol related options   certValidation  ?  (default ()) Certificate validation against CRL or OCSP related options   ciphers  string[]  (default [TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256]) List of ciphers to be used (e.g.: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA)   sslVerifyClient  string  The type of client certificate verification. (e.g.: \"require\" or \"optional\")   shareSession  boolean  (default true) Enable/disable new SSL session creation   handshakeTimeoutInSeconds  int?  (default ()) SSL handshake time out   sessionTimeoutInSeconds  int?  (default ()) SSL session time out   ocspStapling  ?  (default ()) Enable/disable OCSP stapling"},{"page":"/learn/api-docs/ballerina/http/records/LoadBalanceClientConfiguration.html","name":"Record - : LoadBalanceClientConfiguration","summary":"The configurations related to the load balance client endpoint. Following fields are inherited from the other\nconfiguration records in ...","content":"Records  v1.2.2  All Modules  Record - : LoadBalanceClientConfiguration  The configurations related to the load balance client endpoint. Following fields are inherited from the other configuration records in addition to the load balance client specific configs.      httpVersion - Copied from CommonClientConfiguration http1Settings - Copied from CommonClientConfiguration http2Settings - Copied from CommonClientConfiguration timeoutInMillis - Copied from CommonClientConfiguration forwarded - Copied from CommonClientConfiguration followRedirects - Copied from CommonClientConfiguration poolConfig - Copied from CommonClientConfiguration cache - Copied from CommonClientConfiguration compression - Copied from CommonClientConfiguration auth - Copied from CommonClientConfiguration circuitBreaker - Copied from CommonClientConfiguration retryConfig - Copied from CommonClientConfiguration cookieConfig - Copied from CommonClientConfiguration     Fields  targets  []  (default []) The upstream HTTP endpoints among which the incoming HTTP traffic load should be distributed   lbRule  ?  (default ) LoadBalancing rule   failover  boolean  (default true) Configuration for load balancer whether to fail over in case of a failure"},{"page":"/learn/api-docs/ballerina/http/records/LoadBalanceActionErrorData.html","name":"Record - : LoadBalanceActionErrorData","summary":"Represents an error occurred in an remote function of the Load Balance connector.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : LoadBalanceActionErrorData  Represents an error occurred in an remote function of the Load Balance connector.   Fields  httpActionErr  error?[]  (default []) Array of errors occurred at each endpoint   message  string  An explanation of the error   cause  error  The original error which resulted in a LoadBalanceActionError"},{"page":"/learn/api-docs/ballerina/http/records/Local.html","name":"Record - : Local","summary":"Presents a read-only view of the local address.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : Local  Presents a read-only view of the local address.   Fields  host  string  The local host name/IP   port  int  (default 0) The local port"},{"page":"/learn/api-docs/ballerina/http/records/MutualSslHandshake.html","name":"Record - : MutualSslHandshake","summary":"A record for providing mutual SSL handshake results.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : MutualSslHandshake  A record for providing mutual SSL handshake results.   Fields  status  (default ()) Status of the handshake.   base64EncodedCert  string?  (default ()) Base64 encoded certificate."},{"page":"/learn/api-docs/ballerina/http/records/OutboundAuthConfig.html","name":"Record - : OutboundAuthConfig","summary":"The OutboundAuthConfig record can be used to configure the authentication mechanism used by the HTTP endpoint.\n\n   ...","content":"Records  v1.2.2  All Modules  Record - : OutboundAuthConfig  The OutboundAuthConfig record can be used to configure the authentication mechanism used by the HTTP endpoint.   Fields  authHandler  The outbound authentication handler"},{"page":"/learn/api-docs/ballerina/http/records/PoolConfiguration.html","name":"Record - : PoolConfiguration","summary":"Configurations for managing HTTP client connection pool.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : PoolConfiguration  Configurations for managing HTTP client connection pool.   Fields  maxActiveConnections  int  (default config:getAsInt(b7a.http.pool.maxActiveConnections, -1)) Max active connections per route(host:port). Default value is -1 which indicates unlimited.   maxIdleConnections  int  (default config:getAsInt(b7a.http.pool.maxIdleConnections, 100)) Maximum number of idle connections allowed per pool.   waitTimeInMillis  int  (default config:getAsInt(b7a.http.pool.waitTimeInMillis, 30000)) Maximum amount of time, the client should wait for an idle connection before it sends an error when the pool is exhausted   maxActiveStreamsPerConnection  int  (default config:getAsInt(b7a.http.pool.maxActiveStreamsPerConnection, 50)) Maximum active streams per connection. This only applies to HTTP/2."},{"page":"/learn/api-docs/ballerina/http/records/ProxyConfig.html","name":"Record - : ProxyConfig","summary":"Proxy server configurations to be used with the HTTP client endpoint.\n\n        ...","content":"Records  v1.2.2  All Modules  Record - : ProxyConfig  Proxy server configurations to be used with the HTTP client endpoint.   Fields  host  string  Host name of the proxy server   port  int  (default 0) Proxy server port   userName  string  Proxy server username   password  string  proxy server password"},{"page":"/learn/api-docs/ballerina/http/records/Protocols.html","name":"Record - : Protocols","summary":"A record for configuring SSL/TLS protocol and version to be used.\n\n        ...","content":"Records  v1.2.2  All Modules  Record - : Protocols  A record for configuring SSL/TLS protocol and version to be used.   Fields  name  string  SSL Protocol to be used (e.g.: TLS1.2)   versions  string[]  (default []) SSL/TLS protocols to be enabled (e.g.: TLSv1,TLSv1.1,TLSv1.2)"},{"page":"/learn/api-docs/ballerina/http/records/Remote.html","name":"Record - : Remote","summary":"Presents a read-only view of the remote address.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : Remote  Presents a read-only view of the remote address.   Fields  host  string  The remote host IP   port  int  (default 0) The remote port"},{"page":"/learn/api-docs/ballerina/http/records/ResourceAuth.html","name":"Record - : ResourceAuth","summary":"Configures the authentication scheme for a resource.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : ResourceAuth  Configures the authentication scheme for a resource.   Fields  enabled  boolean  Specifies whether authentication is enabled   authHandlers  An array of inbound authentication handlers or an array consisting of arrays of inbound authentication handlers. An array is used to indicate that at least one of the authentication handlers should be successfully authenticated. An array consisting of arrays is used to indicate that at least one authentication handler from the sub-arrays should be successfully authenticated.   scopes  An array of scopes or an array consisting of arrays of scopes. An array is used to indicate that at least one of the scopes should be successfully authorized. An array consisting of arrays is used to indicate that at least one scope from the sub-arrays should be successfully authorized."},{"page":"/learn/api-docs/ballerina/http/records/RetryInferredConfig.html","name":"Record - : RetryInferredConfig","summary":"Derived set of configurations from the RetryConfig.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : RetryInferredConfig  Derived set of configurations from the RetryConfig.   Fields  count  int  (default 0) Number of retry attempts before giving up   intervalInMillis  int  (default 0) Retry interval in milliseconds   backOffFactor  float  (default 0.0) Multiplier of the retry interval to exponentially increase retry interval   maxWaitIntervalInMillis  int  (default 0) Maximum time of the retry interval in milliseconds   statusCodes  boolean[]  (default []) HTTP response status codes which are considered as failures"},{"page":"/learn/api-docs/ballerina/http/records/RollingWindow.html","name":"Record - : RollingWindow","summary":"Represents a rolling window in the Circuit Breaker.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : RollingWindow  Represents a rolling window in the Circuit Breaker.   Fields  requestVolumeThreshold  int  (default 10) Minimum number of requests in a RollingWindow that will trip the circuit.   timeWindowInMillis  int  (default 60000) Time period in milliseconds for which the failure threshold is calculated   bucketSizeInMillis  int  (default 10000) The granularity at which the time window slides. This is measured in milliseconds."},{"page":"/learn/api-docs/ballerina/http/records/RetryConfig.html","name":"Record - : RetryConfig","summary":"Provides configurations for controlling the retrying behavior in failure scenarios.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : RetryConfig  Provides configurations for controlling the retrying behavior in failure scenarios.   Fields  count  int  (default 0) Number of retry attempts before giving up   intervalInMillis  int  (default 0) Retry interval in milliseconds   backOffFactor  float  (default 0.0) Multiplier, which increases the retry interval exponentially.   maxWaitIntervalInMillis  int  (default 0) Maximum time of the retry interval in milliseconds   statusCodes  int[]  (default []) HTTP response status codes which are considered as failures"},{"page":"/learn/api-docs/ballerina/http/records/ServiceAuth.html","name":"Record - : ServiceAuth","summary":"Configures the authentication scheme for a service.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : ServiceAuth  Configures the authentication scheme for a service.   Fields  enabled  boolean  (default true) Specifies whether authentication is enabled   authHandlers  An array of inbound authentication handlers or an array consisting of arrays of inbound authentication handlers. An array is used to indicate that at least one of the authentication handlers should be successfully authenticated. An array consisting of arrays is used to indicate that at least one authentication handler from the sub-arrays should be successfully authenticated.   scopes  An array of scopes or an array consisting of arrays of scopes. An array is used to indicate that at least one of the scopes should be successfully authorized. An array consisting of arrays is used to indicate that at least one scope from the sub-arrays should be successfully authorized."},{"page":"/learn/api-docs/ballerina/http/records/ValidateCert.html","name":"Record - : ValidateCert","summary":"A record for providing configurations for certificate revocation status checks.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : ValidateCert  A record for providing configurations for certificate revocation status checks.   Fields  enable  boolean  (default false) The status of validateCertEnabled   cacheSize  int  (default 0) Maximum size of the cache   cacheValidityPeriod  int  (default 0) The time period for which a cache entry is valid"},{"page":"/learn/api-docs/ballerina/http/records/TargetService.html","name":"Record - : TargetService","summary":"Represents a single service and its related configurations.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : TargetService  Represents a single service and its related configurations.   Fields  url  string  URL of the target service   secureSocket  ?  (default ()) Configurations for secure communication with the remote HTTP endpoint"},{"page":"/learn/api-docs/ballerina/http/records/Versioning.html","name":"Record - : Versioning","summary":"Configurations for service versioning.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : Versioning  Configurations for service versioning.   Fields  pattern  string  (default v{major}.{minor}) Expected version pattern in the request URL   allowNoVersion  boolean  (default false) Allow requests with missing version path segment in the URL to be dispatched   matchMajorVersion  boolean  (default false) Allow requests with only the major version specified in the URL to be dispatched"},{"page":"/learn/api-docs/ballerina/http/records/WSServiceConfig.html","name":"Record - : WSServiceConfig","summary":"Configurations for a WebSocket service.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : WSServiceConfig  Configurations for a WebSocket service.   Fields  path  string  Path of the WebSocket service   subProtocols  string[]  (default []) Negotiable sub protocol by the service   idleTimeoutInSeconds  int  (default 0) Idle timeout for the client connection. Upon timeout, onIdleTimeout resource (if defined) in the server service will be triggered. Note that this overrides the timeoutInMillis config in the http:Listener.   maxFrameSize  int  (default 0) The maximum payload size of a WebSocket frame in bytes. If this is not set or is negative or zero, the default frame size will be used."},{"page":"/learn/api-docs/ballerina/http/records/WebSocketFailoverClientConfiguration.html","name":"Record - : WebSocketFailoverClientConfiguration","summary":"Configurations for the WebSocket client endpoint.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : WebSocketFailoverClientConfiguration  Configurations for the WebSocket client endpoint.   Fields  callbackService  service?  (default ()) The callback service of the client. Resources in this service gets called on the receipt of messages from the server   subProtocols  string[]  (default []) Negotiable sub protocols of the client   customHeaders  map  (default {}) Custom headers, which should be sent to the server   idleTimeoutInSeconds  int  (default -1) Idle timeout of the client. Upon timeout, the onIdleTimeout resource (if defined) of the client service will be triggered   readyOnConnect  boolean  (default true) Set to true if the client is ready to receive messages as soon as the connection is established This is set to true by default. If changed to false, the ready() function of the WebSocketFailoverClient needs to be called once to start receiving messages   secureSocket  ?  (default ()) SSL/TLS-related options   maxFrameSize  int  (default 0) The maximum payload size of a WebSocket frame in bytes If this is not set, is negative, or is zero, the default frame size of 65536 will be used.   targetUrls  string[]  (default []) The set of URLs, which are used to connect to the server   failoverIntervalInMillis  int  (default 1000) The maximum number of milliseconds to delay a failover attempt   webSocketCompressionEnabled  boolean  (default true) Enable support for compression in the WebSocket   handShakeTimeoutInSeconds  int  (default 300) Time (in seconds) that a connection waits to get the response of the webSocket handshake. If the timeout exceeds, then the connection is terminated with an error. If the value < 0, then the value sets to the default value(300)"},{"page":"/learn/api-docs/ballerina/http/records/WebSocketClientConfiguration.html","name":"Record - : WebSocketClientConfiguration","summary":"Configurations for the WebSocket client endpoint.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : WebSocketClientConfiguration  Configurations for the WebSocket client endpoint.   Fields  callbackService  service?  (default ()) The callback service of the client. Resources in this service gets called on the receipt of messages from the server   subProtocols  string[]  (default []) Negotiable sub protocols of the client   customHeaders  map  (default {}) Custom headers, which should be sent to the server   idleTimeoutInSeconds  int  (default -1) Idle timeout of the client. Upon timeout, the onIdleTimeout resource (if defined) of the client service will be triggered   readyOnConnect  boolean  (default true) Set to true if the client is ready to receive messages as soon as the connection is established. This is set to true by default. If changed to false, the ready() function of the WebSocketClient needs to be called once to start receiving messages   secureSocket  ?  (default ()) SSL/TLS-related options   maxFrameSize  int  (default 0) The maximum payload size of a WebSocket frame in bytes If this is not set, is negative, or is zero, the default frame size of 65536 will be used.   webSocketCompressionEnabled  boolean  (default true) Enable support for compression in the WebSocket   handShakeTimeoutInSeconds  int  (default 300) Time (in seconds) that a connection waits to get the response of the webSocket handshake. If the timeout exceeds, then the connection is terminated with an error.If the value < 0, then the value sets to the default value(300).   retryConfig  Retry related configurations"},{"page":"/learn/api-docs/ballerina/http/records/WebSocketRetryConfig.html","name":"Record - : WebSocketRetryConfig","summary":"Retry configurations for WebSocket.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : WebSocketRetryConfig  Retry configurations for WebSocket.   Fields  maxCount  int  (default 0) The maximum number of retry attempts. If the count is zero, the client will retry indefinitely   intervalInMillis  int  (default 1000) The number of milliseconds to delay before attempting to reconnect   backOffFactor  float  (default 1.0) The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist   maxWaitIntervalInMillis  int  (default 30000) Maximum time of the retry interval in milliseconds"},{"page":"/learn/api-docs/ballerina/http/records/WebSocketUpgradeConfig.html","name":"Record - : WebSocketUpgradeConfig","summary":"Resource configuration to upgrade from HTTP to WebSocket.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : WebSocketUpgradeConfig  Resource configuration to upgrade from HTTP to WebSocket.   Fields  upgradePath  string  Path which is used to upgrade from HTTP to WebSocket   upgradeService  service  Callback service for a successful upgrade"},{"page":"/learn/api-docs/ballerina/","name":"Modules","summary":"This module provides the default authentication provider configurations, which can be extended to create new authentication providers.This module provides APIs for handle caching in Ballerina. It consists of a default implementation based on the map data structure. It also provides a default cache eviction policy object, which is based on ...","content":"Modules  This module provides the default authentication provider configurations, which can be extended to create new authentication providers.   This module provides APIs for handle caching in Ballerina. It consists of a default implementation based on the map data structure. It also provides a default cache eviction policy object, which is based on the LRU eviction algorithm.   This module provides the Config API to read configurations from environment variables, TOML files, and command-line parameters and build a consolidated set of configurations.   This module provides the necessary utilities that are required to hash content using different hashing mechanisms and algorithms.   This module contains functions to perform email operations such as sending and reading emails using the SMTP, POP3, and IMAP4 protocols.   This module provides the necessary utilities, which are required to encode and decode content using different URL encoding mechanisms and algorithms.   This module contains functions to perform file system based operations such as create, delete, rename the file/directory, and retrieve metadata of the file.   This module provides a platform-independent API for working with file paths.   This module provides support for the gRPC messaging protocol. gRPC is an inter-process communication technology that allows you to connect, invoke and operate distributed heterogeneous applications as easily as making a local function call. The gRPC protocol is layered over HTTP/2 and It uses Protocol Buffers for marshaling/unmarshaling messages. This makes gRPC, highly efficient on wire and a simple service definition framework.   This module provides an implementation for connecting and interacting with HTTP, HTTP2, and WebSocket endpoints. The module facilitates two types of network entry points as ‘Client’ and ‘Listener’.   This module is designed to support input and output operations via channels in a canonical way, either in a blocking, or non-blocking manner.   This module provides the API for Java interoperability in Ballerina. It includes a set of Ballerina annotations with which Java constructors, methods, and fields can provide implementations of Ballerina functions with external function bodies.   This module provides APIs to create new Java array instances, get elements from arrays, set elements, etc.   This module provides the functionality required to access and manipulate data stored in any type of relational database that is accessible via Java Database Connectivity (JDBC).   This module provides utility functions to manipulate the built-in json data type. It provides APIs to convert an xml to a json or convert a table to a json.   This module provides an inbound and outbound JWT authentication provider, which can be used to authenticate using a JWT and the functionality related to issuing and validating JWT.   This module is used to interact with Kafka Brokers via Kafka Consumer and Kafka Producer clients. This module supports Kafka 1.x.x and 2.0.0 versions.   This module provides lang library list operations defined by the language specification 2020R1.   This module provides lang library operations on boolean values defined by the language specification 2020R1.   This module provides lang library operations on decimal values defined by the language specification 2020R1.   This module provides lang library operations on error values defined by the language specification 2020R1.   This module provides lang library operations on float values defined by the language specification 2020R1.   This module provides lang library operations on future values defined by the language specification 2020R1.   This module provides lang library operations on int values defined by the language specification 2020R1.   This module provides lang library map operations defined by the language specification 2020R1.   This module defines the shape expected from all listeners as defined by the language specification 2020R1.   This module provides lang library operations on stream values defined by the language specification 2020R1.   This module provides lang library string operations defined by the language specification 2020R1.   This module provides lang library operations on table values defined by the language specification 2020R1.   This module provides lang library operations on typedesc values defined by the language specification 2020R1.   This module provides lang library operations common to all values defined by the language specification 2020R1.   This module provides lang library operations on xml values defined by the language specification 2020R1.   This module provides an inbound LDAP authentication provider, which is used to authenticate using LDAP credentials.   This module provides a basic API for logging.   This module provides functions to perform fixed-precision integer arithmetic and fixed-precision decimal arithmetic. It includes functions to get the absolute, cosine, sine, root, tangent, and more for a given value.   This module provides functions to encapsulate multiple body parts such as attachments into a single message. The communication of such messages follow the MIME (Multipurpose Internet Mail Extensions) specification as specified in the .   This module provides the capability to connect with NATS and NATS Streaming servers and performs the below functionalities.   This module provides an inbound OAuth2 authentication provider, which can be used to authenticate the provided credentials against an introspection endpoint and an outbound OAuth2 authentication provider, which can be used to authenticate an external endpoint.   This module provides apis for observing Ballerina services. Ballerina supports Observability out of the box. This module provides user api's to make Ballerina Observability more flexible for the user.   This module provides the following code generation capabilities.   is one of the most popular open-source enterprise messaging systems modelled on the Advanced Message Queuing Protocol (AMQP) standard. This guide covers the Ballerina RabbitMQ module and its public API. This module contains the functionality to support messaging with the RabbitMQ broker (AMQP 0-9-1). It assumes that the most recent version of Ballerina is used and is built on top of the basics.   This module provides utility methods for obtaining reflective information about the Ballerina runtime.   This module provides functions to interact with the runtime, the invocation context, and to manage errors.   This module provides an implementation for sending/receiving messages to/from another application process (local or remote) for both connection-oriented and connectionless protocols.   This module provides utility functions to manipulate the built-in string data type.   This module provides functions to retrieve information about the system and the current users of the system. The system:exec method creates the system:Process object, which can control and obtain information about a Ballerina process.   This module provides the functionality to configure and manage Task Listeners and Task Schedulers. Task Listeners and Task Schedulers can be used to perform tasks periodically.   This module allow developers to write testable code.   This module provides implementations related to time, date, time zones, and durations.   This module provides Ballerina transaction manager implementation.   This module contains an implementation of the W3C recommendation, which facilitates a push-based content delivery/notification mechanism between publishers and subscribers.   This module provides utility functions to manipulate the built-in xml data type. It provides APIs to convert a json to an xml or convert a table to an xml.   This module provides a function to transform the XML content to another XML/HTML/plain text using XSL transformations."},{"page":"/learn/api-docs/ballerina/io/functions.html","name":"Functions -","summary":"(byte[] content)Creates an in-memory channel, which will be a reference stream of bytes.\nContent, which should be exposed as a channelThe ByteChannel representation to read the memory content or else an io:Error if any error occurred(string path,  fieldSeparator, string charset, int skipHeaders)Retrieves a readable CSV channel from a given file ...","content":"Functions  v1.2.2  All Modules  Functions - Creates an in-memory channel, which will be a reference stream of bytes.  Retrieves a readable CSV channel from a given file path.  Retrieves a ReadableByteChannel from a given file path.  Retrieves a writable CSV channel from a given file path.  Retrieves a WritableByteChannel from a given file path.  Prints any or error value(s) to the STDOUT.  Prints any or error value(s) to the STDOUT followed by a new line.  Retrieves the input read from the STDIN.  Returns a formatted string using the specified format string and arguments.  createReadableChannel (byte[] content)  returns | Creates an in-memory channel, which will be a reference stream of bytes.  var byteChannel = io:createReadableChannel(content);    Parameters  content byte[] Content, which should be exposed as a channel   Return Type ( | )  The ByteChannel representation to read the memory content or else an io:Error if any error occurred   openReadableCsvFile (string path, fieldSeparator, string charset, int skipHeaders)  returns | Retrieves a readable CSV channel from a given file path.  io:ReadableCSVChannel rCsvChannel = check io:openReadableCsvFile(srcFileName);    Parameters  path string File path, which describes the location of the CSV   fieldSeparator (default ,)  CSV record separator (i.e., comma or tab)   charset string (default UTF-8)  Representation of the encoding characters in the file   skipHeaders int (default 0)  Number of headers, which should be skipped   Return Type ( | )  The ReadableCSVChannel, which could be used to iterate through the CSV records or else an io:Error if any error occurred.   openReadableFile (string path)  returns | Retrieves a ReadableByteChannel from a given file path.  io:ReadableByteChannel readableFieldResult = check io:openReadableFile(\"./files/sample.txt\");    Parameters  path string Relative/absolute path string to locate the file   Return Type ( | )  The ByteChannel representation of the file resource or else an io:Error if any error occurred   openWritableCsvFile (string path, fieldSeparator, string charset, int skipHeaders)  returns | Retrieves a writable CSV channel from a given file path.  io:WritableCSVChannel wCsvChannel = check io:openWritableCsvFile(srcFileName);    Parameters  path string File path, which describes the location of the CSV   fieldSeparator (default ,)  CSV record separator (i.e., comma or tab)   charset string (default UTF-8)  Representation of the encoding characters in the file   skipHeaders int (default 0)  Number of headers, which should be skipped   Return Type ( | )  The WritableCSVChannel, which could be used to write the CSV records or else an io:Error if any error occurred   openWritableFile (string path, boolean append)  returns | Retrieves a WritableByteChannel from a given file path.  io:WritableByteChannel writableFileResult = check io:openWritableFile(\"./files/sampleResponse.txt\");    Parameters  path string Relative/absolute path string to locate the file   append boolean (default false)  Whether to append to the end of file   Return Type ( | )  The ByteChannel representation of the file resource or else an io:Error if any error occurred   print Prints any or error value(s) to the STDOUT. io:print(\"Start processing the CSV file from \", srcFileName);    Parameters  values any | error[] The value(s) to be printed.   println Prints any or error value(s) to the STDOUT followed by a new line. io:println(\"Start processing the CSV file from \", srcFileName);    Parameters  values any | error[] The value(s) to be printed.   readln (any a)  returns string Retrieves the input read from the STDIN.  string choice = io:readln(\"Enter choice 1 - 5: \");    Parameters  a any Any value to be printed   Return Type (string)  Input read from the STDIN   sprintf (string format, any | error[] args)  returns string Returns a formatted string using the specified format string and arguments. Following format specifiers are allowed. b - boolean B - boolean (ALL_CAPS) d - int f - float x - hex X - HEX (ALL_CAPS) s - string (This specifier is applicable for any of the supported types in Ballerina. These values will be converted to their string representation.)  string s8 = io:sprintf(\"%s scored %d for %s and has an average of %.2f.\", name, marks, subjects[0], average);    Parameters  format string A format string   args any | error[] Arguments referred by the format specifiers in the format string   Return Type (string)  The formatted string"},{"page":"/learn/api-docs/ballerina/io/","name":"Module : io","summary":"This module is designed to support input and output operations via channels in a canonical way, either in a blocking,\nor non-blocking manner.A channel represents an I/O source or sink of some bytes, characters, or records that are opened for reading or\nwriting respectively.The most primitive channel is the ByteChannel which reads ...","content":"v1.2.2  All Modules  Module : io  Module Overview This module is designed to support input and output operations via channels in a canonical way, either in a blocking, or non-blocking manner.  Channels A channel represents an I/O source or sink of some bytes, characters, or records that are opened for reading or writing respectively. Byte channels The most primitive channel is the ByteChannel which reads and writes 8-bit bytes. For an example on the ByteChannel, see the . Character channels The CharacterChannel is used to read and write characters. The charset encoding is specified when creating the CharacterChannel. For an example on the CharacterChannel, see the . If a ReadableCharacterChannel points to a JSON or XML source, it can be read and then written directly into a variable of the respective type. For examples on reading/writing JSON or XML sources, see the and . Record channels Also, Ballerina supports I/O for delimited records. For an example on reading the records in a text file, see the . A .CSV file can be read and written directly into a CSVChannel as shown in this . Data Channels Ballerina supports performing data i/o operations. A Person object could be serialized into a file or a network socket as seen in the .    Records Anonymous record  Anonymous record  Anonymous record  Anonymous record  Record type to hold the details of an error.  Objects ReadableByteChannel represents an input resource (i.  Represents a ReadableCSVChannel which could be used to read records from CSV file.  Represents a channel, which could be used to read characters through a given ReadableByteChannel.  Represents a data channel for reading data.  Represents a channel which will allow to read   Represents a reader which will wrap string content as a channel.  WritableByteChannel represents an output resource (i.  Represents a WritableCSVChannel, which could be used to write records from the CSV file.  Represents a channel which could be used to write characters through a given WritableCharacterChannel.  Represents a WritableDataChannel for writing data.  Represents a channel, which will allow to write records through a given WritableCharacterChannel.  Functions Creates an in-memory channel, which will be a reference stream of bytes.  Retrieves a readable CSV channel from a given file path.  Retrieves a ReadableByteChannel from a given file path.  Retrieves a writable CSV channel from a given file path.  Retrieves a WritableByteChannel from a given file path.  Prints any or error value(s) to the STDOUT.  Prints any or error value(s) to the STDOUT followed by a new line.  Retrieves the input read from the STDIN.  Returns a formatted string using the specified format string and arguments.  Constants Default value is the format specified by the CSVChannel.  Field separator will be \",\" and the record separator will be a new line.  Field separator will be a tab and the record separator will be a new line.  Comma (,) will be used as the field separator.  Tab (/t) will be use as the field separator.  Colon (:) will be use as the field separator.  This will be used to construct a ConnectionTimedOutError.  This will be used to construct an IO GenericError.  This will be used to construct a AccessDeniedError.  This will be used to construct a FileNotFoundError.  This will be used to construct an EofError.  Represents the record separator of the CSV file.  Represents the colon separator, which should be used to identify colon-separated files.  Represents the minimum number of headers, which will be included in the CSV.  Specifies the bytes to be in the order of most significant byte first.  Specifies the byte order to be the least significant byte first.  Types Represents IO module related errors.  The format, which will be used to represent the CSV.  Field separators, which are supported by the DelimitedTextRecordChannel.  Errors This will get returned due to file permission issues.  This will return when connection timed out happen when try to connect to a remote host.  This will get returned if read operations are performed on a channel after it closed.  This will get returned if the file is not available in the given file path.  Represents generic IO error."},{"page":"/learn/api-docs/ballerina/io/objects/ReadableCSVChannel.html","name":"Object - : ReadableCSVChannel","summary":"Represents a ReadableCSVChannel which could be used to read records from CSV file.\n\n      ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  ReadableCSVChannel  Represents a ReadableCSVChannel which could be used to read records from CSV file.   Constructor __init( byteChannel, fs, int nHeaders)   byteChannel The CharacterChannel, which will represent the content in the CSV file   fs ,  Field separator, which will separate between the records in the CSV file   nHeaders int 0  Number of headers, which should be skipped prior to reading records   Methods  Indicates whether there's another record, which could be read.  Gets the next record from the CSV file.  Closes a given CSVChannel.  Returns a table, which corresponds to the CSV records.  hasNext ()  returns boolean Indicates whether there's another record, which could be read.  boolean hasNext = readableCSVChannel.hasNext();    Return Type (boolean)  True if there's a record   getNext ()  returns string[] | | () Gets the next record from the CSV file.  string[]|io:Error record = readableCSVChannel.getNext();    Return Type (string[] | | ())  List of fields in the CSV or else an io:Error   close ()  returns ? Closes a given CSVChannel.  io:Error? err = readableCSVChannel.close();    Return Type (?)  io:Error if any error occurred   getTable (typedesc structType)  returns table | Returns a table, which corresponds to the CSV records.  var tblResult = readableCSVChannel.getTable(Employee);    Parameters  structType typedesc The object in which the CSV records should be deserialized   Return Type (table | )  Table, which represents the CSV records or else an io:Error"},{"page":"/learn/api-docs/ballerina/io/objects/ReadableByteChannel.html","name":"Object - : ReadableByteChannel","summary":"ReadableByteChannel represents an input resource (i.e file). which could be used to source bytes.\n\n     ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  ReadableByteChannel  ReadableByteChannel represents an input resource (i.e file). which could be used to source bytes.   Methods  Source bytes from a given input/output resource.  Encodes a given ReadableByteChannel using the Base64 encoding scheme.  Decodes a given ReadableByteChannel using the Base64 encoding scheme.  Closes a given ReadableByteChannel.  read (int nBytes)  returns byte[] | Source bytes from a given input/output resource. The number of bytes returned will be < 0 if the file reached its end. This operation will be asynchronous in which the total number of required bytes might not be returned at a given time. An io:EofError will return once the channel reaches the end.  byte[]|io:Error result = readableByteChannel.read(1000);    Parameters  nBytes int A positive integer. Represents the number of bytes, which should be read   Return Type (byte[] | )  Content (the number of bytes) read, an EofError once the channel reaches the end or else an io:Error   base64Encode ()  returns | Encodes a given ReadableByteChannel using the Base64 encoding scheme.  ReadableByteChannel|Error encodedChannel = readableByteChannel.base64Encode();    Return Type ( | )  An encoded ReadableByteChannel or else an io:Error   base64Decode ()  returns | Decodes a given ReadableByteChannel using the Base64 encoding scheme.  ReadableByteChannel|Error encodedChannel = readableByteChannel.base64Decode();    Return Type ( | )  A decoded ReadableByteChannel or else an io:Error   close ()  returns ? Closes a given ReadableByteChannel.  io:Error? err = readableByteChannel.close();    Return Type (?)  Will return () if there is no error"},{"page":"/learn/api-docs/ballerina/io/objects/StringReader.html","name":"Object - : StringReader","summary":"Represents a reader which will wrap string content as a channel.\n\n        ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  StringReader  Represents a reader which will wrap string content as a channel.   Constructor __init(string content, string encoding)   content string The content, which should be written   encoding string UTF-8  Encoding of the characters of the content   Methods  Reads string as JSON using the reader.  Reads a string as XML using the reader.  Reads the characters from the given string.  Closes the reader.  readJson ()  returns json | Reads string as JSON using the reader.  io:StringReader reader = new(\"{\\\"name\\\": \\\"Alice\\\"}\");  json|io:Error? person = reader.readJson();    Return Type (json | )  JSON or else io:Error if any error occurred   readXml ()  returns xml | | () Reads a string as XML using the reader.  io:StringReader reader = new(\"<Person><Name>Alice</Name></Person>\");  xml|io:Error? person = reader.readXml();    Return Type (xml | | ())  XML or else io:Error if any error occurred   readChar (int nCharacters)  returns string | | () Reads the characters from the given string.  io:StringReader reader = new(\"Some text\");  string|io:Error? person = reader.readChar(4);    Parameters  nCharacters int Number of characters to be read   Return Type (string | | ())  String or else io:Error if any error occurred   close ()  returns ? Closes the reader.  io:Error? err = reader.close();    Return Type (?)  An io:Error if could not close the channel or else ()."},{"page":"/learn/api-docs/ballerina/io/objects/ReadableCharacterChannel.html","name":"Object - : ReadableCharacterChannel","summary":"Represents a channel, which could be used to read characters through a given ReadableByteChannel.\n\n     ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  ReadableCharacterChannel  Represents a channel, which could be used to read characters through a given ReadableByteChannel.   Constructor __init( byteChannel, string charset)   byteChannel The ReadableByteChannel, which would be used to read the characters   charset string The character set, which would be used to encode/decode the given bytes to characters   Methods  Reads a given number of characters.  Reads a JSON from the given channel.  Reads an XML from the given channel.  Closes a given character channel.  read (int numberOfChars)  returns string | Reads a given number of characters. This will attempt to read up to the numberOfChars characters of the channel. An io:EofError will return once the channel reaches the end.  string|io:Error result = readableCharChannel.read(1000);    Parameters  numberOfChars int Number of characters, which should be read   Return Type (string | )  Content, which is read, an EofError once the channel reaches the end or else an io:Error   readJson ()  returns json | Reads a JSON from the given channel.  json|io:Error result = readableCharChannel.readJson();    Return Type (json | )  The read JSON string or else an io:Error   readXml ()  returns xml | Reads an XML from the given channel.  json|io:Error result = readableCharChannel.readXml();    Return Type (xml | )  The read XML or else an io:Error   close ()  returns ? Closes a given character channel.  io:Error? err = readableCharChannel.close();    Return Type (?)  If an error occurred while writing"},{"page":"/learn/api-docs/ballerina/io/objects/ReadableDataChannel.html","name":"Object - : ReadableDataChannel","summary":"Represents a data channel for reading data.\n\n            ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  ReadableDataChannel  Represents a data channel for reading data.   Constructor __init( byteChannel, bOrder)   byteChannel The channel, which would represent the source to read/write data   bOrder BE  network byte order   Methods  Reads a 16 bit integer.  Reads a 32 bit integer.  Reads a 64 bit integer.  Reads a 32 bit float.  Reads a 64 bit float.  Reads a byte and convert its value to boolean.  Reads the string value represented through the provided number of bytes.  Reads a variable length integer.  Closes the data channel.  readInt16 ()  returns int | Reads a 16 bit integer.  int|io:Error result = dataChannel.readInt16();    Return Type (int | )  The value of the integer, which is read or else an io:Error if any error occurred   readInt32 ()  returns int | Reads a 32 bit integer.  int|io:Error result = dataChannel.readInt32();    Return Type (int | )  The value of the integer, which is read or else an io:Error if any error occurred   readInt64 ()  returns int | Reads a 64 bit integer.  int|io:Error result = dataChannel.readInt64();    Return Type (int | )  The value of the integer, which is read or else an io:Error if any error occurred   readFloat32 ()  returns float | Reads a 32 bit float.  float|io:Error result = dataChannel.readFloat32();    Return Type (float | )  The value of the float which is read or else io:Error if any error occurred   readFloat64 ()  returns float | Reads a 64 bit float.  float|io:Error result = dataChannel.readFloat64();    Return Type (float | )  The value of the float which is read or else io:Error if any error occurred   readBool ()  returns boolean | Reads a byte and convert its value to boolean.  boolean|io:Error result = dataChannel.readBool();    Return Type (boolean | )  boolean value which is read or else io:Error if any error occurred   readString (int nBytes, string encoding)  returns string | Reads the string value represented through the provided number of bytes.  string|io:Error string = dataChannel.readString(10, \"UTF-8\");    Parameters  nBytes int Specifies the number of bytes, which represents the string   encoding string Specifies the char-set encoding of the string   Return Type (string | )  The value of the string or else io:Error if any error occurred   readVarInt ()  returns int | Reads a variable length integer.  int|io:Error result = dataChannel.readVarInt();    Return Type (int | )  The value of the integer which is read or else io:Error if any error occurred   close ()  returns ? Closes the data channel.  io:Error? err = dataChannel.close();    Return Type (?)  () if the channel is closed successfully or else an io:Error if any error occurred"},{"page":"/learn/api-docs/ballerina/io/objects/ReadableTextRecordChannel.html","name":"Object - : ReadableTextRecordChannel","summary":"Represents a channel which will allow to read\n\n           ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  ReadableTextRecordChannel  Represents a channel which will allow to read   Constructor __init( charChannel, string fs, string rs, string fmt)   charChannel CharacterChannel which will point to the input/output resource   fs string Field separator (this could be a regex)   rs string Record separator (this could be a regex)   fmt string default  Methods  Checks whether there's a record left to be read.  Get the next record from the input/output resource.  Closes a given record channel.  hasNext ()  returns boolean Checks whether there's a record left to be read.  boolean hasNext = readableRecChannel.hasNext();    Return Type (boolean)  True if there's a record left to be read   getNext ()  returns string[] | Get the next record from the input/output resource.  string[]|io:Error record = readableRecChannel.getNext();    Return Type (string[] | )  Set of fields included in the record or else io:Error   close ()  returns ? Closes a given record channel.  io:Error err = readableRecChannel.close();    Return Type (?)  An io:Error if the record channel could not be closed properly"},{"page":"/learn/api-docs/ballerina/io/objects/WritableCSVChannel.html","name":"Object - : WritableCSVChannel","summary":"Represents a WritableCSVChannel, which could be used to write records from the CSV file.\n\n     ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  WritableCSVChannel  Represents a WritableCSVChannel, which could be used to write records from the CSV file.   Constructor __init( characterChannel, fs)   characterChannel fs ,  Field separator, which will separate the records in the CSV   Methods  Writes the record to a given CSV file.  Closes a given CSVChannel.  write (string[] csvRecord)  returns ? Writes the record to a given CSV file.  io:Error err = csvChannel.write(record);    Parameters  csvRecord string[] A record to be written to the channel   Return Type (?)  An io:Error if the record could not be written properly   close ()  returns ? Closes a given CSVChannel.  io:Error? err = csvChannel.close();    Return Type (?)  () or else io:Error if any error occurred"},{"page":"/learn/api-docs/ballerina/io/objects/WritableCharacterChannel.html","name":"Object - : WritableCharacterChannel","summary":"Represents a channel which could be used to write characters through a given WritableCharacterChannel.\n\n     ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  WritableCharacterChannel  Represents a channel which could be used to write characters through a given WritableCharacterChannel.   Constructor __init( bChannel, string charset)   bChannel The WritableByteChannel, which would be used to write the characters   charset string The character set, which would be used to encode the given bytes to characters   Methods  Writes a given sequence of characters (string).  Writes a given JSON to the given channel.  Writes a given XML to the channel.  Closes a given WritableCharacterChannel channel.  write (string content, int startOffset)  returns int | Writes a given sequence of characters (string).  int|io:Error result = writableCharChannel.write(\"Content\", 0);    Parameters  content string Content, which should be written   startOffset int Number of characters, which should be offset when writing the content   Return Type (int | )  Content length that written or else io:Error   writeJson (json content)  returns ? Writes a given JSON to the given channel.  io:Error? err = writableCharChannel.writeJson(inputJson, 0);    Parameters  content json The JSON, which should be written   Return Type (?)  If an io:Error occurred while writing   writeXml (xml content)  returns ? Writes a given XML to the channel.  io:Error? err = writableCharChannel.writeXml(inputXml, 0);    Parameters  content xml The XML, which should be written   Return Type (?)  () or else io:Error if any error occurred   close ()  returns ? Closes a given WritableCharacterChannel channel.  io:Error err = writableCharChannel.close();    Return Type (?)  () or else an io:Error if any error occurred"},{"page":"/learn/api-docs/ballerina/io/objects/WritableByteChannel.html","name":"Object - : WritableByteChannel","summary":"WritableByteChannel represents an output resource (i.e file). which could be used to sink bytes.\n\n     ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  WritableByteChannel  WritableByteChannel represents an output resource (i.e file). which could be used to sink bytes.   Methods  Sinks bytes from a given input/output resource.  Closes a given byte channel.  write (byte[] content, int offset)  returns int | Sinks bytes from a given input/output resource. This operation will be asynchronous. Writing might return without writing all the content.  int|io:Error result = writableByteChannel.write(record, 0);    Parameters  content byte[] Block of bytes, which should be written   offset int Offset, which should be kept when writing bytes.   Return Type (int | )  Number of bytes written or else io:Error   close ()  returns ? Closes a given byte channel.  io:Error err = writableByteChannel.close();    Return Type (?)  io:Error or else ()"},{"page":"/learn/api-docs/ballerina/io/objects/WritableDataChannel.html","name":"Object - : WritableDataChannel","summary":"Represents a WritableDataChannel for writing data.\n\n            ( ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  WritableDataChannel  Represents a WritableDataChannel for writing data.   Constructor __init( byteChannel, bOrder)   byteChannel channel which would represent the source to read/write data   bOrder BE  network byte order   Methods  Writes a 16 bit integer.  Writes a 32 bit integer.  Writes a 64 bit integer.  Writes a 32 bit float.  Writes a 64 bit float.  Writes a boolean.  Writes a given string value to the respective channel.  Writes a variable-length integer.  Closes the data channel.  writeInt16 (int value)  returns ? Writes a 16 bit integer.  io:Error? err = dataChannel.writeInt16(length);    Parameters  value int The integer, which will be written   Return Type (?)  () if the content is written successfully or else an io:Error if any error occurred   writeInt32 (int value)  returns ? Writes a 32 bit integer.  io:Error? err = dataChannel.writeInt32(length);    Parameters  value int The integer, which will be written   Return Type (?)  () if the content is written successfully or else io:Error if any error occurred   writeInt64 (int value)  returns ? Writes a 64 bit integer.  io:Error? err = dataChannel.writeInt64(length);    Parameters  value int The integer, which will be written   Return Type (?)  () if the content is written successfully or else io:Error if any error occurred   writeFloat32 (float value)  returns ? Writes a 32 bit float.  io:Error? err = dataChannel.writeFloat32(3.12);    Parameters  value float The float, which will be written   Return Type (?)  () if the float is written successfully or else io:Error if any error occurred   writeFloat64 (float value)  returns ? Writes a 64 bit float.  io:Error? err = dataChannel.writeFloat32(3.12);    Parameters  value float The float, which will be written   Return Type (?)  () if the float is written successfully or else io:Error if any error occurred   writeBool (boolean value)  returns ? Writes a boolean.  io:Error? err = dataChannel.writeInt64(length);    Parameters  value boolean The boolean, which will be written   Return Type (?)  () if the content is written successfully or else io:Error if any error occurred   writeString (string value, string encoding)  returns ? Writes a given string value to the respective channel.  io:Error? err = dataChannel.writeString(record);    Parameters  value string The value, which should be written   encoding string The encoding, which will represent the value string   Return Type (?)  () if the content is written successfully or else io:Error if any error occurred   writeVarInt (int value)  returns ? Writes a variable-length integer.  io:Error? err = dataChannel.writeVarInt(length);    Parameters  value int The int, which will be written   Return Type (?)  The value of the integer, which is written or else io:Error if any error occurred   close ()  returns ? Closes the data channel.  io:Error? err = dataChannel.close();    Return Type (?)  () if the channel is closed successfully or else io:Error if any error occurred"},{"page":"/learn/api-docs/ballerina/io/objects/WritableTextRecordChannel.html","name":"Object - : WritableTextRecordChannel","summary":"Represents a channel, which will allow to write records through a given WritableCharacterChannel.\n\n      ...","content":"Objects  >  >  >  >  >  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  WritableTextRecordChannel  Represents a channel, which will allow to write records through a given WritableCharacterChannel.   Constructor __init( characterChannel, string fs, string rs, string fmt)   characterChannel The WritableCharacterChannel, which will point to the input/output resource   fs string Field separator (this could be a regex)   rs string Record separator (this could be a regex)   fmt string default  The format, which will be used to represent the CSV (this could be \"DEFAULT\" (the format specified by the CSVChannel), \"CSV\" (Field separator would be \",\" and record separator would be a new line) or else \"TDF\" (Field separator will be a tab and record separator will be a new line).   Methods  Writes records to a given output resource.  Closes a given record channel.  write (string[] textRecord)  returns ? Writes records to a given output resource.  io:Error? err = writableChannel.write(records);    Parameters  textRecord string[] List of fields to be written   Return Type (?)  An io:Error if the records could not be written properly or else ()   close ()  returns ? Closes a given record channel.  io:Error? err = writableChannel.close();    Return Type (?)  An io:Error if the record channel could not be closed properly or else ()"},{"page":"/learn/api-docs/ballerina/io/records/T11.html","name":"Record - : T11","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T11"},{"page":"/learn/api-docs/ballerina/io/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/io/records/T12.html","name":"Record - : T12","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T12"},{"page":"/learn/api-docs/ballerina/io/records/T13.html","name":"Record - : T13","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T13"},{"page":"/learn/api-docs/ballerina/io/records/T14.html","name":"Record - : T14","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T14"},{"page":"/learn/api-docs/ballerina/java/","name":"Module : java","summary":"This module provides the API for Java interoperability in Ballerina. It includes a set of Ballerina annotations with which Java constructors, methods, and fields can provide implementations of Ballerina functions with external function bodies.For information on the operations, which you can perform with the Java module, see the below Functions. ...","content":"v1.2.2  All Modules  Module : java  Module Overview This module provides the API for Java interoperability in Ballerina. It includes a set of Ballerina annotations with which Java constructors, methods, and fields can provide implementations of Ballerina functions with external function bodies. For information on the operations, which you can perform with the Java module, see the below Functions. For examples on the usage of the operations, see the following.            Records Represents a Java array type.  Describes a Java constructor.  Describes a Java field.  Describes a Java method.  Functions Returns a handle, which refers to Java null.  Returns a handle, which refers to the Java string representation of the Ballerina string.  Returns a handle, which refers to the Java Class object associated with the class or interface with the given string name.  Returns true if this handle refers to Java null.  Returns a Ballerina string representation of the Java object referred by the handle.  Annotations Describes a Java constructor, which provides an implementation of a Ballerina function of which the body is marked as external.  Describes a Java Field access, which provides an implementation of a Ballerina function of which the body is marked as external.  Describes a Java Field mutate, which provides an implementation of a Ballerina function of which the body is marked as external.  Describes a Java method, which provides an implementation of a Ballerina function of which the body is marked as external."},{"page":"/learn/api-docs/ballerina/java/functions.html","name":"Functions -","summary":"()Returns a handle, which refers to Java null.\nThe handle, which refers to Java null(string value)Returns a handle, which refers to the Java string representation of the Ballerina string.\nThe Ballerina string with which the handle is createdThe handle, which refers to the Java String representation of the Ballerina string(string name)Returns a ...","content":"Functions  v1.2.2  All Modules  Functions - Returns a handle, which refers to Java null.  Returns a handle, which refers to the Java string representation of the Ballerina string.  Returns a handle, which refers to the Java Class object associated with the class or interface with the given string name.  Returns true if this handle refers to Java null.  Returns a Ballerina string representation of the Java object referred by the handle.  createNull ()  returns handle Returns a handle, which refers to Java null.  handle nullHandle = java:createNull();    Return Type (handle)  The handle, which refers to Java null   fromString (string value)  returns handle Returns a handle, which refers to the Java string representation of the Ballerina string.  handle header = java:fromString(\"Content-Type\");    Parameters  value string The Ballerina string with which the handle is created   Return Type (handle)  The handle, which refers to the Java String representation of the Ballerina string   getClass (string name)  returns handle | error Returns a handle, which refers to the Java Class object associated with the class or interface with the given string name.  handle|error intClass = java:getClass(\"int\");  This function performs a Java class.forName(name) except for the following cases:   NameOutput   booleanJava Class instance representing the primitive type boolean byteJava Class instance representing the primitive type byte charJava Class instance representing the primitive type char shortJava Class instance representing the primitive type short intJava Class instance representing the primitive type int longJava Class instance representing the primitive type long floatJava Class instance representing the primitive type float doubleJava Class instance representing the primitive type double     Parameters  name string The name of the Java class   Return Type (handle | error)  The Java Class object for the class with the given name   isNull (handle value)  returns boolean Returns true if this handle refers to Java null.  boolean status = java:isNull(value);    Parameters  value handle The handle of which the referred value is to be tested with Java null   Return Type (boolean)  true if this handle refers to Java null   toString (handle value)  returns string? Returns a Ballerina string representation of the Java object referred by the handle. If the handle refers to Java null, then this function returns a nil value.  string? version = java:toString(versionProperty);    Parameters  value handle The handle of which the referred value is to be converted to a Ballerina string   Return Type (string?)  The Ballerina string representation of the Java object referred by the handle or else returns () if the handle refers to Java null"},{"page":"/learn/api-docs/ballerina/java/records/MethodData.html","name":"Record - : MethodData","summary":"Describes a Java method. If the paramTypes field is not specified, then the parameter types are inferred from ...","content":"Records  v1.2.2  All Modules  Record - : MethodData  Describes a Java method. If the paramTypes field is not specified, then the parameter types are inferred from the corresponding Ballerina function.   Fields  name  Identifier  An optional field, which describes the name of the Java method. If this field is not provided, then the name is inferred from the Ballerina function name   class  Class  The class in which the method exists   paramTypes  Class | []  An optional field, which describes the parameter types of the method"},{"page":"/learn/api-docs/ballerina/java/records/ArrayType.html","name":"Record - : ArrayType","summary":"Represents a Java array type. It is used to specify the parameter types in the java:Constructor and java:Method\nannotations.\n\n ...","content":"Records  v1.2.2  All Modules  Record - : ArrayType  Represents a Java array type. It is used to specify the parameter types in the java:Constructor and java:Method annotations.   Fields  class  Class  Element class of the array type   dimensions  byte  Dimensions of the array type"},{"page":"/learn/api-docs/ballerina/java/records/FieldData.html","name":"Record - : FieldData","summary":"Describes a Java field.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : FieldData  Describes a Java field.   Fields  name  Identifier  An optional field, which describes the name of the Java field. If this field is not provided, then the name is inferred from the Ballerina function name   class  Class  The class in which the field exists"},{"page":"/learn/api-docs/ballerina/java/records/ConstructorData.html","name":"Record - : ConstructorData","summary":"Describes a Java constructor. If the paramTypes field is not specified, then the parameter types are inferred from\nthe ...","content":"Records  v1.2.2  All Modules  Record - : ConstructorData  Describes a Java constructor. If the paramTypes field is not specified, then the parameter types are inferred from the corresponding Ballerina function.   Fields  class  Class  The class in which the constructor exists   paramTypes  Class | []  An optional field, which describes the parameter types of the constructor"},{"page":"/learn/api-docs/ballerina/java.arrays/functions.html","name":"Functions -","summary":"(handle array, int index)Returns a handle, which refers to the element at the specified index in the given Java array. This function\ncompletes abruptly with a panic if the specified handle refers to a Java null or if the handle does not refer\nto a Java array.\nThe handle, which refers to the ...","content":"Functions  v1.2.2  All Modules  Functions - Returns a handle, which refers to the element at the specified index in the given Java array.  Returns the length of the given Java array.  Returns a new Java array instance with the specified element type and dimensions.  Replaces the indexed element at the specified index in the given Java array with the specified element.  get (handle array, int index)  returns handle Returns a handle, which refers to the element at the specified index in the given Java array. This function completes abruptly with a panic if the specified handle refers to a Java null or if the handle does not refer to a Java array.  handle words = getSortedArray();  handle firstWord = java.arrays:get(words, 0);    Parameters  array handle The handle, which refers to the Java array   index int The index of the element to be returned   Return Type (handle)  The handle, which refers to the element at the specified position in the Java array   getLength (handle array)  returns int Returns the length of the given Java array.  handle array = getArray();  int length = java.arrays:getLength(array);    Parameters  array handle The handle, which refers to the Java array   Return Type (int)  The length of the given Java array   newInstance (handle class, int[] dimensions)  returns handle Returns a new Java array instance with the specified element type and dimensions. This function completes abruptly with a panic if the specified handle refers to a Java null or if zero dimensions have been provided.  handle stringClass = check java:getClass(\"java.lang.String\");  handle StrArray = java.arrays:newInstance(stringClass, 4);    Parameters  class handle The element type of the array   dimensions int[] The dimensions of the array   Return Type (handle)  The new Java array instance   set Replaces the indexed element at the specified index in the given Java array with the specified element. This function completes abruptly with a panic if the specified handle refers to a Java null or if the handle does not refer to a Java array.  handle strArray = getStringArray();  java.arrays:set(strArray, 0, java:fromString(\"Ballerina\"));    Parameters  array handle The handle, which refers to the Java array   index int The index of the element to be replaced   element handle The element to be stored at the specified index"},{"page":"/learn/api-docs/ballerina/java.arrays/","name":"Module : java.arrays","summary":"This module provides APIs to create new Java array instances, get elements from arrays, set elements, etc.For information on the operations, which you can perform with the java.arrays module, see the below Functions. For an example on the usage of the operations, see the . ...","content":"v1.2.2  All Modules  Module : java.arrays  Module Overview This module provides APIs to create new Java array instances, get elements from arrays, set elements, etc. For information on the operations, which you can perform with the java.arrays module, see the below Functions. For an example on the usage of the operations, see the .    Functions Returns a handle, which refers to the element at the specified index in the given Java array.  Returns the length of the given Java array.  Returns a new Java array instance with the specified element type and dimensions.  Replaces the indexed element at the specified index in the given Java array with the specified element."},{"page":"/learn/api-docs/ballerina/java.jdbc/clients/Client.html","name":"Clients - : Client","summary":"Represents a JDBC client endpoint.\n( c)(string sqlQuery, typedesc[]? recordType, [] parameters)The call remote function implementation for JDBC Client to invoke stored procedures/functions.\nThe SQL stored procedure to executeArray of record types of the returned tables if there is anyThe parameters to be passed to the procedure/function callA table[] if there are ...","content":"Clients  v1.2.2  All Modules  Clients - :  Client  Represents a JDBC client endpoint.    Constructor __init( c)   c Remote Methods  The call remote function implementation for JDBC Client to invoke stored procedures/functions.   The select remote function implementation for JDBC Client to select data from tables.   The update remote function implementation for JDBC Client to insert/delete/modify data and schema of the database.   The batchUpdate remote function implementation for JDBC Client to execute batch operations.   Methods  Deprecated  Stops the JDBC client.  call (string sqlQuery, typedesc[]? recordType, [] parameters)  returns table[] | () | Deprecated  The call remote function implementation for JDBC Client to invoke stored procedures/functions.   Parameters  sqlQuery string The SQL stored procedure to execute   recordType typedesc[]? Array of record types of the returned tables if there is any   parameters [] The parameters to be passed to the procedure/function call   Return Type (table[] | () | )  A table[] if there are tables returned by the call remote function and else nil. Error will be returned if there is any error   select (string sqlQuery, typedesc? recordType, [] parameters)  returns table | Deprecated  The select remote function implementation for JDBC Client to select data from tables.   Parameters  sqlQuery string SQL query to execute   recordType typedesc? Type of the returned table   parameters [] The parameters to be passed to the select query   Return Type (table | )  A table returned by the SQL query statement or else Error will be returned if there is an error   update (string sqlQuery, [] parameters)  returns | Deprecated  The update remote function implementation for JDBC Client to insert/delete/modify data and schema of the database.   Parameters  sqlQuery string SQL statement to execute   parameters [] The parameters to be passed to the update query   Return Type ( | )  UpdateResult with the updated row count and key column values, else Error will be returned if there is an error   batchUpdate (string sqlQuery, boolean rollbackAllInFailure, ?[][] parameters)  returns Deprecated  The batchUpdate remote function implementation for JDBC Client to execute batch operations.   Parameters  sqlQuery string SQL statement to execute   rollbackAllInFailure boolean If one of the commands in a batch update fails to execute properly, the JDBC driver may or may not continue to process the remaining commands in the batch. This property can be used to override this behavior. When it is set to true, if there is a failure in a few commands and the JDBC driver continues with the remaining commands, the successfully executed commands in the batch also will get rolled back.   parameters ?[][] Variable number of parameter arrays each representing the set of parameters belonging to each update statement   Return Type ()  A BatchUpdateResult with the updated row count and returned error if any. If all the commands in the batch have executed successfully, the error will be nil. If one or more commands have failed, the returnedError field will give the corresponding Error along with the int[] which contains updated row count or the status returned from each command in the batch.   stop ()  returns error? Deprecated  Stops the JDBC client.   Return Type (error?)  Possible error during closing the client"},{"page":"/learn/api-docs/ballerina/java.jdbc/","name":"Module : java.jdbc","summary":"This module provides the functionality required to access and manipulate data stored in any type of relational database\nthat is accessible via Java Database Connectivity (JDBC).Prerequisite: Please add the JDBC driver corresponding to the database you are trying to interact with,\nas a native library dependency in your Ballerina project. Then, once ...","content":"v1.2.2  All Modules  Module : java.jdbc  Module overview This module provides the functionality required to access and manipulate data stored in any type of relational database that is accessible via Java Database Connectivity (JDBC). Prerequisite: Please add the JDBC driver corresponding to the database you are trying to interact with, as a native library dependency in your Ballerina project. Then, once you build the project with ballerina build command, you should be able to run the resultant jar with, the java -jar command. e.g. Ballerina.toml content. Please change the path to the JDBC driver appropriately. [project] org-name= \"sample\" version= \"0.1.0\"  [platform] target = \"java8\"   [[platform.libraries]]  artafactId = \"mysql-connector-java\"  version = \"8.0.17\"  path = \"/path/to/mysql-connector-java-8.0.17.jar\"  groupId = \"mysql\"  modules = [\"samplemodule\"]  Or, if you're trying to run a single bal file, you can copy the JDBC driver into ${BALLERINA_HOME}/bre/lib and run the bal file with ballerina run command. Client To access a database, you must first create a Client object. The code for creating a JDBC client can be found below. Creating a client jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  dbOptions: {useSSL: false} });  The full list of client properties can be found listed under the jdbc:PoolOptions type. Connection pool handling There are 3 possible scenarios for connection pool handling.   Global, shareable default connection pool If you do not provide the poolOptions field, a globally shareable pool will be created for your database unless a connection pool matching with the properties you provided already exists. jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  dbOptions: {useSSL: false} });    Client owned, unsharable connection pool If you define the poolOptions field inline, an unshareable connection pool will be created. jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  poolOptions: {maximumPoolSize: 5},  dbOptions: {useSSL: false} });    Local shareable connection pool If you create a record of type jdbc:PoolOptions and reuse that in the configuration of multiple clients, for each set of clients that connects to the same database instance with the same set of properties, a shared connection pool will be created. jdbc:PoolOptions poolOptions1 = {maximumPoolSize: 5};  jdbc:Client testDB1 = new ({  url: \"jdbc:mysql://localhost:3306/testdb1\",  username: \"root\",  password: \"root\",  poolOptions: poolOptions1,  dbOptions: {useSSL: false} });  jdbc:Client testDB2 = new ({  url: \"jdbc:mysql://localhost:3306/testdb1\",  username: \"root\",  password: \"root\",  poolOptions: poolOptions1,  dbOptions: {useSSL: false} });  jdbc:Client testDB3 = new ({  url: \"jdbc:mysql://localhost:3306/testdb2\",  username: \"root\",  password: \"root\",  poolOptions: poolOptions1,  dbOptions: {useSSL: false} });    Database operations Once the client is created, database operations can be executed through that client. This module provides support for creating tables and executing stored procedures. It also supports selecting, inserting, deleting, updating, and batch updating data. Samples for these operations can be found below. Creating tables This sample creates a table with two columns. One column is of type int, and the other is of type varchar. The CREATE statement is executed via the update remote function of the client. // Create the ‘Students’ table with fields ‘id’, 'name' and ‘age’. var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\"); if (ret is jdbc:UpdateResult) {  io:println(\"Students table create status in DB: \", ret.updatedRowCount); } else {  error err = ret;  io:println(\"Students table creation failed: \",  <string>err.detail()[\"message\"]); }  Inserting data This sample shows three examples of data insertion by executing an INSERT statement using the update remote function of the client. In the first example, query parameter values are passed directly into the query statement of the update remote function: var ret = testDB->update(\"INSERT INTO student(age, name) \" +  \"values (23, 'john')\"); if (ret is jdbc:UpdateResult) {  io:println(\"Inserted row count to Students table: \", ret.updatedRowCount); } else {  error err = ret;  io:println(\"Insert to Students table failed: \",  <string>err.detail()[\"message\"]); }  In the second example, the parameter values, which are in local variables, are passed directly as parameters to the update remote function. This direct parameter passing can be done for any primitive Ballerina type like string, int, float, or boolean. The SQL type of the parameter is derived from the type of the Ballerina variable that is passed in. string name = \"Anne\"; int age = 8; var ret = testDB->update(\"INSERT INTO student(age, name) values (?, ?)\",  age, name); if (ret is jdbc:UpdateResult) {  io:println(\"Inserted row count to Students table: \", ret.updatedRowCount); } else {  error err = ret;  io:println(\"Insert to Students table failed: \",  <string>err.detail()[\"message\"]); }  In the third example, parameter values are passed as a jdbc:Parameter to the update remote function. Use jdbc:Parameter when you need to provide more details such as the exact SQL type of the parameter, or the parameter direction. The default parameter direction is IN. jdbc:Parameter p1 = {sqlType: jdbc:TYPE_VARCHAR, value: \"James\"}; jdbc:Parameter p2 = {sqlType: jdbc:TYPE_INTEGER, value: 10};  var ret = testDB->update(\"INSERT INTO student(age, name) values (?, ?)\",  p2, p1); if (ret is jdbc:UpdateResult) {  io:println(\"Inserted row count to Students table: \", ret.updatedRowCount); } else {  error err = ret;  io:println(\"Insert to Students table failed: \",  <string>err.detail()[\"message\"]); }  Inserting data with auto-generated keys This example demonstrates inserting data while returning the auto-generated keys. It achieves this by using the update remote function to execute the INSERT statement. int age = 31; string name = \"Kate\"; var ret = testDB->update(\"INSERT INTO student (age, name) values (?, ?)\",  age, name); if (ret is jdbc:UpdateResult) {  int count = ret.updatedRowCount;  int generatedKey = <int>ret.generatedKeys[\"GENERATED_KEY\"];  io:println(\"Inserted row count: \", count);  io:println(\"Generated key: \", generatedKey); } else {  error err = ret;  io:println(\"Insert to table failed: \", <string>err.detail()[\"message\"]); }  Selecting data This example demonstrates selecting data. First, a type is created to represent the returned result set. Next, the SELECT query is executed via the select remote function of the client by passing that result set type. Once the query is executed, each data record can be retrieved by looping the result set. The table returned by the select operation holds a pointer to the actual data in the database and it loads data from the table only when it is accessed. This table can be iterated only once. // Define a type to represent the results. type Student record {  int id;  int age;  string name; };  // Select the data from the table. Query Parameters are passed directly. Similar to `update` examples, // parameters can be passed as `jdbc:Parameter`s as well. var ret = testDB->select(\"SELECT * FROM student WHERE id < ? AND age > ?\",  Student, 10, 12); if (ret is table<Student>) {  // Iterating returned table.  foreach var row in ret {  io:println(\"Student:\", row.id, \"|\", row.name, \"|\", row.age);  } } else {  error err = ret;  io:println(\"Select data from student table failed: \",  <string>err.detail()[\"message\"]); }  Updating data This example demonstrates modifying data by executing an UPDATE statement via the update remote function of the client. var ret = testDB->update(\"UPDATE student SET name = 'John' WHERE age = ?\", 23); if (ret is jdbc:UpdateResult) {  io:println(\"Updated row count in Students table: \", ret.updatedRowCount); } else {  error err = ret;  io:println(\"Insert to Students table failed: \",  <string>err.detail()[\"message\"]); }  Batch updating data This example demonstrates how to insert multiple records with a single INSERT statement that is executed via the batchUpdate remote function of the client. This is done by first creating multiple parameter arrays, each representing a single record, and then passing those arrays to the batchUpdate operation. Similarly, multiple UPDATE statements can also be executed via batchUpdate. // Create the first batch of parameters. jdbc:Parameter para1 = {sqlType: jdbc:TYPE_VARCHAR, value: \"Alex\"}; jdbc:Parameter para2 = {sqlType: jdbc:TYPE_INTEGER, value: 12}; jdbc:Parameter[] parameters1 = [para1, para2];  // Create the second batch of parameters. jdbc:Parameter para3 = {sqlType: jdbc:TYPE_VARCHAR, value: \"Peter\"}; jdbc:Parameter para4 = {sqlType: jdbc:TYPE_INTEGER, value: 6}; jdbc:Parameter[] parameters2 = [para3, para4];  // Do the batch update by passing the batches. jdbc:BatchUpdateResult ret = testDB->batchUpdate(\"INSERT INTO \" +  \"Student(name, age) values (?, ?)\",  false, parameters1, parameters2); error? e = ret.returnedError; if (e is error) {  io:println(\"Error occurred:\", <string>e.detail()[\"message\"]); } else {  io:println(\"Batch item 1 update count: \", ret.updatedRowCount[0]);  io:println(\"Batch item 2 update count: \", ret.updatedRowCount[1]); }  Calling stored procedures The following examples demonstrate executing stored procedures via the call remote function of the client. The first example shows how to create and call a simple stored procedure that inserts data. // Create the stored procedure. var ret = testDB->update(\"CREATE PROCEDURE INSERTDATA \" +  \"(IN pName VARCHAR(255), IN pAge INT) \" +  \"BEGIN \" +  \"INSERT INTO Student(name, age) \" +  \"values (pName, pAge); \" +  \"END\"); if (ret is jdbc:UpdateResult) {  io:println(\"Stored proc creation status: : \", ret.updatedRowCount); } else {  error err = ret;  io:println(\"Stored proc creation failed: \",  <string>err.detail()[\"message\"]); }  // Call the stored procedure. var retCall = testDB->call(\"{CALL INSERTDATA(?,?)}\", (), \"George\", 15); if (retCall is () | table<record {}>[]) {  io:println(\"Call operation successful\"); } else {  error err = retCall;  io:println(\"Stored procedure call failed: \",  <string>err.detail()[\"message\"]); }  This next example shows how to create and call a stored procedure that accepts INOUT and OUT parameters. // Create the stored procedure. var ret = testDB->update(\"CREATE PROCEDURE GETCOUNT \" +  \"(INOUT pID INT, OUT pCount INT) \" +  \"BEGIN \" +  \"SELECT COUNT(*) INTO pID FROM Student \" +  \"WHERE id = pID; \" +  \"SELECT COUNT(*) INTO pCount FROM Student \" +  \"WHERE id = 2; \" +  \"END\"); if (ret is jdbc:UpdateResult) {  io:println(\"Stored proc creation status: : \", ret.updatedRowCount); } else {  error err = ret;  io:println(\"Stored procedure creation failed: \",  <string>err.detail()[\"message\"]); }  // Call the stored procedure. jdbc:Parameter param1 = {sqlType: jdbc:TYPE_INTEGER, value: 3,  direction: jdbc:DIRECTION_INOUT}; jdbc:Parameter param2 = {sqlType: jdbc:TYPE_INTEGER,  direction: jdbc:DIRECTION_OUT}; var retCall = testDB->call(\"{CALL GETCOUNT(?,?)}\", (), param1, param2); if (retCall is () | table<record {}>[]) {  io:println(\"Call operation successful\");  io:print(\"Student count with ID = 3: \");  io:println(param1.value);  io:print(\"Student count with ID = 2: \");  io:println(param2.value); } else {  error err = retCall;  io:println(\"Stored procedure call failed: \",  <string>err.detail()[\"message\"]); }   Note: The default thread pool size used in Ballerina is the number of processors available * 2. You can configure the thread pool size by using the BALLERINA_MAX_POOL_SIZE environment variable.     Records Anonymous record  Anonymous record  Anonymous record  Anonymous record  Anonymous record  Anonymous record  Anonymous record  Anonymous record  Anonymous record  Deprecated  Represents the properties belonging to an ApplicationError   Deprecated  Represents the output of the batchUpdate remote function.  Deprecated  Provides a set of configurations for the JDBC Client.  Deprecated  Represents the properties belonging to a DatabaseError.  Deprecated  Represents a parameter for the JDBC Client remote functions when a variable needs to be passed to the remote function.  Deprecated  Represents the properties which are used to configure DB connection pool.  Deprecated  Represents the output of the update remote function.  Clients Deprecated  Represents a JDBC client endpoint.  Constants Identifies the issues related to database accessibility, erroneous queries, constraint violations, database resource clean-up, and other similar scenarios.  Identifies the errors originating from application-level causes.  Small variable-length character string   Small fixed-length character string   Large variable-length character string   Small fixed-length character string with Unicode support   Large variable-length character string with Unicode support   Large variable-length character string with Unicode support   Single bit value, which can be zero, one, or nil   Boolean value being either True or false   8-bit integer value, which may be unsigned or signed   16-bit signed integer value, which may be unsigned or signed   32-bit signed integer value, which may be unsigned or signed   64-bit signed integer value, which may be unsigned or signed   Fixed-precision and scaled decimal values   Fixed-precision and scaled decimal values   Single precision floating point number   Double precision floating point number   Double precision floating point number   Small fixed-length binary value   Large Binary object   Large variable-length binary value   Small variable-length binary value   Large Character object   Large Character objects in a multibyte national character set   Both DATE and TIME with an additional nanosecond field   Both DATE and TIME with an additional nanosecond field   Both DATE and TIME with an additional nanosecond field   Both DATE and TIME with an additional nanosecond field   Composite data value, which consists of zero or more elements of a specified data type   User-defined structured type, which consists of one or more attributes   Cursor value   IN parameters are used to send values to stored procedures   OUT parameters are used to get values from stored procedures   INOUT parameters are used to both send and get values to/from stored procedures   Types Deprecated  The direction of the parameter.  Deprecated  Represents a database or application level error returned from JDBC client remote functions.  Deprecated  The parameter passed into the operations.  Deprecated  The SQL Datatype of the parameter.  Errors Deprecated  Represents an error originating from application-level causes.  Deprecated  Represents an error caused by an issue related to database accessibility, erroneous queries, constraint violations, database resource clean-up, and other similar scenarios."},{"page":"/learn/api-docs/ballerina/java.jdbc/records/ApplicationErrorData.html","name":"Record - : ApplicationErrorData","summary":"Deprecated\n              ...","content":"Records  v1.2.2  All Modules  Record - : ApplicationErrorData  Deprecated  Represents the properties belonging to an ApplicationError   Fields  message  string  Error message   cause  error  Cause of the error"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/BatchUpdateResult.html","name":"Record - : BatchUpdateResult","summary":"Deprecated\n              ...","content":"Records  v1.2.2  All Modules  Record - : BatchUpdateResult  Deprecated  Represents the output of the batchUpdate remote function.   Fields  updatedRowCount  int[]  The updated row count during the sql statement exectuion A number greater than or equal to zero - indicates that the command was processed successfully and is an update count giving the number of rows A value of -2 - Indicates that the command was processed successfully but that the number of rows affected is unknown A value of -3 - Indicates that the command failed to execute successfully and occurs only if a driver continues to process remaining commands after a command fails   generatedKeys  map  A map of auto generated key values during the batch update execution   returnedError  ?  The Error returned from the remote function in case of a failure"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/ClientConfiguration.html","name":"Record - : ClientConfiguration","summary":"Deprecated\n              ...","content":"Records  v1.2.2  All Modules  Record - : ClientConfiguration  Deprecated  Provides a set of configurations for the JDBC Client.   Fields  url  string  URL of the database to connect   username  string  Username for the database connection   password  string  Password for the database connection   poolOptions  Properties for the connection pool configuration. Refer PoolOptions for more details   dbOptions  map  (default {}) A map of DB specific properties. These properties will have an effect only if the dataSourceClassName is provided in poolOptions"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/DatabaseErrorData.html","name":"Record - : DatabaseErrorData","summary":"Deprecated\n              ...","content":"Records  v1.2.2  All Modules  Record - : DatabaseErrorData  Deprecated  Represents the properties belonging to a DatabaseError.   Fields  message  string  Error message   sqlErrorCode  int  SQL error code   sqlState  string  SQL state   cause  error  Cause of the error"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/PoolOptions.html","name":"Record - : PoolOptions","summary":"Deprecated\n              ...","content":"Records  v1.2.2  All Modules  Record - : PoolOptions  Deprecated  Represents the properties which are used to configure DB connection pool. Default values of the fields can be set through the configuration API.   Fields  connectionInitSql  string  (default config:getAsString(b7a.jdbc.pool.connectionInitSql, )) SQL statement that will be executed after every new connection creation before adding it to the pool. Default value is none and it can be changed through the configuration API with the key b7a.jdbc.pool.connectionInitSql.   dataSourceClassName  string  (default config:getAsString(b7a.jdbc.pool.dataSourceClassName, )) Name of the DataSource class provided by the JDBC driver. This is used on following scenarios. 1. In JDBC client when DB specific properties are required (which are given with dbOptions) 2. In any data client in which XA transactions enabled by isXA property and need to provide a custom XA implementation.Default value is none and it can be changed through the configuration API with the key b7a.jdbc.pool.dataSourceClassName.   autoCommit  boolean  (default config:getAsBoolean(b7a.jdbc.pool.autoCommit, true)) Auto-commit behavior of connections returned from the pool. Default value is true and it can be changed through the configuration API with the key b7a.jdbc.pool.autoCommit.   isXA  boolean  (default config:getAsBoolean(b7a.jdbc.pool.isXA, false)) Whether connections are used for a distributed transaction. Default value is false and it can be set through the configuration API with the key b7a.jdbc.pool.isXA.   maximumPoolSize  int  (default config:getAsInt(\"b7a.jdbc.pool.maximumPoolSize\", 15)) The maximum size that the pool is allowed to reach, including both idle and in-use connections. Default value is 15 and it can be changed through the configuration API with the key b7a.jdbc.pool.maximumPoolSize.   connectionTimeoutInMillis  int  (default config:getAsInt(\"b7a.jdbc.pool.connectionTimeoutInMillis\", 30000)) The maximum number of milliseconds that a client will wait for a connection from the pool. Default value is 30000 (30 seconds) and it can be changed through the configuration API with the key b7a.jdbc.pool.connectionTimeoutInMillis. Lowest acceptable connection timeout value is 250 ms.   idleTimeoutInMillis  int  (default config:getAsInt(b7a.jdbc.pool.idleTimeoutInMillis, 600000)) The maximum amount of time that a connection is allowed to sit idle in the pool. Default value is 600000 (10 minutes) and it can be changed through the configuration API with the key b7a.jdbc.pool.idleTimeoutInMillis. The minimum allowed value is 10000ms (10 seconds). This setting only applies when minimumIdle is defined to be less than maximumPoolSize.   minimumIdle  int  (default config:getAsInt(b7a.jdbc.pool.minimumIdle, 15)) The minimum number of idle connections that pool tries to maintain in the pool. Default is the same as maximumPoolSize and it can be changed through the configuration API with the key b7a.jdbc.pool.minimumIdle.   maxLifetimeInMillis  int  (default config:getAsInt(b7a.jdbc.pool.maxLifetimeInMillis, 1800000)) The maximum lifetime of a connection in the pool. Default value is 1800000 (30 minutes) and it can be changed through the configuration API with the key b7a.jdbc.pool.maxLifetimeInMillis. A value of 0 indicates unlimited maximum lifetime (infinite lifetime), subject to the idleTimeoutInMillis.   validationTimeoutInMillis  int  (default config:getAsInt(\"b7a.jdbc.pool.validationTimeoutInMillis\", 5000)) The maximum duration of time that a connection will be tested for aliveness. Default value is 5000 (5 seconds) and it can be changed through the configuration API with the key b7a.jdbc.pool.validationTimeoutInMillis. Lowest acceptable validation timeout is 250 ms."},{"page":"/learn/api-docs/ballerina/java.jdbc/records/Parameter.html","name":"Record - : Parameter","summary":"Deprecated\n              ...","content":"Records  v1.2.2  All Modules  Record - : Parameter  Deprecated  Represents a parameter for the JDBC Client remote functions when a variable needs to be passed to the remote function.   Fields  sqlType  The data type of the corresponding SQL parameter   value  anydata  (default ()) Value of paramter passed into the SQL statement   direction  (default DIRECTION_IN) Direction of the SQL Parameter IN, OUT, or INOUT - Default value is IN   recordType  typedesc  In case of OUT direction, if the sqlType is REFCURSOR, this represents the record type to map a result row"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T2.html","name":"Record - : T2","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T2"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T3.html","name":"Record - : T3","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T3"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T4.html","name":"Record - : T4","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T4"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T43.html","name":"Record - : T43","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T43"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T6.html","name":"Record - : T6","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T6"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T5.html","name":"Record - : T5","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T5"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/T7.html","name":"Record - : T7","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T7"},{"page":"/learn/api-docs/ballerina/java.jdbc/records/UpdateResult.html","name":"Record - : UpdateResult","summary":"Deprecated\n              ...","content":"Records  v1.2.2  All Modules  Record - : UpdateResult  Deprecated  Represents the output of the update remote function.   Fields  updatedRowCount  int  The updated row count during the sql statement exectuion   generatedKeys  map  A map of auto generated key values during the sql statement execution"},{"page":"/learn/api-docs/ballerina/jsonutils/functions.html","name":"Functions -","summary":"(table tableValue)Converts a table to its JSON representation.\nThe source table to be converted to JSONThe JSON representation of the source table(xml x,  options)Converts an XML object to its JSON representation.\nThe XML source to be converted to JSONThe XmlOptions record consisting of the configurations for the conversionThe JSON representation of ...","content":"Functions  v1.2.2  All Modules  Functions - Converts a table to its JSON representation.  Converts an XML object to its JSON representation.  fromTable (table tableValue)  returns json Converts a table to its JSON representation.  table<Person> tableValue = table{  { key id, age, salary, name, married },  [ { 1, 30, 300.5, \"Mary\", true },  { 2, 20, 300.5, \"John\", true }  ]  };  json jsonValue = jsonutils:fromTable(tableValue);    Parameters  tableValue table The source table to be converted to JSON   Return Type (json)  The JSON representation of the source table   fromXML (xml x, options)  returns json | error Converts an XML object to its JSON representation.  xml xmlValue = xml `<!-- outer comment -->` + xml `<name>supun</name>`;  json|error jsonValue = fromXML(mxlValue);    Parameters  x xml The XML source to be converted to JSON   options (default {})  The XmlOptions record consisting of the configurations for the conversion   Return Type (json | error)  The JSON representation of the given XML on success, else returns an error"},{"page":"/learn/api-docs/ballerina/jsonutils/","name":"Module : jsonutils","summary":"This module provides utility functions to manipulate the built-in json data type. It provides APIs to convert an xml to a json or convert a table to a json. ...","content":"v1.2.2  All Modules  Module : jsonutils  Module Overview This module provides utility functions to manipulate the built-in json data type. It provides APIs to convert an xml to a json or convert a table to a json.    Records Anonymous record  Anonymous record  Provides configurations for converting XML to JSON.  Functions Converts a table to its JSON representation.  Converts an XML object to its JSON representation."},{"page":"/learn/api-docs/ballerina/jsonutils/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1"},{"page":"/learn/api-docs/ballerina/jsonutils/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0"},{"page":"/learn/api-docs/ballerina/jsonutils/records/XmlOptions.html","name":"Record - : XmlOptions","summary":"Provides configurations for converting XML to JSON.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : XmlOptions  Provides configurations for converting XML to JSON.   Fields  attributePrefix  string  (default @) Attribute prefix used in the XML   preserveNamespaces  boolean  (default true) Instructs whether to preserve the namespaces of the XML when converting"},{"page":"/learn/api-docs/ballerina/jwt/functions.html","name":"Functions -","summary":"( header)Builds the header string from the jwt:JwtHeader record.\nJWT header record to be built as a stringThe header string or else a jwt:Error if building the string fails( payload)Builds the payload string from the jwt:JwtPayload record.\nJWT payload record to be built as a stringThe payload string or else a jwt:Error ...","content":"Functions  v1.2.2  All Modules  Functions - Builds the header string from the jwt:JwtHeader record.  Builds the payload string from the jwt:JwtPayload record.  Decodes the given JWT string.  Issues a JWT based on the provided header and payload.  Validates the given JWT string.  buildHeaderString ( header)  returns string | Builds the header string from the jwt:JwtHeader record.  string|jwt:Error jwtHeader = buildHeaderString(header);    Parameters  header JWT header record to be built as a string   Return Type (string | )  The header string or else a jwt:Error if building the string fails   buildPayloadString ( payload)  returns string | Builds the payload string from the jwt:JwtPayload record.  string|jwt:Error jwtPayload = jwt:buildPayloadString(payload);    Parameters  payload JWT payload record to be built as a string   Return Type (string | )  The payload string or else a jwt:Error if building the string fails   decodeJwt (string jwtToken)  returns [, ] | Decodes the given JWT string.  [jwt:JwtHeader, jwt:JwtPayload]|jwt:Error [header, payload] = jwt:decodeJwt(jwtToken);    Parameters  jwtToken string JWT that needs to be decoded   Return Type ([, ] | )  The JWT header and payload tuple or else a jwt:Error if token decoding fails   issueJwt ( header, payload, ? config)  returns string | Issues a JWT based on the provided header and payload. JWT will be signed (JWS) if crypto:KeyStore information is provided in the jwt:JwtKeyStoreConfig and the alg field of the jwt:JwtHeader is not jwt:NONE.  string|jwt:error jwt = jwt:issueJwt(header, payload, keyStoreConfig);    Parameters  header JwtHeader object   payload JwtPayload object   config ? JWT key store config record   Return Type (string | )  JWT as a string or else a jwt:Error if token validation fails   validateJwt (string jwtToken, config)  returns | Validates the given JWT string.  jwt:JwtPayload|jwt:error result = jwt:validateJwt(jwt, validatorConfig);    Parameters  jwtToken string JWT that needs to be validated   config JWT validator config record   Return Type ( | )  JWT payload or else a jwt:Error if token validation fails"},{"page":"/learn/api-docs/ballerina/jwt/","name":"Module : jwt","summary":"This module provides an inbound and outbound JWT authentication provider, which can be used to authenticate using a JWT and the functionality related to issuing and validating JWT.For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the ...","content":"v1.2.2  All Modules  Module : jwt  Module Overview This module provides an inbound and outbound JWT authentication provider, which can be used to authenticate using a JWT and the functionality related to issuing and validating JWT. For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operations, see the following.         Records Record type to hold the details of an error.  Represents an entry of JWT cache.  Represents JWT header.  Represents JWT validator configurations.  Represents JWT key store configurations.  Represents JWT payload.  Represents JWT trust store configurations.  Represents JWT validator configurations.  Objects Represents the inbound JWT auth provider, which authenticates by validating a JWT.  Represents the outbound JWT auth provider, which is used to authenticate with an external endpoint by generating a JWT.  Functions Builds the header string from the jwt:JwtHeader record.  Builds the payload string from the jwt:JwtPayload record.  Decodes the given JWT string.  Issues a JWT based on the provided header and payload.  Validates the given JWT string.  Constants The RSA-SHA256 algorithm   The RSA-SHA384 algorithm   The RSA-SHA512 algorithm   Unsecured JWTs (no signing)   Represents the reason of the JWT error.  Types The key algorithms supported by crypto module.  Errors Represents the JWT error type with details."},{"page":"/learn/api-docs/ballerina/jwt/objects/InboundJwtAuthProvider.html","name":"Object - : InboundJwtAuthProvider","summary":"Represents the inbound JWT auth provider, which authenticates by validating a JWT.\nThe jwt:InboundJwtAuthProvider is another implementation of the ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  InboundJwtAuthProvider  Represents the inbound JWT auth provider, which authenticates by validating a JWT. The jwt:InboundJwtAuthProvider is another implementation of the auth:InboundAuthProvider interface.  jwt:InboundJwtAuthProvider inboundJwtAuthProvider = new({  issuer: \"example\",  audience: \"ballerina\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  });    Constructor __init( jwtValidatorConfig)   jwtValidatorConfig JWT validator configurations   Methods  Authenticates provided JWT against jwt:JwtValidatorConfig.  Fields  jwtValidatorConfig  JWT validator configurations   authenticate (string credential)  returns boolean | Authenticates provided JWT against jwt:JwtValidatorConfig.  boolean|auth:Error result = inboundJwtAuthProvider.authenticate(\"<credential>\");    Parameters  credential string JWT to be authenticated   Return Type (boolean | )  true if authentication is successful, false otherwise or else an auth:Error if JWT validation failed"},{"page":"/learn/api-docs/ballerina/jwt/objects/OutboundJwtAuthProvider.html","name":"Object - : OutboundJwtAuthProvider","summary":"Represents the outbound JWT auth provider, which is used to authenticate with an external endpoint by generating a ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  OutboundJwtAuthProvider  Represents the outbound JWT auth provider, which is used to authenticate with an external endpoint by generating a JWT. The jwt:OutboundJwtAuthProvider is another implementation of the auth:OutboundAuthProvider interface.  jwt:OutboundJwtAuthProvider jwtAuthProvider = new({  issuer: \"example\",  audience: [\"ballerina\"],  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  }  });    Constructor __init(? jwtIssuerConfig)   jwtIssuerConfig ? ()  JWT issuer configurations   Methods  Generates the token for JWT authentication.  Inspects the incoming data and generates the token for JWT authentication.  Fields  jwtIssuerConfig  ?  JWT issuer configurations   generateToken ()  returns string | Generates the token for JWT authentication.  string|auth:Error token = outboundJwtAuthProvider.generateToken();    Return Type (string | )  Generated token or else an auth:Error if token can't be generated   inspect (map data)  returns string | | () Inspects the incoming data and generates the token for JWT authentication.   Parameters  data map Map of data, which is extracted from the HTTP response   Return Type (string | | ())  JWT as string, () if nothing to be returned or else an auth:Error if token can't be generated"},{"page":"/learn/api-docs/ballerina/jwt/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  The specific error message for the error.   cause  error  The cause of the error if this error occurred due to another error"},{"page":"/learn/api-docs/ballerina/jwt/records/JwtIssuerConfig.html","name":"Record - : JwtIssuerConfig","summary":"Represents JWT validator configurations.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : JwtIssuerConfig  Represents JWT validator configurations.   Fields  username  string  JWT token username   issuer  string  JWT token issuer   audience  string[]  JWT token audience   customClaims  map  Map of custom claims   expTimeInSeconds  int  (default 300) Expiry time in seconds   keyStoreConfig  JWT key store configurations   signingAlg  (default RS256) Signing algorithm"},{"page":"/learn/api-docs/ballerina/jwt/records/JwtPayload.html","name":"Record - : JwtPayload","summary":"Represents JWT payload.\n\n            \n    ...","content":"Records  v1.2.2  All Modules  Record - : JwtPayload  Represents JWT payload.   Fields  iss  string  Issuer, identifies the principal that issued the JWT   sub  string  Subject, identifies the principal that is the subject of the JWT   aud  string | string[]  Audience, identifies the recipients that the JWT is intended for   jti  string  JWT ID, unique identifier for the JWT   exp  int  Expiration time, identifies the expiration time (seconds since the Epoch) on or after which the JWT must not be accepted   nbf  int  Not before, identifies the time (seconds since the Epoch) before which the JWT must not be accepted   iat  int  Issued at, identifies the time (seconds since the Epoch) at which the JWT was issued   customClaims  map  Map of custom claims"},{"page":"/learn/api-docs/ballerina/jwt/records/InboundJwtCacheEntry.html","name":"Record - : InboundJwtCacheEntry","summary":"Represents an entry of JWT cache.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : InboundJwtCacheEntry  Represents an entry of JWT cache.   Fields  jwtPayload  Parsed JWT payload   expTime  int?  Expiry time (milliseconds since the Epoch) of the parsed JWT"},{"page":"/learn/api-docs/ballerina/jwt/records/JwtHeader.html","name":"Record - : JwtHeader","summary":"Represents JWT header.\n\n            \n    ...","content":"Records  v1.2.2  All Modules  Record - : JwtHeader  Represents JWT header.   Fields  alg  Signing algorithm   typ  string  Media type of the JWT   cty  string  Content type, convey structural information about the JWT   kid  string  Key ID, hint indicating which key was used to secure the JWS"},{"page":"/learn/api-docs/ballerina/jwt/records/JwtTrustStoreConfig.html","name":"Record - : JwtTrustStoreConfig","summary":"Represents JWT trust store configurations.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : JwtTrustStoreConfig  Represents JWT trust store configurations.   Fields  trustStore  Trust store used for signature verification   certificateAlias  string  Token signed public key certificate alias"},{"page":"/learn/api-docs/ballerina/jwt/records/JwtKeyStoreConfig.html","name":"Record - : JwtKeyStoreConfig","summary":"Represents JWT key store configurations.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : JwtKeyStoreConfig  Represents JWT key store configurations.   Fields  keyStore  Keystore to be used in JWT signing   keyAlias  string  Signing key alias   keyPassword  string  Signing key password"},{"page":"/learn/api-docs/ballerina/jwt/records/JwtValidatorConfig.html","name":"Record - : JwtValidatorConfig","summary":"Represents JWT validator configurations.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : JwtValidatorConfig  Represents JWT validator configurations.   Fields  issuer  string  Expected issuer   audience  string | string[]  Expected audience   clockSkewInSeconds  int  (default 0) Clock skew in seconds   trustStoreConfig  JWT trust store configurations   jwtCache  (default ) Cache used to store parsed JWT information"},{"page":"/learn/api-docs/ballerina/kafka/clients/Consumer.html","name":"Clients - : Consumer","summary":"Represents a Kafka consumer endpoint.\n( config)Configurations related to consumer endpoint\n                    \n                    Used ...","content":"Clients  v1.2.2  All Modules  Clients - :  Consumer  Represents a Kafka consumer endpoint.    Constructor __init( config)   config Configurations related to consumer endpoint   Remote Methods  Assigns consumer to a set of topic partitions.   Closes consumer connection to the external Kafka broker.  kafka:ConsumerError? result = consumer->close();    Commits current consumed offsets for consumer.  kafka:ConsumerError? result = consumer->commit();    Commits given offsets and partitions for the given topics, for consumer.   Connects consumer to the provided host in the consumer configs.  kafka:ConsumerError? result = consumer->connect();    Retrieves the currently assigned partitions for the consumer.  kafka:TopicPartition[]|kafka:ConsumerError result = consumer->getAssignment();    Retrieves the available list of topics for a particular consumer.  string[]|kafka:ConsumerError result = consumer->getAvailableTopics();    Retrieves the start offsets for given set of partitions.   Retrieves the last committed offsets for the given topic partitions.   Retrieves the last offsets for given set of partitions.   Retrieves the partitions, which are currently paused.  kafka:TopicPartition[]|kafka:ConsumerError result = consumer->getPausedPartitions();    Retrieves the offset of the next record that will be fetched, if a records exists in that position.   Retrieves the set of topics which are currently subscribed by the consumer.  string[]|kafka:ConsumerError result = consumer->getSubscription();    Retrieves the set of partitions in which the topic belongs to.  kafka:TopicPartition[]|kafka:ConsumerError result = consumer->getTopicPartitions(\"kafka-topic\");    Pauses retrieving messages from a set of partitions.   Polls the consumer for external broker for records.  kafka:ConsumerRecord[]|kafka:ConsumerError result = consumer->poll(1000);    Resumes consumer retrieving messages from set of partitions which were paused earlier.   Seeks for a given offset in a topic partition.   Seeks the beginning of the offsets for the given set of topic partitions.   Seeks end of the offsets for the given set of topic partitions.   Subscribes the consumer to the provided set of topics.  kafka:ConsumerError? result = consumer->subscribe([\"kafka-topic-1\", \"kafka-topic-2\"]);    Subscribes the consumer to the topics which matches to the provided pattern.  kafka:ConsumerError? result = consumer->subscribeToPattern(\"kafka.*\");    Subscribes to the provided set of topics with rebalance listening enabled. This function can be used inside a service, to subscribe to a set of topics, while rebalancing the patition assignment of the consumers.   Unsubscribes from all the topic subscriptions.  kafka:ConsumerError? result = consumer->unsubscribe();    Methods  Starts the registered services.  Stops the kafka listener.  Stops the kafka listener.  Gets called every time a service attaches itself to the listener.  Detaches a consumer service from the listener.  Fields  consumerConfig  ?  (default ()) Used to store configurations related to a Kafka connection   assign ([] partitions)  returns ? Assigns consumer to a set of topic partitions.   Parameters  partitions [] Topic partitions to be assigned   Return Type (?)  kafka:ConsumerError if an error is encountered or else nil   close (int duration)  returns ? Closes consumer connection to the external Kafka broker.  kafka:ConsumerError? result = consumer->close();    Parameters  duration int (default -1)  Timeout duration for the close operation execution   Return Type (?)  kafka:ConsumerError if an error is encountered or else nil   commit ()  returns ? Commits current consumed offsets for consumer.  kafka:ConsumerError? result = consumer->commit();    Return Type (?)  kafka:ConsumerError if an error is encountered or else nil   commitOffset ([] offsets, int duration)  returns ? Commits given offsets and partitions for the given topics, for consumer.   Parameters  offsets [] Offsets to be commited   duration int (default -1)  Timeout duration for the commit operation execution   Return Type (?)  kafka:ConsumerError if an error is encountered or else nil   connect ()  returns ? Connects consumer to the provided host in the consumer configs.  kafka:ConsumerError? result = consumer->connect();    Return Type (?)  kafka:ConsumerError if an error is encountered or else nil   getAssignment ()  returns [] | Retrieves the currently assigned partitions for the consumer.  kafka:TopicPartition[]|kafka:ConsumerError result = consumer->getAssignment();    Return Type ([] | )  Array of assigned partitions for the consumer if executes successfully or else kafka:ConsumerError   getAvailableTopics (int duration)  returns string[] | Retrieves the available list of topics for a particular consumer.  string[]|kafka:ConsumerError result = consumer->getAvailableTopics();    Parameters  duration int (default -1)  Timeout duration for the get available topics execution   Return Type (string[] | )  Array of topics currently available (authorized) for the consumer to subscribe or else kafka:ConsumerError   getBeginningOffsets ([] partitions, int duration)  returns [] | Retrieves the start offsets for given set of partitions.   Parameters  partitions [] Array of topic partitions to get the starting offsets   duration int (default -1)  Timeout duration for the get beginning offsets execution   Return Type ([] | )  Starting offsets for the given partitions if executes successfully or else kafka:ConsumerError   getCommittedOffset ( partition, int duration)  returns | Retrieves the last committed offsets for the given topic partitions.   Parameters  partition The TopicPartition in which the committed offset is returned for consumer   duration int (default -1)  Timeout duration for the get committed offset operation to execute   Return Type ( | )  Committed offset for the consumer for the given partition if executes successfully or else kafka:ConsumerError   getEndOffsets ([] partitions, int duration)  returns [] | Retrieves the last offsets for given set of partitions.   Parameters  partitions [] Set of partitions to get the last offsets   duration int (default -1)  Timeout duration for the get end offsets operation to execute   Return Type ([] | )  End offsets for the given partitions if executes successfully or else kafka:ConsumerError   getPausedPartitions ()  returns [] | Retrieves the partitions, which are currently paused.  kafka:TopicPartition[]|kafka:ConsumerError result = consumer->getPausedPartitions();    Return Type ([] | )  Set of partitions paused from message retrieval if executes successfully or else kafka:ConsumerError   getPositionOffset ( partition, int duration)  returns int | Retrieves the offset of the next record that will be fetched, if a records exists in that position.   Parameters  partition The TopicPartition in which the position is required   duration int (default -1)  Timeout duration for the get position offset operation to execute   Return Type (int | )  Offset which will be fetched next (if a records exists in that offset) or else kafka:ConsumerError if the operation fails   getSubscription ()  returns string[] | Retrieves the set of topics which are currently subscribed by the consumer.  string[]|kafka:ConsumerError result = consumer->getSubscription();    Return Type (string[] | )  Array of subscribed topics for the consumer if executes successfully or else kafka:ConsumerError   getTopicPartitions (string topic, int duration)  returns [] | Retrieves the set of partitions in which the topic belongs to.  kafka:TopicPartition[]|kafka:ConsumerError result = consumer->getTopicPartitions(\"kafka-topic\");    Parameters  topic string The topic for which the partition information is needed   duration int (default -1)  Timeout duration for the get topic partitions operation to execute   Return Type ([] | )  Array of partitions for the given topic if executes successfully or else kafka:ConsumerError   pause ([] partitions)  returns ? Pauses retrieving messages from a set of partitions.   Parameters  partitions [] Partitions to pause the retrieval of messages   Return Type (?)  kafka:ConsumerError if an error is encountered or else nil   poll (int timeoutValue)  returns [] | Polls the consumer for external broker for records.  kafka:ConsumerRecord[]|kafka:ConsumerError result = consumer->poll(1000);    Parameters  timeoutValue int Polling time in milliseconds   Return Type ([] | )  Array of consumer records if executed successfully or else kafka:ConsumerError   resume ([] partitions)  returns ? Resumes consumer retrieving messages from set of partitions which were paused earlier.   Parameters  partitions [] Partitions to resume the retrieval of messages   Return Type (?)  kafka:ConsumerError if an error is encountered or else ()   seek ( offset)  returns ? Seeks for a given offset in a topic partition.   Parameters  offset The PartitionOffset to seek   Return Type (?)  kafka:ConsumerError if an error is encountered or else ()   seekToBeginning ([] partitions)  returns ? Seeks the beginning of the offsets for the given set of topic partitions.   Parameters  partitions [] The set of topic partitions to seek   Return Type (?)  kafka:ConsumerError if an error is encountered or else ()   seekToEnd ([] partitions)  returns ? Seeks end of the offsets for the given set of topic partitions.   Parameters  partitions [] The set of topic partitions to seek   Return Type (?)  kafka:ConsumerError if an error is encountered or else ()   subscribe (string[] topics)  returns ? Subscribes the consumer to the provided set of topics.  kafka:ConsumerError? result = consumer->subscribe([\"kafka-topic-1\", \"kafka-topic-2\"]);    Parameters  topics string[] Array of topics to be subscribed to   Return Type (?)  kafka:ConsumerError if an error is encountered or else ()   subscribeToPattern (string regex)  returns ? Subscribes the consumer to the topics which matches to the provided pattern.  kafka:ConsumerError? result = consumer->subscribeToPattern(\"kafka.*\");    Parameters  regex string Pattern which should be matched with the topics to be subscribed to   Return Type (?)  kafka:ConsumerError if an error is encountered or else ()   subscribeWithPartitionRebalance (string[] topics, function(, []) returns (()) onPartitionsRevoked, function(, []) returns (()) onPartitionsAssigned)  returns ? Subscribes to the provided set of topics with rebalance listening enabled. This function can be used inside a service, to subscribe to a set of topics, while rebalancing the patition assignment of the consumers.   Parameters  topics string[] Array of topics to be subscribed to   onPartitionsRevoked function(, []) returns (()) Function which will be executed if partitions are revoked from this consumer   onPartitionsAssigned function(, []) returns (()) Function which will be executed if partitions are assigned this consumer   Return Type (?)  kafka:ConsumerError if an error is encountered or else ()   unsubscribe ()  returns ? Unsubscribes from all the topic subscriptions.  kafka:ConsumerError? result = consumer->unsubscribe();    Return Type (?)  kafka:ConsumerError if an error is encountered or else ()   __start ()  returns error? Starts the registered services.   Return Type (error?)  An kafka:ConsumerError if an error is encountered while starting the server or else nil   __gracefulStop ()  returns error? Stops the kafka listener.   Return Type (error?)  An kafka:ConsumerError if an error is encountered during the listener stopping process or else nil   __immediateStop ()  returns error? Stops the kafka listener.   Return Type (error?)  An kafka:ConsumerError if an error is encountered during the listener stopping process or else nil   __attach (service s, string? name)  returns error? Gets called every time a service attaches itself to the listener.   Parameters  s service The service to be attached   name string? (default ())  Name of the service   Return Type (error?)  An kafka:ConsumerError if an error is encountered while attaching the service or else nil   __detach (service s)  returns error? Detaches a consumer service from the listener.   Parameters  s service The service to be detached   Return Type (error?)  An kafka:ConsumerError if an error is encountered while detaching a service or else nil"},{"page":"/learn/api-docs/ballerina/kafka/clients/Producer.html","name":"Clients - : Producer","summary":"Represents a Kafka producer endpoint.\n( config)Configurations related to initializing a Kafka Producer\n                    \n                   ...","content":"Clients  v1.2.2  All Modules  Clients - :  Producer  Represents a Kafka producer endpoint.    Constructor __init( config)   config Configurations related to initializing a Kafka Producer   Remote Methods  Closes the producer connection to the external Kafka broker.  kafka:ProducerError? result = producer->close();    Commits the offsets consumed by the provided consumer.   Commits the consumer offsets in a given transaction.   Flushes the batch of records already sent to the broker by the producer.  kafka:ProducerError? result = producer->flushRecords();    Retrieves the topic partition information for the provided topic.  kafka:TopicPartition[]|kafka:ProducerError result = producer->getTopicPartitions(\"kafka-topic\");    Produces records to the Kafka server.  kafka:ProducerError? result = producer->send(\"Hello World, Ballerina\", \"kafka-topic\");    Fields  producerConfig  ?  (default ()) Used to store configurations related to a Kafka connection   connectorId  string  (default system:uuid()) Unique ID for a particular connector   close ()  returns ? Closes the producer connection to the external Kafka broker.  kafka:ProducerError? result = producer->close();    Return Type (?)  A kafka:ProducerError if closing the producer is failed or else ()   commitConsumer ( consumer)  returns ? Commits the offsets consumed by the provided consumer.   Parameters  consumer Consumer, which needs offsets to be committed   Return Type (?)  Akafka:ProducerError if committing the consumer failed or else ()   commitConsumerOffsets ([] offsets, string groupID)  returns ? Commits the consumer offsets in a given transaction.   Parameters  offsets [] Consumer offsets to commit for a given transaction   groupID string Consumer group ID   Return Type (?)  A kafka:ProducerError if committing consumer offsets failed or else ()   flushRecords ()  returns ? Flushes the batch of records already sent to the broker by the producer.  kafka:ProducerError? result = producer->flushRecords();    Return Type (?)  A kafka:ProducerError if records couldn't be flushed or else ()   getTopicPartitions (string topic)  returns [] | Retrieves the topic partition information for the provided topic.  kafka:TopicPartition[]|kafka:ProducerError result = producer->getTopicPartitions(\"kafka-topic\");    Parameters  topic string Topic of which the partition information is given   Return Type ([] | )  A kafka:TopicPartition array for the given topic or else a kafka:ProducerError if the operation fails   send (anydata value, string topic, anydata? key, int? partition, int? timestamp)  returns ? Produces records to the Kafka server.  kafka:ProducerError? result = producer->send(\"Hello World, Ballerina\", \"kafka-topic\");    Parameters  value anydata Record contents   topic string Topic to which the record will be appended   key anydata? (default ())  Key that will be included in the record   partition int? (default ())  Partition to which the record should be sent   timestamp int? (default ())  Timestamp of the record in milliseconds since epoch   Return Type (?)  A kafka:ProducerError if send action fails to send data or else ()"},{"page":"/learn/api-docs/ballerina/kafka/","name":"Module : kafka","summary":"This module is used to interact with Kafka Brokers via Kafka Consumer and Kafka Producer clients.\nThis module supports Kafka 1.x.x and 2.0.0 versions.For information on the operations, which you can perform with this module, see the below Functions.\nFor examples on the usage of the operations, see the following.The Ballerina Kafka ...","content":"v1.2.2  All Modules  Module : kafka  Module Overview This module is used to interact with Kafka Brokers via Kafka Consumer and Kafka Producer clients. This module supports Kafka 1.x.x and 2.0.0 versions. For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operations, see the following.        Basic Usages Publishing Messages  Initialize the Kafka message producer.  kafka:ProducerConfiguration producerConfiguration = {  bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,  valueSerializerType: kafka:SER_STRING,  keySerializerType: kafka:SER_INT };  kafka:Producer kafkaProducer = new (producerConfiguration);   Use the kafka:Producer to publish messages.  string message = \"Hello World, Ballerina\"; kafka:ProducerError? result = kafkaProducer->send(message, \"kafka-topic\", key = 1);  Consuming Messages  Initializing the Kafka message consumer.  kafka:ConsumerConfiguration consumerConfiguration = {  bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",  offsetReset: \"earliest\",  topics: [\"kafka-topic\"] };  kafka:Consumer consumer = new (consumerConfiguration);   Use the kafka:Consumer as a simple record consumer.  kafka:ConsumerRecord[]|kafka:ConsumerError result = consumer->poll(1000);   Use the kafka:Consumer as a listener.  listener kafka:Consumer consumer = new (consumerConfiguration);  service kafkaService on consumer {  // This resource will be executed when a message is published to the  // subscribed topic/topics.  resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {  } }  Send Data Using Avro The Ballerina Kafka module supports Avro serialization and deserialization. To try this, create a new Ballerina project and two modules inside it. Execute the below commands to do this. ballerina new kafka_avro_sample cd kafka_avro_sample ballerina add producer ballerina add consumer  Dependencies To use Avro, you need to add the necessary dependencies to the Ballerina project you created. To do so, download the necessary dependencies and add them inside the resources directory. Also, add those dependencies to the Ballerina.toml file of your project. The following is a sample Ballerina.toml file with the dependencies.  [[platform.libraries]]  module = \"producer\"  path = \"./resources/kafka-avro-serializer-5.4.1.jar\"  artifactId = \"kafka-avro-serializer\"  version = \"5.4.1\"  groupId = \"io.confluent\"   [[platform.libraries]]  module = \"producer\"  path = \"./resources/kafka-schema-registry-client-5.4.1.jar\"  artifactId = \"kafka-schema-registry-client\"  version = \"5.4.1\"  groupId = \"io.confluent\"   [[platform.libraries]]  module = \"producer\"  path = \"./resources/common-config-5.4.1.jar\"  artifactId = \"common-config\"  version = \"5.4.1\"  groupId = \"io.confluent\"   [[platform.libraries]]  module = \"producer\"  path = \"./resources/common-utils-5.4.1.jar\"  artifactId = \"common-utils\"  version = \"5.4.1\"  groupId = \"io.confluent\"   [[platform.libraries]]  module = \"producer\"  path = \"./resources/avro-1.9.2.jar\"  artifactId = \"avro\"  version = \"1.9.2\"  groupId = \"org.apache.avro\"   [[platform.libraries]]  module = \"producer\"  path = \"./resources/jackson-core-2.10.3.jar\"  artifactId = \"jackson-core\"  version = \"1.9.2\"  groupId = \"com.fasterxml.jackson.core\"   [[platform.libraries]]  module = \"producer\"  path = \"./resources/jackson-databind-2.10.3.jar\"  artifactId = \"jackson-databind\"  version = \"2.10.3\"  groupId = \"com.fasterxml.jackson.core\"   [[platform.libraries]]  module = \"producer\"  path = \"./resources/jackson-annotations-2.10.3.jar\"  artifactId = \"jackson-annotations\"  version = \"2.10.3\"  groupId = \"com.fasterxml.jackson.core\"  Now, the directory structure will look like below (some of the files are ignored). ├── Ballerina.toml ├── resources │ ├── avro-1.9.2.jar │ ├── common-config-5.4.1.jar │ ├── common-utils-5.4.1.jar │ ├── jackson-annotations-2.10.3.jar │ ├── jackson-core-2.10.3.jar │ ├── jackson-databind-2.10.3.jar │ ├── kafka-avro-serializer-5.4.1.jar │ └── kafka-schema-registry-client-5.4.1.jar └── src  ├── consumer  │ └── main.bal  └── producer  └── main.bal  Avro Producer The kafka:Proucer can be configured to send data using Avro by providing the following configurations.  schemaString: This is the schema string, which is used to define the Avro schema. dataRecord: The data record you want to send through Kafka.  src/producer/main.bal: import ballerina/io; import ballerina/kafka;  public type Person record {  string name;  int age; };  kafka:ProducerConfiguration configs = {  bootstrapServers: \"<KAFKA_BROKER_HOST_AND_PORT>\",  // Other configurations  valueSerializerType: kafka:SER_AVRO,  schemaRegistryUrl: \"<SCHEMA_REGISTRY_URL>\" };  string schema = \"{\\\"type\\\" : \\\"record\\\",\" +  \"\\\"namespace\\\" : \\\"Thisaru\\\",\" +  \"\\\"name\\\" : \\\"person\\\",\" +  \"\\\"fields\\\" : [\" + \"{ \\\"name\\\" : \\\"name\\\", \\\"type\\\" : \\\"string\\\" },\" +  \"{ \\\"name\\\" : \\\"age\\\", \\\"type\\\" : \\\"int\\\" }\" +  \"]}\";  public function main() {  kafka:Producer producer = new(configs);   Person person = {  name: \"Lahiru Perera\",  age: 28  };   kafka:AvroRecord avroRecord = {  schemaString: schema,  dataRecord: person  };   kafka:ProducerError? result = producer->send(avroRecord, \"add-person\");  if (result is kafka:ProducerError) {  io:println(result); } }  Avro Consumer The Kafka implementation of Ballerina currently supports Avro deserialization only for generic records. The Consumer will return a kafka:AvroGenericRecord with the data received from Avro. The following is a sample consumer. src/producer/main.bal: import ballerina/io; import ballerina/kafka;  kafka:ConsumerConfiguration configs = {  bootstrapServers: \"<KAFKA_BROKER_HOST_AND_PORT>\",  groupId: \"test-group\",  // Other configurations  topics: [\"add-person\"],  valueDeserializerType: kafka:DES_AVRO,  schemaRegistryUrl: \"<SCHEMA_REGISTRY_URL>\" };  listener kafka:Consumer consumer = new(configs);  service KafkaService on consumer {  resource function onMessage(kafka:Consumer consumer, kafka:ConsumerRecord[] records) {  io:println(\"Records received\");  foreach var kafkaRecord in records {  anydata value = kafkaRecord.value;  if (value is kafka:AvroGenericRecord) {  io:println(value);  } else {  io:println(\"Invalid record type\");  }  }  } }  Now, execute the below command to run the consumer: ballerina run consumer  This will start the Kafka service to listen. You can verify it by the following messages, which will be displayed on the screen. [ballerina/kafka] kafka servers: <KAFKA_BROKER_HOST_AND_PORT> [ballerina/kafka] subscribed topics: add-person [ballerina/kafka] started kafka listener  Then, open another terminal and execute the below command to run the producer: ballerina run producer  Now, the consumer will receive the data and the received data will be printed on the Console as follows. Records received name=Lahiru Perera age=28     Records Represents a generic Avro record.  Defines a records to send data using Avro serialization.  Configurations related to consumer endpoint.  Type related to consumer record.  Represents the details of an error.  Configurations related to the KeyStore.  Represents the topic partition position in which the consumed record is stored.  Represents the Kafka Producer configuration.  Configurations related to the SSL/TLS protocol and the versions to be used.  Configurations for facilitating secure communication with the Kafka server.  Represents a topic partition.  Configurations related to the TrustStore.  Objects Represents a Kafka deserializer object.  Represents a Kafka serializer object.  Clients Represents a Kafka consumer endpoint.  Represents a Kafka producer endpoint.  Constants In-built Kafka byte array deserializer.  In-built Kafka string deserializer.  In-built Kafka int deserializer.  In-built Kafka float deserializer.  User-defined deserializer.  Apache Avro deserializer.  Configures the consumer to read the committed messages only in the transactional mode when poll() is called.  Configures the consumer to read all the messages even the aborted ones.  Producer acknowledgement type is 'all'.  Producer acknowledgement type '0'.  Producer acknowledgement type '1'.  In-built Kafka Byte Array serializer.  In-built Kafka string serializer.  In-built Kafka int serializer.  In-built Kafka float serializer.  User-defined serializer.  Apache Avro serializer.  No compression.  Kafka GZIP compression type.  Kafka Snappy compression type.  Kafka LZ4 compression type.  Kafka ZSTD compression type.  Used as the error reason for the kafka:ConsumerError type.  Used as the error reason for the kafka:ProducerError type.  Used as the error reason for the kafka:AvroError type.  Types Kafka compression types to compress the messages.  Kafka in-built deserializer type.  Kafka consumer isolation level type.  Kafka producer acknowledgement types.  Kafka in-built serializer types.  Errors Represents a Kafka Avro related error.  Error type specific to the kafka:Consumer object functions.  Error type specific to the kafka:Producer object functions."},{"page":"/learn/api-docs/ballerina/kafka/objects/Deserializer.html","name":"Object - : Deserializer","summary":"Represents a Kafka deserializer object. This object can be used to create custom deserializers for Ballerina Kafka\nconsumers.\n\n  ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  Deserializer  Represents a Kafka deserializer object. This object can be used to create custom deserializers for Ballerina Kafka consumers.   Methods  Closes the deserialization process.  Deserializes the provided data.  close Closes the deserialization process. This function runs after the deserialization process is done.   deserialize (byte[] data)  returns any Deserializes the provided data. Implement this to deserialize a byte[] and return any data type.   Parameters  data byte[] Data, which should be deserialized   Return Type (any)  The deserialized value"},{"page":"/learn/api-docs/ballerina/kafka/objects/Serializer.html","name":"Object - : Serializer","summary":"Represents a Kafka serializer object. This object can be used to create custom serializers for the Ballerina Kafka\nproducers.\n\n ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  Serializer  Represents a Kafka serializer object. This object can be used to create custom serializers for the Ballerina Kafka producers.   Methods  Closes the serialization process.  Serializes the provided data.  close Closes the serialization process. This function runs after the serialization process is done.   serialize (any data)  returns byte[] Serializes the provided data. Implement this to serialize any data type and return the byte[] value to use in the Kafka producer.   Parameters  data any Data, which should be serialized   Return Type (byte[])  Serialized byte[] value"},{"page":"/learn/api-docs/ballerina/kafka/records/AvroGenericRecord.html","name":"Record - : AvroGenericRecord","summary":"Represents a generic Avro record. This is the type of the value returned from an Avro deserializer consumer.\n\n ...","content":"Records  v1.2.2  All Modules  Record - : AvroGenericRecord  Represents a generic Avro record. This is the type of the value returned from an Avro deserializer consumer."},{"page":"/learn/api-docs/ballerina/kafka/records/AvroRecord.html","name":"Record - : AvroRecord","summary":"Defines a records to send data using Avro serialization.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : AvroRecord  Defines a records to send data using Avro serialization.   Fields  schemaString  string  The string, which defines the Avro schema   dataRecord  anydata  Records, which should be serialized using Avro"},{"page":"/learn/api-docs/ballerina/kafka/records/KeyStore.html","name":"Record - : KeyStore","summary":"Configurations related to the KeyStore.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : KeyStore  Configurations related to the KeyStore.   Fields  keyStoreType  string  The file format of the KeyStore file. This is optional for the client   location  string  The location of the KeyStore file. This is optional for the client and can be used for two-way authentication for the client   password  string  The store password for the KeyStore file. This is optional for the client and is only needed if the ssl.keystore.location is configured   keyManagerAlgorithm  string  The algorithm used by the key manager factory for SSL connections. The default value is the key manager factory algorithm configured for the JVM"},{"page":"/learn/api-docs/ballerina/kafka/records/Detail.html","name":"Record - : Detail","summary":"Represents the details of an error.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Represents the details of an error.   Fields  message  string  The description of the error occurred   cause  error  Cause of the error"},{"page":"/learn/api-docs/ballerina/kafka/records/ConsumerRecord.html","name":"Record - : ConsumerRecord","summary":"Type related to consumer record.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : ConsumerRecord  Type related to consumer record.   Fields  key  anydata  Key that is included in the record   value  anydata  Record content   offset  int  Offset value   partition  int  Partition in which the record is stored   timestamp  int  Timestamp of the record, in milliseconds since epoch   topic  string  Topic to which the record belongs to"},{"page":"/learn/api-docs/ballerina/kafka/records/ConsumerConfiguration.html","name":"Record - : ConsumerConfiguration","summary":"Configurations related to consumer endpoint.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : ConsumerConfiguration  Configurations related to consumer endpoint.   Fields  bootstrapServers  string  List of remote server endpoints of kafka brokers   groupId  string  Unique string that identifies the consumer   offsetReset  string  Offset reset strategy if no initial offset   partitionAssignmentStrategy  string  Strategy class for handling the partition assignment among consumers   metricsRecordingLevel  string  Metrics recording level   metricsReporterClasses  string  Metrics reporter classes   clientId  string  Identifier to be used for server side logging   interceptorClasses  string  Interceptor classes to be used before sending records   isolationLevel  Transactional message reading method   keyDeserializerType  (default DES_BYTE_ARRAY) Deserializer used for the Kafka record key. This should be a kafka:DeserializerType   valueDeserializerType  (default DES_BYTE_ARRAY) Deserializer used for the Kafka record value. This should be a kafka:DeserializerType   keyDeserializer  Custom deserializer object to deserialize kafka keys. This should be implement the kafka:Deserializer object   valueDeserializer  Custom deserializer object to deserialize kafka values. This should implement the kafka:Deserializer object   schemaRegistryUrl  string  Avro schema registry url. Use this field to specify schema registry url, if Avro serializer is used   topics  string[]  Topics to be subscribed by the consumer   properties  string[]  Additional properties if required   sessionTimeoutInMillis  int  Timeout used to detect consumer failures when heartbeat threshold is reached   heartBeatIntervalInMillis  int  Expected time between heartbeats   metadataMaxAgeInMillis  int  Maximum time to force a refresh of metadata   autoCommitIntervalInMillis  int  Auto committing interval for commit offset, when auto-commit is enabled   maxPartitionFetchBytes  int  The maximum amount of data per-partition the server returns   sendBuffer  int  Size of the TCP send buffer (SO_SNDBUF)   receiveBuffer  int  Size of the TCP receive buffer (SO_RCVBUF)   fetchMinBytes  int  Minimum amount of data the server should return for a fetch request   fetchMaxBytes  int  Maximum amount of data the server should return for a fetch request   fetchMaxWaitTimeInMillis  int  Maximum amount of time the server will block before answering the fetch request   reconnectBackoffTimeMaxInMillis  int  Maximum amount of time in milliseconds to wait when reconnecting   retryBackoffInMillis  int  Time to wait before attempting to retry a failed request   metricsSampleWindowInMillis  int  Window of time a metrics sample is computed over   metricsNumSamples  int  Number of samples maintained to compute metrics   requestTimeoutInMillis  int  Wait time for response of a request   connectionMaxIdleTimeInMillis  int  Close idle connections after the number of milliseconds   maxPollRecords  int  Maximum number of records returned in a single call to poll   maxPollInterval  int  Maximum delay between invocations of poll   reconnectBackoffTimeInMillis  int  Time to wait before attempting to reconnect   pollingTimeoutInMillis  int  Timeout interval for polling   pollingIntervalInMillis  int  Polling interval for the consumer   concurrentConsumers  int  Number of concurrent consumers   defaultApiTimeoutInMillis  int  Default API timeout value for APIs with duration   autoCommit  boolean  (default true) Enables auto committing offsets   checkCRCS  boolean  (default true) Check the CRC32 of the records consumed. This ensures that no on-the-wire or on-disk corruption to the messages occurred. This may add some overhead, and might needed set to false if extreme performance is required   excludeInternalTopics  boolean  (default true) Whether records from internal topics should be exposed to the consumer   decoupleProcessing  boolean  (default false) Decouples processing   secureSocket  Configurations related to SSL/TLS"},{"page":"/learn/api-docs/ballerina/kafka/records/PartitionOffset.html","name":"Record - : PartitionOffset","summary":"Represents the topic partition position in which the consumed record is stored.\n\n       ...","content":"Records  v1.2.2  All Modules  Record - : PartitionOffset  Represents the topic partition position in which the consumed record is stored.   Fields  partition  The kafka:TopicPartition to which the record is related   offset  int  Offset in which the record is stored in the partition"},{"page":"/learn/api-docs/ballerina/kafka/records/ProducerConfiguration.html","name":"Record - : ProducerConfiguration","summary":"Represents the Kafka Producer configuration.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : ProducerConfiguration  Represents the Kafka Producer configuration.   Fields  bootstrapServers  string  List of remote server endpoints of Kafka brokers   acks  (default ACKS_SINGLE) Number of acknowledgments   compressionType  (default COMPRESSION_NONE) Compression type to be used for messages   clientId  string  Identifier to be used for server side logging   metricsRecordingLevel  string  Metrics recording level   metricReporterClasses  string  Metrics reporter classes   partitionerClass  string  Partitioner class to be used to select the partition to which the message is sent   interceptorClasses  string  Interceptor classes to be used before sending records   transactionalId  string  Transactional ID to be used in transactional delivery   valueSerializerType  (default SER_BYTE_ARRAY) Serializer used for the Kafka record value. This can be either kafka:SerializerType or a user-defined serializer   keySerializerType  (default SER_BYTE_ARRAY) Serializer used for the Kafka record key. This can be either kafka:SerializerType or a user-defined serializer   valueSerializer  Custom serializer object to serialize Kafka values. This should implement the kafka:Serializer object   keySerializer  Custom serializer object to serialize Kafka keys. This should implement the kafka:Serializer object   schemaRegistryUrl  string  Avro schema registry URL. Use this field to specify the schema registry URL if the Avro serializer is used   bufferMemory  int  Total bytes of memory the producer can use to buffer records   retryCount  int  Number of retries to resend a record   batchSize  int  Number of records to be batched for a single request. Use 0 for no batching   linger  int  Delay to allow other records to be batched   sendBuffer  int  Size of the TCP send buffer (SO_SNDBUF)   receiveBuffer  int  Size of the TCP receive buffer (SO_RCVBUF)   maxRequestSize  int  The maximum size of a request in bytes   reconnectBackoffTimeInMillis  int  Time to wait before attempting to reconnect   reconnectBackoffMaxTimeInMillis  int  Maximum amount of time in milliseconds to wait when reconnecting   retryBackoffTimeInMillis  int  Time to wait before attempting to retry a failed request   maxBlock  int  Maximum block time during which the sending is blocked when the buffer is full   requestTimeoutInMillis  int  Wait time for the response of a request   metadataMaxAgeInMillis  int  Maximum time to force a refresh of metadata   metricsSampleWindowInMillis  int  Time window for a metrics sample to compute over   metricsNumSamples  int  Number of samples maintained to compute the metrics   maxInFlightRequestsPerConnection  int  Maximum number of unacknowledged requests on a single connection   connectionsMaxIdleTimeInMillis  int  Close the idle connections after this number of milliseconds   transactionTimeoutInMillis  int  Timeout for transaction status update from the producer   enableIdempotence  boolean  (default false) Exactly one copy of each message is written in the stream when enabled   secureSocket  Configurations related to SSL/TLS"},{"page":"/learn/api-docs/ballerina/kafka/records/Protocols.html","name":"Record - : Protocols","summary":"Configurations related to the SSL/TLS protocol and the versions to be used.\n\n       ...","content":"Records  v1.2.2  All Modules  Record - : Protocols  Configurations related to the SSL/TLS protocol and the versions to be used.   Fields  securityProtocol  string  The protocol used to communicate with brokers.   sslProtocol  string  The SSL protocol used to generate the SSLContext. The default setting is TLS, which is fine for most cases. Allowed values in recent JVMs are TLS, TLSv1.1, and TLSv1.2. Also, SSL, SSLv2 and SSLv3 may be supported in older JVMs but their usage is discouraged due to known security vulnerabilities   sslProtocolVersions  string  The list of protocols enabled for SSL connections"},{"page":"/learn/api-docs/ballerina/kafka/records/SecureSocket.html","name":"Record - : SecureSocket","summary":"Configurations for facilitating secure communication with the Kafka server.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : SecureSocket  Configurations for facilitating secure communication with the Kafka server.   Fields  keyStore  Configurations associated with the KeyStore   trustStore  Configurations associated with the TrustStore   protocol  Configurations related to the SSL/TLS protocol and the version to be used   sslProvider  string  The name of the security provider used for SSL connections. Default value is the default security provider of the JVM   sslKeyPassword  string  The password of the private key in the key store file. This is optional for the client   sslCipherSuites  string  A list of Cipher suites. This is a named combination of the authentication, encryption, MAC, and key exchange algorithms used to negotiate the security settings for a network connection using the TLS or SSL network protocols. By default, all the available Cipher suites are supported   sslEndpointIdentificationAlgorithm  string  The endpoint identification algorithm to validate the server hostname using the server certificate   sslSecureRandomImplementation  string  The SecureRandom PRNG implementation to use for the SSL cryptography operations"},{"page":"/learn/api-docs/ballerina/kafka/records/TopicPartition.html","name":"Record - : TopicPartition","summary":"Represents a topic partition.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : TopicPartition  Represents a topic partition.   Fields  topic  string  Topic to which the partition is related   partition  int  Index for the partition"},{"page":"/learn/api-docs/ballerina/kafka/records/TrustStore.html","name":"Record - : TrustStore","summary":"Configurations related to the TrustStore.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : TrustStore  Configurations related to the TrustStore.   Fields  trustStoreType  string  The file format of the TrustStore file   location  string  The location of the TrustStore file   password  string  The password for the TrustStore file. If a password is not set, access to the TrustStore is still available but integrity checking is disabled   trustManagerAlgorithm  string  The algorithm used by the trust manager factory for SSL connections. The default value is the trust manager factory algorithm configured for the JVM"},{"page":"/learn/api-docs/ballerina/lang.array/","name":"Module : lang.array","summary":"This module provides lang library list operations defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.array  Module Overview This module provides lang library list operations defined by the language specification 2020R1.    Records Anonymous record  Anonymous record  Objects Functions Returns a new array consisting of index and member pairs.  Selects the members from an array for which a function returns true.  Applies a function to each member of an array.  Returns the byte array that a string represents in Base16.  Returns the byte array that a string represents in Base64.  Returns the index of first member of arr that is equal to val if there is one.  Returns an iterator over an array.  Returns the index of last member of arr that is equal to val if there is one.  Returns the number of members of an array.  Applies a function to each member of an array and returns an array of the results.  Removes and returns the last member of an array.  Adds values to the end of an array.  Combines the members of an array using a combining function.  Removes a member of an array.  Removes all members of an array.  Reverses the order of the members of an array.  Changes the length of an array.  Removes and returns first member of an array.  Returns a subarray starting from startIndex (inclusive) to endIndex (exclusive).  Sorts an array using a comparator function.  Returns the string that is the Base16 representation of an array of bytes.  Returns the string that is the Base64 representation of an array of bytes.  Returns a stream from the given array.  Adds values to the start of an array."},{"page":"/learn/api-docs/ballerina/lang.array/functions.html","name":"Functions -","summary":"(Type[] arr)Returns a new array consisting of index and member pairs.\nthe arrayarray of index, member pairs(Type[] arr,  function(Type) returns (boolean)  func)Selects the members from an array for which a function returns true.\nthe arraya predicate to apply to each member to test whether it should be selectednew array only ...","content":"Functions  v1.2.2  All Modules  Functions - Returns a new array consisting of index and member pairs.  Selects the members from an array for which a function returns true.  Applies a function to each member of an array.  Returns the byte array that a string represents in Base16.  Returns the byte array that a string represents in Base64.  Returns the index of first member of arr that is equal to val if there is one.  Returns an iterator over an array.  Returns the index of last member of arr that is equal to val if there is one.  Returns the number of members of an array.  Applies a function to each member of an array and returns an array of the results.  Removes and returns the last member of an array.  Adds values to the end of an array.  Combines the members of an array using a combining function.  Removes a member of an array.  Removes all members of an array.  Reverses the order of the members of an array.  Changes the length of an array.  Removes and returns first member of an array.  Returns a subarray starting from startIndex (inclusive) to endIndex (exclusive).  Sorts an array using a comparator function.  Returns the string that is the Base16 representation of an array of bytes.  Returns the string that is the Base64 representation of an array of bytes.  Returns a stream from the given array.  Adds values to the start of an array.  enumerate (Type[] arr)  returns [int, Type][] Returns a new array consisting of index and member pairs.   Parameters  arr Type[] the array   Return Type ([int, Type][])  array of index, member pairs   filter (Type[] arr, function(Type) returns (boolean) func)  returns Type[] Selects the members from an array for which a function returns true.   Parameters  arr Type[] the array   func function(Type) returns (boolean) a predicate to apply to each member to test whether it should be selected   Return Type (Type[])  new array only containing members of arr for which func evaluates to true   forEach Applies a function to each member of an array. The parameter func is applied to each member of array arr in order.   Parameters  arr Type[] the array   func function(Type) returns (()) a function to apply to each member   fromBase16 (string str)  returns byte[] | error Returns the byte array that a string represents in Base16. str must consist of the characters 0..9, A..F, a..f and whitespace as allowed by a Ballerina Base16Literal.   Parameters  str string Base16 string representation   Return Type (byte[] | error)  the byte array or error   fromBase64 (string str)  returns byte[] | error Returns the byte array that a string represents in Base64. str must consist of the characters A..Z, a..z, 0..9, +, /, = and whitespace as allowed by a Ballerina Base64Literal.   Parameters  str string Base64 string representation   Return Type (byte[] | error)  the byte array or error   indexOf (PureType[] arr, PureType val, int startIndex)  returns int? Returns the index of first member of arr that is equal to val if there is one. Returns () if not found. Equality is tested using ==.   Parameters  arr PureType[] the array   val PureType member to search for   startIndex int (default 0)  index to start the search from   Return Type (int?)  index of the member if found, else ()   iterator (Type[] arr)  returns Returns an iterator over an array.   Parameters  arr Type[] the array   Return Type ()  a new iterator object that will iterate over the members of arr.   lastIndexOf (PureType[] arr, PureType val, int startIndex)  returns int? Returns the index of last member of arr that is equal to val if there is one. Returns () if not found. Equality is tested using ==.   Parameters  arr PureType[] the array   val PureType member to search for   startIndex int (default arr.length(arr) - 1)  index to start searching backwards from   Return Type (int?)  index of the member if found, else ()   length (any | error[] arr)  returns int Returns the number of members of an array.   Parameters  arr any | error[] the array   Return Type (int)  number of members in arr   map (Type[] arr, function(Type) returns (Type1) func)  returns Type1[] Applies a function to each member of an array and returns an array of the results.   Parameters  arr Type[] the array   func function(Type) returns (Type1) a function to apply to each member   Return Type (Type1[])  new array containing result of applying func to each member of arr in order   pop (Type[] arr)  returns Type Removes and returns the last member of an array. The array must not be empty.   Parameters  arr Type[] the array   Return Type (Type)  removed member   push Adds values to the end of an array.   Parameters  arr Type[] the array   vals Type[] values to add to the end of the array   reduce (Type[] arr, function(Type1, Type) returns (Type1) func, Type1 initial)  returns Type1 Combines the members of an array using a combining function. The combining function takes the combined value so far and a member of the array, and returns a new combined value.   Parameters  arr Type[] the array   func function(Type1, Type) returns (Type1) combining function   initial Type1 initial value for the first argument of combining parameter func   Return Type (Type1)  result of combining the members of arr using func For example  reduce([1, 2, 3], function (int total, int n) returns int { return total + n; }, 0)  is the same as sum(1, 2, 3).   remove (Type[] arr, int index)  returns Type Removes a member of an array.   Parameters  arr Type[] the array   index int index of member to be removed from arr   Return Type (Type)  the member of arr that was at index This removes the member of arr with index index and returns it. It panics if there is no such member.   removeAll Removes all members of an array.   Parameters  arr any | error[] the array Panics if any member cannot be removed.   reverse (Type[] arr)  returns Type[] Reverses the order of the members of an array.   Parameters  arr Type[] the array to be reversed   Return Type (Type[])  arr with its members in reverse order   setLength Changes the length of an array.   Parameters  arr any | error[] the array of which to change the length   length int new length setLength(arr, 0) is equivalent to removeAll(arr).   shift (Type[] arr)  returns Type Removes and returns first member of an array. The array must not be empty.   Parameters  arr Type[] the array   Return Type (Type)  the value that was the first member of the array   slice (Type[] arr, int startIndex, int endIndex)  returns Type[] Returns a subarray starting from startIndex (inclusive) to endIndex (exclusive).   Parameters  arr Type[] the array   startIndex int index of first member to include in the slice   endIndex int (default arr.length(arr))  index of first member not to include in the slice   Return Type (Type[])  array slice within specified range   sort (Type[] arr, function(Type, Type) returns (int) func)  returns Type[] Sorts an array using a comparator function. The comparator function must return a value less than, equal to or greater than zero according as its first argument is to be ordered before, equal to or after its second argument.   Parameters  arr Type[] the array to be sorted   func function(Type, Type) returns (int) comparator function   Return Type (Type[])  arr with its members sorted   toBase16 (byte[] arr)  returns string Returns the string that is the Base16 representation of an array of bytes. The representation is the same as used by a Ballerina Base16Literal. The result will contain only characters 0..9, a..f. There will be no whitespace in the returned string.   Parameters  arr byte[] the array   Return Type (string)  Base16 string representation   toBase64 (byte[] arr)  returns string Returns the string that is the Base64 representation of an array of bytes. The representation is the same as used by a Ballerina Base64Literal. The result will contain only characters A..Z, a..z, 0..9, +, / and =. There will be no whitespace in the returned string.   Parameters  arr byte[] the array   Return Type (string)  Base64 string representation   toStream (Type[] arr)  returns stream Returns a stream from the given array.   Parameters  arr Type[] The array from which the stream is created   Return Type (stream)  The stream representation of the array arr   unshift Adds values to the start of an array. The values newly added to the array will be in the same order as they are in vals.   Parameters  arr Type[] the array   vals Type[] values to add to the start of the array"},{"page":"/learn/api-docs/ballerina/lang.array/objects/T1.html","name":"Object - : T1","summary":"() ...","content":"Objects  >  v1.2.2  All Modules  Object - :  T1  Methods  next ()  returns ? Return Type (?)"},{"page":"/learn/api-docs/ballerina/lang.boolean/functions.html","name":"Functions -","summary":"(string s)Converts a string to a boolean.\nReturns the boolean of which s is a string representation.\nThe accepted representations are true, false\n(in any combination of lower- and upper-case),\nand also 1 for true and 0 for false.\nThis is the inverse of value:toString applied to a boolean.\nstring representing a boolean valueboolean that s ...","content":"Functions  v1.2.2  All Modules  Functions - Converts a string to a boolean.  fromString (string s)  returns boolean | error Converts a string to a boolean. Returns the boolean of which s is a string representation. The accepted representations are true, false (in any combination of lower- and upper-case), and also 1 for true and 0 for false. This is the inverse of value:toString applied to a boolean.   Parameters  s string string representing a boolean value   Return Type (boolean | error)  boolean that s represents, or an error if there is no such boolean"},{"page":"/learn/api-docs/ballerina/lang.array/records/T2.html","name":"Record - : T2","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T2  Fields  value  Type"},{"page":"/learn/api-docs/ballerina/lang.boolean/","name":"Module : lang.boolean","summary":"This module provides lang library operations on boolean values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.boolean  Module Overview This module provides lang library operations on boolean values defined by the language specification 2020R1.    Functions Converts a string to a boolean."},{"page":"/learn/api-docs/ballerina/lang.array/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0  Fields  value  Type"},{"page":"/learn/api-docs/ballerina/lang.decimal/functions.html","name":"Functions -","summary":"(decimal x)IEEE abs operation.\ndecimal value to operate onabsolute value of x(decimal x)Rounds a decimal up to the closest integral value.\ndecimal value to operate onsmallest (closest to -∞) decimal value not less than x that is a mathematical integer(decimal x)Rounds a decimal down to the closest integral value.\ndecimal value to operate ...","content":"Functions  v1.2.2  All Modules  Functions - IEEE abs operation.  Rounds a decimal up to the closest integral value.  Rounds a decimal down to the closest integral value.  Return the decimal value represented by s.  Maximum of one or more decimal values.  Minimum of one or more decimal values   Round a decimal to the closest integral value.  Sum of zero or more decimal values.  abs (decimal x)  returns decimal IEEE abs operation.   Parameters  x decimal decimal value to operate on   Return Type (decimal)  absolute value of x   ceiling (decimal x)  returns decimal Rounds a decimal up to the closest integral value.   Parameters  x decimal decimal value to operate on   Return Type (decimal)  smallest (closest to -∞) decimal value not less than x that is a mathematical integer   floor (decimal x)  returns decimal Rounds a decimal down to the closest integral value.   Parameters  x decimal decimal value to operate on   Return Type (decimal)  largest (closest to +∞) decimal value not greater than x that is a mathematical integer.   fromString (string s)  returns decimal | error Return the decimal value represented by s. s must follow the syntax of DecimalFloatingPointNumber as defined by the Ballerina specification with the following modifications  the DecimalFloatingPointLiteral may have a leading + or - sign a FloatingPointTypeSuffix is not allowed This is the inverse of value:toString applied to an decimal.    Parameters  s string string representation of a decimal   Return Type (decimal | error)  decimal representation of the argument or error   max (decimal x, decimal[] xs)  returns decimal Maximum of one or more decimal values.   Parameters  x decimal first decimal value   xs decimal[] other decimal values   Return Type (decimal)  maximum value of x and all the xs   min (decimal x, decimal[] xs)  returns decimal Minimum of one or more decimal values   Parameters  x decimal first decimal value   xs decimal[] other decimal values   Return Type (decimal)  minimum value of x and all the xs.   round (decimal x)  returns decimal Round a decimal to the closest integral value. Returns the decimal value that is a mathematical integer and closest to x. If there are two such values, choose the one that is even (this is the round-to-nearest rounding mode, which is the default for IEEE and for Ballerina). Same as Java Math.rint method Same as .NET Math.Round method IEEE 754 roundToIntegralTiesToEven operation Note that <int>x is the same as <int>x.round()   Parameters  x decimal decimal value to operate on   Return Type (decimal)  closest decimal value to x that is a mathematical integer   sum (decimal[] xs)  returns decimal Sum of zero or more decimal values.   Parameters  xs decimal[] decimal values to sum   Return Type (decimal)  sum of all the xs; 0 if xs is empty"},{"page":"/learn/api-docs/ballerina/lang.decimal/","name":"Module : lang.decimal","summary":"This module provides lang library operations on decimal values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.decimal  Module Overview This module provides lang library operations on decimal values defined by the language specification 2020R1.    Functions IEEE abs operation.  Rounds a decimal up to the closest integral value.  Rounds a decimal down to the closest integral value.  Return the decimal value represented by s.  Maximum of one or more decimal values.  Minimum of one or more decimal values   Round a decimal to the closest integral value.  Sum of zero or more decimal values."},{"page":"/learn/api-docs/ballerina/lang.error/functions.html","name":"Functions -","summary":"( e)Returns the error's detail record.\nThe returned value will be immutable.\nthe error valueerror detail value( e)Returns the error's reason string.\nthe error valueerror reason(error e)Returns an object representing the stack trace of the error.\nthe error valuea new object representing the stack trace of the error value ...","content":"Functions  v1.2.2  All Modules  Functions - Returns the error's detail record.  Returns the error's reason string.  Returns an object representing the stack trace of the error.  detail ( e)  returns DetailType Returns the error's detail record. The returned value will be immutable.   Parameters  e the error value   Return Type (DetailType)  error detail value   reason ( e)  returns null Returns the error's reason string.   Parameters  e the error value   Return Type (null)  error reason   stackTrace (error e)  returns Returns an object representing the stack trace of the error.   Parameters  e error the error value   Return Type ()  a new object representing the stack trace of the error value"},{"page":"/learn/api-docs/ballerina/lang.error/","name":"Module : lang.error","summary":"This module provides lang library operations on error values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.error  Module Overview This module provides lang library operations on error values defined by the language specification 2020R1.    Records Representation of CallStackElement   The type to which error detail records must belong.  Objects Represent error call stack.  Functions Returns the error's detail record.  Returns the error's reason string.  Returns an object representing the stack trace of the error.  Errors"},{"page":"/learn/api-docs/ballerina/lang.error/objects/CallStack.html","name":"Object - : CallStack","summary":"Represent error call stack.\n\n            \n   ...","content":"Objects  >  v1.2.2  All Modules  Object - :  CallStack  Represent error call stack.   Fields  callStack  []  (default []) call stack"},{"page":"/learn/api-docs/ballerina/lang.error/records/CallStackElement.html","name":"Record - : CallStackElement","summary":"Representation of CallStackElement\n\n            \n    ...","content":"Records  v1.2.2  All Modules  Record - : CallStackElement  Representation of CallStackElement   Fields  callableName  string  Callable name   moduleName  string  Module name   fileName  string  File name   lineNumber  int  Line number"},{"page":"/learn/api-docs/ballerina/lang.error/records/Detail.html","name":"Record - : Detail","summary":"The type to which error detail records must belong.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  The type to which error detail records must belong.   Fields  message  string  the error message   cause  error  the error cause"},{"page":"/learn/api-docs/ballerina/lang.float/","name":"Module : lang.float","summary":"This module provides lang library operations on float values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.float  Module Overview This module provides lang library operations on float values defined by the language specification 2020R1.    Functions IEEE abs operation.  Returns the arccosine of a float value.  Returns the arcsine of a float value.  Returns the arctangent of a float value.  Performs the 2-argument arctangent operation.  Returns the cube root of a float value.  Rounds a float up to the closest integral value.  Returns the cosine of a float value.  Returns the hyperbolic cosine of a float value.  Raises Euler's number to a power.  Rounds a float down to the closest integral value.  Returns the float that is represented in IEEE 64-bit floating point by x.  Return the float value represented by s.  Return the float value represented by s.  Tests whether a float is finite.  Tests whether a float is infinite.  Tests whether a float is NaN.  Returns the natural logarithm of a float value Corresponds to IEEE log operation.  Returns the base 10 logarithm of a float value.  Maximum of zero or more float values.  Minimum of zero or more float values.  Raises one float value to the power of another float values.  Round a float value to the closest integral value.  Returns the sine of a float value.  Returns the hyperbolic sine of a float value.  Returns the square root of a float value.  Sum of zero or more float values.  Returns the tangent of a float value.  Returns the hyperbolic tangent of a float value.  Returns IEEE 64-bit binary floating point format representation of x as an int.  Returns a string that represents x as a hexadecimal floating point number.  Constants The number π   Euler's number   IEEE not-a-number value   IEEE positive infinity"},{"page":"/learn/api-docs/ballerina/lang.float/functions.html","name":"Functions -","summary":"(float x)IEEE abs operation.\nfloat value to operate onabsolute value of x(float x)Returns the arccosine of a float value.\nCorresponds to IEEE acos operation\nfloat value to operate onthe arccosine of x in radians(float x)Returns the arcsine of a float value.\nCorresponds to IEEE asin operation.\nfloat value to operate onthe arcsine of x in ...","content":"Functions  v1.2.2  All Modules  Functions - IEEE abs operation.  Returns the arccosine of a float value.  Returns the arcsine of a float value.  Returns the arctangent of a float value.  Performs the 2-argument arctangent operation.  Returns the cube root of a float value.  Rounds a float up to the closest integral value.  Returns the cosine of a float value.  Returns the hyperbolic cosine of a float value.  Raises Euler's number to a power.  Rounds a float down to the closest integral value.  Returns the float that is represented in IEEE 64-bit floating point by x.  Return the float value represented by s.  Return the float value represented by s.  Tests whether a float is finite.  Tests whether a float is infinite.  Tests whether a float is NaN.  Returns the natural logarithm of a float value Corresponds to IEEE log operation.  Returns the base 10 logarithm of a float value.  Maximum of zero or more float values.  Minimum of zero or more float values.  Raises one float value to the power of another float values.  Round a float value to the closest integral value.  Returns the sine of a float value.  Returns the hyperbolic sine of a float value.  Returns the square root of a float value.  Sum of zero or more float values.  Returns the tangent of a float value.  Returns the hyperbolic tangent of a float value.  Returns IEEE 64-bit binary floating point format representation of x as an int.  Returns a string that represents x as a hexadecimal floating point number.  abs (float x)  returns float IEEE abs operation.   Parameters  x float float value to operate on   Return Type (float)  absolute value of x   acos (float x)  returns float Returns the arccosine of a float value. Corresponds to IEEE acos operation   Parameters  x float float value to operate on   Return Type (float)  the arccosine of x in radians   asin (float x)  returns float Returns the arcsine of a float value. Corresponds to IEEE asin operation.   Parameters  x float float value to operate on   Return Type (float)  the arcsine of x in radians   atan (float x)  returns float Returns the arctangent of a float value. Corresponds to IEEE atan operation.   Parameters  x float float value to operate on   Return Type (float)  the arctangent of x in radians   atan2 (float y, float x)  returns float Performs the 2-argument arctangent operation. Corresponds IEEE atan2(y, x) operation.   Parameters  y float the y-coordinate   x float the x-coordinate   Return Type (float)  the angle in radians from the positive x-axis to the point whose Cartesian coordinates are (x, y)   cbrt (float x)  returns float Returns the cube root of a float value. Corresponds to IEEE rootn(x, 3) operation.   Parameters  x float float value to operate on   Return Type (float)  cube root of x   ceiling (float x)  returns float Rounds a float up to the closest integral value.   Parameters  x float float value to operate on   Return Type (float)  smallest (closest to -∞) decimal value not less than x that is a mathematical integer   cos (float x)  returns float Returns the cosine of a float value. Corresponds to IEEE cos operation.   Parameters  x float float value, specifying an angle in radians   Return Type (float)  the cosine of x   cosh (float x)  returns float Returns the hyperbolic cosine of a float value. Corresponds to IEEE cosh operation.   Parameters  x float float value to operate on   Return Type (float)  hyperbolic cosine of x   exp (float x)  returns float Raises Euler's number to a power. Corresponds to IEEE exp operation.   Parameters  x float float value to operate on   Return Type (float)  Euler's number raised to the power x   floor (float x)  returns float Rounds a float down to the closest integral value.   Parameters  x float float value to operate on   Return Type (float)  largest (closest to +∞) float value not greater than x that is a mathematical integer.   fromBitsInt (int x)  returns float Returns the float that is represented in IEEE 64-bit floating point by x. All bit patterns that IEEE defines to be NaNs will all be mapped to the single float NaN value.   Parameters  x int int value   Return Type (float)  x bit pattern as a float   fromHexString (string s)  returns float | error Return the float value represented by s. s must follow the syntax of HexFloatingPointLiteral as defined by the Ballerina specification with the following modifications  the HexFloatingPointLiteral may have a leading + or - sign NaN is allowed Infinity is allowed with an optional leading + or - sign    Parameters  s string hexadecimal floating point hex string representation   Return Type (float | error)  float value or error   fromString (string s)  returns float | error Return the float value represented by s. s must follow the syntax of DecimalFloatingPointNumber as defined by the Ballerina specification with the following modifications  the DecimalFloatingPointNumber may have a leading + or - sign NaN is allowed Infinity is allowed with an optional leading + or - sign a FloatingPointTypeSuffix is not allowed This is the inverse of value:toString applied to an float.    Parameters  s string string representation of a float   Return Type (float | error)  float value or error   isFinite (float x)  returns boolean Tests whether a float is finite. Exactly one of isFinite, isInfinite and IsNaN will be true for any float value   Parameters  x float the float to be tested   Return Type (boolean)  true if x is finite, i.e. neither NaN nor +∞ nor -∞   isInfinite (float x)  returns boolean Tests whether a float is infinite. Exactly one of isFinite, isInfinite and IsNaN will be true for any float value   Parameters  x float the float to be tested   Return Type (boolean)  true if x is either +∞ or -∞   isNaN (float x)  returns boolean Tests whether a float is NaN. Exactly one of isFinite, isInfinite and IsNaN will be true for any float value.   Parameters  x float the float to be tested   Return Type (boolean)  true if x is NaN   log (float x)  returns float Returns the natural logarithm of a float value Corresponds to IEEE log operation.   Parameters  x float float value to operate on   Return Type (float)  natural logarithm of x   log10 (float x)  returns float Returns the base 10 logarithm of a float value. Corresponds to IEEE log10 operation.   Parameters  x float float value to operate on   Return Type (float)  base 10 logarithm of x   max (float[] xs)  returns float Maximum of zero or more float values. Result is -∞ if no args NaN if any arg is NaN   Parameters  xs float[] float values to operate on   Return Type (float)  maximum value of all the xs   min (float[] xs)  returns float Minimum of zero or more float values. Result is +∞ if no args Result is NaN if any arg is NaN   Parameters  xs float[] float values to operate on   Return Type (float)  minimum value of all the xs   pow (float x, float y)  returns float Raises one float value to the power of another float values. Corresponds to IEEE pow(x, y) operation.   Parameters  x float base value   y float the exponent   Return Type (float)  x raised to the power of y   round (float x)  returns float Round a float value to the closest integral value. Returns the float value that is a mathematical integer and closest to x. If there are two such values, choose the one that is even (this is the round-to-nearest rounding mode, which is the default for IEEE and for Ballerina). Same as Java Math.rint method Same as .NET Math.Round method IEEE roundToIntegralTiesToEven operation Note that <int>x is the same as <int>x.round()   Parameters  x float float value to operate on   Return Type (float)  closest float value to x that is a mathematical integer   sin (float x)  returns float Returns the sine of a float value. Corresponds to IEEE sin operation.   Parameters  x float float value, specifying an angle in radians   Return Type (float)  the sine of x   sinh (float x)  returns float Returns the hyperbolic sine of a float value. Corresponds to IEEE sinh operation.   Parameters  x float float value to operate on   Return Type (float)  hyperbolic sine of x   sqrt (float x)  returns float Returns the square root of a float value. Corresponds to IEEE squareRoot operation.   Parameters  x float float value to operate on   Return Type (float)  square root of x   sum (float[] xs)  returns float Sum of zero or more float values. Result is NaN if any arg is NaN   Parameters  xs float[] float values to sum   Return Type (float)  sum of all the xs, +0.0 if xs is empty   tan (float x)  returns float Returns the tangent of a float value. Corresponds to IEEE tan operation   Parameters  x float float value, specifying an angle in radians   Return Type (float)  the tangent of x   tanh (float x)  returns float Returns the hyperbolic tangent of a float value. Corresponds to IEEE tanh operation.   Parameters  x float float value to operate on   Return Type (float)  hyperbolic tangent of x   toBitsInt (float x)  returns int Returns IEEE 64-bit binary floating point format representation of x as an int.   Parameters  x float float value   Return Type (int)  x bit pattern as an int   toHexString (float x)  returns string Returns a string that represents x as a hexadecimal floating point number. The returned string will comply to the grammar of HexFloatingPointLiteral in the Ballerina spec with the following modifications:  it will have a leading - sign if negative positive infinity will be represented by Infinity negative infinity will be represented by -Infinity NaN will be represented by NaN The representation includes 0x for finite numbers.    Parameters  x float float value   Return Type (string)  hexadecimal floating point hex string representation"},{"page":"/learn/api-docs/ballerina/lang.future/functions.html","name":"Functions -","summary":"Requests cancellation of a future.\nThis sets the cancellation flag in the strand corresponding to f.\nEach time that a strand yields, it will check the cancellation flag\nand terminate abnormally if the flag is set.\nthe future to be cancelled ...","content":"Functions  v1.2.2  All Modules  Functions - Requests cancellation of a future.  cancel Requests cancellation of a future. This sets the cancellation flag in the strand corresponding to f. Each time that a strand yields, it will check the cancellation flag and terminate abnormally if the flag is set.   Parameters  f future the future to be cancelled"},{"page":"/learn/api-docs/ballerina/lang.future/","name":"Module : lang.future","summary":"This module provides lang library operations on future values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.future  Module Overview This module provides lang library operations on future values defined by the language specification 2020R1.    Functions Requests cancellation of a future."},{"page":"/learn/api-docs/ballerina/lang.int/functions.html","name":"Functions -","summary":"(int n)Returns absolute value of an int.\nint value to be operated onabsolute value of n(string s)Returns the integer that s represents in hexadecimal.\nBoth uppercase A-F and lowercase a-f are allowed.\nIt may start with an optional + or - sign.\nNo 0x or 0X prefix is allowed.\nReturns an error if the s ...","content":"Functions  v1.2.2  All Modules  Functions - Returns absolute value of an int.  Returns the integer that s represents in hexadecimal.  Returns the integer that s represents in decimal.  Maximum of one or more int values.  Minimum of one or more int values   Returns sum of zero or more int values.  Returns representation of n as hexdecimal string.  abs (int n)  returns int Returns absolute value of an int.   Parameters  n int int value to be operated on   Return Type (int)  absolute value of n   fromHexString (string s)  returns int | error Returns the integer that s represents in hexadecimal. Both uppercase A-F and lowercase a-f are allowed. It may start with an optional + or - sign. No 0x or 0X prefix is allowed. Returns an error if the s is not in an allowed format.   Parameters  s string hexadecimal string representation of int value   Return Type (int | error)  int value or error   fromString (string s)  returns int | error Returns the integer that s represents in decimal. Returns error if s is not the decimal representation of an integer. The first character may be + or -. This is the inverse of value:toString applied to an int.   Parameters  s string string representation of a integer value   Return Type (int | error)  int representation of the argument or error   max (int n, int[] ns)  returns int Maximum of one or more int values.   Parameters  n int first int value   ns int[] other int values   Return Type (int)  maximum value of value of x and all the xs   min (int n, int[] ns)  returns int Minimum of one or more int values   Parameters  n int first int value   ns int[] other int values   Return Type (int)  minimum value of n and all the ns   sum (int[] ns)  returns int Returns sum of zero or more int values.   Parameters  ns int[] int values to sum   Return Type (int)  sum of all the ns; 0 is ns is empty   toHexString (int n)  returns string Returns representation of n as hexdecimal string. There is no 0x prefix. Lowercase letters a-f are used. Negative numbers will have a - prefix. No sign for non-negative numbers.   Parameters  n int int value   Return Type (string)  hexadecimal string representation of int value"},{"page":"/learn/api-docs/ballerina/lang.int/","name":"Module : lang.int","summary":"This module provides lang library operations on int values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.int  Module Overview This module provides lang library operations on int values defined by the language specification 2020R1.    Functions Returns absolute value of an int.  Returns the integer that s represents in hexadecimal.  Returns the integer that s represents in decimal.  Maximum of one or more int values.  Minimum of one or more int values   Returns sum of zero or more int values.  Returns representation of n as hexdecimal string.  Constants Maximum value of type int.  Minimum value of type int.  Maximum value of type Signed32.  Minimum value of type Signed32.  Maximum value of type Signed16.  Minimum value of type Signed16.  Maximum value of type Signed8.  Minimum value of type Signed8.  Maximum value of type Unsigned32.  Maximum value of type Unsigned16.  Maximum value of type Unsigned8."},{"page":"/learn/api-docs/ballerina/lang.map/functions.html","name":"Functions -","summary":"(map m)Returns a map containing [key, member] pair as the value for each key.\nthe mapa new map of [key, member] pairs(map m,  function(Type) returns (boolean)  func)Selects the members from a map for which a function returns true.\nthe mapa predicate to apply to each element to test whether it ...","content":"Functions  v1.2.2  All Modules  Functions - Returns a map containing [key, member] pair as the value for each key.  Selects the members from a map for which a function returns true.  Applies a function to each member of a map.  Returns the member of map m with key k.  Tests whether m has a member with key k.  Returns an iterator over a map.  Returns a list of all the keys of map m.  Returns number of members of a map.  Applies a function each member of a map and returns a map of the result.  Combines the members of a map using a combining function.  Removes a member of a map.  Removes all members of a map.  Removes a member of a map with a given key, if the map has member with the key.  Returns a list of all the members of a map.  entries (map m)  returns map Returns a map containing [key, member] pair as the value for each key.   Parameters  m map the map   Return Type (map)  a new map of [key, member] pairs   filter (map m, function(Type) returns (boolean) func)  returns map Selects the members from a map for which a function returns true.   Parameters  m map the map   func function(Type) returns (boolean) a predicate to apply to each element to test whether it should be included   Return Type (map)  new map containing members for which func evaluates to true   forEach Applies a function to each member of a map. The parameter func is applied to each member of m.   Parameters  m map the map   func function(Type) returns (()) a function to apply to each member   get (map m, string k)  returns Type Returns the member of map m with key k. This for use in a case where it is known that the map has a specific key, and accordingly panics if m does not have a member with key k.   Parameters  m map the map   k string the key   Return Type (Type)  member with key k   hasKey (map m, string k)  returns boolean Tests whether m has a member with key k.   Parameters  m map the map   k string the key   Return Type (boolean)  true if m has a member with key k   iterator (map m)  returns Returns an iterator over a map. The iterator will iterate over the members of the map not the keys. The entries function can be used to iterate over the keys and members together. The keys function can be used to iterator over just the keys.   Parameters  m map the map   Return Type ()  a new iterator object that will iterate over the members of m   keys (map m)  returns string[] Returns a list of all the keys of map m.   Parameters  m map the map   Return Type (string[])  a new list of all keys   length (map m)  returns int Returns number of members of a map.   Parameters  m map the map   Return Type (int)  number of members in m   map (map m, function(Type) returns (Type1) func)  returns map Applies a function each member of a map and returns a map of the result. The resulting map will have the same keys as the argument map.   Parameters  m map the map   func function(Type) returns (Type1) a function to apply to each member   Return Type (map)  new map containing result of applying parameter func to each member   reduce (map m, function(Type1, Type) returns (Type1) func, Type1 initial)  returns Type1 Combines the members of a map using a combining function. The combining function takes the combined value so far and a member of the map, and returns a new combined value.   Parameters  m map the map   func function(Type1, Type) returns (Type1) combining function   initial Type1 initial value for the first argument of combining parameter func   Return Type (Type1)  result of combining the members of m using func   remove (map m, string k)  returns Type Removes a member of a map.   Parameters  m map the map   k string the key   Return Type (Type)  the member of m that had key k This removed the member of m with key k and returns it. It panics if there is no such member.   removeAll Removes all members of a map. This panics if any member cannot be removed.   Parameters  m map the map   removeIfHasKey (map m, string k)  returns Type? Removes a member of a map with a given key, if the map has member with the key.   Parameters  m map the map   k string the key   Return Type (Type?)  the member of m that had key k, or () if m does not have a key k If m has a member with key k, it removes and returns it; otherwise it returns ().   toArray (map m)  returns Type[] Returns a list of all the members of a map.   Parameters  m map the map   Return Type (Type[])  an array whose members are the members of m"},{"page":"/learn/api-docs/ballerina/lang.map/","name":"Module : lang.map","summary":"This module provides lang library map operations defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.map  Module Overview This module provides lang library map operations defined by the language specification 2020R1.    Records Anonymous record  Anonymous record  Objects Functions Returns a map containing [key, member] pair as the value for each key.  Selects the members from a map for which a function returns true.  Applies a function to each member of a map.  Returns the member of map m with key k.  Tests whether m has a member with key k.  Returns an iterator over a map.  Returns a list of all the keys of map m.  Returns number of members of a map.  Applies a function each member of a map and returns a map of the result.  Combines the members of a map using a combining function.  Removes a member of a map.  Removes all members of a map.  Removes a member of a map with a given key, if the map has member with the key.  Returns a list of all the members of a map."},{"page":"/learn/api-docs/ballerina/lang.map/objects/T2.html","name":"Object - : T2","summary":"() ...","content":"Objects  >  v1.2.2  All Modules  Object - :  T2  Methods  next ()  returns ? Return Type (?)"},{"page":"/learn/api-docs/ballerina/lang.map/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0  Fields  value  Type"},{"page":"/learn/api-docs/ballerina/lang.map/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1  Fields  value  Type"},{"page":"/learn/api-docs/ballerina/lang.object/","name":"Module : lang.object","summary":"This module defines the shape expected from all listeners as defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.object  Module Overview This module defines the shape expected from all listeners as defined by the language specification 2020R1.    Objects Represents the shape expected from all listeners."},{"page":"/learn/api-docs/ballerina/lang.object/objects/Listener.html","name":"Object - : Listener","summary":"Represents the shape expected from all listeners.\n\n            ...","content":"Objects  >  v1.2.2  All Modules  Object - :  Listener  Represents the shape expected from all listeners.   Methods  Handle service attachment to the listener.  Handle service detachment from the listener.  Handle listener start.  Handle listener graceful stop.  Handle listener immediate stop.  __attach (service s, string? name)  returns error? Handle service attachment to the listener.   Parameters  s service the service to attach   name string? (default ())  optionally a name associated with the service   Return Type (error?)  () if no error occurred, and an error otherwise   __detach (service s)  returns error? Handle service detachment from the listener.   Parameters  s service the service to detach   Return Type (error?)  () if no error occurred, and an error otherwise   __start ()  returns error? Handle listener start.   Return Type (error?)  () if no error occurred, and an error otherwise   __gracefulStop ()  returns error? Handle listener graceful stop.   Return Type (error?)  () if no error occurred, and an error otherwise   __immediateStop ()  returns error? Handle listener immediate stop.   Return Type (error?)  () if no error occurred, and an error otherwise"},{"page":"/learn/api-docs/ballerina/lang.stream/","name":"Module : lang.stream","summary":"This module provides lang library operations on stream values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.stream  Module Overview This module provides lang library operations on stream values defined by the language specification 2020R1.    Records Anonymous record  Anonymous record  Objects Functions Closes a stream.  Selects the members from a stream for which a function returns true.  Applies a function to each member of a stream.  Returns an iterator over a stream.  Applies a function to each member of a stream and returns a stream of the results.  Returns the next element in the stream wrapped in a record or () if the stream ends.  Combines the members of a stream using a combining function."},{"page":"/learn/api-docs/ballerina/lang.stream/functions.html","name":"Functions -","summary":"(stream stm)Closes a stream.\nThis releases any system resources being used by the stream.\nthe stream to close() if the close completed successfully, otherwise an error(stream stm,  function(Type) returns (boolean)  func)Selects the members from a stream for which a function returns true.\nthe streama predicate to apply to each member to ...","content":"Functions  v1.2.2  All Modules  Functions - Closes a stream.  Selects the members from a stream for which a function returns true.  Applies a function to each member of a stream.  Returns an iterator over a stream.  Applies a function to each member of a stream and returns a stream of the results.  Returns the next element in the stream wrapped in a record or () if the stream ends.  Combines the members of a stream using a combining function.  close (stream stm)  returns ErrorType? Closes a stream. This releases any system resources being used by the stream.   Parameters  stm stream the stream to close   Return Type (ErrorType?)  () if the close completed successfully, otherwise an error   filter (stream stm, function(Type) returns (boolean) func)  returns stream Selects the members from a stream for which a function returns true.   Parameters  stm stream the stream   func function(Type) returns (boolean) a predicate to apply to each member to test whether it should be selected   Return Type (stream)  new stream only containing members of stm for which func evaluates to true   forEach (stream stm, function(Type) returns (()) func)  returns ErrorType? Applies a function to each member of a stream. The Combining function is applied to each member of stream in order.   Parameters  stm stream the stream   func function(Type) returns (()) a function to apply to each member   Return Type (ErrorType?)  An error if iterating the stream encounters an error   iterator (stream stm)  returns Returns an iterator over a stream.   Parameters  stm stream the stream   Return Type ()  a new iterator object that will iterate over the members of stm.   map (stream stm, function(Type) returns (Type1) func)  returns stream Applies a function to each member of a stream and returns a stream of the results.   Parameters  stm stream the stream   func function(Type) returns (Type1) a function to apply to each member   Return Type (stream)  new stream containing result of applying func to each member of stm in order   next (stream strm)  returns | ErrorType | () Returns the next element in the stream wrapped in a record or () if the stream ends.   Parameters  strm stream The stream   Return Type ( | ErrorType | ())  If the stream has elements, return the element wrapped in a record with single field called value, otherwise returns ()   reduce (stream stm, function(Type1, Type) returns (Type1) func, Type1 initial)  returns Type1 | ErrorType Combines the members of a stream using a combining function. The combining function takes the combined value so far and a member of the stream, and returns a new combined value.   Parameters  stm stream the stream   func function(Type1, Type) returns (Type1) combining function   initial Type1 initial value for the first argument of combining function   Return Type (Type1 | ErrorType)  result of combining the members of stm using the combining function"},{"page":"/learn/api-docs/ballerina/lang.stream/objects/T0.html","name":"Object - : T0","summary":"(stream strm,  function(Type) returns (boolean) ...","content":"Objects  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  T0  Constructor __init(stream strm, function(Type) returns (boolean) func)   strm stream func function(Type) returns (boolean) Methods  Fields  strm  stream  func  any  next ()  returns | ErrorType | () Return Type ( | ErrorType | ())"},{"page":"/learn/api-docs/ballerina/lang.stream/objects/T3.html","name":"Object - : T3","summary":"() ...","content":"Objects  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  T3  Methods  next ()  returns | ErrorType | () Return Type ( | ErrorType | ())"},{"page":"/learn/api-docs/ballerina/lang.stream/objects/T2.html","name":"Object - : T2","summary":"() ...","content":"Objects  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  T2  Methods  next ()  returns | ErrorType | () Return Type ( | ErrorType | ())"},{"page":"/learn/api-docs/ballerina/lang.stream/objects/T4.html","name":"Object - : T4","summary":"(stream strm,  function(Type) returns (Type1) ...","content":"Objects  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  T4  Constructor __init(stream strm, function(Type) returns (Type1) func)   strm stream func function(Type) returns (Type1) Methods  Fields  strm  stream  func  any  next ()  returns | ErrorType | () Return Type ( | ErrorType | ())"},{"page":"/learn/api-docs/ballerina/lang.stream/objects/T6.html","name":"Object - : T6","summary":"() ...","content":"Objects  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  T6  Methods  next ()  returns | ErrorType | () Return Type ( | ErrorType | ())"},{"page":"/learn/api-docs/ballerina/lang.stream/objects/T7.html","name":"Object - : T7","summary":"()() ...","content":"Objects  >  >  >  >  >  >  v1.2.2  All Modules  Object - :  T7  Methods  next ()  returns | ErrorType | () Return Type ( | ErrorType | ())  close ()  returns ErrorType? Return Type (ErrorType?)"},{"page":"/learn/api-docs/ballerina/lang.stream/records/T5.html","name":"Record - : T5","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T5  Fields  value  Type"},{"page":"/learn/api-docs/ballerina/lang.stream/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1  Fields  value  Type"},{"page":"/learn/api-docs/ballerina/lang.string/functions.html","name":"Functions -","summary":"(string str1, string str2)Lexicographically compares strings using their Unicode code points.\nThis orders strings in a consistent and well-defined way,\nbut the ordering will often not be consistent with cultural expectations\nfor sorted order.\nthe first string to be comparedthe second string to be comparedan int that is less than, equal to or greater ...","content":"Functions  v1.2.2  All Modules  Functions - Lexicographically compares strings using their Unicode code points.  Concatenates zero or more strings.  Tests whether a string ends with another string.  Tests whether two strings are the same, ignoring the case of ASCII characters.  Constructs a string from its UTF-8 representation in bytes.  Constructs a single character string from a code point.  Constructs a string from an array of code points.  Returns the code point of a character in a string.  Finds the first occurrence of one string in another string.  Returns an iterator over the string.  Joins zero or more strings together with a separator.  Finds the last occurrence of one string in another string.  Returns the length of the string.  Tests whether a string starts with another string.  Returns a substring of a string.  Represents str as an array of bytes using UTF-8.  Converts a single character string to a code point.  Converts a string to an array of code points.  Converts occurrences of A-Z to a-z.  Converts occurrences of a-z to A-Z.  Removes ASCII white space characters from the start and end of a string.  codePointCompare (string str1, string str2)  returns int Lexicographically compares strings using their Unicode code points. This orders strings in a consistent and well-defined way, but the ordering will often not be consistent with cultural expectations for sorted order.   Parameters  str1 string the first string to be compared   str2 string the second string to be compared   Return Type (int)  an int that is less than, equal to or greater than zero, according as str1 is less than, equal to or greater than str2   concat (string[] strs)  returns string Concatenates zero or more strings.   Parameters  strs string[] strings to be concatenated   Return Type (string)  concatenation of all of the strs; empty string if strs is empty   endsWith (string str, string substr)  returns boolean Tests whether a string ends with another string.   Parameters  str string the string to be tested   substr string the ending string   Return Type (boolean)  true if str ends with substr; false otherwise   equalsIgnoreCaseAscii (string str1, string str2)  returns boolean Tests whether two strings are the same, ignoring the case of ASCII characters. A character in the range a-z is treated the same as the corresponding character in the range A-Z.   Parameters  str1 string the first string to be compared   str2 string the second string to be compared   Return Type (boolean)  true if str1 is the same as str2, treating upper-case and lower-case ASCII letters as the same; false, otherwise   fromBytes (byte[] bytes)  returns string | error Constructs a string from its UTF-8 representation in bytes.   Parameters  bytes byte[] UTF-8 byte array   Return Type (string | error)  bytes converted to string or error   fromCodePointInt (int codePoint)  returns | error Constructs a single character string from a code point. An int is a valid code point if it is in the range 0 to 0x10FFFF inclusive, but not in the range 0xD800 or 0xDFFF inclusive.   Parameters  codePoint int an int specifying a code point   Return Type ( | error)  a single character string whose code point is codePoint; or an error if codePoint is not a valid code point   fromCodePointInts (int[] codePoints)  returns string | error Constructs a string from an array of code points. An int is a valid code point if it is in the range 0 to 0x10FFFF inclusive, but not in the range 0xD800 or 0xDFFF inclusive.   Parameters  codePoints int[] an array of ints, each specifying a code point   Return Type (string | error)  a string with a character for each code point in codePoints; or an error if any member of codePoints is not a valid code point   getCodePoint (string str, int index)  returns int Returns the code point of a character in a string.   Parameters  str string the string   index int an index in str   Return Type (int)  the Unicode code point of the character at index in str   indexOf (string str, string substr, int startIndex)  returns int? Finds the first occurrence of one string in another string.   Parameters  str string the string in which to search   substr string the string to search for   startIndex int (default 0)  index to start searching from   Return Type (int?)  index of the first occurrence of substr in str that is >= startIndex, or () if there is no such occurrence   iterator (string str)  returns Returns an iterator over the string. The iterator will yield the substrings of length 1 in order.   Parameters  str string the string to be iterated over   Return Type ()  a new iterator object   join (string separator, string[] strs)  returns string Joins zero or more strings together with a separator.   Parameters  separator string separator string   strs string[] strings to be joined   Return Type (string)  a string consisting of all of strs concatenated in order with separator in between them   lastIndexOf (string str, string substr, int startIndex)  returns int? Finds the last occurrence of one string in another string.   Parameters  str string the string in which to search   substr string the string to search for   startIndex int (default str.length(str) - substr.length(substr))  index to start searching backwards from   Return Type (int?)  index of the last occurrence of substr in str that is <= startIndex, or () if there is no such occurrence   length (string str)  returns int Returns the length of the string.   Parameters  str string the string   Return Type (int)  the number of characters (code points) in str   startsWith (string str, string substr)  returns boolean Tests whether a string starts with another string.   Parameters  str string the string to be tested   substr string the starting string   Return Type (boolean)  true if str starts with substr; false otherwise   substring (string str, int startIndex, int endIndex)  returns string Returns a substring of a string.   Parameters  str string source string.   startIndex int the starting index, inclusive   endIndex int (default str.length(str))  the ending index, exclusive   Return Type (string)  substring consisting of characters with index >= startIndex and < endIndex   toBytes (string str)  returns byte[] Represents str as an array of bytes using UTF-8.   Parameters  str string the string   Return Type (byte[])  UTF-8 byte array   toCodePointInt ( ch)  returns int Converts a single character string to a code point.   Parameters  ch a single character string   Return Type (int)  the code point of ch   toCodePointInts (string str)  returns int[] Converts a string to an array of code points.   Parameters  str string the string   Return Type (int[])  an array with a code point for each character of str   toLowerAscii (string str)  returns string Converts occurrences of A-Z to a-z. Other characters are left unchanged.   Parameters  str string the string to be converted   Return Type (string)  str with any occurrences of A-Z converted to a-z   toUpperAscii (string str)  returns string Converts occurrences of a-z to A-Z. Other characters are left unchanged.   Parameters  str string the string to be converted   Return Type (string)  str with any occurrences of a-z converted to A-Z   trim (string str)  returns string Removes ASCII white space characters from the start and end of a string. The ASCII white space characters are 0x9...0xD, 0x20.   Parameters  str string the string   Return Type (string)  str with leading or trailing ASCII white space characters removed"},{"page":"/learn/api-docs/ballerina/lang.string/objects/T2.html","name":"Object - : T2","summary":"() ...","content":"Objects  >  v1.2.2  All Modules  Object - :  T2  Methods  next ()  returns ? Return Type (?)"},{"page":"/learn/api-docs/ballerina/lang.string/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0  Fields  value  string"},{"page":"/learn/api-docs/ballerina/lang.string/","name":"Module : lang.string","summary":"This module provides lang library string operations defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.string  Module Overview This module provides lang library string operations defined by the language specification 2020R1.    Records Anonymous record  Anonymous record  Objects Functions Lexicographically compares strings using their Unicode code points.  Concatenates zero or more strings.  Tests whether a string ends with another string.  Tests whether two strings are the same, ignoring the case of ASCII characters.  Constructs a string from its UTF-8 representation in bytes.  Constructs a single character string from a code point.  Constructs a string from an array of code points.  Returns the code point of a character in a string.  Finds the first occurrence of one string in another string.  Returns an iterator over the string.  Joins zero or more strings together with a separator.  Finds the last occurrence of one string in another string.  Returns the length of the string.  Tests whether a string starts with another string.  Returns a substring of a string.  Represents str as an array of bytes using UTF-8.  Converts a single character string to a code point.  Converts a string to an array of code points.  Converts occurrences of A-Z to a-z.  Converts occurrences of a-z to A-Z.  Removes ASCII white space characters from the start and end of a string."},{"page":"/learn/api-docs/ballerina/lang.string/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1  Fields  value  string"},{"page":"/learn/api-docs/ballerina/lang.table/functions.html","name":"Functions -","summary":"(table tbl, RowType data)Add record to the table.\ntable to operate onA record with dataAn error will be returned if there is any error occurred during adding data or else nil is returnedReleases the database connection. If the table data is fully iterated, it will be automatically closed. This explicit\nclose is ...","content":"Functions  v1.2.2  All Modules  Functions - Add record to the table.  Releases the database connection.  Retrives the current row and return a record with the data in the columns.  Checks for a new row in the given table.  Returns an iterator over the members of tbl.  Remove data from the table.  add (table tbl, RowType data)  returns error | () Add record to the table.   Parameters  tbl table table to operate on   data RowType A record with data   Return Type (error | ())  An error will be returned if there is any error occurred during adding data or else nil is returned   close Releases the database connection. If the table data is fully iterated, it will be automatically closed. This explicit close is required only if it is not fully iterated.   Parameters  tbl table table to operate on   getNext (table tbl)  returns RowType Retrives the current row and return a record with the data in the columns.   Parameters  tbl table table to operate on   Return Type (RowType)  The resulting row as a record   hasNext (table tbl)  returns boolean Checks for a new row in the given table. If a new row is found, moves the cursor to it.   Parameters  tbl table table to operate on   Return Type (boolean)  True if there is a new row; false otherwise   iterator (table tbl)  returns Returns an iterator over the members of tbl. The iterator will iterate over the rows of the table in order.   Parameters  tbl table table to operate on   Return Type ()  an iterator over tbl   remove (table tbl, function(RowType) returns (boolean) func)  returns int | error Remove data from the table.   Parameters  tbl table table to operate on   func function(RowType) returns (boolean) The function pointer for delete crieteria   Return Type (int | error)  An int the number of deleted record count or error if any error occurred during removing data"},{"page":"/learn/api-docs/ballerina/lang.table/","name":"Module : lang.table","summary":"This module provides lang library operations on table values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.table  Module Overview This module provides lang library operations on table values defined by the language specification 2020R1.    Records Anonymous record  Anonymous record  Objects Functions Add record to the table.  Releases the database connection.  Retrives the current row and return a record with the data in the columns.  Checks for a new row in the given table.  Returns an iterator over the members of tbl.  Remove data from the table."},{"page":"/learn/api-docs/ballerina/lang.table/objects/T2.html","name":"Object - : T2","summary":"() ...","content":"Objects  >  v1.2.2  All Modules  Object - :  T2  Methods  next ()  returns ? Return Type (?)"},{"page":"/learn/api-docs/ballerina/lang.table/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0  Fields  value  RowType"},{"page":"/learn/api-docs/ballerina/lang.table/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1  Fields  value  RowType"},{"page":"/learn/api-docs/ballerina/lang.typedesc/","name":"Module : lang.typedesc","summary":"This module provides lang library operations on typedesc values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.typedesc  Module Overview This module provides lang library operations on typedesc values defined by the language specification 2020R1.    Functions Constructs a value with a specified type by copying another value."},{"page":"/learn/api-docs/ballerina/lang.typedesc/functions.html","name":"Functions -","summary":"(typedesc t, anydata v)Constructs a value with a specified type by copying another value.\nthe type for the copy to be constructedthe value to be copieda new value that belongs to the type of t, or an error if this cannot be doneWhen v is a structural value, the inherent type ...","content":"Functions  v1.2.2  All Modules  Functions - Constructs a value with a specified type by copying another value.  constructFrom (typedesc t, anydata v)  returns null | error Constructs a value with a specified type by copying another value.   Parameters  t typedesc the type for the copy to be constructed   v anydata the value to be copied   Return Type (null | error)  a new value that belongs to the type of t, or an error if this cannot be done When v is a structural value, the inherent type of the value to be constructed comes from t. When t is a union, it must be possible to determine which member of the union to use for the inherent type by following the same rules that are used by list constructor expressions and mapping constructor expressions with the contextually expected type. If not, then an error is returned. The constructFrom operation is recursively applied to each member of v using the type descriptor that the inherent type requires for that member. Like the Clone abstract operation, this does a deep copy, but differs in the following respects:  the inherent type of any structural values constructed comes from the specified type descriptor rather than the value being constructed the graph structure of v is not preserved; the result will always be a tree; an error will be returned if v has cycles immutable structural values are copied rather being returned as is; all structural values in the result will be mutable, except for error values (which are always immutable) numeric values can be converted using the NumericConvert abstract operation if a record type descriptor specifies default values, these will be used to supply any missing members"},{"page":"/learn/api-docs/ballerina/lang.value/","name":"Module : lang.value","summary":"This module provides lang library operations common to all values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.value  Module Overview This module provides lang library operations common to all values defined by the language specification 2020R1.    Functions Returns a clone of v.  Returns a clone of v that is read-only, i.  Parses a string in JSON format and returns the the value that it represents.  Tests whether v is read-only, i.  Merges two json values.  Returns the string that represents v in JSON format.  Performs a minimal conversion of a value to a string."},{"page":"/learn/api-docs/ballerina/lang.value/functions.html","name":"Functions -","summary":"(null v)Returns a clone of v.\nA clone is a deep copy that does not copy immutable subtrees.\nA clone can therefore safely be used concurrently with the original.\nIt corresponds to the Clone(v) abstract operation,\ndefined in the Ballerina Language Specification.\nsource valueclone of v(null v)Returns a clone of v that is read-only, i.e. ...","content":"Functions  v1.2.2  All Modules  Functions - Returns a clone of v.  Returns a clone of v that is read-only, i.  Parses a string in JSON format and returns the the value that it represents.  Tests whether v is read-only, i.  Merges two json values.  Returns the string that represents v in JSON format.  Performs a minimal conversion of a value to a string.  clone (null v)  returns null Returns a clone of v. A clone is a deep copy that does not copy immutable subtrees. A clone can therefore safely be used concurrently with the original. It corresponds to the Clone(v) abstract operation, defined in the Ballerina Language Specification.   Parameters  v null source value   Return Type (null)  clone of v   cloneReadOnly (null v)  returns null Returns a clone of v that is read-only, i.e. immutable. It corresponds to the ImmutableClone(v) abstract operation, defined in the Ballerina Language Specification.   Parameters  v null source value   Return Type (null)  immutable clone of v   fromJsonString (string str)  returns json | error Parses a string in JSON format and returns the the value that it represents. All numbers in the JSON will be represented as float values. Returns an error if the string cannot be parsed.   Parameters  str string string representation of json   Return Type (json | error)  str parsed to json or error   isReadOnly (anydata v)  returns boolean Tests whether v is read-only, i.e. immutable Returns true if read-only, false otherwise.   Parameters  v anydata source value   Return Type (boolean)  true if read-only, false otherwise   mergeJson (json j1, json j2)  returns json | error Merges two json values.   Parameters  j1 json json value   j2 json json value   Return Type (json | error)  the merge of j1 with j2 or an error if the merge fails The merge of j1 with j2 is defined as follows:  if j1 is (), then the result is j2 if j2 is (), then the result is j1 if j1 is a mapping and j2 is a mapping, then for each entry [k, j] in j2, set j1[k] to the merge of j1[k] with j  if j1[k] is undefined, then set j1[k] to j if any merge fails, then the merge of j1 with j2 fails otherwise, the result is j1.   otherwise, the merge fails If the merge fails, then j1 is unchanged.    toJsonString (json v)  returns string Returns the string that represents v in JSON format.   Parameters  v json json value   Return Type (string)  string representation of json   toString (any | error v)  returns string Performs a minimal conversion of a value to a string. The conversion is minimal in particular in the sense that the conversion applied to a value that is already a string does nothing.   Parameters  v any | error the value to be converted to a string   Return Type (string)  a string resulting from the conversion The result of toString(v) is as follows:  if v is a string, then returns v if v is (), then returns an empty string if v is boolean, then the string true or false if v is an int, then return v represented as a decimal string if v is a float or decimal, then return v represented as a decimal string, with a decimal point only if necessary, but without any suffix indicating the type of v; return NaN, Infinity for positive infinity, and -Infinity for negative infinity if v is a list, then returns the results toString on each member of the list separated by a space character if v is a map, then returns key=value for each member separated by a space character if v is xml, then returns v in XML format (as if it occurred within an XML element) if v is table, TBD if v is an error, then a string consisting of the following in order  the string error a space character the reason string if the detail record is non-empty  a space character the result of calling toString on the detail record     if v is an object, then  if v provides a toString method with a string return type and no required methods, then the result of calling that method on v otherwise, object followed by some implementation-dependent string   if v is any other behavioral type, then the identifier for the behavioral type (function, future, service, typedesc or handle) followed by some implementation-dependent string  Note that toString may produce the same string for two Ballerina values that are not equal (in the sense of the == operator)."},{"page":"/learn/api-docs/ballerina/lang.xml/","name":"Module : lang.xml","summary":"This module provides lang library operations on xml values defined by the language specification 2020R1. ...","content":"v1.2.2  All Modules  Module : lang.xml  Module Overview This module provides lang library operations on xml values defined by the language specification 2020R1.    Records Anonymous record  Anonymous record  Objects Functions Concatenates xml and string values.  Constructs an xml sequence consisting of only a comment item.  Constructs an xml sequence consisting of only a new element item.  Constructs an xml sequence consisting of only a processing instruction item.  Selects the elements from an xml value.  Selects the items from an xml sequence for which a function returns true.  Applies a function to each item in an xml sequence.  Constructs an xml value from a string.  Returns the item of x with index i.  Returns the map representing the attributes of elem.  Returns the children of elem.  Returns the content of a text or processing instruction or comment item.  Returns a string giving the expanded name of elem.  Returns the target part of the processing instruction.  Returns an iterator over the xml items of x   Returns number of xml items in x.  Applies a function to each item in an xml sequence, and returns an xml sequence of the results.  Sets the children of elem to children.  Change the name of element elem to xName.  Returns a subsequence of an xml value.  Strips the insignificant parts of the an xml value.  Constants The namespace URI bound to the xml prefix.  The namespace URI bound to the xmlns prefix.  The expanded name of the xml:space attribute.  The expanded name of the xml:lang attribute.  The expanded name of the xml:base attribute."},{"page":"/learn/api-docs/ballerina/lang.xml/functions.html","name":"Functions -","summary":"(xml | string[] xs)Concatenates xml and string values.\nxml or string items to concatenatean xml sequence that is the concatenation of all the xs;\nan empty xml sequence if the xs are empty(string content)Constructs an xml sequence consisting of only a comment item.\nthe content of the comment to be constructed.an xml sequence ...","content":"Functions  v1.2.2  All Modules  Functions - Concatenates xml and string values.  Constructs an xml sequence consisting of only a comment item.  Constructs an xml sequence consisting of only a new element item.  Constructs an xml sequence consisting of only a processing instruction item.  Selects the elements from an xml value.  Selects the items from an xml sequence for which a function returns true.  Applies a function to each item in an xml sequence.  Constructs an xml value from a string.  Returns the item of x with index i.  Returns the map representing the attributes of elem.  Returns the children of elem.  Returns the content of a text or processing instruction or comment item.  Returns a string giving the expanded name of elem.  Returns the target part of the processing instruction.  Returns an iterator over the xml items of x   Returns number of xml items in x.  Applies a function to each item in an xml sequence, and returns an xml sequence of the results.  Sets the children of elem to children.  Change the name of element elem to xName.  Returns a subsequence of an xml value.  Strips the insignificant parts of the an xml value.  concat (xml | string[] xs)  returns xml Concatenates xml and string values.   Parameters  xs xml | string[] xml or string items to concatenate   Return Type (xml)  an xml sequence that is the concatenation of all the xs; an empty xml sequence if the xs are empty   createComment (string content)  returns Constructs an xml sequence consisting of only a comment item.   Parameters  content string the content of the comment to be constructed.   Return Type ()  an xml sequence consisting of a comment with content content   createElement (string name, xml children)  returns Constructs an xml sequence consisting of only a new element item.   Parameters  name string the name of the new element   children xml (default concat())  the children of the new element   Return Type ()  an xml sequence consisting of only a new xml element with name name, no attributes, and children children   createProcessingInstruction (string target, string content)  returns Constructs an xml sequence consisting of only a processing instruction item.   Parameters  target string the target part of the processing instruction to be constructed   content string the content part of the processing instruction to be constructed   Return Type ()  an xml sequence consisting of a processing instruction with target target and content content   elements (xml x)  returns xml Selects the elements from an xml value.   Parameters  x xml the xml value   Return Type (xml)  an xml sequence consisting of all the element items in x   filter (xml x, function(ItemType) returns (boolean) func)  returns xml Selects the items from an xml sequence for which a function returns true. Each item is represented as a singleton value.   Parameters  x xml xml value   func function(ItemType) returns (boolean) a predicate to apply to each item to test whether it should be selected   Return Type (xml)  new xml sequence containing items in x for which func evaluates to true   forEach Applies a function to each item in an xml sequence. Each item is represented as a singleton value.   Parameters  x xml the xml value   func function(ItemType) returns (()) a function to apply to each item in x   fromString (string s)  returns xml | error Constructs an xml value from a string. This parses the string using the content production of the XML 1.0 Recommendation.   Parameters  s string a string in XML format   Return Type (xml | error)  xml value resulting from parsing s, or an error   get (xml x, int i)  returns xml Returns the item of x with index i. This differs from x[i] in that it panics if x does not have an item with index i.   Parameters  x xml the xml sequence   i int the index   Return Type (xml)  the item with index i in x   getAttributes ( x)  returns map Returns the map representing the attributes of elem. This includes namespace attributes. The keys in the map are the expanded names of the attributes.   Parameters  x xml element   Return Type (map)  attributes of x   getChildren ( elem)  returns xml Returns the children of elem.   Parameters  elem xml element   Return Type (xml)  children of elem   getContent ( | | x)  returns string Returns the content of a text or processing instruction or comment item.   Parameters  x | | xml item   Return Type (string)  the content of x   getName ( elem)  returns string Returns a string giving the expanded name of elem.   Parameters  elem xml element   Return Type (string)  element name   getTarget ( x)  returns string Returns the target part of the processing instruction.   Parameters  x xml processing instruction item   Return Type (string)  target part of x   iterator (xml x)  returns Returns an iterator over the xml items of x   Parameters  x xml xml sequence to iterate over   Return Type ()  iterator object Each item is represented by an xml singleton.   length (xml x)  returns int Returns number of xml items in x.   Parameters  x xml xml item   Return Type (int)  number of XML items in x   map (xml x, function(ItemType) returns (XmlType) func)  returns xml Applies a function to each item in an xml sequence, and returns an xml sequence of the results. Each item is represented as a singleton value.   Parameters  x xml the xml value   func function(ItemType) returns (XmlType) a function to apply to each child or item   Return Type (xml)  new xml value containing result of applying func to each child or item   setChildren Sets the children of elem to children. This panics if it would result in the element structure becoming cyclic.   Parameters  elem xml element   children xml | string xml or string to set as children   setName Change the name of element elem to xName.   Parameters  elem xml element   xName string new expanded name   slice (xml x, int startIndex, int endIndex)  returns xml Returns a subsequence of an xml value.   Parameters  x xml the xml value   startIndex int start index, inclusive   endIndex int (default x.length(x))  end index, exclusive   Return Type (xml)  a subsequence of x consisting of items with index >= startIndex and < endIndex   strip (xml x)  returns xml Strips the insignificant parts of the an xml value. Comment items, processing instruction items are considered insignificant. After removal of comments and processing instructions, the text is grouped into the biggest possible chunks (i.e. only elements cause division into multiple chunks) and a chunk is considered insignificant if the entire chunk is whitespace.   Parameters  x xml the xml value   Return Type (xml)  x with insignificant parts removed"},{"page":"/learn/api-docs/ballerina/lang.xml/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0  Fields  value  xml | string"},{"page":"/learn/api-docs/ballerina/lang.xml/objects/T7.html","name":"Object - : T7","summary":"() ...","content":"Objects  >  v1.2.2  All Modules  Object - :  T7  Methods  next ()  returns ? Return Type (?)"},{"page":"/learn/api-docs/ballerina/lang.xml/records/T6.html","name":"Record - : T6","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T6  Fields  value  xml | string"},{"page":"/learn/api-docs/ballerina/ldap/functions.html","name":"Functions -","summary":"( ldapConnection, string username, string password)Authenticates with the username and password.\nThe ldap:LdapConnection instanceUsername of the user to be authenticatedPassword of the user to be authenticatedtrue if authentication is successful, false otherwise, or else an ldap:Error if an error occurred( ldapConnection, handle username, handle password)( ldapConnectionConfig, handle instanceId)( ldapConnection, string username)Retrieves ...","content":"Functions  v1.2.2  All Modules  Functions - Authenticates with the username and password.  Retrieves the group(s) of the user related to the provided username.  Initailizes the LDAP connection context.  doAuthenticate ( ldapConnection, string username, string password)  returns boolean | Authenticates with the username and password.  boolean|ldap:Error result = ldap:doAuthenticate(ldapConnection, username, password);    Parameters  ldapConnection The ldap:LdapConnection instance   username string Username of the user to be authenticated   password string Password of the user to be authenticated   Return Type (boolean | )  true if authentication is successful, false otherwise, or else an ldap:Error if an error occurred   externDoAuthenticate ( ldapConnection, handle username, handle password)  returns boolean | Parameters  ldapConnection username handle password handle Return Type (boolean | )  externInitLdapConnectionContext ( ldapConnectionConfig, handle instanceId)  returns | Parameters  ldapConnectionConfig instanceId handle Return Type ( | )  getGroups ( ldapConnection, string username)  returns string[] | Retrieves the group(s) of the user related to the provided username.  string[]|ldap:Error groups = ldap:getGroups(ldapConnection, username);    Parameters  ldapConnection The ldap:LdapConnection instance   username string Username of the user to be checked for the groups   Return Type (string[] | )  Array of groups of the provided user or else an ldap:Error if it fails   initLdapConnectionContext ( ldapConnectionConfig, string instanceId)  returns | Initailizes the LDAP connection context.  ldap:LdapConnection|ldap:Error connection = ldap:initLdapConnectionContext(ldapConnectionConfig, instanceId);    Parameters  ldapConnectionConfig The ldap:LdapConnectionConfig instance   instanceId string Instance ID of the endpoint   Return Type ( | )  The ldap:LdapConnection instance or else an ldap:Error if an error occurred"},{"page":"/learn/api-docs/ballerina/ldap/","name":"Module : ldap","summary":"This module provides an inbound LDAP authentication provider, which is used to authenticate using LDAP credentials.For information on the operations, which you can perform with this module, see the below Functions. For an example on the usage of the operations, see the . ...","content":"v1.2.2  All Modules  Module : ldap  Module Overview This module provides an inbound LDAP authentication provider, which is used to authenticate using LDAP credentials. For information on the operations, which you can perform with this module, see the below Functions. For an example on the usage of the operations, see the .    Records Represets the LDAP connection.  Represents the configurations that are required for an LDAP auth store.  Configures the SSL/TLS options to be used for LDAP communication.  Objects Represents the inbound LDAP auth provider.  Functions Authenticates with the username and password.  Retrieves the group(s) of the user related to the provided username.  Initailizes the LDAP connection context.  Constants Represents the LDAP error reason.  Errors Represents the LDAP error type with details."},{"page":"/learn/api-docs/ballerina/ldap/objects/InboundLdapAuthProvider.html","name":"Object - : InboundLdapAuthProvider","summary":"Represents the inbound LDAP auth provider. This connects to an active directory or an LDAP, retrieves the necessary\nuser ...","content":"Objects  >  v1.2.2  All Modules  Object - :  InboundLdapAuthProvider  Represents the inbound LDAP auth provider. This connects to an active directory or an LDAP, retrieves the necessary user information, and performs authentication and authorization. The ldap:InboundLdapAuthProvider is another implementation of the auth:InboundAuthProvider interface.  ldap:InboundLdapAuthProvider inboundLdapAuthProvider = new(ldapConfig, \"instanceId\");    Constructor __init( ldapConnectionConfig, string instanceId)   ldapConnectionConfig The ldap:LdapConnectionConfig instance   instanceId string Instance ID of the endpoint   Methods  Authenticates the base64-encoded username:password credentials.  Fields  instanceId  string  Instance ID of the endpoint   ldapConnection  LDAP connection instance   ldapConnectionConfig  LDAP connection configurations   authenticate (string credential)  returns boolean | Authenticates the base64-encoded username:password credentials.  boolean|auth:Error result = inboundLdapAuthProvider.authenticate(\"<credential>\");    Parameters  credential string Base64-encoded username:password value   Return Type (boolean | )  true if authentication is successful, false otherwise, or else an auth:Error occurred while authenticating the credentials"},{"page":"/learn/api-docs/ballerina/ldap/records/LdapConnection.html","name":"Record - : LdapConnection","summary":"Represets the LDAP connection.\n\n             ...","content":"Records  v1.2.2  All Modules  Record - : LdapConnection  Represets the LDAP connection."},{"page":"/learn/api-docs/ballerina/log/","name":"Module : log","summary":"This module provides a basic API for logging.Each module in Ballerina has its own dedicated logger. A log record contains the timestamp, log level, module name, and the log message. The printError() function takes an optional error record apart from the log message. A sample log record logged from the ...","content":"v1.2.2  All Modules  Module : log  Module Overview This module provides a basic API for logging. Loggers Each module in Ballerina has its own dedicated logger. A log record contains the timestamp, log level, module name, and the log message. The printError() function takes an optional error record apart from the log message. A sample log record logged from the foo module would look as follows: 2018-04-09 11:33:21,300 ERROR [foo] - This is an error log.  Log Output Logs are written to the stderr stream (i.e., the console) by default in order to make the logs more container friendly. To publish the logs to a file, redirect the stderr stream to a file. $ ballerina run program.bal 2> b7a-user.log  Log Levels This module provides functions to log at the WARN, ERROR, INFO, DEBUG, and TRACE levels. By default, all log messages are logged to the console at the INFO level. In addition to these, there are two other levels named OFF and ALL. The OFF log level turns off logging, and the ALL log level allows all log levels. The log level can be configured through the Config API. The b7a.log.level configuration key can be used to configure the log level for the log API (i.e., for all the modules). The following can be provided in a configuration file. b7a.log.level=\"<LOG_LEVEL>\"  The log level can also be configured through a CLI parameter as follows: $ ballerina run program.bal --b7a.log.level=<LOG_LEVEL>  Log levels can be configured for modules either through a configuration file as <MODULE_NAME>.loglevel=\"<LOG_LEVEL>\" or through a CLI parameter as <MODULE_NAME>.loglevel=<LOG_LEVEL>. Suppose there is a module named foo. We can set the log level of foo to DEBUG in a configuration file by placing the following entry in it: [\"<org-name>/foo\"] loglevel=\"DEBUG\"  OR \"<org-name>/foo.loglevel\"=\"DEBUG\"  The log level of foo can also be configured through the CLI as follows: $ ballerina run foo --\\\"<org-name>/foo.loglevel\\\"=DEBUG  For information on the operation, which you can perform with this module, see the below Function. For examples on the usage of the operation, see .    Functions Logs the specified value at DEBUG level.  Logs the specified message at ERROR level.  Logs the specified message at INFO level.  Logs the specified message at TRACE level.  Logs the specified message at WARN level."},{"page":"/learn/api-docs/ballerina/ldap/records/LdapConnectionConfig.html","name":"Record - : LdapConnectionConfig","summary":"Represents the configurations that are required for an LDAP auth store.\n\n        ...","content":"Records  v1.2.2  All Modules  Record - : LdapConnectionConfig  Represents the configurations that are required for an LDAP auth store.   Fields  domainName  string  Unique name to identify the user store   connectionURL  string  Connection URL of the LDAP server   connectionName  string  The username used to connect to the LDAP server   connectionPassword  string  The password used to connect to the LDAP server   userSearchBase  string  DN of the context or object under which the user entries are stored in the LDAP server   userEntryObjectClass  string  Object class used to construct user entries   userNameAttribute  string  The attribute used for uniquely identifying a user entry   userNameSearchFilter  string  Filtering criteria used to search for a particular user entry   userNameListFilter  string  Filtering criteria for searching user entries in the LDAP server   groupSearchBase  string[]  DN of the context or object under which the group entries are stored in the LDAP server   groupEntryObjectClass  string  Object class used to construct group entries   groupNameAttribute  string  The attribute used for uniquely identifying a group entry   groupNameSearchFilter  string  Filtering criteria used to search for a particular group entry   groupNameListFilter  string  Filtering criteria for searching group entries in the LDAP server   membershipAttribute  string  Define the attribute, which contains the distinguished names (DN) of user objects that are there in a group   userRolesCacheEnabled  boolean  (default false) To indicate whether to cache the role list of a user   connectionPoolingEnabled  boolean  (default true) Define whether LDAP connection pooling is enabled   connectionTimeoutInMillis  int  (default 5000) Timeout (in milliseconds) in making the initial LDAP connection   readTimeoutInMillis  int  (default 60000) Reading timeout in milliseconds for LDAP operations   retryAttempts  int  (default 0) Retry the authentication request if a timeout happened   secureSocket  The SSL configurations for the LDAP client socket. This needs to be configured in order to communicate through LDAPs"},{"page":"/learn/api-docs/ballerina/log/functions.html","name":"Functions -","summary":"Logs the specified value at DEBUG level.\nThe message to be loggedLogs the specified message at ERROR level.\nThe message to be loggedThe error struct to be loggedLogs the specified message at INFO level.\nThe message to be loggedLogs the specified message at TRACE level.\nThe message to be loggedLogs the specified message at ...","content":"Functions  v1.2.2  All Modules  Functions - Logs the specified value at DEBUG level.  Logs the specified message at ERROR level.  Logs the specified message at INFO level.  Logs the specified message at TRACE level.  Logs the specified message at WARN level.  printDebug Logs the specified value at DEBUG level.  log:printDebug(\"debug log\");    Parameters  msg string | function() returns (string) The message to be logged   printError Logs the specified message at ERROR level.  error e = error(\"error occurred\");  log:printError(\"error log with cause\", err = e);    Parameters  msg string | function() returns (string) The message to be logged   err error? (default ())  The error struct to be logged   printInfo Logs the specified message at INFO level.  log:printInfo(\"info log\");    Parameters  msg string | function() returns (string) The message to be logged   printTrace Logs the specified message at TRACE level.  log:printTrace(\"trace log\");    Parameters  msg string | function() returns (string) The message to be logged   printWarn Logs the specified message at WARN level.  log:printWarn(\"warn log\");    Parameters  msg string | function() returns (string) The message to be logged"},{"page":"/learn/api-docs/ballerina/ldap/records/SecureSocket.html","name":"Record - : SecureSocket","summary":"Configures the SSL/TLS options to be used for LDAP communication.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : SecureSocket  Configures the SSL/TLS options to be used for LDAP communication.   Fields  trustStore  Configures the trust store to be used   trustedCertFile  string  A file containing the certificate(s), which the client trusts"},{"page":"/learn/api-docs/ballerina/math/","name":"Module : math","summary":"This module provides functions to perform fixed-precision integer arithmetic and fixed-precision decimal arithmetic. It includes functions to get the absolute, cosine, sine, root, tangent, and more for a given value.For information on the operation, which you can perform with this module, see the below Function. For examples on the usage ...","content":"v1.2.2  All Modules  Module : math  Module Overview This module provides functions to perform fixed-precision integer arithmetic and fixed-precision decimal arithmetic. It includes functions to get the absolute, cosine, sine, root, tangent, and more for a given value. For information on the operation, which you can perform with this module, see the below Function. For examples on the usage of the operation, see .    Records Record type to hold the details of an error.  Functions Calculates the absolute value of a float value.  Calculates the absolute value of an int value.  Calculates the arc cosine of a value; the returned angle is in the range 0.  Calculates the arc sine of a value.  Calculates the arc tangent of a value.  Calculates the angle theta from the conversion of rectangular coordinates (a, b) to polar coordinates (r, theta).  Calculates the cube root of a float value.  Calculates the smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer.  Calculates the first floating-point argument with the sign of the second floating-point argument.  Calculates the trigonometric cosine of an angle.  Calculates the hyperbolic cosine of a float value.  Calculates Euler's number, that is 'e' raised to the power of exponent.  Calculates (e to the power of x) -1.  Calculates the largest (closest to positive infinity) float value that is less than or equal to the argument and is equal to a mathematical integer.  Calculates the largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient.  Calculates the floor modulus of the long arguments.  Calculates the unbiased exponent used in the representation of a float.  Calculates sqrt(a squared +b squared) without intermediate overflow or underflow.  Calculates the natural logarithm (base e) of a float value.  Calculates the base 10 logarithm of a float value.  Calculates the natural logarithm of the sum of the argument and 1.  Calculates the negation of the argument.  Calculates the floating-point number adjacent to the first argument in the direction of the second argument.  Calculates the adjacent floating-point value closer to negative infinity.  Calculates the adjacent floating-point value closer to positive infinity.  Calculates the value of the 'a' raised to the power of 'b'.  Selects a random number between 0.  Selects a random number between the given start(inclusive) and end(exclusive) values.  Computes the remainder operation on two arguments as prescribed by the IEEE 754 standard.  Calculates the double value that is closest in value to the argument and is equal to a mathematical integer.  Calculates the closest int to the argument, with ties rounding to positive infinity.  Calculates a × (2 to the power of b) rounded as if performed by a single correctly rounded floating-point multiply to a member of the float value set.  Calculates the signum function of the argument.  Calculates the trigonometric sine of an angle.  Calculates the hyperbolic sine of a float value.  Calculates rounded positive square root of the given value.  Calculates the trigonometric tangent of an angle.  Calculates the hyperbolic tangent of a double value.  Converts an angle measured in radians to an approximately equivalent angle measured in degrees.  Converts an angle measured in degrees to an approximately equivalent angle measured in radians.  Returns the size of an ulp of the argument.  Constants Represents the reason string for the math:Error.  Ratio of the circumference of a circle to its diameter.  Base of the natural logarithms.  Errors Represents an error occurred in the math operation."},{"page":"/learn/api-docs/ballerina/math/functions.html","name":"Functions -","summary":"(float val)Calculates the absolute value of a float value.\nValue to get absolute valueCalculated absolute value(int val)Calculates the absolute value of an int value.\nValue to get the absolute valueCalculated absolute value(float val)Calculates the arc cosine of a value; the returned angle is in the range 0.0 through pi.\nValue to get the ...","content":"Functions  v1.2.2  All Modules  Functions - Calculates the absolute value of a float value.  Calculates the absolute value of an int value.  Calculates the arc cosine of a value; the returned angle is in the range 0.  Calculates the arc sine of a value.  Calculates the arc tangent of a value.  Calculates the angle theta from the conversion of rectangular coordinates (a, b) to polar coordinates (r, theta).  Calculates the cube root of a float value.  Calculates the smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer.  Calculates the first floating-point argument with the sign of the second floating-point argument.  Calculates the trigonometric cosine of an angle.  Calculates the hyperbolic cosine of a float value.  Calculates Euler's number, that is 'e' raised to the power of exponent.  Calculates (e to the power of x) -1.  Calculates the largest (closest to positive infinity) float value that is less than or equal to the argument and is equal to a mathematical integer.  Calculates the largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient.  Calculates the floor modulus of the long arguments.  Calculates the unbiased exponent used in the representation of a float.  Calculates sqrt(a squared +b squared) without intermediate overflow or underflow.  Calculates the natural logarithm (base e) of a float value.  Calculates the base 10 logarithm of a float value.  Calculates the natural logarithm of the sum of the argument and 1.  Calculates the negation of the argument.  Calculates the floating-point number adjacent to the first argument in the direction of the second argument.  Calculates the adjacent floating-point value closer to negative infinity.  Calculates the adjacent floating-point value closer to positive infinity.  Calculates the value of the 'a' raised to the power of 'b'.  Selects a random number between 0.  Selects a random number between the given start(inclusive) and end(exclusive) values.  Computes the remainder operation on two arguments as prescribed by the IEEE 754 standard.  Calculates the double value that is closest in value to the argument and is equal to a mathematical integer.  Calculates the closest int to the argument, with ties rounding to positive infinity.  Calculates a × (2 to the power of b) rounded as if performed by a single correctly rounded floating-point multiply to a member of the float value set.  Calculates the signum function of the argument.  Calculates the trigonometric sine of an angle.  Calculates the hyperbolic sine of a float value.  Calculates rounded positive square root of the given value.  Calculates the trigonometric tangent of an angle.  Calculates the hyperbolic tangent of a double value.  Converts an angle measured in radians to an approximately equivalent angle measured in degrees.  Converts an angle measured in degrees to an approximately equivalent angle measured in radians.  Returns the size of an ulp of the argument.  absFloat (float val)  returns float Calculates the absolute value of a float value.  float absoluteFloatValue = math:absFloat(-152.2544);    Parameters  val float Value to get absolute value   Return Type (float)  Calculated absolute value   absInt (int val)  returns int Calculates the absolute value of an int value.  int absoluteIntValue = math:absInt(-152);    Parameters  val int Value to get the absolute value   Return Type (int)  Calculated absolute value   acos (float val)  returns float Calculates the arc cosine of a value; the returned angle is in the range 0.0 through pi.  float acosValue = math:acos(0.027415567780803774);    Parameters  val float Value to get the arc cosine   Return Type (float)  Calculated arc cosine value   asin (float val)  returns float Calculates the arc sine of a value.  float arcSineValue = math:asin(0.027415567780803774);    Parameters  val float Value to get the arc sine   Return Type (float)  Calculates arc sine value   atan (float val)  returns float Calculates the arc tangent of a value.  float arcTangent = math:atan(0.027415567780803774);    Parameters  val float Value to get the arc tangent   Return Type (float)  Calculated arc tangent value   atan2 (float a, float b)  returns float Calculates the angle theta from the conversion of rectangular coordinates (a, b) to polar coordinates (r, theta).  float arcTangentFromCoordinates = math:atan2(6.4, 3.2);    Parameters  a float Ordinate coordinate   b float Abscissa coordinate   Return Type (float)  Calculated angle theta   cbrt (float val)  returns float Calculates the cube root of a float value.  float cubeRoot = math:cbrt(-27.0);    Parameters  val float Value to get the cube root   Return Type (float)  Calculated cube root value   ceil (float val)  returns float Calculates the smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer.  float ceilingValue = math:ceil(6.4);    Parameters  val float Value to get the ceil   Return Type (float)  Calculated smallest double value   copySign (float a, float b)  returns float Calculates the first floating-point argument with the sign of the second floating-point argument.  float copySignValue = math:copySign(6.4, 2.4);    Parameters  a float Parameter providing the magnitude of the result   b float Parameter providing the sign of the result   Return Type (float)  Calculated floating-point argument   cos (float val)  returns float Calculates the trigonometric cosine of an angle.  float cosineValue = math:cos(0.3124);    Parameters  val float Value to get the trigonometric cosine   Return Type (float)  Calculated cosine value   cosh (float val)  returns float Calculates the hyperbolic cosine of a float value.  float hyperbolicCosineValue = math:cosh(0.3124);    Parameters  val float Number whose hyperbolic cosine is to be returned   Return Type (float)  Calculated hyperbolic cosine of given float value   exp (float val)  returns float Calculates Euler's number, that is 'e' raised to the power of exponent.  float euler = math:exp(3.2);    Parameters  val float Exponential value to raise   Return Type (float)  Calculated exponential value   expm1 (float val)  returns float Calculates (e to the power of x) -1.  float exponentValue = math:expm1(6.4);    Parameters  val float Exponent to raise e to in the computation   Return Type (float)  Calculated result   floor (float val)  returns float Calculates the largest (closest to positive infinity) float value that is less than or equal to the argument and is equal to a mathematical integer.  float floorValue = math:floor(6.4);    Parameters  val float A float value   Return Type (float)  Calculated float value   floorDiv (int a, int b)  returns int | Calculates the largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient.  int|error floorDivValue = math:floorDiv(6, 4);    Parameters  a int Dividend   b int Divisor   Return Type (int | )  Calculated int value or else Error if b is 0   floorMod (int a, int b)  returns int | Calculates the floor modulus of the long arguments.  int|error floorModulesValue = math:floorMod(6, 4);    Parameters  a int dividend   b int divisor   Return Type (int | )  Calculated floor modulus or else Error if b is 0   getExponent (float val)  returns int Calculates the unbiased exponent used in the representation of a float.  int unbiasedExponentValue = math:getExponent(6.4);    Parameters  val float Float value   Return Type (int)  Calculated unbiased exponent of the argument   hypot (float a, float b)  returns float Calculates sqrt(a squared +b squared) without intermediate overflow or underflow.  float pythogarusValue = math:hypot(6.4, 3.6);    Parameters  a float Float value   b float Float value   Return Type (float)  Calculated square root value   log (float val)  returns float Calculates the natural logarithm (base e) of a float value.  float logarithmValue = math:log(6.4);    Parameters  val float A float value   Return Type (float)  Calculated natural logarithm value   log10 (float val)  returns float Calculates the base 10 logarithm of a float value.  float logarithmValueBaseTen = math:log10(6.4);    Parameters  val float A float value   Return Type (float)  Calculated base 10 logarithm of a given float value   log1p (float val)  returns float Calculates the natural logarithm of the sum of the argument and 1.  float naturalLogarithmValue = math:log1p(6.4);    Parameters  val float A float value   Return Type (float)  Calculated natural log of x + 1   negateExact (int val)  returns int | Calculates the negation of the argument.  int|error negationValue = math:negateExact(6);    Parameters  val int value to negate   Return Type (int | )  Calculated negation value or else Error if overflow occurred   nextAfter (float a, float b)  returns float Calculates the floating-point number adjacent to the first argument in the direction of the second argument.  float nextAfterValue = math:nextAfter(6.4, 3.4);    Parameters  a float Starting floating-point value   b float Value indicating which of start's neighbors or start should be returned   Return Type (float)  Calculated floating-point number   nextDown (float val)  returns float Calculates the adjacent floating-point value closer to negative infinity.  float nextDownValue = math:nextDown(6.4);    Parameters  val float Starting floating-point value   Return Type (float)  Calculated floating-point value   nextUp (float val)  returns float Calculates the adjacent floating-point value closer to positive infinity.  float nextUpValue = math:nextUp(6.4);    Parameters  val float Starting floating-point value   Return Type (float)  Calculates floating-point value   pow (float a, float b)  returns float Calculates the value of the 'a' raised to the power of 'b'.  float aPowerB = math:pow(3.2, 2.4);    Parameters  a float Base value   b float Exponential value   Return Type (float)  Calculated exponential value   random ()  returns float Selects a random number between 0.0 and 1.0.  float randomValue = math:random();    Return Type (float)  Selected random value   randomInRange (int startRange, int endRange)  returns int | Selects a random number between the given start(inclusive) and end(exclusive) values.  int|error randomInteger = math:randomInRange(1, 100);    Parameters  startRange int Range start value   endRange int Range end value   Return Type (int | )  Selected random value or else Error if start range is greater than the end range   remainder (float a, float b)  returns float Computes the remainder operation on two arguments as prescribed by the IEEE 754 standard.  float remainderValue = math:remainder(6.4, 3.6);    Parameters  a float dividend   b float divisor   Return Type (float)  Computed remainder when a is divided by b   rint (float val)  returns float Calculates the double value that is closest in value to the argument and is equal to a mathematical integer.  float roundedValue = math:rint(6.4);    Parameters  val float A float value   Return Type (float)  Calculated double value   round (float val)  returns int Calculates the closest int to the argument, with ties rounding to positive infinity.  int roundedIntegerValue = math:round(6.4);    Parameters  val float A floating-point value to be rounded to an integer   Return Type (int)  Calculated value of the argument rounded to the nearest int value   scalb (float a, int b)  returns float Calculates a × (2 to the power of b) rounded as if performed by a single correctly rounded floating-point multiply to a member of the float value set.  float scalbValue = math:scalb(6.4, 2);    Parameters  a float Number to be scaled by a power of two   b int Power of 2 used to scale a   Return Type (float)  Calculated result   signum (float val)  returns float Calculates the signum function of the argument.  float signumValue = math:signum(6.4);    Parameters  val float floating-point value whose signum is to be returned   Return Type (float)  Calculated signum function of the argument   sin (float val)  returns float Calculates the trigonometric sine of an angle.  float sineValue = math:sin(0.96);    Parameters  val float An angle, in radians   Return Type (float)  Calculated sine of the argument   sinh (float val)  returns float Calculates the hyperbolic sine of a float value.  float hyperbolicSineValue = math:sinh(0.96);    Parameters  val float Number whose hyperbolic sine is to be returned   Return Type (float)  Calculated hyperbolic sine of a given float   sqrt (float val)  returns float Calculates rounded positive square root of the given value.  float squareRoot = math:sqrt(6.4);    Parameters  val float Value to get square root   Return Type (float)  Calculated square root value   tan (float val)  returns float Calculates the trigonometric tangent of an angle.  float tanValue = math:tan(0.96);    Parameters  val float An angle, in radians   Return Type (float)  Calculated tangent of the argument   tanh (float val)  returns float Calculates the hyperbolic tangent of a double value.  float hyperbolicTanValue = math:tanh(0.96);    Parameters  val float Number whose hyperbolic tangent is to be returned   Return Type (float)  Calculated hyperbolic tangent of x   toDegrees (float val)  returns float Converts an angle measured in radians to an approximately equivalent angle measured in degrees.  float angleValueInDegrees = math:toDegrees(0.96);    Parameters  val float An angle, in radians   Return Type (float)  Measurement of the angle angrad in degrees   toRadians (float val)  returns float Converts an angle measured in degrees to an approximately equivalent angle measured in radians.  float angleValueInRadians = math:toRadians(0.96);    Parameters  val float An angle, in degrees   Return Type (float)  Measurement of the angle angdeg in radians   ulp (float val)  returns float Returns the size of an ulp of the argument.  float ulpValue = math:ulp(0.96);    Parameters  val float Floating-point value whose ulp is to be returned   Return Type (float)  Size of an ulp of the argument"},{"page":"/learn/api-docs/ballerina/math/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error.   cause  error  Any other error, which causes this error."},{"page":"/learn/api-docs/ballerina/mime/functions.html","name":"Functions -","summary":"(string | byte[] |  contentToBeDecoded, string charset)Deprecated API. Decodes a given input with MIME specific Base64 encoding scheme.\nContent that needs to be decoded can be of type string, byte[] or io:ReadableByteChannelCharset to be used. This is used only with the string inputA decoded string if the given input is ...","content":"Functions  v1.2.2  All Modules  Functions - Deprecated API.  Deprecated API.  Deprecated API.  Deprecated API.  Given the Content-Disposition as a string, gets the ContentDisposition object with it.  Gets the MediaType object populated with it when the Content-Type is in string.  Constructs a DecodeError with the given details.  Constructs an EncodeError with the given details.  base64Decode (string | byte[] | contentToBeDecoded, string charset)  returns string | byte[] | | Deprecated API. Decodes a given input with MIME specific Base64 encoding scheme.   Parameters  contentToBeDecoded string | byte[] | Content that needs to be decoded can be of type string, byte[] or io:ReadableByteChannel   charset string (default utf-8)  Charset to be used. This is used only with the string input   Return Type (string | byte[] | | )  A decoded string if the given input is of type string, a decoded byte[] if the given input is of type byte[], a decoded io:ReadableByteChannel if the given input is of type io:ReadableByteChannel or else a mime:DecodeError in case of errors   base64DecodeBlob (byte[] valueToBeDecoded)  returns byte[] | Deprecated API. Decodes a given byte[] using the Base64 encoding scheme.   Parameters  valueToBeDecoded byte[] Content, which needs to be decoded   Return Type (byte[] | )  A decoded byte[] or else a mime:DecodeError record in case of errors   base64Encode (string | byte[] | contentToBeEncoded, string charset)  returns string | byte[] | | Deprecated API. Encodes a given input with MIME specific Base64 encoding scheme.   Parameters  contentToBeEncoded string | byte[] | Content that needs to be encoded can be of type string, byte[] or io:ReadableByteChannel   charset string (default utf-8)  Charset to be used. This is used only with the string input   Return Type (string | byte[] | | )  An encoded string if the given input is of type string, an encoded byte[] if the given input is of type byte[], an encoded io:ReadableByteChannel if the given input is of type io:ReadableByteChannel, or else a mime:EncodeError record in case of errors   base64EncodeBlob (byte[] valueToBeEncoded)  returns byte[] | Deprecated API. Encodes a given byte[] using the Base64 encoding scheme.   Parameters  valueToBeEncoded byte[] Content, which needs to be encoded   Return Type (byte[] | )  An encoded byte[] or else a mime:EncodeError record in case of errors   getContentDispositionObject (string contentDisposition)  returns Given the Content-Disposition as a string, gets the ContentDisposition object with it.   Parameters  contentDisposition string Content disposition string   Return Type ()  A ContentDisposition object   getMediaType (string contentType)  returns | Gets the MediaType object populated with it when the Content-Type is in string.   Parameters  contentType string Content-Type in string   Return Type ( | )  MediaType object or else a mime:InvalidContentTypeError in case of an invalid content-type   prepareDecodingErrorWithDetail (string detail)  returns Constructs a DecodeError with the given details.   Parameters  detail string Error details   Return Type ()  DecodeError with the given details set to the message   prepareEncodingErrorWithDetail (string detail)  returns Constructs an EncodeError with the given details.   Parameters  detail string Error details   Return Type ()  An EncodeError with the given details set to the message"},{"page":"/learn/api-docs/ballerina/mime/","name":"Module : mime","summary":"This module provides functions to encapsulate multiple body parts such as attachments into a single message. The\ncommunication of such messages follow the MIME (Multipurpose Internet Mail Extensions) specification as specified in\nthe .Entity refers to the header fields and the content of a message or a part of the body in ...","content":"v1.2.2  All Modules  Module : mime  Module Overview This module provides functions to encapsulate multiple body parts such as attachments into a single message. The communication of such messages follow the MIME (Multipurpose Internet Mail Extensions) specification as specified in the .  Entity refers to the header fields and the content of a message or a part of the body in a multipart entity.  Modify and retrieve the data in an entity This module provides functions to set and get an entity body from different kinds of message types such as XML, text, JSON, byte[], and body parts. Headers can be modified through functions such as addHeader(), setHeader(), removeHeader(), etc. For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operations, see the and .    Records Holds the details of the entity header and body-related errors.  Objects Represents values in Content-Disposition header.  Represents the headers and body of a message.  Describes the nature of the data in the body of a MIME entity.  Functions Deprecated API.  Deprecated API.  Deprecated API.  Deprecated API.  Given the Content-Disposition as a string, gets the ContentDisposition object with it.  Gets the MediaType object populated with it when the Content-Type is in string.  Constructs a DecodeError with the given details.  Constructs an EncodeError with the given details.  Constants Header is placed before the payload of the request/response.  Header is placed after the payload of the request/response.  Represents the application/octet-stream media type.  Represents the application/json media type.  Represents the application/xml media type.  Represents the application/svg+xml media type.  Represents the application/xhtml+xml media type.  Represents the application/soap+xml media type.  Represents the application/x-www-form-urlencoded media type.  Represents the application/pdf media type.  Represents the image/jpeg media type.  Represents the image/gif media type.  Represents the image/png media type.  Represents the multipart/form-data media type.  Represents the multipart/mixed media type.  Represents the multipart/alternative media type.  Represents the multipart/related media type.  Represents the multipart/parallel media type.  Represents the text/plain media type.  Represents the text/html media type.  Represents the text/xml media type.  Identifies encoding errors.  Identifies decoding errors.  Identifies generic errors related to MIME.  Identifies the set header errors.  Identifies header parsing errors.  Identifies entity body parsing errors.  Identifies errors related to content-type header.  Identifies errors related to header unavailability.  Identifies errors related to read/write timeouts.  Identifies the errors occurred due to payloads with no content.  Key name for boundary parameter in MediaType.  Key name for start parameter in MediaType.  Key name for type parameter in MediaType.  Key name for charset parameter in MediaType.  Default charset to be used with MIME encoding and decoding.  Represents content-id header name.  Represents content-length header name.  Represents content-type header name.  Represents content-disposition header name.  Types Represents MIME related errors.  Defines the position of the headers in the request/response.  Errors Represents a DecodeError with a detailed message.  Represents an EncodeError with a detailed message.  Represents a GenericMimeError with a detailed message.  Represents a HeaderUnavailableError with a detailed message.  Represents an IdleTimeoutTriggeredError with a detailed message.  Represents an InvalidContentTypeError with a detailed message.  Represents a NoContentError with a detailed message.  Represents a ParserError with a detailed message.  Represents a ReadingHeaderFailed error with a detailed message.  Represents a SetHeaderError with a detailed message."},{"page":"/learn/api-docs/ballerina/mime/objects/Entity.html","name":"Object - : Entity","summary":"Represents the headers and body of a message. This can be used to represent both the entity of ...","content":"Objects  >  >  >  v1.2.2  All Modules  Object - :  Entity  Represents the headers and body of a message. This can be used to represent both the entity of a top level message and an entity(body part) inside of a multipart entity.   Methods  Sets the content-type to the entity.  Gets the content type of the entity.  Sets the content ID of the entity.  Gets the content ID of the entity.  Sets the content length of the entity.  Gets the content length of the entity.  Sets the content disposition of the entity.  Gets the content disposition of the entity.  Sets the body of the entity with the given content.  Sets the entity body with a given file.  Sets the entity body with the given json content.  Extracts the JSON body from the entity.  Sets the entity body with the given XML content.  Extracts the xml body from the entity.  Sets the entity body with the given text content.  Extracts the text body from the entity.  Sets the entity body with the given byte[] content.  Gets the entity body as a byte[] from a given entity.  Sets the entity body with the given byte channel content.  Gets the entity body as a byte channel from a given entity.  Gets the body parts from a given entity.  Gets the body parts as a byte channel from a given entity.  Sets body parts to entity.  Gets the header value associated with the given header name.  Gets all the header values associated with the given header name.  Gets all the header names.  Adds the given header value against the given header.  Sets the given header value against the existing header.  Removes the given header from the entity.  Removes all headers associated with the entity.  Checks whether the requested header key exists in the header map.  setContentType (string mediaType)  returns ? Sets the content-type to the entity.  mime:InvalidContentTypeError? contentType = mimeEntity.setContentType(\"application/json\");    Parameters  mediaType string Content type, which needs to be set to the entity   Return Type (?)  () if successful or else an mime:InvalidContentTypeError in case of invalid media-type   getContentType ()  returns string Gets the content type of the entity.  string contentType = mimeEntity.getContentType();    Return Type (string)  Content type as a string   setContentId Sets the content ID of the entity.  mimeEntity.setContentId(\"test-id\");    Parameters  contentId string Content ID, which needs to be set to the entity   getContentId ()  returns string Gets the content ID of the entity.  string contentId = mimeEntity.getContentId();    Return Type (string)  Content ID as a string   setContentLength Sets the content length of the entity.  mimeEntity.setContentLength(45555);    Parameters  contentLength int Content length, which needs to be set to the entity   getContentLength ()  returns int | error Gets the content length of the entity.  int|error contentLength = mimeEntity.getContentLength();    Return Type (int | error)  Content length as an int or else an error in case of a failure   setContentDisposition Sets the content disposition of the entity.  mimeEntity.setContentDisposition(contentDisposition);    Parameters  contentDisposition Content disposition, which needs to be set to the entity   getContentDisposition ()  returns Gets the content disposition of the entity.   Return Type ()  A ContentDisposition object   setBody Sets the body of the entity with the given content. Note that any string value is set as text/plain. To send a JSON-compatible string, set the content-type header to application/json or use the setJsonPayload method instead.  mimeEntity.setBody(\"body string\");    Parameters  entityBody string | xml | json | byte[] | | [] Entity body can be of the type string,xml,json,byte[],io:ReadableByteChannel, or Entity[].   setFileAsEntityBody Sets the entity body with a given file. This method overrides any existing content-type headers with the default content-type, which is application/octet-stream. This default value can be overridden by passing the content type as an optional parameter.  mimeEntity.setFileAsEntityBody(\"<file path>\");    Parameters  filePath string Path of the file   contentType string (default application/octet-stream)  Content type to be used with the payload. This is an optional parameter. The default value is application/octet-stream   setJson Sets the entity body with the given json content. This method overrides any existing content-type headers with the default content-type, which is application/json. This default value can be overridden by passing the content type as an optional parameter.  mimeEntity.setJson({ \"Hello\": \"World\" });    Parameters  jsonContent json JSON content, which needs to be set to the entity   contentType string (default application/json)  Content type to be used with the payload. This is an optional parameter. The default value is application/json   getJson ()  returns json | Extracts the JSON body from the entity.   Return Type (json | )  json data extracted from the entity body or else an mime:ParserError if the entity body is not a JSON   setXml Sets the entity body with the given XML content. This method overrides any existing content-type headers with the default content-type, which is application/xml. This default value can be overridden by passing the content-type as an optional parameter.  mimeEntity.setXml(xml `<hello> world </hello>`);    Parameters  xmlContent xml XML content, which needs to be set to the entity   contentType string (default application/xml)  Content type to be used with the payload. This is an optional parameter. The default value is application/xml   getXml ()  returns xml | Extracts the xml body from the entity.   Return Type (xml | )  xml data extracted from the entity body or else an mime:ParserError if the entity body is not an XML   setText Sets the entity body with the given text content. This method overrides any existing content-type headers with the default content-type, which is text/plain. This default value can be overridden by passing the content type as an optional parameter.  mimeEntity.setText(\"Hello World\");    Parameters  textContent string Text content, which needs to be set to the entity   contentType string (default text/plain)  Content type to be used with the payload. This is an optional parameter. The default value is text/plain   getText ()  returns string | Extracts the text body from the entity. If the entity body is not text compatible, an error is returned.   Return Type (string | )  string data extracted from the the entity body or else an mime:ParserError if the entity body is not text compatible   setByteArray Sets the entity body with the given byte[] content. This method overrides any existing content-type headers with the default content-type, which is application/octet-stream. This default value can be overridden by passing the content type as an optional parameter.   Parameters  blobContent byte[] byte[] content that needs to be set to the entity   contentType string (default application/octet-stream)  Content type to be used with the payload. This is an optional parameter. The default value is application/octet-stream   getByteArray ()  returns byte[] | Gets the entity body as a byte[] from a given entity. If the entity size is considerably large, consider using the getByteChannel() method instead.   Return Type (byte[] | )  byte[] data extracted from the the entity body or else a mime:ParserError in case of errors   setByteChannel Sets the entity body with the given byte channel content. This method overrides any existing content-type headers with the default content-type, which is application/octet-stream. This default value can be overridden by passing the content-type as an optional parameter.   Parameters  byteChannel Byte channel, which needs to be set to the entity   contentType string (default application/octet-stream)  Content-type to be used with the payload. This is an optional parameter. The application/octet-stream is the default value   getByteChannel ()  returns | Gets the entity body as a byte channel from a given entity.   Return Type ( | )  An io:ReadableByteChannel or else a mime:ParserError record will be returned in case of errors   getBodyParts ()  returns [] | Gets the body parts from a given entity.   Return Type ([] | )  An array of body parts(Entity[]) extracted from the entity body or else a mime:ParserError if the entity body is not a set of the body parts   getBodyPartsAsChannel ()  returns | Gets the body parts as a byte channel from a given entity.   Return Type ( | )  Body parts as a byte channel   setBodyParts Sets body parts to entity. This method overrides any existing content-type headers with the default multipart/form-data content-type. The default multipart/form-data value can be overridden by passing the content type as an optional parameter.   Parameters  bodyParts [] Body parts, which needs to be set to the entity   contentType string (default multipart/form-data)  Content-type to be used with the payload. This is an optional parameter. The default value is multipart/form-data.   getHeader (string headerName, position)  returns string Gets the header value associated with the given header name.  string headerName = mimeEntity.getHeader(mime:CONTENT_LENGTH);    Parameters  headerName string Header name   position (default LEADING)  Position of the header as an optional parameter   Return Type (string)  Header value associated with the given header name as a string. If multiple header values are present, then the first value is returned. An exception is thrown if no header is found. Use Entity.hasHeader() beforehand to check the existence of a header   getHeaders (string headerName, position)  returns string[] Gets all the header values associated with the given header name.   Parameters  headerName string Header name   position (default LEADING)  Position of the header as an optional parameter. If the position is mime:TRAILING, the body of the Entity must be accessed initially   Return Type (string[])  All the header values associated with the given header name as a string[]. Panics if no header is found. Use the Entity.hasHeader() beforehand to check the existence of a header   getHeaderNames ( position)  returns string[] Gets all the header names.  string[] headerNames = mimeEntity.getHeaderNames();    Parameters  position (default LEADING)  Position of the header as an optional parameter   Return Type (string[])  All header names as a string[]   addHeader Adds the given header value against the given header.  mimeEntity.addHeader(\"custom-header\", \"header-value\");    Parameters  headerName string Header name   headerValue string The header value to be added   position (default LEADING)  Position of the header as an optional parameter   setHeader Sets the given header value against the existing header. If a header already exists, its value is replaced with the given header value.  mimeEntity.setHeader(\"custom-header\", \"header-value\");    Parameters  headerName string Header name   headerValue string Header value   position (default LEADING)  Position of the header as an optional parameter   removeHeader Removes the given header from the entity.   Parameters  headerName string Header name   position (default LEADING)  Position of the header as an optional parameter. If the position is mime:TRAILING, the body of the Entity must be accessed initially.   removeAllHeaders Removes all headers associated with the entity.   Parameters  position (default LEADING)  Position of the header as an optional parameter. If the position is mime:TRAILING, the body of the Entity must be accessed initially.   hasHeader (string headerName, position)  returns boolean Checks whether the requested header key exists in the header map.   Parameters  headerName string Header name   position (default LEADING)  Position of the header as an optional parameter. If the position is mime:TRAILING, the body of the Entity must be accessed initially.   Return Type (boolean)  true if the specified header key exists"},{"page":"/learn/api-docs/ballerina/mime/objects/ContentDisposition.html","name":"Object - : ContentDisposition","summary":"Represents values in Content-Disposition header.\n\n            \n  ...","content":"Objects  >  >  >  v1.2.2  All Modules  Object - :  ContentDisposition  Represents values in Content-Disposition header.   Methods  Converts the ContentDisposition type to a string suitable to use as the value of a corresponding MIME header.  Fields  fileName  string  Default filename for storing the body part if the receiving agent wishes to store it in an external file   disposition  string  Indicates how the body part should be presented (inline, attachment, or as form-data)   name  string  Represents the field name in case of multipart/form-data   parameters  map  (default {}) A set of parameters specified in the attribute=value notation   toString ()  returns string Converts the ContentDisposition type to a string suitable to use as the value of a corresponding MIME header.  string contDisposition = contentDisposition.toString();    Return Type (string)  The string representation of the ContentDisposition object"},{"page":"/learn/api-docs/ballerina/mime/objects/MediaType.html","name":"Object - : MediaType","summary":"Describes the nature of the data in the body of a MIME entity.\n\n      ...","content":"Objects  >  >  >  v1.2.2  All Modules  Object - :  MediaType  Describes the nature of the data in the body of a MIME entity.   Methods  Gets the “primaryType/subtype+suffix” combination in a string format.  Converts the media type to a string, which is suitable to be used as the value of a corresponding HTTP header.  Fields  primaryType  string  Declares the general type of data   subType  string  A specific format of the primary-type data   suffix  string  Identifies the semantics of a specific media type   parameters  map  (default {}) A set of parameters specified in an attribute=value notation   getBaseType ()  returns string Gets the “primaryType/subtype+suffix” combination in a string format.  string baseType = mediaType.getBaseType();    Return Type (string)  Base type as a string from the MediaType struct   toString ()  returns string Converts the media type to a string, which is suitable to be used as the value of a corresponding HTTP header.  string mediaTypeString = mediaType.toString();    Return Type (string)  Content type with parameters as a string"},{"page":"/learn/api-docs/ballerina/mime/records/Detail.html","name":"Record - : Detail","summary":"Holds the details of the entity header and body-related errors.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Holds the details of the entity header and body-related errors.   Fields  message  string  Error message   cause  error  Error cause"},{"page":"/learn/api-docs/ballerina/nats/clients/StreamingMessage.html","name":"Clients - : StreamingMessage","summary":"Represents the message a NATS Streaming Server sends to its subscribed services.\n()Acknowledges the NATS streaming server upon the receipt of the message.\n() or else a nats:Error upon failure to acknowledge the server()Gets the message content.\nThe data from the message as a 'byte[]'()Gets the subject that the message was sent to.\nThe ...","content":"Clients  v1.2.2  All Modules  Clients - :  StreamingMessage  Represents the message a NATS Streaming Server sends to its subscribed services.    Remote Methods  Acknowledges the NATS streaming server upon the receipt of the message.   Methods  Gets the message content.  Gets the subject that the message was sent to.  ack ()  returns ? Acknowledges the NATS streaming server upon the receipt of the message.   Return Type (?)  () or else a nats:Error upon failure to acknowledge the server   getData ()  returns byte[] Gets the message content.   Return Type (byte[])  The data from the message as a 'byte[]'   getSubject ()  returns string Gets the subject that the message was sent to.   Return Type (string)  The subject, to which the message was sent"},{"page":"/learn/api-docs/ballerina/nats/clients/Producer.html","name":"Clients - : Producer","summary":"The producer provides the capability to publish messages to the NATS server.\nThe nats:Producer needs the nats:Connection to be initialized.\n( connection)An established NATS connection(string subject,  data, string | service | () replyTo)Publishes data to a given subject.\nThe subject to send the messageData to publishThe subject or the callback service to ...","content":"Clients  v1.2.2  All Modules  Clients - :  Producer  The producer provides the capability to publish messages to the NATS server. The nats:Producer needs the nats:Connection to be initialized.    Constructor __init( connection)   connection An established NATS connection   Remote Methods  Publishes data to a given subject.  nats:Error? result = producer->publish(subject, <@untainted>message);    Publishes data to a given subject and waits for a response.  nats:Message|nats:Error reqReply = producer->request(subject, <@untainted>message, 5000);    Methods  Closes a given connection.  publish (string subject, data, string | service | () replyTo)  returns ? Publishes data to a given subject.  nats:Error? result = producer->publish(subject, <@untainted>message);    Parameters  subject string The subject to send the message   data Data to publish   replyTo string | service | () (default ())  The subject or the callback service to which the receiver should send the response   Return Type (?)  () or else a nats:Error if there is a problem when publishing the message   request (string subject, data, int? duration)  returns | Publishes data to a given subject and waits for a response.  nats:Message|nats:Error reqReply = producer->request(subject, <@untainted>message, 5000);    Parameters  subject string The subject to send the message   data Data to publish   duration int? (default ())  The time (in milliseconds) to wait for the response   Return Type ( | )  The nats:Message response or else a nats:Error if an error is encountered   close ()  returns ? Closes a given connection.   Return Type (?)  () or else a nats:Error if unable to complete the close the operation"},{"page":"/learn/api-docs/ballerina/nats/clients/StreamingProducer.html","name":"Clients - : StreamingProducer","summary":"The streaming producer provides the capability to publish messages to the NATS streaming server.\nThe nats:StreamingProducer needs the nats:Connection to be initialized.\n( connection, string? clientId, string clusterId, ? streamingConfig)An established NATS connectionA unique identifier of the clientThe unique identifier of the cluster configured in the NATS serverThe configuration related to the ...","content":"Clients  v1.2.2  All Modules  Clients - :  StreamingProducer  The streaming producer provides the capability to publish messages to the NATS streaming server. The nats:StreamingProducer needs the nats:Connection to be initialized.    Constructor __init( connection, string? clientId, string clusterId, ? streamingConfig)   connection An established NATS connection   clientId string? ()  A unique identifier of the client   clusterId string test-cluster  The unique identifier of the cluster configured in the NATS server   streamingConfig ? ()  The configuration related to the NATS streaming connectivity   Remote Methods  Publishes data to a given subject. ballerina string|error result = producer->publish(subject, <@untainted>message);   Methods  Close the producer.  publish (string subject, data)  returns string | Publishes data to a given subject. ballerina string|error result = producer->publish(subject, <@untainted>message);   Parameters  subject string The subject to send the message   data Data to publish   Return Type (string | )  The string value representing the NUID (NATS Unique Identifier) of the published message if the message gets successfully published and acknowledged by the NATS server, a nats:Error with NUID and message fields in case an error occurs in publishing, the timeout elapses while waiting for the acknowledgement, or else a nats:Error only with the message field in case an error occurs even before publishing is completed   close ()  returns error? Close the producer.   Return Type (error?)  () or else a nats:Error if unable to complete the close operation."},{"page":"/learn/api-docs/ballerina/nats/","name":"Module : nats","summary":"This module provides the capability to connect with NATS and NATS Streaming servers and performs the\nbelow functionalities.First step is setting up the connection with the NATS Basic/Streaming server. The following ways can be used to connect to a\nNATS Basic/Streaming server.Publishing messages is handled differently in the NATS Basic server and ...","content":"v1.2.2  All Modules  Module : nats  Module Overview This module provides the capability to connect with NATS and NATS Streaming servers and performs the below functionalities.  Point to point communication (Queues) Pub/Sub (Topics) Request/Reply  Basic Usage Setting up the connection First step is setting up the connection with the NATS Basic/Streaming server. The following ways can be used to connect to a NATS Basic/Streaming server.  Connect to a server using the URL  nats:Connection connection = new(\"nats://localhost:4222\");   Connect to one or more servers with a custom configuration  nats:Connection connection = new(\"nats://serverone:4222, nats://servertwo:4222\", config);  Publishing messages Publishing messages is handled differently in the NATS Basic server and Streaming server. The 'ballerina/nats' module provides different APIs to publish messages to each server. Publishing messages to the NATS basic server Once connected, publishing is accomplished via one of the below two methods.  Publish with the subject and the message content.  nats:Producer producer = new(connection); nats:Error? result = producer->publish(subject, \"hello world\");   Publish as a request that expects a reply.  nats:Producer producer = new(connection); nats:Message|nats:Error reqReply = producer->request(subject, \"hello world\", 5000);   Publish messages with a replyTo subject  nats:Producer producer = new(connection); nats:Error? result = producer->publish(subject, <@untainted>message, replyToSubject);   Publish messages with a replyTo callback service  nats:Producer producer = new(connection); nats:Error? result = producer->publish(subject, <@untainted>message, replyToService);  service replyToService = @nats:SubscriptionConfig {  subject: \"replySubject\" } service {   resource function onMessage(nats:Message msg, string data) {  }   resource function onError(nats:Message msg, nats:Error err) {  } };  Publishing messages to a NATS streaming server Once connected to a streaming server, publishing messages is accomplished using the following method. nats:StreamingProducer producer = new(connection); string|error result = producer->publish(subject, \"hello world\");   Publish api supports the byte[], boolean, string, int, float, decimal, xml, json, record {} message types.  Listening to incoming messages The Ballerina NATS module provides the following mechanisms to listen to messages. Similar to message publishing, listening to messages is also handled differently in the NATS basic and streaming servers. Listening to messages from a NATS server // Initializes the NATS listener. listener nats:Listener subscription = new(connection);  // Binds the consumer to listen to the messages published to the 'demo' subject. @nats:SubscriptionConfig {  subject: \"demo\" } service demo on subscription {   resource function onMessage(nats:Message msg, string data) {  }   resource function onError(nats:Message msg, nats:Error err) {  } }  Listening to messages from a Streaming server // Initializes the NATS Streaming listener. listener nats:StreamingListener subscription = new(conn, \"test-cluster\", \"c1\");  // Binds the consumer to listen to the messages published to the 'demo' subject. @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demo on subscription {   resource function onMessage(nats:StreamingMessage msg, string data) {  }   resource function onError(nats:StreamingMessage msg, nats:Error err) {  }  }  Advanced Usage Using the TLS protocol The Ballerina NATS module allows the use of the tls:// protocol in its URLs. This setting expects a secure socket to be set in the connection configuration as shown below. nats:ConnectionConfig config = {  secureSocket : {  trustStore : {  path: \"nats-basic/keyStore.p12\",  password: \"xxxxx\"  }  } };  // Initializes a connection. nats:Connection connection = new(\"tls://localhost:4222\", config = config);   Note: The default thread pool size used in Ballerina is the number of processors available * 2. You can configure the thread pool size by using the BALLERINA_MAX_POOL_SIZE environment variable.  For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the connector, see the following.  .          Records Anonymous record  Configurations related to creating a NATS streaming subscription.  Holds the details of an error.  The configurations to set limits on the maximum number of messages or maximum size of messages this consumer will hold before it starts to drop new messages waiting for the resource functions to drain the queue.  Configurations related to facilitating a secure communication with a remote HTTP endpoint.  Configuration related to establishing a streaming connection.  The configurations for the NATS streaming subscription.  The configurations for the NATS basic subscription.  Objects Represents a single network connection to the NATS server.  Represents the message, which a NATS server sends to its subscribed services.  Clients The producer provides the capability to publish messages to the NATS server.  Represents the message a NATS Streaming Server sends to its subscribed services.  The streaming producer provides the capability to publish messages to the NATS streaming server.  Listeners Represents the NATS server connection to which a subscription service should be bound in order to receive messages of the corresponding subscription.  Represents the NATS streaming server connection to which a subscription service should be bound in order to receive messages of the corresponding subscription.  Constants Default URL for NATS connections.  Represents the reason for the NATS module related errors.  Specifies that message delivery should start with the messages, which are published after the subscription is created.  Specifies that message delivery should start with the last (most recent) message stored for this subject.  Specifies that message delivery should begin at the oldest available message for this subject.  The key for the TimeDeltaStart type.  The key for the SequenceNumber type.  Annotations The annotation, which is used to configure the streaming subscription.  The annotation, which is used to configure the basic subscription.  Types Data types supported when publishing and consuming messages.  Specifies the position to start receiving messages.  Errors Represents NATS module related errors."},{"page":"/learn/api-docs/ballerina/nats/listeners/StreamingListener.html","name":"Listener - : StreamingListener","summary":"Represents the NATS streaming server connection to which a subscription service should be bound in order to\nreceive messages of the corresponding subscription.\n( connection, string? clientId, string clusterId, ? streamingConfig)An established NATS connectionThe unique identifier of the client. The clientId should be unique across all the subscriptions.\nTherefore, multilpe subscription services cannot ...","content":"Listeners  v1.2.2  All Modules  Listener - : StreamingListener Represents the NATS streaming server connection to which a subscription service should be bound in order to receive messages of the corresponding subscription.    Constructor __init( connection, string? clientId, string clusterId, ? streamingConfig)   connection An established NATS connection   clientId string? ()  The unique identifier of the client. The clientId should be unique across all the subscriptions. Therefore, multilpe subscription services cannot be bound to a single listener   clusterId string test-cluster  The unique identifier of the cluster configured in the NATS server. The default value is test-cluster   streamingConfig ? ()  The configuration related to the NATS streaming connectivity   Methods  Stops consuming messages and detaches the service from the nats:StreamingListener.  Stops the nats:StreamingListener gracefully.  Stops the nats:StreamingListener forcefully.  LifeCycle Methods  Binds a service to the nats:StreamingListener.  Starts the nats:StreamingListener.  Methods  __detach (service s)  returns error? Stops consuming messages and detaches the service from the nats:StreamingListener.   Parameters  s service Type descriptor of the service   Return Type (error?)  () or else a nats:Error upon failure to detach the service   __gracefulStop ()  returns error? Stops the nats:StreamingListener gracefully.   Return Type (error?)  () or else a nats:Error upon failure to stop the listener   __immediateStop ()  returns error? Stops the nats:StreamingListener forcefully.   Return Type (error?)  () or else a nats:Error upon failure to stop the listener   LifeCycle Methods  __attach (service s, string? name)  returns error? Binds a service to the nats:StreamingListener.   Parameters  s service Type descriptor of the service   name string? (default ())  Name of the service   Return Type (error?)  () or else a nats:Error upon failure to register the listener   __start ()  returns error? Starts the nats:StreamingListener.   Return Type (error?)  () or else a nats:Error upon failure to start the listener"},{"page":"/learn/api-docs/ballerina/nats/listeners/Listener.html","name":"Listener - : Listener","summary":"Represents the NATS server connection to which a subscription service should be bound in order to\nreceive messages of the corresponding subscription.\n( connection)An established NATS connection.(service s)Stops consuming messages and detaches the service from the nats:Listener.\nType descriptor of the service() or else a nats:Error upon failure to detach the service()Stops the ...","content":"Listeners  v1.2.2  All Modules  Listener - : Listener Represents the NATS server connection to which a subscription service should be bound in order to receive messages of the corresponding subscription.    Constructor __init( connection)   connection An established NATS connection.   Methods  Stops consuming messages and detaches the service from the nats:Listener.  Stops the nats:Listener gracefully.  Stops the nats:Listener forcefully.  LifeCycle Methods  Binds a service to the nats:Listener.  Starts the nats:Listener.  Methods  __detach (service s)  returns error? Stops consuming messages and detaches the service from the nats:Listener.   Parameters  s service Type descriptor of the service   Return Type (error?)  () or else a nats:Error upon failure to detach the service   __gracefulStop ()  returns error? Stops the nats:Listener gracefully.   Return Type (error?)  () or else a nats:Error upon failure to stop the listener   __immediateStop ()  returns error? Stops the nats:Listener forcefully.   Return Type (error?)  () or else a nats:Error upon failure to stop the listener   LifeCycle Methods  __attach (service s, string? name)  returns error? Binds a service to the nats:Listener.   Parameters  s service Type descriptor of the service   name string? (default ())  Name of the service   Return Type (error?)  () or else a nats:Error upon failure to register the listener   __start ()  returns error? Starts the nats:Listener.   Return Type (error?)  () or else a nats:Error upon failure to start the listener"},{"page":"/learn/api-docs/ballerina/nats/objects/Connection.html","name":"Object - : Connection","summary":"Represents a single network connection to the NATS server.\n\n          ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  Connection  Represents a single network connection to the NATS server.   Constructor __init(string[] url, ? config)   url string[] [DEFAULT_URL]  The NATS Broker URL. For a clustered use case, pass the URLs as a string array   config ? ()  Configurations associated with the NATS client to establish a connection with the server   Methods  Closes a given connection.  close (boolean forceful)  returns ? Closes a given connection.   Parameters  forceful boolean (default false)  The graceful shutdown flag. If true, the connection closes immediately. The default value is false.   Return Type (?)  () or else a nats:Error if unable to complete the close operation."},{"page":"/learn/api-docs/ballerina/nats/objects/Message.html","name":"Object - : Message","summary":"Represents the message, which a NATS server sends to its subscribed services.\n\n       ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  Message  Represents the message, which a NATS server sends to its subscribed services.   Methods  Gets the message content.  Gets the replyTo subject of the message.  Gets the subject to which the message was sent to.  getData ()  returns byte[] Gets the message content.   Return Type (byte[])  The data returned from the message as a 'byte[]'   getReplyTo ()  returns string? Gets the replyTo subject of the message.   Return Type (string?)  The subject to which the client is expected to send a reply message   getSubject ()  returns string Gets the subject to which the message was sent to.   Return Type (string)  The subject that this message was sent to."},{"page":"/learn/api-docs/ballerina/nats/records/Detail.html","name":"Record - : Detail","summary":"Holds the details of an error.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Holds the details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/nats/records/ConnectionConfig.html","name":"Record - : ConnectionConfig","summary":"Configurations related to creating a NATS streaming subscription.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : ConnectionConfig  Configurations related to creating a NATS streaming subscription.   Fields  connectionName  string  (default ballerina-nats) Name of the connection (this is optional)   maxReconnect  int  (default 60) Maximum number of reconnect attempts. The reconnect state is triggered when an already established connection is lost. During the initial connection attempt, the client will cycle over its server list one time regardless of the maxReconnects value that is set. Use 0 to turn off auto reconnecting. Use -1 to turn on infinite reconnects.   reconnectWaitInSeconds  int  (default 2) The time(in seconds) to wait between the reconnect attempts to reconnect to the same server   connectionTimeoutInSeconds  int  (default 2) The timeout (in seconds) for the connection attempts   pingIntervalInMinutes  int  (default 2) The interval (in minutes) between the attempts of pinging the server   maxPingsOut  int  (default 2) The maximum number of pings the client can have in flight. The default value is two   username  string  The username for basic authentication   password  string  The password for basic authentication   token  string  The token for token-based authentication   inboxPrefix  string  (default _INBOX.) The connection's inbox prefix, which all inboxes will start with   noEcho  boolean  (default false) Turns off echoing. This prevents the server from echoing messages back to the connection if it has subscriptions on the subject being published to   enableErrorListener  boolean  (default false) Enables the connection to the error listener   secureSocket  ?  (default ()) Configurations related to SSL/TLS"},{"page":"/learn/api-docs/ballerina/nats/records/PendingLimits.html","name":"Record - : PendingLimits","summary":"The configurations to set limits on the maximum number of messages or maximum size of messages this consumer ...","content":"Records  v1.2.2  All Modules  Record - : PendingLimits  The configurations to set limits on the maximum number of messages or maximum size of messages this consumer will hold before it starts to drop new messages waiting for the resource functions to drain the queue. Setting a value less than or equal to 0 will disable this check.   Fields  maxMessages  int  Maximum number of pending messages retrieved and held by the consumer service. The default value is 65536   maxBytes  int  Total size of pending messages in bytes retrieved and held by the consumer service. The default value is 67108864"},{"page":"/learn/api-docs/ballerina/nats/records/StreamingConfig.html","name":"Record - : StreamingConfig","summary":"Configuration related to establishing a streaming connection.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : StreamingConfig  Configuration related to establishing a streaming connection.   Fields  ackTimeoutInSeconds  int  (default 30) Timeout (in seconds) to wait for an acknowledgement for the corresponding subscription   connectionTimeoutInSeconds  int  (default 5) Timeout (in seconds) to wait for a connection   maxPubAcksInFlight  int  (default 16384) The maximum number of publish ACKs that may be in flight at any point of time   discoverPrefix  string  (default _STAN.discover) Subject prefix used for server discovery"},{"page":"/learn/api-docs/ballerina/nats/records/SecureSocket.html","name":"Record - : SecureSocket","summary":"Configurations related to facilitating a secure communication with a remote HTTP endpoint.\n\n       ...","content":"Records  v1.2.2  All Modules  Record - : SecureSocket  Configurations related to facilitating a secure communication with a remote HTTP endpoint.   Fields  trustStore  ?  (default ()) Configurations associated with the TrustStore   keyStore  ?  (default ()) Configurations associated with the KeyStore   protocol  string  (default TLS) The standard name of the requested protocol"},{"page":"/learn/api-docs/ballerina/nats/records/StreamingSubscriptionConfigData.html","name":"Record - : StreamingSubscriptionConfigData","summary":"The configurations for the NATS streaming subscription.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : StreamingSubscriptionConfigData  The configurations for the NATS streaming subscription.   Fields  subject  string  Name of the subject to which it is subscribed to   queueName  string  The name of the queue group to which the subscription belongs to   durableName  string  If set, this will survive client restarts   maxInFlight  int  (default 1024) The number of messages the cluster will have in-flight without an ACK   ackWaitInSeconds  int  (default 30) The time (in seconds) the cluster will wait for an ACK for a given message   subscriptionTimeoutInSeconds  int  (default 2) The time (in seconds) the subscription will wait if a network failure occurs during the creation of it   manualAck  boolean  (default false) Enables manual acknowledgments   startPosition  (default NEW_ONLY) The position to start receiving messages"},{"page":"/learn/api-docs/ballerina/nats/records/SubscriptionConfigData.html","name":"Record - : SubscriptionConfigData","summary":"The configurations for the NATS basic subscription.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : SubscriptionConfigData  The configurations for the NATS basic subscription.   Fields  subject  string  Name of the subject   queueName  string  Name of the queue group   pendingLimits  Parameters to set limits on the maximum number of pending messages or maximum size of pending messages"},{"page":"/learn/api-docs/ballerina/nats/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1"},{"page":"/learn/api-docs/ballerina/oauth2/functions.html","name":"Functions -","summary":"(string scopes)Reads the scope(s) for the user with the given username.\nSet of scopes seperated with a spaceArray of groups for the user denoted by the username ...","content":"Functions  v1.2.2  All Modules  Functions - Reads the scope(s) for the user with the given username.  getScopes (string scopes)  returns string[] Reads the scope(s) for the user with the given username.   Parameters  scopes string Set of scopes seperated with a space   Return Type (string[])  Array of groups for the user denoted by the username"},{"page":"/learn/api-docs/ballerina/oauth2/","name":"Module : oauth2","summary":"This module provides an inbound OAuth2 authentication provider, which can be used to authenticate the provided credentials against an introspection endpoint and an outbound OAuth2 authentication provider, which can be used to authenticate an external endpoint.For information on the operations, which you can perform with this module, see the below ...","content":"v1.2.2  All Modules  Module : oauth2  Module Overview This module provides an inbound OAuth2 authentication provider, which can be used to authenticate the provided credentials against an introspection endpoint and an outbound OAuth2 authentication provider, which can be used to authenticate an external endpoint. For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operations, see the and .    Records The data structure, which is used to configure the OAuth2 client credentials grant type.  Record type to hold the details of an error.  The data structure, which is used to configure the OAuth2 access token directly.  The data structure, which can be used to pass the configurations for refreshing the access token directly.  Represents cached OAuth2 information.  Represents introspection server onfigurations.  The data structure, which stores the values received from the authorization/token server to use them for the latter requests without requesting tokens again.  The data structure, which is used to configure the OAuth2 password grant type.  The data structure, which can be used to pass the configurations for refreshing the access token of the password grant type.  Objects Represents the inbound OAuth2 provider, which calls the introspection server, validates the received credentials, and performs authentication and authorization.  Represents the outbound OAuth2 provider, which generates OAtuh2 tokens.  Functions Reads the scope(s) for the user with the given username.  Constants Represents the OAuth2 error reason.  Errors Represents the OAuth2 error type with details."},{"page":"/learn/api-docs/ballerina/oauth2/objects/OutboundOAuth2Provider.html","name":"Object - : OutboundOAuth2Provider","summary":"Represents the outbound OAuth2 provider, which generates OAtuh2 tokens. This supports the client credentials grant type,\npassword grant type, ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  OutboundOAuth2Provider  Represents the outbound OAuth2 provider, which generates OAtuh2 tokens. This supports the client credentials grant type, password grant type, and the direct token mode, which sends the access token directly. The oauth2:OutboundOAuth2Provider is an implementation of the auth:OutboundAuthProvider interface.  Client Credentials Grant Type   oauth2:OutboundOAuth2Provider oauth2Provider1 = new({  tokenUrl: \"https://localhost:9196/oauth2/token\",  clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L\",  clientSecret: \"9205371918321623741\",  scopes: [\"token-scope1\", \"token-scope2\"]  });   Password Grant Type   oauth2:OutboundOAuth2Provider oauth2Provider5 = new({  tokenUrl: \"https://localhost:9196/oauth2/token/authorize/header\",  username: \"johndoe\",  password: \"A3ddj3w\",  clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L\",  clientSecret: \"9205371918321623741\",  scopes: [\"token-scope1\", \"token-scope2\"]  });   Direct Token Mode   oauth2:OutboundOAuth2Provider oauth2Provider13 = new({  accessToken: \"2YotnFZFEjr1zCsicMWpAA\",  refreshConfig: {  refreshUrl: \"https://localhost:9196/oauth2/token/refresh\",  refreshToken: \"XlfBs91yquexJqDaKEMzVg==\",  clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L\",  clientSecret: \"9205371918321623741\",  scopes: [\"token-scope1\", \"token-scope2\"]  }  });    Constructor __init(GrantTypeConfig? oauth2ProviderConfig)   oauth2ProviderConfig GrantTypeConfig? ()  Outbound OAuth2 provider configurations   Methods  Generate a token for the OAuth2 authentication.  Inspects the incoming data and generates the token for the OAuth2 authentication.  Fields  oauth2ProviderConfig  GrantTypeConfig?  Outbound OAuth2 provider configurations   oauth2CacheEntry  Outbound OAuth2 cache entry   generateToken ()  returns string | Generate a token for the OAuth2 authentication.  string:auth:Error token = outboundOAuth2Provider.generateToken();    Return Type (string | )  Generated string token or else an auth:Error if an error occurred   inspect (map data)  returns string | | () Inspects the incoming data and generates the token for the OAuth2 authentication.  string:auth:Error? token = outboundOAuth2Provider.inspect(data);    Parameters  data map Map of data, which is extracted from the HTTP response   Return Type (string | | ())  Generated string token, an auth:Error occurred while generating the token, or else () if nothing is to be returned"},{"page":"/learn/api-docs/ballerina/oauth2/objects/InboundOAuth2Provider.html","name":"Object - : InboundOAuth2Provider","summary":"Represents the inbound OAuth2 provider, which calls the introspection server, validates the received credentials,\nand performs authentication and authorization. ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  InboundOAuth2Provider  Represents the inbound OAuth2 provider, which calls the introspection server, validates the received credentials, and performs authentication and authorization. The oauth2:InboundOAuth2Provider is an implementation of the auth:InboundAuthProvider interface.  oauth2:IntrospectionServerConfig introspectionServerConfig = {  url: \"https://localhost:9196/oauth2/token/introspect\"  };  oauth2:InboundOAuth2Provider inboundOAuth2Provider = new(introspectionServerConfig);    Constructor __init( config)   config OAuth2 introspection server configurations   Methods  Authenticates the provider OAuth2 tokens with an introspection endpoint.  Fields  introspectionClient  Introspection client endpoint   tokenTypeHint  string?  A hint about the type of the token submitted for introspection   authenticate (string credential)  returns boolean | Authenticates the provider OAuth2 tokens with an introspection endpoint.  boolean|auth:Error result = inboundOAuth2Provider.authenticate(\"<credential>\");    Parameters  credential string OAuth2 token to be authenticated   Return Type (boolean | )  true if authentication is successful, false otherwise, or else an auth:Error if an error occurred"},{"page":"/learn/api-docs/ballerina/oauth2/records/DirectTokenConfig.html","name":"Record - : DirectTokenConfig","summary":"The data structure, which is used to configure the OAuth2 access token directly.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : DirectTokenConfig  The data structure, which is used to configure the OAuth2 access token directly.   Fields  accessToken  string  Access token for the authorization endpoint   refreshConfig  Configurations for refreshing the access token   clockSkewInSeconds  int  (default 0) Clock skew in seconds   retryRequest  boolean  (default true) Retry the request if the initial request returns a 401 response   credentialBearer  (default http:AUTH_HEADER_BEARER) Bearer of the authentication credentials, which is sent to the authorization endpoint"},{"page":"/learn/api-docs/ballerina/oauth2/records/ClientCredentialsGrantConfig.html","name":"Record - : ClientCredentialsGrantConfig","summary":"The data structure, which is used to configure the OAuth2 client credentials grant type.\n\n     ...","content":"Records  v1.2.2  All Modules  Record - : ClientCredentialsGrantConfig  The data structure, which is used to configure the OAuth2 client credentials grant type.   Fields  tokenUrl  string  Token URL for the authorization endpoint   clientId  string  Client ID for the client credentials grant authentication   clientSecret  string  Client secret for the client credentials grant authentication   scopes  string[]  Scope(s) of the access request   clockSkewInSeconds  int  (default 0) Clock skew in seconds   retryRequest  boolean  (default true) Retry the request if the initial request returns a 401 response   credentialBearer  (default http:AUTH_HEADER_BEARER) Bearer of the authentication credentials, which is sent to the authorization endpoint   clientConfig  (default {}) HTTP client configurations, which are used to call the authorization endpoint"},{"page":"/learn/api-docs/ballerina/oauth2/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/oauth2/records/InboundOAuth2CacheEntry.html","name":"Record - : InboundOAuth2CacheEntry","summary":"Represents cached OAuth2 information.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : InboundOAuth2CacheEntry  Represents cached OAuth2 information.   Fields  username  string  Username of the OAuth2 validated user   scopes  string  Scopes of the OAuth2 validated user"},{"page":"/learn/api-docs/ballerina/oauth2/records/DirectTokenRefreshConfig.html","name":"Record - : DirectTokenRefreshConfig","summary":"The data structure, which can be used to pass the configurations for refreshing the access token directly.\n\n  ...","content":"Records  v1.2.2  All Modules  Record - : DirectTokenRefreshConfig  The data structure, which can be used to pass the configurations for refreshing the access token directly.   Fields  refreshUrl  string  Refresh token URL for the refresh token server   refreshToken  string  Refresh token for the refresh token server   clientId  string  Client ID for authentication with the authorization endpoint   clientSecret  string  Client secret for authentication with the authorization endpoint   scopes  string[]  Scope(s) of the access request   credentialBearer  (default http:AUTH_HEADER_BEARER) Bearer of authentication credentials, which is sent to the authorization endpoint   clientConfig  (default {}) HTTP client configurations, which are used to call the authorization endpoint"},{"page":"/learn/api-docs/ballerina/oauth2/records/OutboundOAuth2CacheEntry.html","name":"Record - : OutboundOAuth2CacheEntry","summary":"The data structure, which stores the values received from the authorization/token server to use them\nfor the latter requests ...","content":"Records  v1.2.2  All Modules  Record - : OutboundOAuth2CacheEntry  The data structure, which stores the values received from the authorization/token server to use them for the latter requests without requesting tokens again.   Fields  accessToken  string  Access token received from the authorization endpoint   refreshToken  string  Refresh token for the refresh token server   expTime  int  Expiry time (milliseconds since the Epoch) of the access token"},{"page":"/learn/api-docs/ballerina/oauth2/records/IntrospectionServerConfig.html","name":"Record - : IntrospectionServerConfig","summary":"Represents introspection server onfigurations.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : IntrospectionServerConfig  Represents introspection server onfigurations.   Fields  url  string  URL of the introspection server   tokenTypeHint  string  A hint about the type of the token submitted for introspection   oauth2Cache  Cache used to store the OAuth2 token and other related information   defaultTokenExpTimeInSeconds  int  (default 3600) Expiration time of the tokens if introspection response does not contain an exp field   clientConfig  (default {}) HTTP client configurations which calls the introspection server"},{"page":"/learn/api-docs/ballerina/oauth2/records/RefreshConfig.html","name":"Record - : RefreshConfig","summary":"The data structure, which can be used to pass the configurations for refreshing the access token of\nthe password ...","content":"Records  v1.2.2  All Modules  Record - : RefreshConfig  The data structure, which can be used to pass the configurations for refreshing the access token of the password grant type.   Fields  refreshUrl  string  Refresh token URL for the refresh token server   scopes  string[]  Scope(s) of the access request   credentialBearer  (default http:AUTH_HEADER_BEARER) Bearer of the authentication credentials, which is sent to the authorization endpoint   clientConfig  (default {}) HTTP client configurations, which are used to call the authorization endpoint"},{"page":"/learn/api-docs/ballerina/oauth2/records/PasswordGrantConfig.html","name":"Record - : PasswordGrantConfig","summary":"The data structure, which is used to configure the OAuth2 password grant type.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : PasswordGrantConfig  The data structure, which is used to configure the OAuth2 password grant type.   Fields  tokenUrl  string  Token URL for the authorization endpoint   username  string  Username for the password grant authentication   password  string  Password for the password grant authentication   clientId  string  Client ID for the password grant authentication   clientSecret  string  Client secret for the password grant authentication   scopes  string[]  Scope(s) of the access request   refreshConfig  Configurations for refreshing the access token   clockSkewInSeconds  int  (default 0) Clock skew in seconds   retryRequest  boolean  (default true) Retry the request if the initial request returns a 401 response   credentialBearer  (default http:AUTH_HEADER_BEARER) Bearer of the authentication credentials, which is sent to the authorization endpoint   clientConfig  (default {}) HTTP client configurations, which are used to call the authorization endpoint"},{"page":"/learn/api-docs/ballerina/observe/functions.html","name":"Functions -","summary":"(string tagKey, string tagValue, int spanId)Add a key value pair as a tag to the span.\nKey of the tagValue of the tagId of span to which the tags should be added or -1 to add tags to the current active spanAn error if an error occurred while attaching tag to ...","content":"Functions  v1.2.2  All Modules  Functions - Add a key value pair as a tag to the span.  Finish the current span.  Retrieve all registered metrics including default metrics from the ballerina runtime, and user defined metrics.  Retrieves the specific metric that is described by the given name and tags.  Start a span with no parent span.  Start a span and create child relationship to current active span or user specified span.  addTagToSpan (string tagKey, string tagValue, int spanId)  returns error? Add a key value pair as a tag to the span.   Parameters  tagKey string Key of the tag   tagValue string Value of the tag   spanId int (default -1)  Id of span to which the tags should be added or -1 to add tags to the current active span   Return Type (error?)  An error if an error occurred while attaching tag to the span   finishSpan (int spanId)  returns error? Finish the current span.   Parameters  spanId int Id of span to finish   Return Type (error?)  An error if an error occurred while finishing the span   getAllMetrics ()  returns [] Retrieve all registered metrics including default metrics from the ballerina runtime, and user defined metrics.   Return Type ([])  Array of all registered metrics.   lookupMetric (string name, map? tags)  returns | | () Retrieves the specific metric that is described by the given name and tags.   Parameters  name string Name of the metric to lookup.   tags map? (default ())  The key/value pair tags that associated with the metric that should be looked up.   Return Type ( | | ())  The metric instance.   startRootSpan (string spanName, map? tags)  returns int Start a span with no parent span.   Parameters  spanName string Name of the span   tags map? (default ())  Tags to be associated to the span   Return Type (int)  SpanId of the started span   startSpan (string spanName, map? tags, int parentSpanId)  returns int | error Start a span and create child relationship to current active span or user specified span.   Parameters  spanName string Name of the span   tags map? (default ())  Tags to be associated to the span   parentSpanId int (default -1)  Id of the parent span or -1 if parent span should be taken from system trace   Return Type (int | error)  SpanId of the started span"},{"page":"/learn/api-docs/ballerina/observe/","name":"Module : observe TracingMetrics","summary":"This module provides apis for observing Ballerina services.\nBallerina supports Observability out of the box. This module provides user api's to make Ballerina Observability more flexible for the user.To observe Ballerina code, the '--b7a.observability.enabled=true' property should be given when starting the service.\ni.e. `ballerina run hello_world.bal --b7a.observability.enabled=true'\nFor more information on Ballerina Observability ...","content":"v1.2.2  All Modules  Module : observe  Module Overview This module provides apis for observing Ballerina services. Ballerina supports Observability out of the box. This module provides user api's to make Ballerina Observability more flexible for the user. To observe Ballerina code, the '--b7a.observability.enabled=true' property should be given when starting the service. i.e. `ballerina run hello_world.bal --b7a.observability.enabled=true' For more information on Ballerina Observability visit . Tracing Samples Start a root span & attach a child span The following code snippet show an example of how start a root span with no parent and start another span as a child of the first span. Note: Make sure that all started spans are closed properly to ensure that all spans are reported properly. int spanId = observe:startRootSpan(\"Parent Span\");  // Do Something.  int spanId2 = checkpanic observe:startSpan(\"Child Span\", parentSpanId = spanId);  // Do Something.  var ret1 = observe:finishSpan(spanId2);  // Do Something.  var ret2 = observe:finishSpan(spanId);  Start a span attached to a system trace When no parentSpanId is given or a parentSpanId of -1 is given, a span is started as a child span to the current active span in the ootb system trace. int spanId = checkpanic observe:startSpan(\"Child Span\");  // Do Something.  var ret = observe:finishSpan(spanId);  Attach a tag to a span It is possible to add tags to span by using the observe:addTagToSpan() api by providing the span id and relevant tag key and tag value. _ = observe:addTagToSpan(spanId = spanId, \"Tag Key\", \"Tag Value\");  Attach a tag to a span in the system trace When no spanId is provided or -1 is given, the defined tags are added to the current active span in the ootb system trace. var ret = observe:addTagToSpan(\"Tag Key\", \"Tag Value\");  Metrics There are mainly two kind of metrics instances supported; Counter and Gauge. A counter is a cumulative metric that represents a single monotonically increasing counter whose value can only increase or be reset to zero on restart. For example, you can use a counter to represent the number of requests served, tasks completed, or errors. The Gauge metric instance represents a single numerical value that can arbitrarily go up and down, and also based on the statistics configurations provided to the Gauge, it can also report the statistics such as max, min, mean, percentiles, etc. Counter Samples Create The following code snippets provides the information on how Counter instances can be created. Instantiating the counter will simply create an instance based on the params passed. // Create counter with simply by name. observe:Counter simpleCounter = new(\"SimpleCounter\"); // Create counter with description. observe:Counter counterWithDesc = new(\"CounterWithDesc\", desc = \"This is a sample counter description\");  // Create counter with tags. map<string> counterTags = { \"method\": \"GET\" }; observe:Counter counterWithTags = new(\"CounterWithTags\", desc = \"Some description\", tags = counterTags);  Register The counter can registered with the global metrics registry, therefore it can be looked up later without having the reference of the counter that was created. Also, only the registered counters will be reported to the Metrics reporter such as Prometheus. In case, if there is already another non counter metric registered, then there will be an error returned. But if it's another counter instance, then the registered counter instance will be returned. map<string> counterTags = { \"method\": \"GET\" }; observe:Counter counterWithTags = new(\"CounterWithTags\", desc = \"Some description\", tags = counterTags); var anyError = counterWithTags.register(); if anyError is error {  log:printError(\"Cannot register the counter\", err = anyError); }  Unregister The counter can unregistered with the global metrics registry if it is already registered. If a metrics is unregistered, then further it'll not be included in metrics reporting. map<string> counterTags = { \"method\": \"GET\" }; observe:Counter counterWithTags = new(\"CounterWithTags\", desc = \"Some description\", tags = counterTags); var anyError = counterWithTags.register(); if anyError is error {  log:printError(\"Cannot register the counter\", err = anyError); } counterWithTags.unregister();  Increment The counter can be incremented without passing any params (defaulted to 1), or by a specific amount. map<string> counterTags = { \"method\": \"GET\" }; observe:Counter counterWithTags = new(\"CounterWithTags\", desc = \"Some description\", tags = counterTags); // Increment by 1. counterWithTags.increment(); // Increment by amount 10. counterWithTags.increment(amount = 10);  Reset The counter can be resetted to default amount = 0. map<string> counterTags = { \"method\": \"GET\" }; observe:Counter counterWithTags = new(\"CounterWithTags\", desc = \"Some description\", tags = counterTags); counterWithTags.reset();  Get Value The current value can be retrieved by this operation. map<string> counterTags = { \"method\": \"GET\" }; observe:Counter counterWithTags = new(\"CounterWithTags\", desc = \"Some description\", tags = counterTags); int currentValue = counterWithTags.getValue();  Gauge Samples Create The following code snippets provides the information on how Gauge instances can be created. Instantiating the gauge will simply create an instance based on the params passed. // Create gauge with simply by name. // Uses the default statistics configuration. observe:Gauge simpleGauge = new(\"SimpleGauge\"); // Create gauge with description. // Uses the default statistics configuration. observe:Gauge gaugeWithDesc = new(\"GaugeWithDesc\", desc = \"This is a sample gauge description\");  // Create gauge with tags. // Uses the default statistics configuration. map<string> gaugeTags = { \"method\": \"GET\" }; observe:Counter gaugeWithTags = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags);  // Create gauge with disabled statistics. observe:StatisticConfig[] statsConfigs = []; observe:Gauge gaugeWithNoStats = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags, statisticConfig = statsConfigs);  // Create gauge with statistics config. observe:StatisticConfig config = { timeWindow: 30000, percentiles: [0.33, 0.5, 0.9, 0.99], buckets: 3 }; statsConfigs[0]=config; observe:Gauge gaugeWithStats = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags, statisticConfig = statsConfigs);  Register The gauge can registered with the global metrics registry, therefore it can be looked up later without having the reference of the gauge that was created. Also, only the registered counters will be reported to the Metrics reporter such as Prometheus. In case, if there is already another non gauge metric registered, then there will be an error returned. But if it's another gauge instance, then the registered gauge instance will be returned. map<string> gaugeTags = { \"method\": \"GET\" }; observe:Gauge gaugeWithTags = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags); var anyError = gaugeWithTags.register(); if anyError is error {  log:printError(\"Cannot register the gauge\", err = anyError); }  Unregister The gauge can unregistered with the global metrics registry if it is already registered. If a metrics is unregistered, then further it'll not be included in metrics reporting. map<string> gaugeTags = { \"method\": \"GET\" }; observe:Gauge gaugeWithTags = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags); var anyError = gaugeWithTags.register(); if anyError is error {  log:printError(\"Cannot register the gauge\", err = anyError); } gaugeWithTags.unregister();  Increment The gauge can be incremented without passing any params (defaulted to 1.0), or by a specific amount. map<string> gaugeTags = { \"method\": \"GET\" }; observe:Gauge gaugeWithTags = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags); // Increment by 1. gaugeWithTags.increment(); // Increment by amount 10. gaugeWithTags.increment(amount = 10.0); Decrement The gauge can be decremented without passing any params (defaulted to 1.0), or by a specific amount. map<string> gaugeTags = { \"method\": \"GET\" }; observe:Gauge gaugeWithTags = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags); // Increment by 1. gaugeWithTags.decrement(); // Increment by amount 10. gaugeWithTags.decrement(amount = 10.0);  Set Value This method sets the gauge's value with specific amount. map<string> gaugeTags = { \"method\": \"GET\" }; observe:Gauge gaugeWithTags = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags); gaugeWithTags.setValue(100.0);  Get Value. The current value can be retrieved by this operation. map<string> gaugeTags = { \"method\": \"GET\" }; observe:Gauge gaugeWithTags = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags); float currentValue = gaugeWithTags.getValue(); Get Snapshot. This method retrieves current snapshot of the statistics calculation based on the configurations passed to the gauge. If the statistics are disabled, then it'll be returning nil (). map<string> gaugeTags = { \"method\": \"GET\" }; observe:Gauge gaugeWithTags = new(\"GaugeWithTags\", desc = \"Some description\", tags = gaugeTags); gaugeWithTags.setValue(1.0); gaugeWithTags.setValue(2.0); gaugeWithTags.setValue(3.0);  observe:Snapshot[]? summarySnapshot = gaugeWithTags.getSnapshot(); if summarySnapshot is observe:Snapshot[] {  io:println(summarySnapshot); } else {  io:println(\"No statistics available!\"); }  Global Metrics Samples Get All Metrics This method returns all the metrics that are registered in the global metrics registry. This method is mainly useful for metric reporters, where they can fetch all metrics, format those, and report. observe:Metric[] metrics = observe:getAllMetrics(); foreach var metric in metrics {  // Do something. }  Lookup Metric This method will lookup for the metric from the global metric registry and return it. map<string> tags = { \"method\": \"GET\" }; observe:Counter|observe:Gauge|() metric = observe:lookupMetric(\"MetricName\", tags = tags); if metric is observe:Counter {  metric.increment(amount = 10); } else if metric is observe:Gauge {  metric.increment(amount = 10.0); } else {  io:println(\"No Metric Found!\"); }     Records This represents the generic metric record that can represent both counter and gauge.  This represents the percentile value record.  This represents the snapshot of the statistics calculation of the gauge.  This represents the statistic configuration that can be used to instatiate gauge metric.  Objects This represents the metric type - counter, that can be only increased by an integer number.  This represents the metric type - gauge, that can hold instantaneous, increased or decreased value during the usage.  Functions Add a key value pair as a tag to the span.  Finish the current span.  Retrieve all registered metrics including default metrics from the ballerina runtime, and user defined metrics.  Retrieves the specific metric that is described by the given name and tags.  Start a span with no parent span.  Start a span and create child relationship to current active span or user specified span."},{"page":"/learn/api-docs/ballerina/observe/objects/Gauge.html","name":"Object - : Gauge","summary":"This represents the metric type - gauge, that can hold instantaneous, increased or decreased value\nduring the usage.\n\n  ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  Gauge  This represents the metric type - gauge, that can hold instantaneous, increased or decreased value during the usage.   Constructor __init(string name, string? desc, map? tags, []? statisticConfig)   name string Name of the Gauge instance.   desc string? Description of the Gauge instance. If no description is provided, the the default empty string will be used.   tags map? ()  The key/value pair of Tags. If no tags are provided, the default nil value will be used.   statisticConfig []? ()  Statistics configurations array is used for statistics calculation. In case if empty statistics configurations array is passed, then statistics calculation will be disabled. If nil () is passed, then default statistics configs will be used for the statitics calculation.   Methods  Register the gauge metric instance with the Metric Registry.  Unregister the counter metric instance with the Metric Registry.  Increment the gauge's value by an amount.  Decrement the gauge's value by an amount.  Sets the instantaneous value for gauge.  Retrieves the gauge's current value.  Retrieves statistics snapshots based on the statistics configs of the gauge.  Fields  name  string  Name of the counter metric.   description  string  Description of the counter metric.   metricTags  map  Tags associated with the counter metric.   statisticConfigs  []  Array of StatisticConfig objects which defines about the statistical calculation of the gauge during its usage.   register ()  returns error? Register the gauge metric instance with the Metric Registry.   Return Type (error?)  Returns error if there is any metric registered already with the same name but different parameters or in a different kind.   unregister Unregister the counter metric instance with the Metric Registry.   increment Increment the gauge's value by an amount.   Parameters  amount float (default 1.0)  The amount by which the value of gauge needs to be increased. The amount is defaulted as 1.0 and will be used if there is no amount passed in.   decrement Decrement the gauge's value by an amount.   Parameters  amount float (default 1.0)  The amount by which the value of gauge needs to be decreased. The amount is defaulted as 1.0 and will be used if there is no amount passed in.   setValue Sets the instantaneous value for gauge.   Parameters  amount float The instantaneous value that needs to be set as gauge value.   getValue ()  returns float Retrieves the gauge's current value.   Return Type (float)  The current value of the gauge.   getSnapshot ()  returns []? Retrieves statistics snapshots based on the statistics configs of the gauge.   Return Type ([]?)  Array of the statistics snapshots. If there is no statisticsConfigs provided, then it will be nil."},{"page":"/learn/api-docs/ballerina/observe/objects/Counter.html","name":"Object - : Counter","summary":"This represents the metric type - counter, that can be only increased by an integer number.\n\n   ...","content":"Objects  >  >  v1.2.2  All Modules  Object - :  Counter  This represents the metric type - counter, that can be only increased by an integer number.   Constructor __init(string name, string? desc, map? tags)   name string Name of the Counter instance.   desc string? Description of the Counter instance. If no description is provided, the the default empty string will be used.   tags map? ()  The key/value pair of Tags. If no tags are provided, the default nil value will be used.   Methods  Register the counter metric instance with the Metric Registry.  Unregister the counter metric instance with the Metric Registry.  Increment the counter's value by an amount.  Resets the counter's value to zero.  Retrieves the counter's current value.  Fields  name  string  Name of the counter metric.   description  string  Description of the counter metric.   metricTags  map  Tags associated with the counter metric.   register ()  returns error? Register the counter metric instance with the Metric Registry.   Return Type (error?)  Returns error if there is any metric registered already with the same name but different parameters or in a different kind.   unregister Unregister the counter metric instance with the Metric Registry.   increment Increment the counter's value by an amount.   Parameters  amount int (default 1)  The amount by which the value needs to be increased. The amount is defaulted as 1 and will be used if there is no amount passed in.   reset Resets the counter's value to zero.   getValue ()  returns int Retrieves the counter's current value.   Return Type (int)  The current value of the counter."},{"page":"/learn/api-docs/ballerina/observe/records/Metric.html","name":"Record - : Metric","summary":"This represents the generic metric record that can represent both counter and gauge.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : Metric  This represents the generic metric record that can represent both counter and gauge.   Fields  name  string  Name of the metric.   desc  string  Description of the metric.   tags  map  Tags associated with the metric.   metricType  string  Type of the metric.   value  int | float  Current value the metric.   summary  []?  If the metric is configured with statistics config, then the calculated statistics of the metric."},{"page":"/learn/api-docs/ballerina/observe/records/PercentileValue.html","name":"Record - : PercentileValue","summary":"This represents the percentile value record.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : PercentileValue  This represents the percentile value record.   Fields  percentile  float  The percentile of the reported value.   value  float  The value of the percentile."},{"page":"/learn/api-docs/ballerina/observe/records/Snapshot.html","name":"Record - : Snapshot","summary":"This represents the snapshot of the statistics calculation of the gauge.\n\n        ...","content":"Records  v1.2.2  All Modules  Record - : Snapshot  This represents the snapshot of the statistics calculation of the gauge.   Fields  timeWindow  int  The time window in which variation of the values are considered.   mean  float  The average value within the time window.   max  float  The max value within the time window.   min  float  The min value within the time window.   stdDev  float  The standard deviation value within the time window.   percentileValues  []  The percentiles values calculated wihtin the time window."},{"page":"/learn/api-docs/ballerina/observe/records/StatisticConfig.html","name":"Record - : StatisticConfig","summary":"This represents the statistic configuration that can be used to instatiate gauge metric.\n\n      ...","content":"Records  v1.2.2  All Modules  Record - : StatisticConfig  This represents the statistic configuration that can be used to instatiate gauge metric.   Fields  percentiles  float[]  The percentiles that needs to be calculated.   timeWindow  int  The time window (in milli seconds) in which variation of the values are considered.   buckets  int  The number of buckets used in the sliding time window."},{"page":"/learn/api-docs/ballerina/openapi/","name":"Module : openapi Samples","summary":"This module provides the following code generation capabilities.The openapi command in Ballerina is used for OpenAPI to Ballerina and Ballerina to OpenAPI code generation.\nCode generation from OpenAPI to Ballerina can produce ballerina mock services and ballerina client stubs.For build time client stub generation, annotation support is provided.ballerina openapi gen-service <moduleName>:<serivceName> ...","content":"v1.2.2  All Modules  Module : openapi  Module overview This module provides the following code generation capabilities.  Generate the Ballerina code for a given OpenAPI definition. Generate the client stub for an existing Ballerina service at build time. Export the OpenAPI definition of a Ballerina service.  The openapi command in Ballerina is used for OpenAPI to Ballerina and Ballerina to OpenAPI code generation. Code generation from OpenAPI to Ballerina can produce ballerina mock services and ballerina client stubs. For build time client stub generation, annotation support is provided. Mock service from OpenAPI ballerina openapi gen-service <moduleName>:<serivceName> <openapi_contract> [-c: copy-contract] [-o: outputFile] Generates a Ballerina service for the OpenAPI file. This generated service is a mock version of the actual Ballerina service. Generated sources contain the service definition in src/<module-name>/ and the contract will be available in src/<module-name>/resources. Client stub from OpenAPI ballerina openapi gen-client [moduleName]:clientName openapi-contract -o[output directory name] Generates a Ballerina client stub for the service defined in a OpenAPI file. This client can be used in client applications to call the service defined in the OpenAPI file. Service to OpenAPI export ballerina openapi gen-contract [moduleName]:serviceName [-i: ballerinaFile] [-o: contractFile] [-s: skip-bind] Export the Ballerina service to a definition of OpenApi Specification 3.0. For the export to work properly, the input Ballerina service should be defined using basic service and resource level HTTP annotations. Client stub for service Generates a Ballerina client stub to communicate with a Ballerina service. All endpoint(s) that are used for client stub generation should be marked with the @openapi:ClientEndpoint annotation. If not, there might be errors during client stub generation. Endpoints that are not marked with this annotation are not picked for client stub generation. The @openapi:ClientConfig { generate: true } annotation is used to enable or disable client stub generation per service. Samples Mock service from OpenAPI ballerinna openapi gen-service helloworld:helloService hello_service.yaml Client stub from OpenAPI ballerina openapi gen-client hello_client hello_service.yaml OpenAPI from service ballerina openapi gen-contract hello_service.bal Client stub from service import ballerina/http; import ballerina/log; import ballerina/openapi;  // Define this endpoint as a selected endpoint for client generation. @openapi:ClientEndpoint listener http:Listener helloEp = new(9090);  // Enable client code generation for this service. @openapi:ClientConfig {  generate: true } @http:ServiceConfig {  basePath: \"/sample\" } service Hello on helloEp { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/hello\"  }  resource function hello(http:Caller caller, http:Request req) {  http:Response res = new;  res.setPayload(\"Hello\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error when responding\", err = result);  }  } }     Records Configuration elements for client code generation.  Service validation codee   Annotations Annotation to configure client code generation.  Presence of this annotation will mark this endpoint to be used as a service endpoint for client generation   Annotation for additional OpenAPI information of a Ballerina service."},{"page":"/learn/api-docs/ballerina/openapi/records/ServiceInformation.html","name":"Record - : ServiceInformation","summary":"Service validation codee\n\n            \n    ...","content":"Records  v1.2.2  All Modules  Record - : ServiceInformation  Service validation codee   Fields  contract  string  OpenApi Contract link   tags  string[]?  (default []) OpenApi Tags   operations  string[]?  (default []) OpenApi Operations"},{"page":"/learn/api-docs/ballerina/openapi/records/ClientInformation.html","name":"Record - : ClientInformation","summary":"Configuration elements for client code generation.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : ClientInformation  Configuration elements for client code generation.   Fields  generate  boolean  (default true) generates client code if set to true"},{"page":"/learn/api-docs/ballerina/rabbitmq/clients/Message.html","name":"Clients - : Message","summary":"Provides the functionality to manipulate the messages received by the consumer services.\n(boolean multiple)Acknowledges one or several received messages.\ntrue to acknowledge all messages up to and including the called on message and\nfalse to acknowledge just the called on messageA rabbitmq:Error if an I/O error is encountered or else ()(boolean multiple, boolean ...","content":"Clients  v1.2.2  All Modules  Clients - :  Message  Provides the functionality to manipulate the messages received by the consumer services.    Remote Methods  Acknowledges one or several received messages.  rabbitmq:Error? ackResult = message->basicAck(true);    Rejects one or several received messages.  rabbitmq:Error? nackResult = message->basicNack(true, requeue = false);    Methods  Retrieves the delivery tag of the message.  Retrieves the properties of the message (i.  Retrieves the text content of the RabbitMQ message.  Retrieves the float content of the RabbitMQ message.  Retrieves the int content of the RabbitMQ message.  Retrieves the byte array content of the RabbitMQ message.  Retrieves the JSON content of the RabbitMQ message.  Retrieves the XML content of the RabbitMQ message.  basicAck (boolean multiple)  returns ? Acknowledges one or several received messages.  rabbitmq:Error? ackResult = message->basicAck(true);    Parameters  multiple boolean (default false)  true to acknowledge all messages up to and including the called on message and false to acknowledge just the called on message   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   basicNack (boolean multiple, boolean requeue)  returns ? Rejects one or several received messages.  rabbitmq:Error? nackResult = message->basicNack(true, requeue = false);    Parameters  multiple boolean (default false)  true to reject all messages up to and including the called on message and false to reject just the called on message   requeue boolean (default true)  true if the rejected message(s) should be re-queued rather than discarded/dead-lettered   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   getDeliveryTag ()  returns int Retrieves the delivery tag of the message.  int deliveryTag = message.getDeliveryTag();    Return Type (int)  The delivery tag of the message   getProperties ()  returns | Retrieves the properties of the message (i.e., routing headers etc.).  rabbitmq:BasicProperties|rabbitmq:Error properties = message.getProperties();    Return Type ( | )  Properties of the message or else a rabbitmq:Error if an error is encountered   getTextContent ()  returns string | Retrieves the text content of the RabbitMQ message.  string|rabbitmq:Error msgContent = message.getTextContent();    Return Type (string | )  Message data as string value or else a rabbitmq:Error if an error is encountered   getFloatContent ()  returns float | Retrieves the float content of the RabbitMQ message.  float|rabbitmq:Error msgContent = message.getFloatContent();    Return Type (float | )  Message data as a float value or else a rabbitmq:Error if an error is encountered   getIntContent ()  returns int | Retrieves the int content of the RabbitMQ message.  int|rabbitmq:Error msgContent = message.getIntContent();    Return Type (int | )  Message data as an int value or else a rabbitmq:Error if an error is encountered   getByteArrayContent ()  returns byte[] Retrieves the byte array content of the RabbitMQ message.  byte[] msgContent = message.getIntContent();    Return Type (byte[])  Message data as a byte array   getJSONContent ()  returns json | Retrieves the JSON content of the RabbitMQ message.  json|rabbitmq:Error msgContent = message.getJSONContent();    Return Type (json | )  Message data as a JSON value or else a rabbitmq:Error if an error is encountered   getXMLContent ()  returns xml | Retrieves the XML content of the RabbitMQ message.  xml|rabbitmq:Error msgContent = message.getXMLContent();    Return Type (xml | )  Message data as an XML value or else a rabbitmq:Error if an error is encountered"},{"page":"/learn/api-docs/ballerina/rabbitmq/clients/Channel.html","name":"Clients - : Channel","summary":"The Ballerina interface to provide AMQP Channel related functionality.\n( |  connectionOrConnectionConfig)A rabbitmq:Connection object or a connection configuration(? queueConfig)Declares a non-exclusive, auto-delete, or non-durable queue with the given configurations.\nConfigurations required to declare a queueThe name of the queue if autogenerated, () if the queue was successfully\ngenerated with the given parameters, ...","content":"Clients  v1.2.2  All Modules  Clients - :  Channel  The Ballerina interface to provide AMQP Channel related functionality.    Constructor __init( | connectionOrConnectionConfig)   connectionOrConnectionConfig | A rabbitmq:Connection object or a connection configuration   Remote Methods  Declares a non-exclusive, auto-delete, or non-durable queue with the given configurations.  string|rabbitmq:Error? queueResult = newChannel->queueDeclare();    Declares a non-auto-delete, non-durable exchange with no extra arguments. If the arguments are specified, then the exchange is declared accordingly.  rabbitmq:Error? exchangeResult = newChannel->exchangeDeclare({  exchangeName: \"MyExchange\",  exchangeType: rabbitmq:DIRECT_EXCHANGE,  durable: true,  autoDelete: true });    Binds a queue to an exchange with the given binding key.  rabbitmq:Error? bindResult = newChannel.queueBind(\"MyQueue\", \"MyExchange\", \"routing-key\");    Publishes a message. Publishing to a non-existent exchange will result in a channel-level protocol error, which closes the channel.  rabbitmq:Error? sendResult = newChannel->basicPublish(\"Hello from Ballerina\", \"MyQueue\");    Deletes the queue with the given name although it is in use or has messages in it. If the ifUnused or ifEmpty parameters are given, the queue is checked before deleting.  rabbitmq:Error? deleteResult = newChannel->queueDelete(\"MyQueue\");    Deletes the exchange with the given name.  rabbitmq:Error? deleteResult = newChannel->exchangeDelete(\"MyExchange\");    Purges the content of the given queue.  rabbitmq:Error? purgeResult = newChannel->queuePurge(\"MyQueue\");    Retrieves a message synchronously from the given queue providing direct access to the messages in the queue.  rabbitmq:Message|rabbitmq:Error getResult = newChannel->basicGet(\"MyQueue\", rabbitmq:AUTO_ACK);    Methods  Retrieves the connection, which carries this channel.  Closes the rabbitmq:Channel.  Aborts the RabbitMQ rabbitmq:Channel.  queueDeclare (? queueConfig)  returns string | | () Declares a non-exclusive, auto-delete, or non-durable queue with the given configurations.  string|rabbitmq:Error? queueResult = newChannel->queueDeclare();    Parameters  queueConfig ? (default ())  Configurations required to declare a queue   Return Type (string | | ())  The name of the queue if autogenerated, () if the queue was successfully generated with the given parameters, or else a rabbitmq:Error if an I/O error is encountered   exchangeDeclare ( exchangeConfig)  returns ? Declares a non-auto-delete, non-durable exchange with no extra arguments. If the arguments are specified, then the exchange is declared accordingly.  rabbitmq:Error? exchangeResult = newChannel->exchangeDeclare({  exchangeName: \"MyExchange\",  exchangeType: rabbitmq:DIRECT_EXCHANGE,  durable: true,  autoDelete: true });    Parameters  exchangeConfig Configurations required to declare an exchange   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   queueBind (string queueName, string exchangeName, string bindingKey)  returns ? Binds a queue to an exchange with the given binding key.  rabbitmq:Error? bindResult = newChannel.queueBind(\"MyQueue\", \"MyExchange\", \"routing-key\");    Parameters  queueName string Name of the queue   exchangeName string Name of the exchange   bindingKey string Binding key used to bind the queue to the exchange   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   basicPublish ( messageContent, string routingKey, string exchangeName, ? properties)  returns ? Publishes a message. Publishing to a non-existent exchange will result in a channel-level protocol error, which closes the channel.  rabbitmq:Error? sendResult = newChannel->basicPublish(\"Hello from Ballerina\", \"MyQueue\");    Parameters  messageContent The message body   routingKey string The routing key   exchangeName string The name of the exchange to which the message is published   properties ? (default ())  Other properties for the message (routing headers, etc.)   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   queueDelete (string queueName, boolean ifUnused, boolean ifEmpty)  returns ? Deletes the queue with the given name although it is in use or has messages in it. If the ifUnused or ifEmpty parameters are given, the queue is checked before deleting.  rabbitmq:Error? deleteResult = newChannel->queueDelete(\"MyQueue\");    Parameters  queueName string Name of the queue to be deleted   ifUnused boolean (default false)  True if the queue should be deleted only if it's not in use   ifEmpty boolean (default false)  True if the queue should be deleted only if it's empty   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   exchangeDelete (string exchangeName)  returns ? Deletes the exchange with the given name.  rabbitmq:Error? deleteResult = newChannel->exchangeDelete(\"MyExchange\");    Parameters  exchangeName string The name of the exchange   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   queuePurge (string queueName)  returns ? Purges the content of the given queue.  rabbitmq:Error? purgeResult = newChannel->queuePurge(\"MyQueue\");    Parameters  queueName string The name of the queue   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   basicGet (string queueName, ackMode)  returns | Retrieves a message synchronously from the given queue providing direct access to the messages in the queue.  rabbitmq:Message|rabbitmq:Error getResult = newChannel->basicGet(\"MyQueue\", rabbitmq:AUTO_ACK);    Parameters  queueName string The name of the queue   ackMode Type of the acknowledgement mode   Return Type ( | )  A rabbitmq:Message object containing the retrieved message data or else arabbitmq:Error if an I/O error is encountered   getConnection ()  returns | Retrieves the connection, which carries this channel.  rabbitmq:Connection|rabbitmq:Error connResult = newChannel.getConnection();    Return Type ( | )  A rabbitmq:Connection object or else a rabbitmq:Error if an I/O error is encountered   close (int? closeCode, string? closeMessage)  returns ? Closes the rabbitmq:Channel.  rabbitmq:Error? closeResult = newChannel.close();    Parameters  closeCode int? (default ())  The close code (for information, go to the \"Reply Codes\" section in the [AMQP 0-9-1 specification] (#https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf))   closeMessage string? (default ())  A message indicating the reason for closing the channel   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   abortChannel (int? closeCode, string? closeMessage)  returns ? Aborts the RabbitMQ rabbitmq:Channel. Forces the rabbitmq:Channel to close and waits for all the close operations to complete. Any encountered exceptions in the close operations are discarded silently.  rabbitmq:Error? abortResult = newChannel.abortChannel(320, \"Channel Aborted\");    Parameters  closeCode int? (default ())  The close code (for information, go to the \"Reply Codes\" section in the [AMQP 0-9-1 specification] (#https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf))   closeMessage string? (default ())  A message indicating the reason for closing the channel   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()"},{"page":"/learn/api-docs/ballerina/rabbitmq/","name":"Module : rabbitmq","summary":"is one of the most popular open-source enterprise messaging systems modelled on the Advanced Message Queuing Protocol (AMQP) standard. This guide covers the Ballerina RabbitMQ module and its public API. This module contains the functionality to support messaging with the RabbitMQ broker (AMQP 0-9-1). It assumes that the most ...","content":"v1.2.2  All Modules  Module : rabbitmq  Module Overview  is one of the most popular open-source enterprise messaging systems modelled on the Advanced Message Queuing Protocol (AMQP) standard. This guide covers the Ballerina RabbitMQ module and its public API. This module contains the functionality to support messaging with the RabbitMQ broker (AMQP 0-9-1). It assumes that the most recent version of Ballerina is used and is built on top of the basics. Key sections include:  Connecting to RabbitMQ Using Exchanges and Queues Publishing Messages Consuming Messages Using Consumer Services Client Acknowledgements  Connecting to RabbitMQ The core APIs are the rabbitmq:Connection, rabbitmq:Channel, and rabbitmq:Message representing an AMQP 0-9-1 Connection, a Channel, and a Ballerina RabbitMQ Message respectively. The following code connects to a RabbitMQ node using the given parameters (host name, port number, etc.):  rabbitmq:Connection newConnection = new({ host: \"localhost\", port: 5672, username: “guest”, password: “guest” });  The rabbitmq:Connection created above can then be used to open a rabbitmq:Channel.  rabbitmq:Channel newChannel = new(connection);  The rabbitmq:Channel can now be used to send and receive messages as described in the subsequent sections. Enabling TLS It is possible to encrypt the communication between the Ballerina client and the broker by using TLS-enabled connections. Client and server authentication (peer verification) is also supported. To enable the TLS support in the RabbitMQ broker, the node has to be to know the location of the Certificate Authority bundle, the server's certificate file, and the server's key. A TLS listener should also be configured to know which port to listen for TLS-enabled client connections. Connecting to a TLS-enabled RabbitMQ node using the Ballerina client can be done by passing a rabbitmq:SecureSocket record with the appropriate values to the rabbitmq:ConnectionConfiguration record when initializing the connection.  rabbitmq:Connection connection = new({ host: \"localhost\", port: 5671, secureSocket: { trustStore: { path: \"/path/to/trustStore\",  password: \"rabbitstore\" },  keystore: { path: \"/path/to/client_key.p12\",  password: \"MySecretPassword\" },  verifyHostname: true }});  Disconnecting from RabbitMQ To disconnect, simply close the open channels and the connections:  rabbitmq:Error? closeResult = newChannel.close();  rabbitmq:Error? closeResult = newConnection.close();   Note: Closing the Channel may be a good practice. However, it isn’t strictly necessary in this case as it will be done automatically when the underlying Connection is closed.  Using exchanges and queues Client applications work with exchanges and queues, which are the high-level building blocks of the AMQP protocol. These must be declared before they can be used. The following code declares an exchange and a server-named queue and then binds them together.  rabbitmq:Error? exchangeResult = newChannel->exchangeDeclare({ exchangeName: \"MyExchange\",  exchangeType: rabbitmq:DIRECT_EXCHANGE,  durable: true,  autoDelete: true });  string|rabbitmq:Error? queueResult = newChannel->queueDeclare();  if (queueResult is string) {  rabbitmq:Error? bindResult = newChannel.queueBind(queueResult, \"MyExchange\", \"routing-key\");  }  This sample code will declare,  a durable auto-delete exchange of the type rabbitmq:DIRECT_EXCHANGE a non-durable, exclusive auto-delete queue with an auto-generated name  Next, the above function is called to bind the queue to the exchange with the given routing key.  rabbitmq:Error? exchangeResult = newChannel->exchangeDeclare({ exchangeName: \"MyExchange\",  exchangeType: rabbitmq:DIRECT_EXCHANGE,  durable: true,  autoDelete: true });  string|rabbitmq:Error? queueResult = newChannel->queueDeclare({ queueName: \"MyQueue\", durable: true,  exclusive: false,  autoDelete: false });   rabbitmq:Error? bindResult = newChannel.queueBind(\"MyQueue\", \"MyExchange\", \"routing-key\");  This sample code will declare,  a durable auto-delete exchange of the type rabbitmq:DIRECT_EXCHANGE a durable, non-exclusive non-auto-delete queue with a well-known name  Deleting entities and purging queues  Delete a queue:   rabbitmq:Error? deleteResult = newChannel->queueDelete(\"MyQueue\");   Delete a queue only if it is empty:   rabbitmq:Error? deleteResult = newChannel->queueDelete(\"MyQueue\", false, true);   Delete a queue only if it is unused (does not have any consumers):   rabbitmq:Error? deleteResult = newChannel->queueDelete(\"MyQueue\", true, false);   Delete an exchange:   rabbitmq:Error? deleteResult = newChannel->exchangeDelete(\"MyExchange\");   Purge a queue (delete all of its messages):   rabbitmq:Error? purgeResult = newChannel->queuePurge(\"MyQueue\");  Publishing messages To publish a message to an exchange, use the basicPublish() function as follows:  rabbitmq:Error? sendResult = newChannel->basicPublish(\"Hello from Ballerina\", \"MyQueue\");  Setting other properties of the message such as routing headers can be done by using the BasicProperties record with the appropriate values. Consuming messages using consumer services The most efficient way to receive messages is to set up a subscription using a Ballerina RabbitMQ rabbitmq:Listener and any number of consumer services. The messages will then be delivered automatically as they arrive rather than having to be explicitly requested. Multiple consumer services can be bound to one Ballerina RabbitMQ rabbitmq:Listener. The queue to which the service is listening is configured in the rabbitmq:ServiceConfig annotation of the service. listener rabbitmq:Listener channelListener= new(newConnection);  @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  } } service rabbitmqConsumer on channelListener {  resource function onMessage(rabbitmq:Message message) {  string|rabbitmq:Error? messageContent = message.getTextContent();  } }  The rabbitmq:Message object received can be used to retrieve its contents and for manual client acknowledgements. Client acknowledgements The message consuming is supported by mainly two types of acknowledgement modes, which are auto acknowledgements and client acknowledgements. Client acknowledgements can further be divided into to two different types as positive and negative acknowledgements. The default acknowledgement mode is auto-ack (messages are acknowledged immediately after consuming).  WARNING: To ensure the reliability of receiving messages, use the client-ack mode.  The negatively-acknowledged (rejected) messages can be re-queued.  Note: The default thread pool size used in Ballerina is the number of processors available * 2. You can configure the thread pool size by using the BALLERINA_MAX_POOL_SIZE environment variable.  For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the connector, see the following.  .        Records Basic properties of the message - routing headers etc.  Configurations used to create a rabbitmq:Connection.  The details of an error.  Configurations used to declare an exchange.  Configurations used to declare a queue.  Configurations required to create a subscription.  Configurations for facilitating secure connections.  Objects Represents a single network connection to the RabbitMQ broker.  Clients The Ballerina interface to provide AMQP Channel related functionality.  Provides the functionality to manipulate the messages received by the consumer services.  Listeners Ballerina RabbitMQ Message Listener.  Constants Constant for the RabbitMQ Direct Exchange type.  Constant for the RabbitMQ Fan-out Exchange type.  Constant for the RabbitMQ Topic Exchange type.  Constant for the RabbitMQ auto acknowledgement mode.  Constant for the RabbitMQ client acknowledgement mode.  Represents the reason for the RabbitMQ module related errors.  Annotations The annotation, which is used to configure the subscription.  Types Types of acknowledgement modes supported by the Ballerina RabbitMQ Connector.  Types of message content that can be published.  Errors Represents the RabbitMQ module related errors."},{"page":"/learn/api-docs/ballerina/rabbitmq/listeners/Listener.html","name":"Listener - : Listener","summary":"Ballerina RabbitMQ Message Listener.\nProvides a listener to consume messages from the RabbitMQ server.\n( |  connectionOrConnectionConfig, int? prefetchCount, int? prefetchSize)A rabbitmq:Connection object or the connection configurations.Maximum number of messages that the server will deliver. Give the value as 0 if unlimited.\nUnless explicitly given, this value is 10 by default.Maximum amount ...","content":"Listeners  v1.2.2  All Modules  Listener - : Listener Ballerina RabbitMQ Message Listener. Provides a listener to consume messages from the RabbitMQ server.    Constructor __init( | connectionOrConnectionConfig, int? prefetchCount, int? prefetchSize)   connectionOrConnectionConfig | A rabbitmq:Connection object or the connection configurations.   prefetchCount int? ()  Maximum number of messages that the server will deliver. Give the value as 0 if unlimited. Unless explicitly given, this value is 10 by default.   prefetchSize int? ()  Maximum amount of content (measured in octets) that the server will deliver and 0 if unlimited   Methods  Stops consuming messages and detaches the service from the rabbitmq:Listener endpoint.  Stops consuming messages through all consumer services by terminating the connection and all its channels.  Stops consuming messages through all the consumer services and terminates the connection with the server.  Retrieve the rabbitmq:Channel, which initializes this rabbitmq:Listener.  LifeCycle Methods  Attaches the service to the rabbitmq:Listener endpoint.  Starts consuming the messages on all the attached services.  Methods  __detach (service s)  returns error? Stops consuming messages and detaches the service from the rabbitmq:Listener endpoint.   Parameters  s service Type descriptor of the service   Return Type (error?)  () or else a rabbitmq:Error upon failure to detach the service   __gracefulStop ()  returns error? Stops consuming messages through all consumer services by terminating the connection and all its channels.   Return Type (error?)  () or else a rabbitmq:Error upon failure to close the ChannelListener   __immediateStop ()  returns error? Stops consuming messages through all the consumer services and terminates the connection with the server.   Return Type (error?)  () or else a rabbitmq:Error upon failure to close ChannelListener.   getChannel ()  returns Retrieve the rabbitmq:Channel, which initializes this rabbitmq:Listener.   Return Type ()  A rabbitmq:Channel object or else a rabbitmq:Error if an I/O problem is encountered.   LifeCycle Methods  __attach (service s, string? name)  returns error? Attaches the service to the rabbitmq:Listener endpoint.   Parameters  s service Type descriptor of the service   name string? (default ())  Name of the service   Return Type (error?)  () or else a rabbitmq:Error upon failure to register the service   __start ()  returns error? Starts consuming the messages on all the attached services.   Return Type (error?)  () or else a rabbitmq:Error upon failure to start"},{"page":"/learn/api-docs/ballerina/rabbitmq/objects/Connection.html","name":"Object - : Connection","summary":"Represents a single network connection to the RabbitMQ broker.\n\n          ...","content":"Objects  >  v1.2.2  All Modules  Object - :  Connection  Represents a single network connection to the RabbitMQ broker.   Constructor __init( connectionConfiguration)   connectionConfiguration Configurations required to initialize the rabbitmq:Connection   Methods  Closes the rabbitmq:Connection and all its rabbitmq:Channels.  Aborts the rabbitmq:Connection and all its rabbitmq:Channels.  Checks whether close was already called.  close (int? closeCode, string? closeMessage, int? timeoutInMillis)  returns ? Closes the rabbitmq:Connection and all its rabbitmq:Channels. It waits with a provided timeout for all the close operations to complete. When the timeout is reached, the socket is forced to close.  rabbitmq:Error? closeResult = newConnection.close();    Parameters  closeCode int? (default ())  The close code (for information, go to the \"Reply Codes\" section in the [AMQP 0-9-1 specification] (#https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf))   closeMessage string? (default ())  A message indicating the reason for closing the connection   timeoutInMillis int? (default ())  Timeout (in milliseconds) for completing all the close-related operations. Use -1 for infinity   Return Type (?)  A rabbitmq:Error if an I/O error is encountered or else ()   abortConnection Aborts the rabbitmq:Connection and all its rabbitmq:Channels. Forces the rabbitmq:Connection to close and waits for all the close operations to complete. When the timeout is reached, the socket is forced to close. Any encountered exceptions in the close operations are discarded silently.  connection.abortConnection(320, \"Channel Aborted\");    Parameters  closeCode int? (default ())  The close code (for information, go to the \"Reply Codes\" section in the [AMQP 0-9-1 specification] (#https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf))   closeMessage string? (default ())  A message indicating the reason for closing the connection   timeoutInMillis int? (default ())  Timeout (in milliseconds) for completing all the close-related operations. Use -1 for infinity   isClosed ()  returns boolean Checks whether close was already called.  boolean closed = newConnection.isClosed();    Return Type (boolean)  The value true if the rabbitmq:Connection is already closed or else false"},{"page":"/learn/api-docs/ballerina/rabbitmq/records/ConnectionConfiguration.html","name":"Record - : ConnectionConfiguration","summary":"Configurations used to create a rabbitmq:Connection.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : ConnectionConfiguration  Configurations used to create a rabbitmq:Connection.   Fields  host  string  The host used for establishing the connection   port  int  (default 5672) The port used for establishing the connection   username  string?  (default ()) The username used for establishing the connection   password  string?  (default ()) The password used for establishing the connection   connectionTimeoutInMillis  int?  (default ()) Connection TCP establishment timeout in milliseconds and zero for infinite   handshakeTimeoutMillis  int?  (default ()) The AMQP 0-9-1 protocol handshake timeout in milliseconds   shutdownTimeoutInMillis  int?  (default ()) Shutdown timeout in milliseconds, zero for infinite, and the default value is 10000. If the consumers exceed this timeout, then any remaining queued deliveries (and other Consumer callbacks) will be lost   heartbeatInSeconds  int?  (default ()) The initially-requested heartbeat timeout in seconds and zero for none   secureSocket  ?  (default ()) Configurations for facilitating secure connections"},{"page":"/learn/api-docs/ballerina/rabbitmq/records/BasicProperties.html","name":"Record - : BasicProperties","summary":"Basic properties of the message - routing headers etc.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : BasicProperties  Basic properties of the message - routing headers etc.   Fields  replyTo  string?  The queue name to which the other apps should send the response   contentType  string?  (default ()) Content type of the message   contentEncoding  string?  (default ()) Content encoding of the message   correlationId  string?  (default ()) Client-specific ID that can be used to mark or identify messages between clients"},{"page":"/learn/api-docs/ballerina/rabbitmq/records/QueueConfiguration.html","name":"Record - : QueueConfiguration","summary":"Configurations used to declare a queue.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : QueueConfiguration  Configurations used to declare a queue.   Fields  queueName  string  The name of the queue, which will be autogenerated if not specified   durable  boolean  (default false) True if declaring a durable queue (the queue will survive in a server restart)   exclusive  boolean  (default false) True if declaring an exclusive queue (restricted to this connection)   autoDelete  boolean  (default true) True if declaring an auto-delete queue (the server will delete it when it is no longer in use)   arguments  map?  (default ()) Other properties (construction arguments) for the queue"},{"page":"/learn/api-docs/ballerina/rabbitmq/records/ExchangeConfiguration.html","name":"Record - : ExchangeConfiguration","summary":"Configurations used to declare an exchange.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : ExchangeConfiguration  Configurations used to declare an exchange.   Fields  exchangeName  string  The name of the exchange   exchangeType  (default DIRECT_EXCHANGE) The type of the exchange   durable  boolean  (default false) True if declaring a durable exchange (the exchange will survive in a server restart)   autoDelete  boolean  (default false) True if an autodelete exchange is declared (the server will delete it when it is no longer in use)   arguments  map?  (default ()) Other properties (construction arguments) for the queue"},{"page":"/learn/api-docs/ballerina/rabbitmq/records/Detail.html","name":"Record - : Detail","summary":"The details of an error.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : Detail  The details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/rabbitmq/records/RabbitMQServiceConfig.html","name":"Record - : RabbitMQServiceConfig","summary":"Configurations required to create a subscription.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : RabbitMQServiceConfig  Configurations required to create a subscription.   Fields  queueConfig  Configurations of the queue to be subscribed   ackMode  (default AUTO_ACK) Type of the acknowledgement mode   prefetchCount  int  Maximum number of messages that the server will deliver and 0 if unlimited. Unless explicitly given, this value is 10 by default.   prefetchSize  int  Maximum amount of content (measured in octets) that the server will deliver and 0 if unlimited"},{"page":"/learn/api-docs/ballerina/rabbitmq/records/SecureSocket.html","name":"Record - : SecureSocket","summary":"Configurations for facilitating secure connections.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : SecureSocket  Configurations for facilitating secure connections.   Fields  trustStore  ?  (default ()) Configurations associated with the TrustStore   keyStore  ?  (default ()) Configurations associated with the KeyStore   tlsVersion  string  (default TLS) TLS version   verifyHostname  boolean  (default true) True if hostname verification should be enabled"},{"page":"/learn/api-docs/ballerina/reflect/","name":"Module : reflect","summary":"This module provides utility methods for obtaining reflective information about the Ballerina runtime.The sample below shows how to retrieve all the annotations of a service: ...","content":"v1.2.2  All Modules  Module : reflect  Module overview This module provides utility methods for obtaining reflective information about the Ballerina runtime. Get service annotations The sample below shows how to retrieve all the annotations of a service: @http:ServiceConfig { basePath: \"/helloWorld\" } service hello on new http:Listener(9090) {   resource function hello(http:Caller caller, http:Request req) {  http:Response res = new;  res.setTextPayload(\"hello world\");  var result = caller->respond(res);  } }  reflect:annotationData[] annotations = reflect:getServiceAnnotations(hello); string annoName = annotations[0].name; // E.g. “ServiceConfig” string annoPkg = annotations[0].moduleName; // E.g. “ballerina.http”      Functions Function to retrieve the resource's annotation.  Function to retrieve the service's annotation."},{"page":"/learn/api-docs/ballerina/reflect/functions.html","name":"Functions -","summary":"(service serviceType, string resourceName, string annotName, string? moduleName)Function to retrieve the resource's annotation.\nThe service that the resource belongs toName of the resourceName of the annotationName of the moduleReturns the resource annotation data(service serviceType, string annotName, string? moduleName)Function to retrieve the service's annotation.\nThe service that the annotation belongs toName of the ...","content":"Functions  v1.2.2  All Modules  Functions - Function to retrieve the resource's annotation.  Function to retrieve the service's annotation.  getResourceAnnotations (service serviceType, string resourceName, string annotName, string? moduleName)  returns any Function to retrieve the resource's annotation.   Parameters  serviceType service The service that the resource belongs to   resourceName string Name of the resource   annotName string Name of the annotation   moduleName string? (default ())  Name of the module   Return Type (any)  Returns the resource annotation data   getServiceAnnotations (service serviceType, string annotName, string? moduleName)  returns any Function to retrieve the service's annotation.   Parameters  serviceType service The service that the annotation belongs to   annotName string Name of the annotation   moduleName string? (default ())  Name of the module   Return Type (any)  Returns the service annotation data"},{"page":"/learn/api-docs/ballerina/runtime/","name":"Module : runtime","summary":"This module provides functions to interact with the runtime, the invocation context, and to manage errors.The Invocation Context is a data holder, which is created per request and preserved for a single request-response flow. It comprises of a unique ID, a runtime:Principal instance, which includes user details, a runtime:AuthenticationContext, which ...","content":"v1.2.2  All Modules  Module : runtime  Module Overview This module provides functions to interact with the runtime, the invocation context, and to manage errors. Invocation Context The Invocation Context is a data holder, which is created per request and preserved for a single request-response flow. It comprises of a unique ID, a runtime:Principal instance, which includes user details, a runtime:AuthenticationContext, which has the authentication-related details if available, and an attribute map to hold context information. The following code snippet shows how to access the runtime:InvocationContext and the set of data for the runtime:Principal and runtime:AuthenticationContext. runtime:InvocationContext invocationContext = runtime:getInvocationContext();  runtime:Principal? principal = invocationContext[\"principal\"]; if (principal is runtime:Principal) {  // Set the username as ‘tom’.  principal[\"username\"] = \"tom\"; }  runtime:AuthenticationContext? authContext = invocationContext[\"authenticationContext\"]; if (authContext is runtime:AuthenticationContext) {  // Set the auth scheme.  authContext.scheme = \"jwt\"; }  The following code snippet shows how to access the runtime:InvocationContext and get the data from the runtime:Principal and runtime:AuthenticationContext, runtime:InvocationContext invocationContext = runtime:getInvocationContext(); runtime:Principal? principal = invocationContext[\"principal\"]; if (principal is runtime:Principal) {  // Retrieve the user name.  string? userName = principal[\"username\"]; }  runtime:AuthenticationContext? authContext = invocationContext[\"authenticationContext\"]; if (authContext is runtime:AuthenticationContext) {  // Retrieve the auth scheme.  string? authScheme = authContext[\"scheme\"]; }  For information on the operations, which you can perform with this module, see the below Functions.    Records Represents the runtime:AuthenticationContext populated with the authenticated information.  Represents a data holder of the current call stack element.  Represents the runtime:InvocationContext.  Represents the runtime:Principal populated with the authenticated user information.  Functions Retrieves the array of runtime:CallStackElement instances.  Returns the runtime:InvocationContext instance.  Returns the system property value associated with the specified property name.  Halts the current worker for a predefined amount of time.  Gives a timeout to the current worker for a predefined amount of time."},{"page":"/learn/api-docs/ballerina/runtime/functions.html","name":"Functions -","summary":"(handle name)()Retrieves the array of runtime:CallStackElement instances.\nArray of runtime:CallStackElement records()Returns the runtime:InvocationContext instance.\nThe runtime:InvocationContext instance(string name)Returns the system property value associated with the specified property name.\nName of the propertyValue of the property if the property exists or else an empty string otherwiseHalts the current worker for a predefined amount of ...","content":"Functions  v1.2.2  All Modules  Functions - Retrieves the array of runtime:CallStackElement instances.  Returns the runtime:InvocationContext instance.  Returns the system property value associated with the specified property name.  Halts the current worker for a predefined amount of time.  Gives a timeout to the current worker for a predefined amount of time.  externGetProperty (handle name)  returns handle Parameters  name handle Return Type (handle)  getCallStack ()  returns [] Retrieves the array of runtime:CallStackElement instances.  runtime:CallStackElement[] callStackElements = runtime:getCallStack();    Return Type ([])  Array of runtime:CallStackElement records   getInvocationContext ()  returns Returns the runtime:InvocationContext instance.  runtime:InvocationContext invocationContext = runtime:getInvocationContext();    Return Type ()  The runtime:InvocationContext instance   getProperty (string name)  returns string Returns the system property value associated with the specified property name.  string userHome = runtime:getProperty(\"user.home\");    Parameters  name string Name of the property   Return Type (string)  Value of the property if the property exists or else an empty string otherwise   sleep Halts the current worker for a predefined amount of time.  runtime:sleep(1000);    Parameters  millis int Amount of time to sleep in milliseconds   timeout (int millis)  returns future Gives a timeout to the current worker for a predefined amount of time.  future<()> f1 = runtime:timeout(2000);    Parameters  millis int Amount of time needed for the timeout in milliseconds   Return Type (future)  Future to be invoked after the timeout"},{"page":"/learn/api-docs/ballerina/runtime/records/CallStackElement.html","name":"Record - : CallStackElement","summary":"Represents a data holder of the current call stack element.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : CallStackElement  Represents a data holder of the current call stack element.   Fields  callableName  string  Callable name   moduleName  string  Module name   fileName  string  File name   lineNumber  int  Line number"},{"page":"/learn/api-docs/ballerina/runtime/records/InvocationContext.html","name":"Record - : InvocationContext","summary":"Represents the runtime:InvocationContext.\n\n            \n    ...","content":"Records  v1.2.2  All Modules  Record - : InvocationContext  Represents the runtime:InvocationContext.   Fields  id  string  Unique ID generated when initiating the invocation context   principal  User principal instance   authenticationContext  Authentication context instance   attributes  map  Map of context attributes"},{"page":"/learn/api-docs/ballerina/runtime/records/Principal.html","name":"Record - : Principal","summary":"Represents the runtime:Principal populated with the authenticated user information.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Principal  Represents the runtime:Principal populated with the authenticated user information.   Fields  userId  string  User ID of the authenticated user   username  string  Username of the authenticated user   claims  map  Claims of the authenticated user   scopes  string[]  Scopes of the authenticated user"},{"page":"/learn/api-docs/ballerina/runtime/records/AuthenticationContext.html","name":"Record - : AuthenticationContext","summary":"Represents the runtime:AuthenticationContext populated with the authenticated information.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : AuthenticationContext  Represents the runtime:AuthenticationContext populated with the authenticated information.   Fields  scheme  string  Authentication scheme   authToken  string  Token for the provided scheme"},{"page":"/learn/api-docs/ballerina/socket/clients/Client.html","name":"Clients - : Client","summary":"Represents the socket client and related remote functions.\n(? clientConfig)This is used to provide the configurations like host, port, and timeout\n                    \n           ...","content":"Clients  v1.2.2  All Modules  Clients - :  Client  Represents the socket client and related remote functions.    Constructor __init(? clientConfig)   clientConfig ? This is used to provide the configurations like host, port, and timeout   Remote Methods  Writes the given data to the client socket.  int|socket:Error writeResult = socketClient:write(payloadByte);    Reads data from the client socket. If the data has the specified length, then it waits until that number of bytes are received from the client. Else, it returns the data available in the OS buffer. In the case of the connection being closed by the client, then return either -1 or the data that is currently available in the buffer. Number of bytes returned will be < 0 if the client closes the connection.  [byte[], int]|socket:ReadTimedOutError result = socketClient->read();    Closes the client socket connection.  socket:Error? closeResult = socketClient->close();    Shuts down any further reading from the socket.  socket:Error? result = socketClient->shutdownRead();    Shuts down any further writing from the socket.  socket:Error? result = socketClient->shutdownWrite();    Fields  remotePort  int  (default 0) The remote port number to which this socket is connected   localPort  int  (default 0) The local port number to which this socket is bound   remoteAddress  string?  (default ()) The remote IP address string in textual presentation to which the socket is connected   localAddress  string?  (default ()) The local IP address string in textual presentation to which the socket is bound   id  int  (default 0) A unique identifier to identify each client   write (byte[] content)  returns int | Writes the given data to the client socket.  int|socket:Error writeResult = socketClient:write(payloadByte);    Parameters  content byte[] The content, which will be sent to the client socket   Return Type (int | )  The number of bytes that got written or else a socket:Error if the given data can't be written   read (int length)  returns [byte[], int] | Reads data from the client socket. If the data has the specified length, then it waits until that number of bytes are received from the client. Else, it returns the data available in the OS buffer. In the case of the connection being closed by the client, then return either -1 or the data that is currently available in the buffer. Number of bytes returned will be < 0 if the client closes the connection.  [byte[], int]|socket:ReadTimedOutError result = socketClient->read();    Parameters  length int (default -100)  Represents the number of bytes, which should be read   Return Type ([byte[], int] | )  Content as a byte array and the number of bytes read or else a socket:ReadTimedOutError if the data can't be read from the client   close ()  returns ? Closes the client socket connection.  socket:Error? closeResult = socketClient->close();    Return Type (?)  A socket:Error if the client can't close the connection or else ()   shutdownRead ()  returns ? Shuts down any further reading from the socket.  socket:Error? result = socketClient->shutdownRead();    Return Type (?)  A socket:Error if the client can't be shut down to stop reading from the socket or else ()   shutdownWrite ()  returns ? Shuts down any further writing from the socket.  socket:Error? result = socketClient->shutdownWrite();    Return Type (?)  A socket:Error if the client can't shut down to stop the writing to the socket or else ()"},{"page":"/learn/api-docs/ballerina/socket/","name":"Module : socket","summary":"This module provides an implementation for sending/receiving messages to/from another application process (local or remote) for both connection-oriented and connectionless protocols.The socket:Client is used to connect to a socket server and interact with it. The client can only send the data to the server and the client's call-back service can ...","content":"v1.2.2  All Modules  Module : socket  Module Overview This module provides an implementation for sending/receiving messages to/from another application process (local or remote) for both connection-oriented and connectionless protocols. TCP Client The socket:Client is used to connect to a socket server and interact with it. The client can only send the data to the server and the client's call-back service can retrieve the data from the server and do multiple requests/responses between the client and the server. A Client can be defined by providing the host, port, and callbackService as follows. socket:Client socketClient = new ({host: \"localhost\", port: 61598, callbackService: ClientService}); string msg = \"Hello Ballerina\\n\"; byte[] message = msg.toBytes(); var writeResult = socketClient->write(message);  A client's call-back service can be defined as follows: service ClientService = service {  resource function onConnect(socket:Caller caller) {  io:println(\"connect: \", caller.remotePort);  } }  UDP Client The socket:UdpClient is used to interact with the remote UDP host and it can be defined as follows: socket:UdpClient socketClient = new; string msg = \"Hello from UDP client\"; byte[] message = msg.toBytes(); int|socket:Error sendResult = socketClient->sendTo(message, { host: \"localhost\", port: 48826 });  Listener The socket:Listener is used to listen to the incoming socket request. The onConnect(socket:Caller) resource function gets invoked when a new client is connected. The new client is represented using the socket:Caller. The onReadReady(socket:Caller) resource gets invoked once the remote client sends some data. A socket:Listener can be defined as follows: listener socket:Listener server = new(61598); service echoServer on server {   resource function onConnect(socket:Caller caller) {  io:println(\"connect: \", caller.remotePort);  }   resource function onReadReady(socket:Caller caller) {  [byte[], int]|socket:ReadTimedOutError result = caller->read();  } }  For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operations, see the following.        Records This represent the IP socket address.  Configurations for the socket client.  Record type to hold the details of an error.  Represents the socket server configuration.  Configurations for the UDP client.  Clients Represents the socket client and related remote functions.  Initializes the UDP client based on the provided configurations.  Listeners Represents the socket listener on which the socket listener service is registered and started.  Constants This will used to construct a ReadTimedOutError.  This will used to construct a GENERIC_ERROR.  Types Represents caller object in socket service resources and client callback service resources.  Represents socket module related errors.  Errors Represents generic socket error.  This will returns once the given read timed out time exceed for socket reads."},{"page":"/learn/api-docs/ballerina/socket/clients/UdpClient.html","name":"Clients - : UdpClient","summary":"Initializes the UDP client based on the provided configurations.\n(? localAddress, ? config)Local binding of the interface and portThe configurations for the UDP client\n                    \n        ...","content":"Clients  v1.2.2  All Modules  Clients - :  UdpClient  Initializes the UDP client based on the provided configurations.    Constructor __init(? localAddress, ? config)   localAddress ? ()  Local binding of the interface and port   config ? ()  The configurations for the UDP client   Remote Methods  Sends the given data to the specified remote client.  int|socket:Error result = socketClient->sendTo(c1, {host: \"localhost\", port: 48826});    Reads data from the remote client. If the data has the specified length, then it waits until that number of bytes are received from the client. Else, it returns the data available in the OS buffer or waits until the data is received. If the request length is lesser than the data in the buffer, then the rest will be discarded.  [byte[], int, Address]|ReadTimedOutError result = socketClient->receiveFrom();    Closes the client socket connection.  socket:Error? closeResult = socketClient->close();    Fields  localPort  int  (default 0) The local port number to which this socket is bound   interface  string?  (default ()) The network interface to bind   id  int  (default 0) A unique identifier to identify each client   sendTo (byte[] content, address)  returns int | Sends the given data to the specified remote client.  int|socket:Error result = socketClient->sendTo(c1, {host: \"localhost\", port: 48826});    Parameters  content byte[] The content to be sent to the client socket   address The address of the remote client socket   Return Type (int | )  The number of bytes got written or else a socket:Error if the given data can't be sent   receiveFrom (int length)  returns [byte[], int, ] | Reads data from the remote client. If the data has the specified length, then it waits until that number of bytes are received from the client. Else, it returns the data available in the OS buffer or waits until the data is received. If the request length is lesser than the data in the buffer, then the rest will be discarded.  [byte[], int, Address]|ReadTimedOutError result = socketClient->receiveFrom();    Parameters  length int (default -100)  Represents the number of bytes, which should be read   Return Type ([byte[], int, ] | )  The content as a byte array, the number of bytes read, the address of the sender, or else a socket:Error if the data can't be read from the client   close ()  returns ? Closes the client socket connection.  socket:Error? closeResult = socketClient->close();    Return Type (?)  A socket:Error if it can't close the connection or else ()"},{"page":"/learn/api-docs/ballerina/socket/listeners/Listener.html","name":"Listener - : Listener","summary":"Represents the socket listener on which the socket listener service is registered and started.\n(int port, ? config)The port number of the remote serviceConfigurations related to the socket:Listener()Stops the socket:Listener gracefully.\n() or else a socket:Error upon failure to stop the listener()Stops the socket:Listener forcefully.\n() or else a socket:Error upon failure to ...","content":"Listeners  v1.2.2  All Modules  Listener - : Listener Represents the socket listener on which the socket listener service is registered and started.    Constructor __init(int port, ? config)   port int The port number of the remote service   config ? ()  Configurations related to the socket:Listener   Methods  Stops the socket:Listener gracefully.  Stops the socket:Listener forcefully.  Stops consuming messages and detaches the service from the socket:Listener.  LifeCycle Methods  Starts the socket:Listener.  Binds a service to the socket:Listener.  Methods  __gracefulStop ()  returns error? Stops the socket:Listener gracefully.  socket:error? result = socketListener.__gracefulStop();    Return Type (error?)  () or else a socket:Error upon failure to stop the listener   __immediateStop ()  returns error? Stops the socket:Listener forcefully.  socket:error? result = socketListener.__immediateStop();    Return Type (error?)  () or else a socket:Error upon failure to stop the listener   __detach (service s)  returns error? Stops consuming messages and detaches the service from the socket:Listener.  socket:error? result = socketListener.__detach(helloService);    Parameters  s service Type descriptor of the service   Return Type (error?)  () or else a socket:Error upon failure to detach the service   LifeCycle Methods  __start ()  returns error? Starts the socket:Listener.  socket:error? result = socketListener.__start();    Return Type (error?)  () or else a socket:Error upon failure to start the listener   __attach (service s, string? name)  returns error? Binds a service to the socket:Listener.  socket:error? result = socketListener.__attach(helloService);    Parameters  s service Type descriptor of the service   name string? (default ())  Name of the service   Return Type (error?)  () or else a socket:Error upon failure to register the listener"},{"page":"/learn/api-docs/ballerina/socket/records/Address.html","name":"Record - : Address","summary":"This represent the IP socket address.\n\n            \n ...","content":"Records  v1.2.2  All Modules  Record - : Address  This represent the IP socket address.   Fields  host  string  The hostname of the Socket Address   port  int  The port number of the Socket Address"},{"page":"/learn/api-docs/ballerina/socket/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  The specific error message for the error.   cause  error  The cause of the error if this error occurred due to another error"},{"page":"/learn/api-docs/ballerina/socket/records/ClientConfig.html","name":"Record - : ClientConfig","summary":"Configurations for the socket client.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : ClientConfig  Configurations for the socket client.   Fields  host  string  The target service URL   port  int  The port number of the remote service   readTimeoutInMillis  int  (default 300000) The socket reading timeout value to be used in milliseconds. If this is not set, the default value of 300000 milliseconds (5 minutes) will be used.   callbackService  service  The callback service for the client. Resources in this service gets called on the receipt of the messages from the server."},{"page":"/learn/api-docs/ballerina/socket/records/UdpClientConfig.html","name":"Record - : UdpClientConfig","summary":"Configurations for the UDP client.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : UdpClientConfig  Configurations for the UDP client.   Fields  readTimeoutInMillis  int  (default 300000) The socket reading timeout value to be used in milliseconds. If this is not set, the default value of 300000 milliseconds (5 minutes) will be used."},{"page":"/learn/api-docs/ballerina/socket/records/ListenerConfig.html","name":"Record - : ListenerConfig","summary":"Represents the socket server configuration.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : ListenerConfig  Represents the socket server configuration.   Fields  interface  string?  (default ()) The interface for the server to be bound   readTimeoutInMillis  int  (default 300000) The socket reading timeout value to be used in milliseconds. If this is not set, the default value of 300000 milliseconds (5 minutes) will be used."},{"page":"/learn/api-docs/ballerina/stringutils/","name":"Module : stringutils","summary":"This module provides utility functions to manipulate the built-in string data type. ...","content":"v1.2.2  All Modules  Module : stringutils  Module overview This module provides utility functions to manipulate the built-in string data type.    Functions Checks whether the given string contains a particular substring.  Checks if two strings are equal ignoring the case of the strings.  Returns a hash code for a given string.  Returns the last index of the provided substring within a string.  Checks whether the given string matches the provided regex.  Replaces each occurrence of the provided substring inside the provided originalString with the specified replacement string.  Replaces each occurrence of the substrings, which matches the provided regular expression from the given original string value with the provided replacement string.  Replaces the first substring that matches the given regular expression with the provided replacement string.  Returns an array of strings by splitting a string using the provided delimiter.  Returns a boolean value of a given string."},{"page":"/learn/api-docs/ballerina/stringutils/functions.html","name":"Functions -","summary":"(string originalString, string substring)Checks whether the given string contains a particular substring.\nThe string to check whether it contains the substringThe substring to find within the originalStringtrue if the originalString contains the provided substring\nor else false(string firstString, string secondString)Checks if two strings are equal ignoring the case of the strings.\nThe first ...","content":"Functions  v1.2.2  All Modules  Functions - Checks whether the given string contains a particular substring.  Checks if two strings are equal ignoring the case of the strings.  Returns a hash code for a given string.  Returns the last index of the provided substring within a string.  Checks whether the given string matches the provided regex.  Replaces each occurrence of the provided substring inside the provided originalString with the specified replacement string.  Replaces each occurrence of the substrings, which matches the provided regular expression from the given original string value with the provided replacement string.  Replaces the first substring that matches the given regular expression with the provided replacement string.  Returns an array of strings by splitting a string using the provided delimiter.  Returns a boolean value of a given string.  contains (string originalString, string substring)  returns boolean Checks whether the given string contains a particular substring.  boolean contains = stringutils:contains(\"Ballerina\", \"in\");    Parameters  originalString string The string to check whether it contains the substring   substring string The substring to find within the originalString   Return Type (boolean)  true if the originalString contains the provided substring or else false   equalsIgnoreCase (string firstString, string secondString)  returns boolean Checks if two strings are equal ignoring the case of the strings.  boolean isEqual = stringutils:equalsIgnoreCase(\"BaLLerinA\", \"ballERina\");    Parameters  firstString string The first string to compare   secondString string The second string to compare   Return Type (boolean)  true if the two strings are equal or else false   hashCode (string stringValue)  returns int Returns a hash code for a given string.  int hashCode = stringutils:hashCode(\"Ballerina\");    Parameters  stringValue string The string to generate the hash code   Return Type (int)  The hash code for the given string   lastIndexOf (string originalString, string substring)  returns int Returns the last index of the provided substring within a string.  int lastIndex = stringutils:lastIndexOf(\"int values in Ballerina\", \"in\");    Parameters  originalString string The string to search for the index of the substring   substring string The string to search in the originalString   Return Type (int)  Starting index of the last appearance of the provided substring if the originalString contains the substring or else -1   matches (string stringToMatch, string regex)  returns boolean Checks whether the given string matches the provided regex.  boolean isMatched = stringutils:matches(\"Ballerina is great\", \"Ba[a-z ]+\");    Parameters  stringToMatch string The string to match the regex   regex string The regex to match the string   Return Type (boolean)  true if the provided string matches the regex or else false   replace (string originalString, string stringToReplace, string replacement)  returns string Replaces each occurrence of the provided substring inside the provided originalString with the specified replacement string.  string result = stringutils:replace(\"Ballerina is great\", \" \", \"_\");    Parameters  originalString string The original string to replace the substrings   stringToReplace string The string to replace within the originalString   replacement string The replacement string to replace the occurrences of the stringToReplace   Return Type (string)  The string with the replaced substrings   replaceAll (string originalString, string regex, string replacement)  returns string Replaces each occurrence of the substrings, which matches the provided regular expression from the given original string value with the provided replacement string.  string result = stringutils:replaceAll(\"Ballerina is great\", \"\\s+\", \"_\");    Parameters  originalString string The original string to replace the occurrences of the substrings that match the provided regex   regex string The regex to match the substrings in the originalString to be replaced   replacement string The replacement string to replace the subsgrings, which match the regex   Return Type (string)  The resultant string with the replaced substrings   replaceFirst (string originalString, string regex, string replacement)  returns string Replaces the first substring that matches the given regular expression with the provided replacement string.  string result = stringutils:replaceFirst(\"Ballerina is great\", \"\\s+\", \"_\");    Parameters  originalString string The original string to replace the occurrences of the substrings that match the provided regex   regex string The regex to match the first substring in the originalString to be replaced   replacement string The replacement string to replace the first substring, which matches the regex   Return Type (string)  The resultant string with the replaced substring   split (string receiver, string delimiter)  returns string[] Returns an array of strings by splitting a string using the provided delimiter.  string[] result = stringutils:split(\"Ballerina is great\", \" \");    Parameters  receiver string The string to split   delimiter string The delimiter to split by   Return Type (string[])  An array of strings containing the individual strings that are split   toBoolean (string stringValue)  returns boolean Returns a boolean value of a given string.  boolean result = stringutils:toBoolean(\"true\");    Parameters  stringValue string string value to convert to a boolean   Return Type (boolean)  true if the string is \"true\" (without considering the case) or else false"},{"page":"/learn/api-docs/ballerina/system/functions.html","name":"Functions -","summary":"(string command, map env, string? dir, string[] args)Executes an operating system command as a subprocess of the current process.\nThe name of the command to be executedEnvironment variables to be set to the processThe current working directory to be set to the processCommand arguments to be passed inA system:Process object if ...","content":"Functions  v1.2.2  All Modules  Functions - Executes an operating system command as a subprocess of the current process.  Returns the environment variable value associated with the provided name.  Returns the current user's home directory path.  Returns the current user's name.  Returns a random UUID string.  exec (string command, map env, string? dir, string[] args)  returns | Executes an operating system command as a subprocess of the current process.  system:Process|system:Error proc = system:exec(\"ls\", {}, \"/\", \"-la\")    Parameters  command string The name of the command to be executed   env map (default {})  Environment variables to be set to the process   dir string? (default ())  The current working directory to be set to the process   args string[] Command arguments to be passed in   Return Type ( | )  A system:Process object if successful or else a system:Error if a failure occurs   getEnv (string name)  returns string Returns the environment variable value associated with the provided name.  string port = system:getEnv(\"HTTP_PORT\");    Parameters  name string Name of the environment variable   Return Type (string)  Environment variable value if it exists or else an empty string   getUserHome ()  returns string Returns the current user's home directory path.  string userHome = system:getUserHome();    Return Type (string)  Current user's home directory if it can be determined or else an empty string   getUsername ()  returns string Returns the current user's name.  string username = system:getUsername();    Return Type (string)  Current user's name if it can be determined or else an empty string   uuid ()  returns string Returns a random UUID string.  string providerId = system:uuid();    Return Type (string)  The random string"},{"page":"/learn/api-docs/ballerina/system/","name":"Module : system","summary":"This module provides functions to retrieve information about the system and the current users of the system. The system:exec method creates the system:Process object, which can control and obtain information about a Ballerina process.For information on the operations, which you can perform with the system module, see the below Functions. ...","content":"v1.2.2  All Modules  Module : system  Module overview This module provides functions to retrieve information about the system and the current users of the system. The system:exec method creates the system:Process object, which can control and obtain information about a Ballerina process. For information on the operations, which you can perform with the system module, see the below Functions.    Records Record type to hold the details of an error.  Objects This object contains information on a process being created from Ballerina.  Functions Executes an operating system command as a subprocess of the current process.  Returns the environment variable value associated with the provided name.  Returns the current user's home directory path.  Returns the current user's name.  Returns a random UUID string.  Constants Represents the error code for invalid operations.  Represents the error code for permission errors.  Represents the error code for file system errors.  Represents the error code for file not found.  Types Represents System related errors.  Errors Represents a FileNotFoundError with a detailed message.  Represents a FileSystemError with a detailed message.  Represents an InvalidOperationError with a detailed message.  Represents a PermissionError with a detailed message."},{"page":"/learn/api-docs/ballerina/system/objects/Process.html","name":"Object - : Process","summary":"This object contains information on a process being created from Ballerina.\nThis is returned from the exec function in ...","content":"Objects  >  v1.2.2  All Modules  Object - :  Process  This object contains information on a process being created from Ballerina. This is returned from the exec function in the system module.   Methods  Waits for the process to finish its work and exit.  Returns the exit code of the process when it has finished the execution.  Destroys the process.  Provides a channel (to write into), which is made available as the 'standard input' for the process.  Provides a channel (to read from), which is made available as the 'standard output' of the process.  Provides a channel (to read from), which is made available as the 'standard error' of the process.  Pipes the standard output of the current process to the standard input of the given process.  waitForExit ()  returns int | Waits for the process to finish its work and exit.  int|error exitCode = process.waitForExit();    Return Type (int | )  Returns the exit code for the process or else an Error if a failure occurs   exitCode ()  returns int | Returns the exit code of the process when it has finished the execution. Error if the process has not exited yet.  int|error exitCode = process.exitCode();    Return Type (int | )  Returns the exit code of the process or else an Error if the process hasn't exited yet   destroy Destroys the process.  process.destroy();    stdin ()  returns Provides a channel (to write into), which is made available as the 'standard input' for the process.  io:WritableByteChannel output = process.stdin();    Return Type ()  The io:WritableByteChannel, which represents the process's 'standard input'   stdout ()  returns Provides a channel (to read from), which is made available as the 'standard output' of the process.  io:ReadableByteChannel input = process.stdout();    Return Type ()  The io:ReadableByteChannel, which represents the process's 'standard output'   stderr ()  returns Provides a channel (to read from), which is made available as the 'standard error' of the process.  io:ReadableByteChannel input = process.stderr();    Return Type ()  The io:ReadableByteChannel, which represents the process's 'standard error'   pipe ( process)  returns Pipes the standard output of the current process to the standard input of the given process.  var x3out = x1.pipe(x2).pipe(x3).stdout();    Parameters  process The process to pipe the data to   Return Type ()  The process that is passed to be used to help the chain pipe operations"},{"page":"/learn/api-docs/ballerina/system/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/task/","name":"Module : task","summary":"This module provides the functionality to configure and manage Task Listeners and Task Schedulers.\nTask Listeners and Task Schedulers can be used to perform tasks periodically.A Task Listener can be used to create a service listener, which will be triggered at specified times.Below are the two types of configurations that can ...","content":"v1.2.2  All Modules  Module : task  Module Overview This module provides the functionality to configure and manage Task Listeners and Task Schedulers. Task Listeners and Task Schedulers can be used to perform tasks periodically. Task Listeners A Task Listener can be used to create a service listener, which will be triggered at specified times. Below are the two types of configurations that can be used to configure a Task Listener, either as a timer or as an appointment.  TimerConfiguration AppointmentConfiguration  Task Listener as a Timer The TimerConfiguration can be used to configure a task that needs to be executed periodically. The following code snippet shows how to create a listener, which registers a task with an initial delay of 3000 milliseconds and is executed every 1000 milliseconds for 10 times. task:TimerConfiguration timerConfiguration = {  intervalInMillis: 1000,  initialDelayInMillis: 3000,  // Number of recurrences will limit the number of times the timer runs.  noOfRecurrences: 10 };  listener task:Listener timer = new(timerConfiguration);  // Creating a service on the `timer` task Listener. service timerService on timer {  // This resource triggers when the timer goes off.  resource function onTrigger() {  } }  For an example on the usage of the task:Listener as a timer, see the . Task Listener as an Appointment The AppointmentConfiguration can be used to schedule an appointment. The following code snippet shows how to create a task appointment, which registers a service using a CRON expression to execute the task every second for 10 times. task:AppointmentConfiguration appointmentConfiguration = {  // This cron expression will schedule the appointment once every second.  appointmentDetails: \"* * * * * ?\",  // Number of recurrences will limit the number of times the timer runs.  noOfRecurrences: 10 };  listener task:Listener appointment = new(appointmentConfiguration);  // Creating a service on the `appointment` task Listener. service appointmentService on appointment {  // This resource triggers when the appointment is due.  resource function onTrigger() {  } }  For an example on the usage of the task:Listener as an appointment, see the . Task Schedulers A Task Scheduler can be used to create timers/appointments dynamically. Service(s) can be attached to the Scheduler so that they can be invoked when the Scheduler is triggered. Similar to Task Listeners, below are the two types of configurations that can be used to configure a Task Scheduler either as a timer or as an appointment.  TimerConfiguration AppointmentConfiguration  Task Scheduler as a Timer A Scheduler can be used to create timers via its TimerConfiguration. The following code snippet shows how to create a task:Scheduler as a timer. task:TimerConfiguration timerConfiguration = {  intervalInMillis: 1000,  initialDelayInMillis: 0,  noOfRecurrences: 10 }; task:Scheduler timer = new(timerConfiguration);  For an example on the usage of the task:Scheduler as a timer, see the . Task Scheduler as an Appointment A Scheduler can also be used to create appointments via its AppointmentConfiguration. The following code snippet shows how to create a Task Scheduler as an appointment. task:AppointmentConfiguration appointmentConfiguration = {  appointmentDetails: \"* * * * * ?\",  noOfRecurrences: 10 }; task:Scheduler appointment = new(appointmentConfiguration);  For an example on the usage of the task:Scheduler as an appointment, see the .    Records Configurations related to an appointment, which are used to define the behavior of an appointment when initializing the task:Listener.  The CRON expression required for scheduling an appointment.  Record type to hold the details of an error.  Configurations related to a timer, which are used to define the behavior of a timer when initializing the task:Listener.  Objects Represents a ballerina task Scheduler, which can be used to run jobs periodically, using the given configurations.  Listeners Represents a ballerina task listener, which can be used to schedule and execute tasks periodically.  Constants Used as the error reason for the task:SchedulerError type.  Used as the error reason for the task:ListenerError type.  Types Represents the Union error type of the ballerina/task module.  Errors Error type specific to the task:Listener object functions.  Error type specific to the task:Scheduler object functions."},{"page":"/learn/api-docs/ballerina/task/listeners/Listener.html","name":"Listener - : Listener","summary":"Represents a ballerina task listener, which can be used to schedule and execute tasks periodically.\n( |  configuration)The task:TimerConfiguration or task:AppointmentConfiguration record to define the\ntask:Listener behavior(service s)Detaches the given service from the task:Listener.\nService to be detached from the listener() or else a task:ListenerError upon failure to detach the service()Stops the ...","content":"Listeners  v1.2.2  All Modules  Listener - : Listener Represents a ballerina task listener, which can be used to schedule and execute tasks periodically.    Constructor __init( | configuration)   configuration | The task:TimerConfiguration or task:AppointmentConfiguration record to define the task:Listener behavior   Methods  Detaches the given service from the task:Listener.  Stops the task:Listener and the attached services gracefully.  Stops the task:Listener and the attached services immediately.  Pauses the task:Listener and the attached services.  Resumes a paused task:Listener.  LifeCycle Methods  Attaches the given service to the task:Listener.  Starts dispatching the services attached to the task:Listener.  Methods  __detach (service s)  returns error? Detaches the given service from the task:Listener.   Parameters  s service Service to be detached from the listener   Return Type (error?)  () or else a task:ListenerError upon failure to detach the service   __gracefulStop ()  returns error? Stops the task:Listener and the attached services gracefully. It will wait if there are any tasks still to be completed. This may panic if the stopping causes any error.   Return Type (error?)  () or else a task:ListenerError upon failure to stop the listener   __immediateStop ()  returns error? Stops the task:Listener and the attached services immediately. This will cancel any ongoing tasks. This may panic if the stopping causes any error.   Return Type (error?)  () or else a task:ListenerError upon failure to stop the listener   pause ()  returns ? Pauses the task:Listener and the attached services.   Return Type (?)  A task:ListenerError if an error occurred while pausing or else ()   resume ()  returns ? Resumes a paused task:Listener. Calling this on an already-running task:Listener will not cause any error.   Return Type (?)  A task:ListenerError if an error occurred while resuming or else ()   LifeCycle Methods  __attach (service s, string? name)  returns error? Attaches the given service to the task:Listener. This may panic if the service attachment is fails.   Parameters  s service Service to attach to the listener   name string? (default ())  Name of the service   Return Type (error?)  () or else a task:ListenerError upon failure to attach the service   __start ()  returns error? Starts dispatching the services attached to the task:Listener. This may panic if the service dispatching causes any error.   Return Type (error?)  () or else a task:ListenerError upon failure to start the listener"},{"page":"/learn/api-docs/ballerina/task/objects/Scheduler.html","name":"Object - : Scheduler","summary":"Represents a ballerina task Scheduler, which can be used to run jobs periodically, using the given configurations.\n\n  ...","content":"Objects  >  v1.2.2  All Modules  Object - :  Scheduler  Represents a ballerina task Scheduler, which can be used to run jobs periodically, using the given configurations.   Constructor __init( | configuration)   configuration | The task:TimerConfiguration or task:AppointmentConfiguration record to define the task:Sceduler behavior   Methods  Attaches the provided service to the task.  Detaches the provided service from the task.  Starts running the task.  Stops the task.  Pauses the task.  Resumes a paused task.  Checks whether the task listener is started or not.  attach (service serviceToAttach, any[] attachments)  returns ? Attaches the provided service to the task.   Parameters  serviceToAttach service Ballerina service object, which needs to be attached to the task   attachments any[] Set of optional parameters, which need to be passed inside the resources   Return Type (?)  A task:SchedulerError if the process failed due to any reason or else ()   detach (service attachedService)  returns ? Detaches the provided service from the task.   Parameters  attachedService service Ballerina service object, which needs to be detached from the task   Return Type (?)  A task:SchedulerError if the process failed due to any reason or else ()   start ()  returns ? Starts running the task. Task Scheduler will not run until this has been called.   Return Type (?)  A task:SchedulerError if the process failed due to any reason or else ()   stop ()  returns ? Stops the task. This will stop after running the existing jobs.   Return Type (?)  A task:SchedulerError if the process failed due to any reason or else ()   pause ()  returns ? Pauses the task.   Return Type (?)  A task:SchedulerError if an error is occurred while pausing or else ()   resume ()  returns ? Resumes a paused task.   Return Type (?)  A task:SchedulerError when an error occurred while resuming or else ()   isStarted ()  returns boolean Checks whether the task listener is started or not.   Return Type (boolean)  true if the Scheduler is already started or else false if the Scheduler is not started yet or stopped calling the Scheduler.stop() function"},{"page":"/learn/api-docs/ballerina/task/records/AppointmentConfiguration.html","name":"Record - : AppointmentConfiguration","summary":"Configurations related to an appointment, which are used to define the behavior of an appointment when initializing\nthe task:Listener.\n\n ...","content":"Records  v1.2.2  All Modules  Record - : AppointmentConfiguration  Configurations related to an appointment, which are used to define the behavior of an appointment when initializing the task:Listener.   Fields  appointmentDetails  string | A CRON expression as a string or task:AppointmentData for scheduling an appointment   noOfRecurrences  int  Number of times to trigger the task after which the task stops running"},{"page":"/learn/api-docs/ballerina/task/records/AppointmentData.html","name":"Record - : AppointmentData","summary":"The CRON expression required for scheduling an appointment.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : AppointmentData  The CRON expression required for scheduling an appointment.   Fields  seconds  string  Second(s) in a given minute in which the appointment will run   minutes  string  Minute(s) in a given hour in which the appointment will run   hours  string  Hour(s) in a given day in which the appointment will run   daysOfMonth  string  Day(s) of the month in which the appointment will run   months  string  Month(s) in a given year in which the appointment will run   daysOfWeek  string  Day(s) of a week in which the appointment will run   year  string  Year(s) in which the appointment will run"},{"page":"/learn/api-docs/ballerina/task/records/Detail.html","name":"Record - : Detail","summary":"Record type to hold the details of an error.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Record type to hold the details of an error.   Fields  message  string  Error message describing the error occurred   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/task/records/TimerConfiguration.html","name":"Record - : TimerConfiguration","summary":"Configurations related to a timer, which are used to define the behavior of a timer when initializing the\ntask:Listener.\n\n ...","content":"Records  v1.2.2  All Modules  Record - : TimerConfiguration  Configurations related to a timer, which are used to define the behavior of a timer when initializing the task:Listener.   Fields  intervalInMillis  int  Timer interval (in milliseconds), which triggers the onTrigger resource   initialDelayInMillis  int  Delay (in milliseconds) after which the timer will run   noOfRecurrences  int  Number of times to trigger the task after which the task stops running"},{"page":"/learn/api-docs/ballerina/test/functions.html","name":"Functions -","summary":"Asserts whether the given values are equal. If it is not, an AssertError is thrown with the given errorMessage.\nActual valueExpected valueAssertion error messageAssert failure is triggered based on user discretion. AssertError is thrown with the given errorMessage.\nAssertion error messageAsserts whether the given condition is false. If it is not, a ...","content":"Functions  v1.2.2  All Modules  Functions - Asserts whether the given values are equal.  Assert failure is triggered based on user discretion.  Asserts whether the given condition is false.  Asserts whether the given values are not equal.  Asserts whether the given condition is true.  Creates an AssertError with custom message and category.  Start a service skeleton from a given OpenApi definition in the given ballerina module.  Starts all the services defined in the module specified in the 'moduleName' argument.  Stop a service skeleton and cleanup created directories of a given ballerina module.  Stops all the services defined in the module specified in the 'moduleName' argument.  assertEquals Asserts whether the given values are equal. If it is not, an AssertError is thrown with the given errorMessage.   Parameters  actual any | error Actual value   expected any | error Expected value   msg string (default Assertion Failed!)  Assertion error message   assertFail Assert failure is triggered based on user discretion. AssertError is thrown with the given errorMessage.   Parameters  msg string (default Test Failed!)  Assertion error message   assertFalse Asserts whether the given condition is false. If it is not, a AssertError is thrown with the given errorMessage.   Parameters  condition boolean Boolean condition to evaluate   msg string (default Assertion Failed!)  Assertion error message   assertNotEquals Asserts whether the given values are not equal. If it is equal, an AssertError is thrown with the given errorMessage.   Parameters  actual any | error Actual value   expected any | error Expected value   msg string (default Assertion Failed!)  Assertion error message   assertTrue Asserts whether the given condition is true. If it is not, a AssertError is thrown with the given errorMessage.   Parameters  condition boolean Boolean condition to evaluate   msg string (default Assertion Failed!)  Assertion error message   createBallerinaError (string errorMessage, string category)  returns error Creates an AssertError with custom message and category.   Parameters  errorMessage string Custom message for the ballerina error   category string error category   Return Type (error)  an AssertError with custom message and category   startServiceSkeleton (string moduleName, string openApiFilePath)  returns boolean Start a service skeleton from a given OpenApi definition in the given ballerina module.   Parameters  moduleName string Name of the module   openApiFilePath string Path to the OpenApi definition   Return Type (boolean)  true if the service skeleton was started successfully, false otherwise   startServices (string moduleName)  returns boolean Starts all the services defined in the module specified in the 'moduleName' argument.   Parameters  moduleName string Name of the module   Return Type (boolean)  true if the services were started successfully, false otherwise   stopServiceSkeleton Stop a service skeleton and cleanup created directories of a given ballerina module.   Parameters  moduleName string Name of the module   stopServices Stops all the services defined in the module specified in the 'moduleName' argument.   Parameters  moduleName string Name of the module"},{"page":"/learn/api-docs/ballerina/test/","name":"Module : test Samples","summary":"This module allow developers to write testable code.Following sample shows how to use assertions in Testerina. ...","content":"v1.2.2  All Modules  Module : test  Module overview This module allow developers to write testable code. Samples Following sample shows how to use assertions in Testerina.  import ballerina/test;  @test:Config{} function testAssertIntEquals() {  int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertEquals(answer, 8, msg = \"int values not equal\"); }  function intAdd(int a, int b) returns (int) {  return (a + b); }     Records Configuration of the function to be mocked.  Configuration set for test functions.  Functions Asserts whether the given values are equal.  Assert failure is triggered based on user discretion.  Asserts whether the given condition is false.  Asserts whether the given values are not equal.  Asserts whether the given condition is true.  Creates an AssertError with custom message and category.  Start a service skeleton from a given OpenApi definition in the given ballerina module.  Starts all the services defined in the module specified in the 'moduleName' argument.  Stop a service skeleton and cleanup created directories of a given ballerina module.  Stops all the services defined in the module specified in the 'moduleName' argument.  Annotations Identifies afterTest function.  Identifies afterSuite function.  Identifies beforeTest function.  Identifies beforeSuite function."},{"page":"/learn/api-docs/ballerina/test/records/MockConfig.html","name":"Record - : MockConfig","summary":"Configuration of the function to be mocked.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : MockConfig  Configuration of the function to be mocked.   Fields  moduleName  string  (default .) Name of the module that the function to be mocked resides in   functionName  string  Name of the function to be mocked"},{"page":"/learn/api-docs/ballerina/test/records/TestConfig.html","name":"Record - : TestConfig","summary":"Configuration set for test functions.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : TestConfig  Configuration set for test functions.   Fields  enable  boolean  (default true) Flag to enable/disable test functions   groups  string[]  (default []) List of groups that this test function belongs to   dataProvider  string  Name of the function which will be used to feed data into this test   before  string  Name of the function to be run before the test is run   after  string  Name of the function to be run after the test is run   dependsOn  string[]  (default []) A list of function names the test function depends on, and will be run before the test"},{"page":"/learn/api-docs/ballerina/time/","name":"Module : time","summary":"This module provides implementations related to time, date, time zones, and durations.The module has two main types as  and . The Time type represents a time associated with a given time zone. It has time and zone as its attributes. The TimeZone type represents the time zone associated with ...","content":"v1.2.2  All Modules  Module : time  Module Overview This module provides implementations related to time, date, time zones, and durations. The module has two main types as and . The Time type represents a time associated with a given time zone. It has time and zone as its attributes. The TimeZone type represents the time zone associated with a given time. It has id and offset as its attributes. An id can be one of the following:  If id equals 'Z', the result is UTC. If id equals 'GMT', 'UTC' or 'UT', it is equivalent to UTC. If id starts with '+' or '-', the ID is parsed as an offset. The offset can be specified in one of the following ways: +h, +hh, +hh:mm, -hh:mm, +hhmm, -hhmm, +hh:mm:ss, -hh:mm:ss, +hhmmss, -hhmmss Also, id can be a region-based zone ID. The format is '{area}/{city}' e.g., \"America/Panama\". The zones are based on IANA Time Zone Database (TZDB) supplied data.  For information on the operations, which you can perform with this module, see the below Functions. For an example on the usage of the operations, see the . Patterns for formatting and parsing The below patterns can be used to generate the formatter string when using the format() and parse() functions.   SymbolMeaningPresentationExamples   GeratextAD; Anno Domini; A uyearyear2004; 04 yyear-of-erayear2004; 04 Dday-of-yearnumber189 M/Lmonth-of-yearnumber/text7; 07; Jul; July; J dday-of-monthnumber10 Q/qquarter-of-yearnumber/text3; 03; Q3; 3rd quarter Yweek-based-yearyear1996; 96 wweek-of-week-based-yearnumber27 Wweek-of-monthnumber4 Eday-of-weektextTue; Tuesday; T e/clocalized day-of-weeknumber/text2; 02; Tue; Tuesday; T Fweek-of-monthnumber3 acam-pm-of-daytextPM hclock-hour-of-am-pm (1-12)number12 Khour-of-am-pm (0-11)number0 kclock-hour-of-am-pm (1-24)number0 Hhour-of-day (0-23)number0 mminute-of-hournumber30 ssecond-of-minutenumber55 Sfraction-of-secondfraction978 Amilli-of-daynumber1234 nnano-of-secondnumber987654321 Nnano-of-daynumber1234000000 Vime-zone IDzone-idAmerica/Los_Angeles; Z; -08:30 ztime-zone namezone-namePacific Standard Time; PST Olocalized zone-offsetoffset-OGMT+8; GMT+08:00; UTC-08:00 Xzone-offset 'Z' for zerooffset-XZ; -08; -0830; -08:30; -083015; -08:30:15 xzone-offsetoffset-x+0000; -08; -0830; -08:30; -083015; -08:30:15 Zzone-offsetoffset-Z+0000; -0800; -08:00 ppad nextpad modifier1 'escape for textdelimiter ''single quoteliteral' [optional section start ]optional section end      Records Details of an error.  Represents a particular time with its associated time-zone.  Represents the time-zone information associated with a particular time.  Functions Add specified durations to the given time value.  Returns the Time object correspoding to the given time components and time-zone.  Returns the current time value with the default system time-zone.  Returns the formatted string representation of the given time.  Returns the date representation of the given time.  Returns the date representation of the given time.  Returns the hour representation of the given time.  Returns the millisecond representation of the given time.  Returns the minute representation of the given time.  Returns the month representation of the given time.  Returns the second representation of the given time.  Returns the time representation of the given time.  Returns the weekday representation of the given time.  Returns the year representation of the given time.  Returns the current system time in nano seconds.  Returns the time for the given string representation based on the given format string.  Subtract specified durations from the given time value.  Returns the ISO 8601 string representation of the given time.  Change the time-zone of the given time.  Constants Specifies the time error, which occurs in the module.  Specifies the time format defined by the RFC-1123.  Types The time format defined by the RFC-1123.  Errors Represents the Time module related error."},{"page":"/learn/api-docs/ballerina/time/functions.html","name":"Functions -","summary":"( time, int years, int months, int days, int hours, int minutes, int seconds, int milliSeconds)Add specified durations to the given time value.\nThe Time record to add the durationThe year representationThe month-of-year to represent, from 1 (January) to 12 (December)The day-of-month to represent, from 1 to 31The hour-of-day to represent, ...","content":"Functions  v1.2.2  All Modules  Functions - Add specified durations to the given time value.  Returns the Time object correspoding to the given time components and time-zone.  Returns the current time value with the default system time-zone.  Returns the formatted string representation of the given time.  Returns the date representation of the given time.  Returns the date representation of the given time.  Returns the hour representation of the given time.  Returns the millisecond representation of the given time.  Returns the minute representation of the given time.  Returns the month representation of the given time.  Returns the second representation of the given time.  Returns the time representation of the given time.  Returns the weekday representation of the given time.  Returns the year representation of the given time.  Returns the current system time in nano seconds.  Returns the time for the given string representation based on the given format string.  Subtract specified durations from the given time value.  Returns the ISO 8601 string representation of the given time.  Change the time-zone of the given time.  addDuration ( time, int years, int months, int days, int hours, int minutes, int seconds, int milliSeconds)  returns Add specified durations to the given time value.  string timeText = \"2020-06-26T09:46:22.444-0500\";  string timeFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";  time:Time|error originalTime = time:parse(timeText, timeFormat);  if (originalTime is time:Time) {  time:Time newTime = time:addDuration(originalTime, 1, 1, 1, 1, 1, 1, 1);  }    Parameters  time The Time record to add the duration   years int The year representation   months int The month-of-year to represent, from 1 (January) to 12 (December)   days int The day-of-month to represent, from 1 to 31   hours int The hour-of-day to represent, from 0 to 23   minutes int The minute-of-hour to represent, from 0 to 59   seconds int The second-of-minute to represent, from 0 to 59   milliSeconds int The milli-of-second to represent, from 0 to 999   Return Type ()  Time object containing time and zone information after the addition   createTime (int year, int month, int date, int hour, int minute, int second, int milliSecond, string zoneId)  returns | Returns the Time object correspoding to the given time components and time-zone.  time:Time|error dateTime = time:createTime(2020, 3, 28, 23, 42, 45, 554, \"America/Panama\");    Parameters  year int The year representation   month int The month-of-year to represent from 1 (January) to 12 (December)   date int The day-of-month to represent from 1 to 31   hour int The hour-of-day to represent from 0 to 23   minute int The minute-of-hour to represent from 0 to 59   second int The second-of-minute to represent, from 0 to 59   milliSecond int The milli-of-second to represent, from 0 to 999   zoneId string The zone id of the required time-zone.If empty the system local time-zone will be used   Return Type ( | )  Time object containing time and zone information or an time:Error if failed to create the time   currentTime ()  returns Returns the current time value with the default system time-zone.  time:Time now = time:currentTime();    Return Type ()  Time object containing the time and the zone information   format ( time, string timeFormat)  returns string | Returns the formatted string representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  string|error timeString = time:format(time, time:TIME_FORMAT_RFC_1123);    Parameters  time The Time record to be formatted   timeFormat string The format, which is used to format the time represented by this object   Return Type (string | )  The formatted string of the given time or else a time:Error if failed to format the time   getDate ( time)  returns [int, int, int] Returns the date representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  [int, int, int] date = time:getDate(time);    Parameters  time The Time record to get the date representation   Return Type ([int, int, int])  The year representation with the month-of-year from 1 (January) to 12 (December) and the day-of-month from 1 to 31   getDay ( time)  returns int Returns the date representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  int day = time:getDay(time);    Parameters  time The Time record to get the date representation   Return Type (int)  The day-of-month from 1 to 31   getHour ( time)  returns int Returns the hour representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  int hour = time:getHour(time);    Parameters  time The Time record to get the hour representation   Return Type (int)  The hour-of-day from 0 to 23   getMilliSecond ( time)  returns int Returns the millisecond representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  int milliSecond = time:getMilliSecond(time);    Parameters  time The Time record to get the millisecond representation   Return Type (int)  The milli-of-second from 0 to 999   getMinute ( time)  returns int Returns the minute representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  int minute = time:getMinute(time);    Parameters  time The Time record to get the minute representation   Return Type (int)  The minute-of-hour to represent from 0 to 59   getMonth ( time)  returns int Returns the month representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  int month = time:getMonth(time);    Parameters  time The Time record to get the month representation from   Return Type (int)  The month-of-year from 1 (January) to 12 (December)   getSecond ( time)  returns int Returns the second representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  int second = time:getSecond(time);    Parameters  time The Time record to get the second representation   Return Type (int)  The second-of-minute from 0 to 59   getTime ( time)  returns [int, int, int, int] Returns the time representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  [int, int, int, int] timeGenerated = time:getTime(time);    Parameters  time The Time record   Return Type ([int, int, int, int])  The hour-of-day to represent from 0 to 23, the minute-of-hour to represent from 0 to 59, the second-of-minute from 0 to 59, and the milli-of-second from 0 to 999   getWeekday ( time)  returns string Returns the weekday representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  string weekDay = time:getWeekday(time);    Parameters  time The Time record to get the weekday representation   Return Type (string)  The weekday representation from SUNDAY to SATURDAY   getYear ( time)  returns int Returns the year representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  int year = time:getYear(time);    Parameters  time The Time record to retrieve the year representation   Return Type (int)  The year representation   nanoTime ()  returns int Returns the current system time in nano seconds.  int now = time:nanoTime();    Return Type (int)  Integer value of the current system time in nano seconds   parse (string data, string timeFormat)  returns | Returns the time for the given string representation based on the given format string.  string timeFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";  time:Time|error time = time:parse(\"2020-06-26T09:46:22.444-0500\", timeFormat);    Parameters  data string The time text to parse   timeFormat string The format, which is used to parse the given text   Return Type ( | )  Time object containing the time and zone information or else a time:Error if failed to parse the given string   subtractDuration ( time, int years, int months, int days, int hours, int minutes, int seconds, int milliSeconds)  returns Subtract specified durations from the given time value.  string timeText = \"2020-06-26T09:46:22.444-0500\";  string timeFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";  time:Time|error originalTime = time:parse(timeText, timeFormat);  if (originalTime is time:Time) {  time:Time newTime = time:subtractDuration(originalTime, 1, 1, 1, 1, 1, 1, 1);  }    Parameters  time The Time record to subtract the duration from   years int The year representation   months int The month-of-year to represent, from 1 (January) to 12 (December)   days int The day-of-month to represent, from 1 to 31   hours int The hour-of-day to represent, from 0 to 23   minutes int The minute-of-hour to represent, from 0 to 59   seconds int The second-of-minute to represent, from 0 to 59   milliSeconds int The milli-of-second to represent, from 0 to 999   Return Type ()  Time object containing time and zone information after the subtraction   toString ( time)  returns string Returns the ISO 8601 string representation of the given time.  time:TimeZone zoneValue = {id: \"America/Panama\"};  time:Time time = {time: 1578488382444, zone: zoneValue};  string timeString = time:toString(time);    Parameters  time The Time record to be converted to string   Return Type (string)  The ISO 8601-formatted string of the given time   toTimeZone ( time, string zoneId)  returns | Change the time-zone of the given time.  string zoneId = \"America/Panama\";  time:TimeZone zoneValue = {id: zoneId};  time:Time time = {time: 1578488382444, zone: zoneValue};  time:Time|time:Error newTime = time:toTimeZone(time, zoneId);    Parameters  time The Time record of which the time-zone is to be changed   zoneId string The new time-zone ID   Return Type ( | )  Time object containing the time and zone information after the conversion or else a time:Error if failed to format the time"},{"page":"/learn/api-docs/ballerina/time/records/Detail.html","name":"Record - : Detail","summary":"Details of an error.\n\n            \n   ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Details of an error.   Fields  message  string  Specific error message of the error   cause  error  Any other error, which causes this error"},{"page":"/learn/api-docs/ballerina/time/records/Time.html","name":"Record - : Time","summary":"Represents a particular time with its associated time-zone.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : Time  Represents a particular time with its associated time-zone.   Fields  time  int  Time value as milliseconds since epoch   zone  The time zone of the time"},{"page":"/learn/api-docs/ballerina/time/records/TimeZone.html","name":"Record - : TimeZone","summary":"Represents the time-zone information associated with a particular time.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : TimeZone  Represents the time-zone information associated with a particular time.   Fields  id  string  Zone short ID or offset string   offset  int  (default 0) The offset in seconds"},{"page":"/learn/api-docs/ballerina/transactions/functions.html","name":"Functions -","summary":"()Get the current transaction id. This function is useful for user code to save state against a transaction ID,\nso that when the oncommit or onabort functions registered for a transaction can retrieve that state using the\ntransaction  that is passed in to those functions.\nA string representing the ID of the ...","content":"Functions  v1.2.2  All Modules  Functions - Get the current transaction id.  getCurrentTransactionId ()  returns string Get the current transaction id. This function is useful for user code to save state against a transaction ID, so that when the oncommit or onabort functions registered for a transaction can retrieve that state using the transaction that is passed in to those functions.   Return Type (string)  A string representing the ID of the current transaction."},{"page":"/learn/api-docs/ballerina/transactions/","name":"Module : transactions","summary":"This module provides Ballerina transaction manager implementation.The code snippet given below uses the functions in the module to get the transaction information. ...","content":"v1.2.2  All Modules  Module : transactions  Module overview This module provides Ballerina transaction manager implementation. The code snippet given below uses the functions in the module to get the transaction information.  // When the `transaction` statement starts, a distributed transaction context is created. transaction {  // Print the current transaction ID  log:printInfo(\"Started transaction: \" +  transactions:getCurrentTransactionId());   // When a participant is called, the transaction context is propagated, and that participant  // gets infected and joins the distributed transaction.  boolean successful = callBusinessService();  if (successful) {  log:printInfo(\"Business operation executed successfully\");  } else {  log:printError(\"Business operation failed\");  abort;  }   // As soon as the `transaction` block ends, the `2-phase commit  // coordination` protocol will run. All participants are prepared  // and depending on the joint outcome, either a `notify commit` or  // `notify abort` will be sent to the participants. } committed {  log:printInfo(\"Initiated transaction committed\"); } aborted {  log:printInfo(\"Initiated transaction aborted\"); }     Records Anonymous record  Anonymous record  Contains the configurations for local transaction participant function.  Functions Get the current transaction id.  Annotations The annotation which is used to configure local transaction participant function."},{"page":"/learn/api-docs/ballerina/transactions/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0  Fields  count  int  (default 0) intervalInMillis  int  (default 0)"},{"page":"/learn/api-docs/ballerina/transactions/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1  Fields  count  int  (default 0) intervalInMillis  int  (default 0)"},{"page":"/learn/api-docs/ballerina/transactions/records/TransactionParticipantConfig.html","name":"Record - : TransactionParticipantConfig","summary":"Contains the configurations for local transaction participant function.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : TransactionParticipantConfig  Contains the configurations for local transaction participant function.   Fields  oncommit  function(string) returns (()) Function to execute when transaction committed.   onabort  function(string) returns (()) Function to execute when transaction aborted."},{"page":"/learn/api-docs/ballerina/websub/clients/Caller.html","name":"Clients - : Caller","summary":"The caller remote functions to respond to client requests.\n( message)Sends the response to the caller.\nThe response or any payload of type string, xml, json, byte[], io:ReadableByteChannel,\nor mime:Entity[]An error on failure or else ()( message)Sends the response to the caller with the \"200 OK\" status.\nThe response or any payload of type ...","content":"Clients  v1.2.2  All Modules  Clients - :  Caller  The caller remote functions to respond to client requests.    Remote Methods  Sends the response to the caller.  error? response = caller->respond();    Sends the response to the caller with the \"200 OK\" status.  error? response = caller->ok();    Sends the response to the caller with the \"202 Accepted\" status.  error? response = caller->accepted();    respond ( message)  returns error? Sends the response to the caller.  error? response = caller->respond();    Parameters  message (default ())  The response or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type (error?)  An error on failure or else ()   ok ( message)  returns error? Sends the response to the caller with the \"200 OK\" status.  error? response = caller->ok();    Parameters  message (default ())  The response or any payload of type string, xml, json, byte[], io:ReadableByteChannel, or mime:Entity[]   Return Type (error?)  An error on failure or else ()   accepted ( message)  returns error? Sends the response to the caller with the \"202 Accepted\" status.  error? response = caller->accepted();    Parameters  message (default ())  The response or any payload of the http:ResponseMessage type   Return Type (error?)  An error on failure or else ()"},{"page":"/learn/api-docs/ballerina/websub/clients/SubscriptionClient.html","name":"Clients - : SubscriptionClient","summary":"The HTTP based client for WebSub subscription and unsubscription.\n(string url, ? config)The URL at which the subscription should be changedThe http:ClientConfiguration for the underlying client or ()( subscriptionRequest)Sends a subscription request to a WebSub Hub.\nThe SubscriptionChangeRequest containing the subscription detailsThe SubscriptionChangeResponse indicating subscription details if the request was successful\nor else ...","content":"Clients  v1.2.2  All Modules  Clients - :  SubscriptionClient  The HTTP based client for WebSub subscription and unsubscription.    Constructor __init(string url, ? config)   url string The URL at which the subscription should be changed   config ? ()  The http:ClientConfiguration for the underlying client or ()   Remote Methods  Sends a subscription request to a WebSub Hub.  websub:SubscriptionChangeResponse|error response = websubHubClientEP->subscribe(subscriptionRequest);    Sends an unsubscription request to a WebSub Hub.  websub:SubscriptionChangeResponse|error response = websubHubClientEP->unsubscribe(subscriptionRequest);    subscribe ( subscriptionRequest)  returns | error Sends a subscription request to a WebSub Hub.  websub:SubscriptionChangeResponse|error response = websubHubClientEP->subscribe(subscriptionRequest);    Parameters  subscriptionRequest The SubscriptionChangeRequest containing the subscription details   Return Type ( | error)  The SubscriptionChangeResponse indicating subscription details if the request was successful or else an error if an error occurred with the subscription request   unsubscribe ( unsubscriptionRequest)  returns | error Sends an unsubscription request to a WebSub Hub.  websub:SubscriptionChangeResponse|error response = websubHubClientEP->unsubscribe(subscriptionRequest);    Parameters  unsubscriptionRequest The SubscriptionChangeRequest containing unsubscription details   Return Type ( | error)  An unsubscription details if the request was successful or else an error if an error occurred with the unsubscription request"},{"page":"/learn/api-docs/ballerina/websub/clients/PublisherClient.html","name":"Clients - : PublisherClient","summary":"The HTTP based client for WebSub topic registration and unregistration, and notifying the hub of new updates.\n(string url, ? config)The URL to publish/notify updatesThe http:ClientConfiguration for the underlying client or else ()(string topic)Registers a topic in a Ballerina WebSub Hub against which subscribers can subscribe and the publisher will\npublish updates.\nThe ...","content":"Clients  v1.2.2  All Modules  Clients - :  PublisherClient  The HTTP based client for WebSub topic registration and unregistration, and notifying the hub of new updates.    Constructor __init(string url, ? config)   url string The URL to publish/notify updates   config ? ()  The http:ClientConfiguration for the underlying client or else ()   Remote Methods  Registers a topic in a Ballerina WebSub Hub against which subscribers can subscribe and the publisher will publish updates.  error? registerTopic = websubHubClientEP->registerTopic(\"http://websubpubtopic.com\");    Unregisters a topic in a Ballerina WebSub Hub.  error? unregisterTopic = websubHubClientEP->unregisterTopic(\"http://websubpubtopic.com\");    Publishes an update to a remote Ballerina WebSub Hub.  error? publishUpdate = websubHubClientEP->publishUpdate(\"http://websubpubtopic.com\",{\"action\": \"publish\",  \"mode\": \"remote-hub\"});    Notifies a remote WebSub Hub from which an update is available to fetch for hubs that require publishing to happen as such.  error? notifyUpdate = websubHubClientEP->notifyUpdate(\"http://websubpubtopic.com\");    registerTopic (string topic)  returns error? Registers a topic in a Ballerina WebSub Hub against which subscribers can subscribe and the publisher will publish updates.  error? registerTopic = websubHubClientEP->registerTopic(\"http://websubpubtopic.com\");    Parameters  topic string The topic to register   Return Type (error?)  An error if an error occurred registering the topic or esle ()   unregisterTopic (string topic)  returns error? Unregisters a topic in a Ballerina WebSub Hub.  error? unregisterTopic = websubHubClientEP->unregisterTopic(\"http://websubpubtopic.com\");    Parameters  topic string The topic to unregister   Return Type (error?)  An errorif an error occurred unregistering the topic or else ()   publishUpdate (string topic, string | xml | json | byte[] | payload, string? contentType, map? headers)  returns error? Publishes an update to a remote Ballerina WebSub Hub.  error? publishUpdate = websubHubClientEP->publishUpdate(\"http://websubpubtopic.com\",{\"action\": \"publish\",  \"mode\": \"remote-hub\"});    Parameters  topic string The topic for which the update occurred   payload string | xml | json | byte[] | The update payload   contentType string? (default ())  The type of the update content to set as the ContentType header   headers map? (default ())  The headers that need to be set (if any)   Return Type (error?)  An errorif an error occurred with the update or else ()   notifyUpdate (string topic, map? headers)  returns error? Notifies a remote WebSub Hub from which an update is available to fetch for hubs that require publishing to happen as such.  error? notifyUpdate = websubHubClientEP->notifyUpdate(\"http://websubpubtopic.com\");    Parameters  topic string The topic for which the update occurred   headers map? (default ())  The headers that need to be set (if any)   Return Type (error?)  An errorif an error occurred with the notification or else ()"},{"page":"/learn/api-docs/ballerina/websub/functions.html","name":"Functions -","summary":"Function to add link headers to a response to allow WebSub discovery.\nThe response being sentThe hubs the publisher advertises as the hubs that it publishes updates toThe topic to which subscribers need to subscribe to, to receive updates for the resource( response)Retrieves hub and topic URLs from the http:response from ...","content":"Functions  v1.2.2  All Modules  Functions - Function to add link headers to a response to allow WebSub discovery.  Retrieves hub and topic URLs from the http:response from a publisher to a discovery request.  Starts up the Ballerina Hub.  addWebSubLinkHeader Function to add link headers to a response to allow WebSub discovery.   Parameters  response The response being sent   hubs string[] The hubs the publisher advertises as the hubs that it publishes updates to   topic string The topic to which subscribers need to subscribe to, to receive updates for the resource   extractTopicAndHubUrls ( response)  returns [string, string[]] | error Retrieves hub and topic URLs from the http:response from a publisher to a discovery request.   Parameters  response An http:Response received   Return Type ([string, string[]] | error)  A (topic, hubs) if parsing and extraction is successful or else an error if not   startHub ( hubServiceListener, string basePath, string subscriptionResourcePath, string publishResourcePath, serviceAuth, subscriptionResourceAuth, publisherResourceAuth, string? publicUrl, hubConfiguration)  returns | | Starts up the Ballerina Hub.  websub:Hub|websub:HubStartedUpError|websub:HubStartupError webSubHub = websub:startHub(new http:Listener(9191),  \"/websub\", \"/hub\");    Parameters  hubServiceListener The http:Listener to which the hub service is attached   basePath string (default /)  The base path of the hub service   subscriptionResourcePath string (default /)  The resource path for subscription changes   publishResourcePath string (default /publish)  The resource path for publishing and topic registration   serviceAuth (default {enabled: false})  The auth configuration for the hub service   subscriptionResourceAuth (default {enabled: false})  The auth configuration for the subscription resource of the hub service   publisherResourceAuth (default {enabled: false})  The auth configuration for the publisher resource of the hub service   publicUrl string? (default ())  The URL for the hub for remote interaction; used in defining the subscription and publish URLs. The subscription URL is defined as {publicUrl}/{basePath}/{subscriptionResourcePath} if publicUrl is specified, defaults to http(s)://localhost:{port}/{basePath}/{subscriptionResourcePath} if not. The publish URL is defined as {publicUrl}/{basePath}/{publishResourcePath} if publicUrl is specified, defaults to http(s)://localhost:{port}/{basePath}/{publishResourcePath} if not.   hubConfiguration (default {})  The hub specific configuration   Return Type ( | | )  A newly started WebSub Hub or else a websub:HubStartedUpError indicating that the hub is already started, and including the websub:Hub object representing the already started up hub"},{"page":"/learn/api-docs/ballerina/websub/","name":"Module : websub","summary":"This module contains an implementation of the W3C  recommendation, which facilitates a push-based content delivery/notification mechanism between publishers and subscribers.This implementation supports introducing all WebSub components:The subscriber discovers from the publisher, the topic it needs to subscribe to and the hub(s) that deliver notifications on updates of the topic.The ...","content":"v1.2.2  All Modules  Module : websub  Module Overview This module contains an implementation of the W3C recommendation, which facilitates a push-based content delivery/notification mechanism between publishers and subscribers. This implementation supports introducing all WebSub components:  Subscriber - A party interested in receiving update notifications for particular topics. Publisher - A party that advertises topics to which interested parties subscribe in order to receive notifications on occurrence of events. Hub - A party that accepts subscription requests from subscribers and delivers content to the subscribers when the topic is updated by the topic's publisher.  Basic flow with WebSub   The subscriber discovers from the publisher, the topic it needs to subscribe to and the hub(s) that deliver notifications on updates of the topic.   The subscriber sends a subscription request to one or more discovered hub(s) specifying the discovered topic along with other subscription parameters such as:  The callback URL to which content is expected to be delivered. (Optional) The lease period (in seconds) the subscriber wants the subscription to stay active. (Optional) A secret to use for .    The hub sends an intent verification request to the specified callback URL. If the response indicates verification (by echoing a challenge specified in the request) by the subscriber, the subscription is added for the topic at the hub.   The publisher notifies the hub of updates to the topic and the content to deliver is identified.   The hub delivers the identified content to the subscribers of the topic.   Features Subscriber This module allows introducing a WebSub Subscriber Service with onIntentVerification, which accepts HTTP GET requests for intent verification, and onNotification, which accepts HTTP POST requests for notifications. The WebSub Subscriber Service provides the following capabilities:  When the service is started a subscription request is sent for a hub/topic combination, either specified as annotations or discovered based on the resource URL specified as an annotation. If onIntentVerification is not specified, intent verification will be done automatically against the topic specified as an annotation or discovered based on the resource URL specified as an annotation. If a secret is specified for the subscription, signature validation will be done for authenticated content distribution.  Sends subscription request on service startup and explicit intent verification  When the subscribeOnStartUp is set to true in the Subscriber Service, it will result in a subscription request being sent to the specified hub for the specified topic, with the specified lease seconds value and the specified secret for authenticated content distribution.   Since an onIntentVerification resource function is not included, intent verification for subscription and unsubscription requests would happen automatically.  ballerina @websub:SubscriberServiceConfig { path: \"/websub\", subscribeOnStartUp: true, target: [\"<HUB_URL>\", \"<TOPIC_URL>\"], leaseSeconds: 3600, secret: \"<SECRET>\" } service websubSubscriber on websubEP { resource function onNotification(websub:Notification notification) { //... } }  Explicit intent verification can be done by introducing an onIntentVerification resource function.  ballerina resource function onIntentVerification(websub:Caller caller, websub:IntentVerificationRequest request) { http:Response response = new; // Insert logic to build subscription/unsubscription intent verification response. error? result = caller->respond(response); } Functions are made available on the websub:IntentVerificationRequest to build a subscription or unsubscription verification response, specifying the topic to verify intent against: http:Response response = request.buildSubscriptionVerificationResponse(\"<TOPIC_TO_VERIFY_FOR>\");  http:Response response = request.buildUnsubscriptionVerificationResponse(\"<TOPIC_TO_VERIFY_FOR>\");  Hub A WebSub compliant hub based on the Ballerina Message Broker is also available. This can be used as a remote hub or to be used by publishers who want to have their own internal hub. Ballerina's WebSub hub honors specified lease periods and supports authenticated content distribution. Enabling Basic Auth support for the hub The Ballerina WebSub Hub can be secured by enforcing authentication (Basic Authentication) and (optionally) authorization. The AuthProvider and authConfig need to be specified for the hub listener and service respectively. If the authStoreProvider of the AuthProvider is set as \"http:CONFIG_AUTH_STORE\", usernames and passwords for authentication and scopes for authorization would be read from a config TOML file. A user can specify AuthProvider as follows and set it to the hubListenerConfig record, which is passed when starting the hub. http:BasicAuthHandler basicAuthHandler = new(new auth:InboundBasicAuthProvider());  http:ServiceEndpointConfiguration hubListenerConfig = {  auth: {  authHandlers: [basicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };  var val = websub:startHub(new http:Listener(9191, hubListenerConfig));  In addition to the BasicAuthHandler for the listener, a user also has to specify the authConfig properties at the service or resource levels. They can be set by passing arguments for the serviceAuth, subscriptionResourceAuth or publisherResourceAuth parameters when starting up the hub. Recognized users can be specified in a .toml file, which can be passed as a configuration file when running the program. [b7a.users]  [b7a.users.tom] password=\"1234\" scopes=\"scope1\"  Once the hub is secured using basic auth, a subscriber should provide the relevant auth config in the hubClientConfig field of the subscriber service annotation. auth:OutboundBasicAuthProvider basicAuthProvider = new({  username: \"tom\",  password: \"1234\" });  http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  @websub:SubscriberServiceConfig {  path: \"/ordereventsubscriber\",  hubClientConfig: {  auth: {  authHandler: basicAuthHandler  }  } }  Enabling data persistence for the hub The Ballerina WebSub Hub supports persistence of topic and subscription data that needs to be restored when the hub is restarted. Users can introduce their own persistence implementation, by introducing an object type that is structurally equivalent to the websub:HubPersistenceStore abstract object. Persistence can be enabled by setting a suitable websub:HubPersistenceStore value for the hubPersistenceStore field in the HubConfiguration record, which is passed to the websub:startHub() function. Any subscriptions added at the hub will be available even after the hub is restarted. Publisher Ballerina WebSub publishers can use utility functions to add WebSub link headers indicating the hub and topic URLs, which facilitates WebSub discovery. A hub client endpoint is also made available to publishers and subscribers to perform the following:   Publishers   Register a topic at the Hub websub:PublisherClient websubHubClientEP = new (\"http://localhost:9191/websub/publish\"); error? registrationResponse = websubHubClientEP->registerTopic(\"http://websubpubtopic.com\");    Publish to the hub indicating an update of the topic websub:PublisherClient websubHubClientEP = new (\"http://localhost:9191/websub/publish\"); error? publishResponse = websubHubClientEP.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"}); Subscribers   Subscribe/Unsubscribe to/from topics at a hub websub:SubscriptionClient websubHubClientEP = new(\"<HUB_URL>\");  // Send subscription request for a subscriber service. websub:SubscriptionChangeRequest subscriptionRequest = {  topic: \"<TOPIC_URL>\", callback: \"<CALLBACK_URL>\",  secret: \"<SECRET>\" }; websub:SubscriptionChangeResponse|error subscriptionChangeResponse = websubHubClientEP->subscribe(subscriptionRequest);  // Send unsubscription request for the subscriber service. websub:SubscriptionChangeRequest unsubscriptionRequest = {  topic: \"<TOPIC_URL>\",  callback: \"<CALLBACK_URL>\" }; websub:SubscriptionChangeResponse|error subscriptionChangeResponse = websubHubClientEP->unsubscribe(unsubscriptionRequest);      Introducing Specific Subscriber Services (Webhook Callback Services) Ballerina's WebSub subscriber service listener can be extended to introduce specific Webhooks. Instead of the single onNotification resource, you can introduce multiple resources to accept content delivery requests using specific subscriber services. These resources will correspond to the content delivery requests that will be delivered with respect to a particular topic. For example, assume a scenario in which you receive notifications either when an issue is opened or when an issue is closed by subscribing to a particular topic in an issue tracking system. With a custom subscriber service listener, which extends the generic WebSub subscriber service listener, you can allow two resources to accept content delivery requests (e.g., onIssueOpened and onIssueClosed) instead of the onNotification resource. These resources will accept two parameters:  The generic websub:Notification record as the first parameter A custom record corresponding to the expected (JSON) payload of the notification (e.g., IssueCreatedEvent, IssueClosedEvent)  You can introduce a specific service as such by extending the generic subscriber service listener, specifying a mapping between the expected notifications and the resources that requests need to be dispatched to. The mapping can be based on one of the following indicators of a notification request. (Requests will then be dispatched based on the value of the indicator in the request and a pre-defined mapping.)   A request header Dispatching will be based on the value of the request header specified as topicHeader. websub:ExtensionConfig extensionConfig = {  topicIdentifier: websub:TOPIC_ID_HEADER,  topicHeader: \"<HEADER_TO_CONSIDER>\",  headerResourceMap: {  \"issueOpened\": [\"onIssueOpened\", IssueOpenedEvent],  \"issueClosed\": [\"onIssueClosed\", IssueClosedEvent]  } };  The \"issueOpened\": [\"onIssueOpened\", IssueOpenedEvent] entry indicates that when the value of the <HEADER_TO_CONSIDER> header is issueOpened, dispatching should happen to a resource named onIssueOpened. The first parameter of this resource will be the generic websub:Notification record, and the second parameter will be a custom IssueOpenedEvent record mapping the JSON payload received when an issue is created.   The payload: the value of a particular key in the JSON payload Dispatching will be based on the value in the request payload of one of the map keys specified in the payloadKeyResourceMap map. websub:ExtensionConfig extensionConfig = {  topicIdentifier: websub:TOPIC_ID_PAYLOAD_KEY,  payloadKeyResourceMap: {  \"<PAYLOAD_KEY_TO_CONSIDER>\": {  \"issueOpened\": [\"onIssueOpened\", IssueOpenedEvent],  \"issueClosed\": [\"onIssueClosed\", IssueClosedEvent]  }  } };  The \"issueOpened\": [\"onIssueOpened\", IssueOpenedEvent] entry indicates that when the value for the JSON payload key <PAYLOAD_KEY_TO_CONSIDER> is issueOpened, dispatching should happen to a resource named onIssueOpened. The first parameter of this resource will be the generic websub:Notification record, and the second parameter will be a custom IssueOpenedEvent record, mapping the JSON payload received when an issue is created.   A request header and the payload (combination of the above two) Dispatching will be based on both a request header and the payload as specified in the headerAndPayloadKeyResourceMap. Also, you can introduce a headerResourceMap and/or a payloadKeyResourceMap as additional mappings. websub:ExtensionConfig extensionConfig = {  topicIdentifier: websub:TOPIC_ID_HEADER_AND_PAYLOAD,  topicHeader: \"<HEADER_TO_CONSIDER>\",  headerAndPayloadKeyResourceMap: {  \"issue\" : {  \"<PAYLOAD_KEY_TO_CONSIDER>\" : {  \"opened\": [\"onIssueOpened\", IssueOpenedEvent],  \"closed\": [\"onIssueClosed\", IssueClosedEvent]  }  }  } };  The \"opened\": [\"onIssueOpened\", IssueOpenedEvent] entry indicates that when the value of the <HEADER_TO_CONSIDER> header is issue and the value of the <PAYLOAD_KEY_TO_CONSIDER> JSON payload key is opened, dispatching should happen to a resource named onIssueOpened. The first parameter of this resource will be the generic websub:Notification record and the second parameter will be a custom IssueOpenedEvent record, mapping the JSON payload received when an issue is created.   The Specific Subscriber Service In order to introduce a specific subscriber service, a new Ballerina listener needs to be introduced. This listener should wrap the generic ballerina/websub:Listener and include the extension configuration described above. The following example is for a service provider that  allows registering webhooks to receive notifications when an issue is opened or assigned includes a header named \"Event-Header\" in each content delivery request indicating what event the notification is for (e.g., \"onIssueOpened\" when an issue is opened and \"onIssueAssigned\" when an issue is assigned)  import ballerina/lang.'object as objects; import ballerina/websub;  // Introduce a record mapping the JSON payload received when an issue is opened. public type IssueOpenedEvent record {  int id;  string title;  string openedBy; }; // Introduce a record mapping the JSON payload received when an issue is assigned. public type IssueAssignedEvent record {  int id;  string assignedTo; }; // Introduce a new `listener` wrapping the generic `ballerina/websub:Listener` public type WebhookListener object {   *objects:Listener;   private websub:Listener websubListener;   public function __init(int port) {  // Introduce the extension config, based on the mapping details.  websub:ExtensionConfig extensionConfig = {  topicIdentifier: websub:TOPIC_ID_HEADER,  topicHeader: \"Event-Header\",  headerResourceMap: {  \"issueOpened\": [\"onIssueOpened\", IssueOpenedEvent],  \"issueAssigned\": [\"onIssueAssigned\", IssueAssignedEvent]  }  };  // Set the extension config in the generic `websub:Listener` config.  websub:SubscriberListenerConfiguration sseConfig = {  extensionConfig: extensionConfig  };  // Initialize the wrapped generic listener.  self.websubListener = new(port, sseConfig);  }   public function __attach(service s, string? name = ()) returns error? {  return self.websubListener.__attach(s, name);  }   public function __start() returns error? {  return self.websubListener.__start();  }  public function __detach(service s) returns error? {  return self.websubListener.__detach(s);  }  public function __immediateStop() returns error? {  return self.websubListener.__immediateStop();  }   public function __gracefulStop() returns error? {  return self.websubListener.__gracefulStop();  } }; A service can be introduced for the above service provider as follows. import ballerina/io; import ballerina/log; import ballerina/websub;  @websub:SubscriberServiceConfig {  path: \"/subscriber\",  subscribeOnStartUp: false } service specificSubscriber on new WebhookListener(8080) {  resource function onIssueOpened(websub:Notification notification, IssueOpenedEvent issueOpened) {  log:printInfo(io:sprintf(\"Issue opened: ID: %s, Title: %s\", issueOpened.id, issueOpened.title));  }  resource function onIssueAssigned(websub:Notification notification, IssueAssignedEvent issueAssigned) {  log:printInfo(io:sprintf(\"Issue ID %s assigned to %s\", issueAssigned.id, issueAssigned.assignedTo));  } }  For a step-by-step guide on introducing custom subscriber services, see the section of \"How to Extend Ballerina\". For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operations, see the following.          Records Anonymous record  Anonymous record  Anonymous record  Holds the details of a WebSub error.  The extension configuration to introduce custom subscriber services.  Record representing hub specific configurations.  Error to represent that a WebSubHub is already started up, encapsulating the started up Hub.  Record representing remote publishing allowance.  Record to represent Subscriber Details.  Represents the configuration for the WebSub Subscriber Service Listener.  Configuration for a WebSubSubscriber service.  Record representing a WebSub subscription change request.  Record representing subscription/unsubscription details if a subscription/unsubscription request is successful.  Record to represent persisted Subscription Details retrieved.  Objects Represents the Ballerina WebSub Hub.  Represents the hub persistence configuration and functions.  Object representing an intent verification request received.  Represents the WebSub Content Delivery Request received.  Clients The caller remote functions to respond to client requests.  The HTTP based client for WebSub topic registration and unregistration, and notifying the hub of new updates.  The HTTP based client for WebSub subscription and unsubscription.  Listeners Represents the WebSubSubscriber Service Listener.  Functions Function to add link headers to a response to allow WebSub discovery.  Retrieves hub and topic URLs from the http:response from a publisher to a discovery request.  Starts up the Ballerina Hub.  Constants The constant used to represent error code of WebSub module.  RemotePublishMode indicating direct update content notification (fat-ping).  RemotePublishMode indicating that once the publisher notifies the hub that an update is available, the hub needs to fetch the topic URL to identify the update content.  The constant used to represent SHA-1 cryptographic hash algorithm   The constant used to represent SHA-256 cryptographic hash algorithm   TopicIdentifier indicating dispatching based solely on a header of the request.  TopicIdentifier indicating dispatching based solely on a value for a key in the JSON payload of the request.  TopicIdentifier indicating dispatching based on a combination of header and values specified for a key/key(s) in the JSON payload of the request.  Represents the reason string for the websub:ListenerStartupError.  Represents the reason string for the websub:HubStartupError.  Annotations Annotation to declare that the service represents a specific webhook.  WebSub Subscriber Configuration for the service, indicating subscription related parameters.  Types The identifier to be used to identify the mode in which update content should be identified.  The identifier to be used to identify the cryptographic hash algorithm.  The identifier to be used to identify the topic for dispatching with custom subscriber services.  Errors Represents a hub startup error.  Represents a listener startup error."},{"page":"/learn/api-docs/ballerina/websub/listeners/Listener.html","name":"Listener - : Listener","summary":"Represents the WebSubSubscriber Service Listener.\n(int port, ? config)The port number of the remote serviceThe configurations related to the websub:Listener\n                    \n            ...","content":"Listeners  v1.2.2  All Modules  Listener - : Listener Represents the WebSubSubscriber Service Listener.    Constructor __init(int port, ? config)   port int The port number of the remote service   config ? ()  The configurations related to the websub:Listener   Methods  Stops consuming messages and detaches the service from the websub:Listener.  Stops the websub:Listener gracefully.  Stops the websub:Listener forcefully.  LifeCycle Methods  Binds a service to the websub:Listener.  Starts the websub:Listener.  Fields  config  ?  (default ()) The configurations for the websub:Listener   Methods  __detach (service s)  returns error? Stops consuming messages and detaches the service from the websub:Listener.  error? result = websubListener.__detach(helloService);    Parameters  s service Type descriptor of the service   Return Type (error?)  () or else an error upon failure to detach the service   __gracefulStop ()  returns error? Stops the websub:Listener gracefully.  error? result = websubListener.__gracefulStop();    Return Type (error?)  () or else an error upon failure to stop the listener   __immediateStop ()  returns error? Stops the websub:Listener forcefully.  error? result = websubListener.__immediateStop();    Return Type (error?)  () or else an error upon failure to stop the listener   LifeCycle Methods  __attach (service s, string? name)  returns error? Binds a service to the websub:Listener.  error? result = websubListener.__attach(helloService);    Parameters  s service Type descriptor of the service   name string? (default ())  Name of the service   Return Type (error?)  () or else an error upon failure to register the listener   __start ()  returns error? Starts the websub:Listener.  error? result = websubListener.__start();    Return Type (error?)  () or else an error upon failure to start the listener"},{"page":"/learn/api-docs/ballerina/websub/objects/Hub.html","name":"Object - : Hub","summary":"Represents the Ballerina WebSub Hub.\n\n            (string subscriptionUrl, ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  Hub  Represents the Ballerina WebSub Hub.   Constructor __init(string subscriptionUrl, string publishUrl, hubHttpListener)   subscriptionUrl string publishUrl string hubHttpListener Methods  Stops the started up Ballerina WebSub Hub.  Publishes an update against the topic in the initialized Ballerina Hub.  Registers a topic in the Ballerina Hub.  Unregisters a topic in the Ballerina Hub.  Removes a subscription from the Ballerina Hub, without verifying intent.  Retrieves topics currently recognized by the Hub.  Retrieves details of subscribers registered to receive updates for a particular topic.  Fields  subscriptionUrl  string  The URL for subscription changes   publishUrl  string  The URL for publishing and topic registration   stop ()  returns error? Stops the started up Ballerina WebSub Hub.  error? registrationResponse = webSubHub.stop();    Return Type (error?)  An error if hub can't be stoped or else ()   publishUpdate (string topic, string | xml | json | byte[] | payload, string? contentType)  returns error? Publishes an update against the topic in the initialized Ballerina Hub.  error? publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",{\"action\": \"publish\",  \"mode\": \"internal-hub\"});    Parameters  topic string The topic for which the update should happen   payload string | xml | json | byte[] | The update payload   contentType string? (default ())  The content type header to set for the request delivering the payload   Return Type (error?)  An error if the hub is not initialized or does not represent the internal hub or else ()   registerTopic (string topic)  returns error? Registers a topic in the Ballerina Hub.  error? registrationResponse = webSubHub.registerTopic(\"http://websubpubtopic.com\");    Parameters  topic string The topic to register   Return Type (error?)  An error if an error occurred with registration or else ()   unregisterTopic (string topic)  returns error? Unregisters a topic in the Ballerina Hub.  error? registrationResponse = webSubHub.unregisterTopic(\"http://websubpubtopic.com\");    Parameters  topic string The topic to unregister   Return Type (error?)  An error if an error occurred with unregistration or else ()   removeSubscription (string topic, string callback)  returns error? Removes a subscription from the Ballerina Hub, without verifying intent.  error? registrationResponse = webSubHub.removeSubscription(\"http://websubpubtopic.com\", \"removeSubscriptioCallback\");    Parameters  topic string The topic for which the subscription should be removed   callback string The callback for which the subscription should be removed   Return Type (error?)  An error if an error occurred with removal or else ()   getAvailableTopics ()  returns string[] Retrieves topics currently recognized by the Hub.  string[] topic = webSubHub.getAvailableTopics();    Return Type (string[])  An array of available topics   getSubscribers (string topic)  returns [] Retrieves details of subscribers registered to receive updates for a particular topic.  string[] topic = webSubHub.getSubscribers(\"http://websubpubtopic.com\");    Parameters  topic string The topic for which details need to be retrieved   Return Type ([])  An array of subscriber details"},{"page":"/learn/api-docs/ballerina/websub/objects/HubPersistenceStore.html","name":"Object - : HubPersistenceStore","summary":"Represents the hub persistence configuration and functions.\n\n            ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  HubPersistenceStore  Represents the hub persistence configuration and functions.   Methods  Adds or updates subscription details.  Removes subscription details.  Function to add a topic.  Function to remove a topic.  Function to retrieve subscription details of all subscribers.  Function to retrieve all registered topics.  addSubscription ( subscriptionDetails)  returns error? Adds or updates subscription details.  error? result = hubPersistenceStore.addSubscription(subscriptionDetails);    Parameters  subscriptionDetails The details of the subscription to add or update   Return Type (error?)  An error if an error occurred while adding the subscription or else () otherwise   removeSubscription ( subscriptionDetails)  returns error? Removes subscription details.  error? result = hubPersistenceStore.removeSubscription(subscriptionDetails);    Parameters  subscriptionDetails The details of the subscription to remove   Return Type (error?)  An error if an error occurred while removing the subscription or else () otherwise   addTopic (string topic)  returns error? Function to add a topic.  error? result = hubPersistenceStore.addTopic(\"topic\");    Parameters  topic string The topic to add   Return Type (error?)  An error if an error occurred while adding the topic or else () otherwise   removeTopic (string topic)  returns error? Function to remove a topic.  error? result = hubPersistenceStore.removeTopic(\"topic\");    Parameters  topic string The topic to remove   Return Type (error?)  An error if an error occurred while removing the topic or else () otherwise   retrieveAllSubscribers ()  returns [] | error Function to retrieve subscription details of all subscribers.  SubscriptionDetails[]|error result = hubPersistenceStore.retrieveAllSubscribers();    Return Type ([] | error)  An array of subscriber details or else an error if an error occurred while retrieving the subscriptions   retrieveTopics ()  returns string[] | error Function to retrieve all registered topics.  string[]|error result = hubPersistenceStore.retrieveTopics();    Return Type (string[] | error)  An array of topics or else error if an error occurred while retrieving the topics"},{"page":"/learn/api-docs/ballerina/websub/objects/IntentVerificationRequest.html","name":"Object - : IntentVerificationRequest","summary":"Object representing an intent verification request received.\n\n            ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  IntentVerificationRequest  Object representing an intent verification request received.   Methods  Builds the response for the request, verifying intention to subscribe, if the topic matches that expected.  Builds the response for the request, verifying intention to unsubscribe, if the topic matches that expected.  Fields  mode  string  The mode specified in the intent verification request, subscription or unsubscription   topic  string  The topic for which intent is verified to subscribe/unsubscribe   challenge  string  The challenge to be echoed to verify intent to subscribe/unsubscribe   leaseSeconds  int  (default 0) The lease seconds period for which a subscription will be active if intent verification is being done for subscription   request  (default ) An http:Request received for intent verification   buildSubscriptionVerificationResponse (string expectedTopic)  returns Builds the response for the request, verifying intention to subscribe, if the topic matches that expected.  http:Response response = request.buildSubscriptionVerificationResponse(\"<TOPIC_TO_VERIFY_FOR>\");    Parameters  expectedTopic string The topic for which subscription should be accepted   Return Type ()  An http:Response, which to the hub verifying/denying intent to subscribe   buildUnsubscriptionVerificationResponse (string expectedTopic)  returns Builds the response for the request, verifying intention to unsubscribe, if the topic matches that expected.  http:Response response = request.buildUnsubscriptionVerificationResponse(\"<TOPIC_TO_VERIFY_FOR>\");    Parameters  expectedTopic string The topic for which unsubscription should be accepted   Return Type ()  An http:Response, which to for the hub verifying/denying intent to unsubscribe"},{"page":"/learn/api-docs/ballerina/websub/objects/Notification.html","name":"Object - : Notification","summary":"Represents the WebSub Content Delivery Request received.\n\n            ...","content":"Objects  >  >  >  >  v1.2.2  All Modules  Object - :  Notification  Represents the WebSub Content Delivery Request received.   Methods  Retrieves the query parameters of the content delivery request as a map.  Retrieves the mime:Entity associated with the content delivery request.  Returns whether the requested header key exists in the header map of the content delivery request.  Returns the value of the specified header.  Retrieves all the header values to which the specified header key maps to.  Retrieves all the names of the headers present in the content delivery request.  Retrieves the type of the payload of the content delivery request (i.  Extracts json payload from the content delivery request.  Extracts xml payload from the content delivery request.  Extracts text payload from the content delivery request.  Retrieves the request payload as a ByteChannel except in the case of multiparts.  Retrieves the request payload as a byte[].  Retrieves the form parameters from the content delivery request as a map.  getQueryParams ()  returns map Retrieves the query parameters of the content delivery request as a map.  map<string[]> payload = notification.getTextPayload();    Return Type (map)  String-constrained array map of the query params   getEntity ()  returns | error Retrieves the mime:Entity associated with the content delivery request.  mime:Entity|error payload = notification.getEntity();    Return Type ( | error)  The mime:Entity of the request or else an error if entity construction fails   hasHeader (string headerName)  returns boolean Returns whether the requested header key exists in the header map of the content delivery request.  boolean payload = notification.hasHeader(\"name\");    Parameters  headerName string The header name   Return Type (boolean)  true if the specified header key exists or else false   getHeader (string headerName)  returns string Returns the value of the specified header. If the specified header key maps to multiple values, the first of these values is returned.  string payload = notification.getHeader(\"name\");    Parameters  headerName string The header name   Return Type (string)  The first header value for the specified header name or else panic if no header is found. Ideally, the Notification.hasHeader() needs to be used to check the existence of a header initially.   getHeaders (string headerName)  returns string[] Retrieves all the header values to which the specified header key maps to.  string[] headersNames = notification.getHeaders(\"name\");    Parameters  headerName string The header name   Return Type (string[])  The header values the specified header key maps to or else panic if no header is found. Ideally, the Notification.hasHeader() needs to be used to check the existence of a header initially.   getHeaderNames ()  returns string[] Retrieves all the names of the headers present in the content delivery request.  string[] headersNames = notification.getHeaderNames();    Return Type (string[])  An array of all the header names   getContentType ()  returns string Retrieves the type of the payload of the content delivery request (i.e: the content-type header value).  string contentType = notification.getContentType();    Return Type (string)  The content-type header value as a string   getJsonPayload ()  returns json | error Extracts json payload from the content delivery request.  json|error payload = notification.getJsonPayload();    Return Type (json | error)  The json payload or else an error in case of errors. If the content; type is not JSON, an error is returned.   getXmlPayload ()  returns xml | error Extracts xml payload from the content delivery request.  xml|error result = notification.getXmlPayload();    Return Type (xml | error)  The xml payload or else an error in case of errors. If the content; type is not XML, an error is returned.   getTextPayload ()  returns string | error Extracts text payload from the content delivery request.  string|error result = notification.getTextPayload();    Return Type (string | error)  The payload as a text or else an error in case of errors. If the content type is not of type text, an error is returned.   getByteChannel ()  returns | error Retrieves the request payload as a ByteChannel except in the case of multiparts.  io:ReadableByteChannel|error result = notification.getByteChannel();    Return Type ( | error)  A byte channel from which the message payload can be read or esle an error in case of errors   getBinaryPayload ()  returns byte[] | error Retrieves the request payload as a byte[].  byte[]|error payload = notification.getBinaryPayload();    Return Type (byte[] | error)  The message payload as a byte[] or else an error in case of errors   getFormParams ()  returns map | error Retrieves the form parameters from the content delivery request as a map.  map<string>|error result = notification.getFormParams();    Return Type (map | error)  The form params as a map or else an error in case of errors"},{"page":"/learn/api-docs/ballerina/websub/records/HubConfiguration.html","name":"Record - : HubConfiguration","summary":"Record representing hub specific configurations.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : HubConfiguration  Record representing hub specific configurations.   Fields  leaseSeconds  int  (default 86400) The default lease seconds value to honour if not specified in subscription requests   signatureMethod  (default SHA256) The signature method to use for authenticated content delivery (SHA1|SHA256)   remotePublish  The record representing configuration related to remote publishing allowance   topicRegistrationRequired  boolean  (default true) Whether a topic needs to be registered at the hub prior to publishing/subscribing to the topic   clientConfig  The configuration for the hub to communicate with remote HTTP endpoints   hubPersistenceStore  The HubPersistenceStore to use to persist hub data"},{"page":"/learn/api-docs/ballerina/websub/records/Detail.html","name":"Record - : Detail","summary":"Holds the details of a WebSub error.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : Detail  Holds the details of a WebSub error.   Fields  message  string  Specific error message for the error   cause  error  Cause of the error; If this error occurred due to another error (Probably from another module)"},{"page":"/learn/api-docs/ballerina/websub/records/ExtensionConfig.html","name":"Record - : ExtensionConfig","summary":"The extension configuration to introduce custom subscriber services.\n\n           ...","content":"Records  v1.2.2  All Modules  Record - : ExtensionConfig  The extension configuration to introduce custom subscriber services.   Fields  topicIdentifier  (default TOPIC_ID_HEADER) The identifier based on which dispatching should happen for custom subscriber   topicHeader  string?  (default ()) The header to consider if required with dispatching for custom services   headerResourceMap  map?  (default ()) The mapping between header value and resource details   payloadKeyResourceMap  map?  (default ()) The mapping between value for a particular JSON payload key and resource details   headerAndPayloadKeyResourceMap  map?  (default ()) The mapping between values for the header and a particular JSON payload key and resource details"},{"page":"/learn/api-docs/ballerina/websub/records/SubscriberDetails.html","name":"Record - : SubscriberDetails","summary":"Record to represent Subscriber Details.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : SubscriberDetails  Record to represent Subscriber Details.   Fields  callback  string  The callback specified for the particular subscription   leaseSeconds  int  (default 0) The lease second period specified for the particular subscription   createdAt  int  (default 0) The time at which the subscription was created"},{"page":"/learn/api-docs/ballerina/websub/records/HubStartedUpError.html","name":"Record - : HubStartedUpError","summary":"Error to represent that a WebSubHub is already started up, encapsulating the started up Hub.\n\n    ...","content":"Records  v1.2.2  All Modules  Record - : HubStartedUpError  Error to represent that a WebSubHub is already started up, encapsulating the started up Hub.   Fields  message  string  The error message   cause  error?  (default ()) The cause of the HubStartedUpError, if available   startedUpHub  The WebSubHub object representing the started up Hub"},{"page":"/learn/api-docs/ballerina/websub/records/RemotePublishConfig.html","name":"Record - : RemotePublishConfig","summary":"Record representing remote publishing allowance.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : RemotePublishConfig  Record representing remote publishing allowance.   Fields  enabled  boolean  (default false) Whether remote publishers should be allowed to publish to this hub (HTTP requests)   mode  (default PUBLISH_MODE_DIRECT) If remote publishing is allowed, the mode to use, direct (default) - fat ping with the notification payload specified or fetch - the hub fetches the topic URL specified in the \"publish\" request to identify the payload"},{"page":"/learn/api-docs/ballerina/websub/records/SubscriptionChangeRequest.html","name":"Record - : SubscriptionChangeRequest","summary":"Record representing a WebSub subscription change request.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : SubscriptionChangeRequest  Record representing a WebSub subscription change request.   Fields  topic  string  The topic for which the subscription/unsubscription request is sent   callback  string  The callback which should be registered/unregistered for the subscription/unsubscription request sent   leaseSeconds  int  (default 0) The lease period for which the subscription is expected to be active   secret  string  The secret to be used for authenticated content distribution with this subscription"},{"page":"/learn/api-docs/ballerina/websub/records/SubscriptionChangeResponse.html","name":"Record - : SubscriptionChangeResponse","summary":"Record representing subscription/unsubscription details if a subscription/unsubscription request is successful.\n\n         ...","content":"Records  v1.2.2  All Modules  Record - : SubscriptionChangeResponse  Record representing subscription/unsubscription details if a subscription/unsubscription request is successful.   Fields  hub  string  The hub at which the subscription/unsubscription was successful   topic  string  The topic for which the subscription/unsubscription was successful   response  The response from the hub to the subscription/unsubscription request"},{"page":"/learn/api-docs/ballerina/websub/records/SubscriberServiceConfiguration.html","name":"Record - : SubscriberServiceConfiguration","summary":"Configuration for a WebSubSubscriber service.\n\n            \n  ...","content":"Records  v1.2.2  All Modules  Record - : SubscriberServiceConfiguration  Configuration for a WebSubSubscriber service.   Fields  path  string  Path of the WebSubSubscriber service   subscribeOnStartUp  boolean  (default true) A boolean indicating whether a subscription request is expected to be sent on start up   target  string | [string, string]  The string resource URL for which discovery will be initiated to identify the hub and topic, or a tuple [hub, topic] representing a discovered hub and a topic   leaseSeconds  int  The period for which the subscription is expected to be active   secret  string  The secret to be used for authenticated content distribution   callback  string  The callback to use when registering, if unspecified host:port/path will be used   expectIntentVerification  boolean  (default false) A boolean indicating whether an intent verification is expected from the hub   publisherClientConfig  The configuration for the discovery client, to use if a resource URL is specified   hubClientConfig  The configuration for the hub client used to interact with the discovered/specified hub"},{"page":"/learn/api-docs/ballerina/websub/records/SubscriberListenerConfiguration.html","name":"Record - : SubscriberListenerConfiguration","summary":"Represents the configuration for the WebSub Subscriber Service Listener.\n\n          ...","content":"Records  v1.2.2  All Modules  Record - : SubscriberListenerConfiguration  Represents the configuration for the WebSub Subscriber Service Listener.   Fields  host  string  The host name/IP of the WebSub Subscriber Service Listener   httpServiceSecureSocket  ?  (default ()) The SSL configurations for the WebSub Subscriber Service Listener   extensionConfig  ?  (default ()) The extension configuration to introduce custom subscriber services (webhooks)"},{"page":"/learn/api-docs/ballerina/websub/records/T41.html","name":"Record - : T41","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T41"},{"page":"/learn/api-docs/ballerina/websub/records/SubscriptionDetails.html","name":"Record - : SubscriptionDetails","summary":"Record to represent persisted Subscription Details retrieved.\n\n            ...","content":"Records  v1.2.2  All Modules  Record - : SubscriptionDetails  Record to represent persisted Subscription Details retrieved.   Fields  topic  string  The topic for which the subscription is added   callback  string  The callback specified for the particular subscription   secret  string  The secret to be used for authenticated content distribution   leaseSeconds  int  (default 0) The lease second period specified for the particular subscription   createdAt  int  (default 0) The time at which the subscription was created"},{"page":"/learn/api-docs/ballerina/websub/records/T42.html","name":"Record - : T42","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T42"},{"page":"/learn/api-docs/ballerina/websub/records/T43.html","name":"Record - : T43","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T43"},{"page":"/learn/api-docs/ballerina/xmlutils/functions.html","name":"Functions -","summary":"(json? jsonValue,  options)Converts a JSON object to an XML representation.\nThe JSON sourceThe xmlutils:JsonOptions record for JSON to XML conversion propertiesXML representation of the given JSON if the JSON is\nsuccessfully converted or else an error(table tableValue)Converts a table to its XML representation.\nThe table value to be converted to an XMLThe ...","content":"Functions  v1.2.2  All Modules  Functions - Converts a JSON object to an XML representation.  Converts a table to its XML representation.  fromJSON (json? jsonValue, options)  returns xml | error Converts a JSON object to an XML representation.  json data = {  name: \"John\",  age: 30  };  xml|error xmlValue = xmlutils:fromJSON(data);    Parameters  jsonValue json? The JSON source   options (default {})  The xmlutils:JsonOptions record for JSON to XML conversion properties   Return Type (xml | error)  XML representation of the given JSON if the JSON is successfully converted or else an error   fromTable (table tableValue)  returns xml Converts a table to its XML representation.  table<Person> personTable = table{  { key id, age, salary, name, married },  [ { 1, 30, 300.5, \"Mary\", true },  { 2, 20, 300.5, \"John\", true }  ]  };  xml xmlValue = xmlutils:fromTable(personTable).toString();    Parameters  tableValue table The table value to be converted to an XML   Return Type (xml)  The XML representation of the provided table"},{"page":"/learn/api-docs/ballerina/xmlutils/","name":"Module : xmlutils","summary":"This module provides utility functions to manipulate the built-in xml data type.\nIt provides APIs to convert a json to an xml or convert a table to an xml. ...","content":"v1.2.2  All Modules  Module : xmlutils  Module overview This module provides utility functions to manipulate the built-in xml data type. It provides APIs to convert a json to an xml or convert a table to an xml.    Records Anonymous record  Anonymous record  Represents a record type to provide configurations for the JSON to XML conversion.  Functions Converts a JSON object to an XML representation.  Converts a table to its XML representation."},{"page":"/learn/api-docs/ballerina/xmlutils/records/JsonOptions.html","name":"Record - : JsonOptions","summary":"Represents a record type to provide configurations for the JSON to XML\nconversion.\n\n       ...","content":"Records  v1.2.2  All Modules  Record - : JsonOptions  Represents a record type to provide configurations for the JSON to XML conversion.   Fields  attributePrefix  string  (default @) The attribute prefix to use in the XML representation   arrayEntryTag  string  (default root) The XML tag to add an element from a JSON array"},{"page":"/learn/api-docs/ballerina/xmlutils/records/T0.html","name":"Record - : T0","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T0"},{"page":"/learn/api-docs/ballerina/xmlutils/records/T1.html","name":"Record - : T1","summary":"...","content":"Records  v1.2.2  All Modules  Record - : T1"},{"page":"/learn/api-docs/ballerina/xslt/functions.html","name":"Functions -","summary":"(xml input, xml xsl)Transforms the single-rooted XML content to another XML/HTML/plain text using XSL transformations.\nAn XML object, which needs to be transformedThe XSL style sheet represented in an XML objectThe transformed result represented in an XML object or else an error if the given XML object\ncan't be transformed ...","content":"Functions  v1.2.2  All Modules  Functions - Transforms the single-rooted XML content to another XML/HTML/plain text using XSL transformations.  transform (xml input, xml xsl)  returns xml | error Transforms the single-rooted XML content to another XML/HTML/plain text using XSL transformations.  xml|error target = xslt:transform(sourceXml, xsl);    Parameters  input xml An XML object, which needs to be transformed   xsl xml The XSL style sheet represented in an XML object   Return Type (xml | error)  The transformed result represented in an XML object or else an error if the given XML object can't be transformed"},{"page":"/learn/api-docs/ballerina/xslt/","name":"Module : xslt","summary":"This module provides a function to transform the XML content to another XML/HTML/plain text using XSL transformations.For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operations, see the . ...","content":"v1.2.2  All Modules  Module : xslt  Module Overview This module provides a function to transform the XML content to another XML/HTML/plain text using XSL transformations. For information on the operations, which you can perform with this module, see the below Functions. For examples on the usage of the operations, see the .    Functions Transforms the single-rooted XML content to another XML/HTML/plain text using XSL transformations."},{"page":"/learn/api-docs/ballerinax/awslambda.html","name":"ballerinax/awslambda module","summary":"Object to represent an AWS Lambda function execution context.@awslambda:Function annotation\n                                         ...","content":"<iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-PSL2TX4\"  height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe>  TABLE OF CONTENTS  »  »  »  ballerinax/awslambda module ballerinax/awslambda module Module Detail  Objects  Object  Description  Object to represent an AWS Lambda function execution context.   Functions  Function  Description  Annotations  Name  Attaches To  Data Type  Description  Function  function  @awslambda:Function annotation   public function __process() public function __register(string handler, function (awslambda:Context,json) returns (json|error) func) Parameter Name  Data Type  Default Value  Description  handler  func  (awslambda:Context,json) returns (json|error)  public type Context object  Object to represent an AWS Lambda function execution context.   <Context>  getRequestId() returns (string) Returns the unique id for this request.   Return Type  Description  the request id   <Context>  getDeadlineMs() returns (int) Returns the request execution deadline in milliseconds from the epoch.   Return Type  Description  the request execution deadline   <Context>  getInvokedFunctionArn() returns (string) Returns the ARN of the function being invoked.   Return Type  Description  the invoked function ARN   <Context>  getTraceId() returns (string) Returns the trace id for this request   Return Type  Description  the trace id   <Context>  getRemainingExecutionTime() returns (int) Returns the remaining execution time for this request in milliseconds   Return Type  Description  the remaining execution time   PRIMITIVE TYPES  BALLERINA MODULES   BALLERINAX MODULES"},{"page":"/learn/api-docs/ballerinax/jdbc.html","name":"ballerinax/jdbc module","summary":"This module provides the functionality required to access and manipulate data stored in any type of relational database that is accessible via Java Database Connectivity (JDBC).To access a database, you must first create a client object. A sample for creating a JDBC client can be found below.NOTE: Although the JDBC ...","content":"xxxxxxx   Ballerina - ballerina/jdbc API Docs  <iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-PSL2TX4\"  height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe>  TABLE OF CONTENTS  »  »  »  ballerinax/jdbc module ballerinax/jdbc module Module overview This module provides the functionality required to access and manipulate data stored in any type of relational database that is accessible via Java Database Connectivity (JDBC). Client To access a database, you must first create a client object. A sample for creating a JDBC client can be found below. NOTE: Although the JDBC client type supports connecting to any type of relational database that is accessible via JDBC, if you are using a MySQL or H2 database, it is recommended to use clients that are created using the client types specific to them via the relevant Ballerina modules. Connection pool handling There are 3 possible scenarios for connection pool handling.  Global, shareable default connection pool If you do not provide the poolOptions field, a globally shareable pool will be created for your database unless a connection pool matching with the properties you provided already exists.  jdbc:Client testDB = new({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  dbOptions: { useSSL: false } });   Client owned, unshareable connection pool If you define the poolOptions field inline, an unshareable connection pool will be created.  jdbc:Client testDB = new({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  poolOptions: { maximumPoolSize: 5 },  dbOptions: { useSSL: false } });   Local shareable connection pool If you create a record of type sql:PoolOptions and reuse that in the configuration of multiple clients, for each set of clients that connect to the same database instance with the same set of properties, a shared connection pool will be created.  jdbc:Client testDB1; jdbc:Client testDB2; jdbc:Client testDB3;  sql:PoolOptions poolOptions1 = { maximumPoolSize: 5 };  testDB1 = new({  url: \"jdbc:mysql://localhost:3306/testdb1\",  username: \"root\",  password: \"root\",  poolOptions: poolOptions1,  dbOptions: { useSSL: false } });  testDB2 = new({  url: \"jdbc:mysql://localhost:3306/testdb1\",  username: \"root\",  password: \"root\",  poolOptions: poolOptions1,  dbOptions: { useSSL: false } });  testDB3 = new({  url: \"jdbc:mysql://localhost:3306/testdb2\",  username: \"root\",  password: \"root\",  poolOptions: poolOptions1,  dbOptions: { useSSL: false } });  Database operations Once the client is created, database operations can be executed through that client. This module provides support for creating tables and executing stored procedures. It also supports selecting, inserting, deleting, updating, and batch updating data. Samples for these operations can be found below. Details of the SQL data types and query parameters relevant for these database operations can be found in the documentation for the SQL module. Samples Creating a client jdbc:Client testDB = new({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  dbOptions: { useSSL: false } });  The full list of client properties can be found listed under the sql:PoolOptions type, which is located in the types.bal file of the SQL module directory. Creating tables This sample creates a table with two columns. One column is of type int, and the other is of type varchar. The CREATE statement is executed via the update remote function of the client. // Create the ‘Students’ table with fields ‘id’, 'name' and ‘age’. var returned = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, age INT, name VARCHAR(255), PRIMARY KEY (id))\"); if (returned is sql:UpdateResult) {  io:println(\"Students table create status in DB: \" + returned.updatedRowCount); } else {  io:println(\"Students table creation failed: \" + <string>returned.detail().message); }  Inserting data This sample shows three examples of data insertion by executing an INSERT statement using the update remote function of the client. In the first example, query parameter values are passed directly into the query statement of the update remote function: var returned = testDB->update(\"INSERT INTO student(age, name) values (23, 'john')\"); if (returned is sql:UpdateResult) {  io:println(\"Inserted row count to Students table: \" + returned.updatedRowCount); } else {  io:println(\"Insert to Students table failed: \" + <string>returned.detail().message); }  In the second example, the parameter values, which are in local variables, are passed directly as parameters to the update remote function. This direct parameter passing can be done for any primitive Ballerina type like string, int, float, or boolean. The sql type of the parameter is derived from the type of the Ballerina variable that is passed in. string name = \"Anne\"; int age = 8; var returned = testDB->update(\"INSERT INTO student(age, name) values (?, ?)\", age, name); if (returned is sql:UpdateResult) {  io:println(\"Inserted row count to Students table: \" + returned.updatedRowCount); } else {  io:println(\"Insert to Students table failed: \" + <string>returned.detail().message); }  In the third example, parameter values are passed as an sql:Parameter to the update remote function. Use sql:Parameter when you need to provide more details such as the exact SQL type of the parameter, or the parameter direction. The default parameter direction is \"IN\". For more details on parameters, see the sql module. sql:Parameter p1 = { sqlType: sql:TYPE_VARCHAR, value: \"James\" }; sql:Parameter p2 = { sqlType: sql:TYPE_INTEGER, value: 10 }; var returned = testDB->update(\"INSERT INTO student(age, name) values (?, ?)\", p2, p1); if (returned is sql:UpdateResult) {  io:println(\"Inserted row count to Students table: \" + returned.updatedRowCount); } else {  io:println(\"Insert to Students table failed: \" + <string>returned.detail().message); }  Inserting data with auto-generated keys This example demonstrates inserting data while returning the auto-generated keys. It achieves this by using the update remote function to execute the INSERT statement. int age = 31; string name = \"Kate\"; var retWithKey = testDB->update(\"INSERT INTO student (age, name) values (?, ?)\", age, name); if (retWithKey is sql:UpdateResult) {  int count = retWithKey.updatedRowCount;  int generatedKey = <int>retWithKey.generatedKeys.GENERATED_KEY;  io:println(\"Inserted row count: \" + count);  io:println(\"Generated key: \" + generatedKey); } else {  io:println(\"Insert to table failed: \" + <string>retWithKey.detail().message); }  Selecting data This example demonstrates selecting data. First, a type is created to represent the returned result set. Next, the SELECT query is executed via the select remote function of the client by passing that result set type. Once the query is executed, each data record can be retrieved by looping the result set. The table returned by the select operation holds a pointer to the actual data in the database and it loads data from the table only when it is accessed. This table can be iterated only once. // Define a type to represent the results set. type Student record {  int id;  string name;  int age; };  // Select the data from the table. var selectRet = testDB->select(\"SELECT * FROM student\", Student); if (selectRet is table<Student>) {  // Iterating returned table.  foreach var row in selectRet {  io:println(\"Student:\" + row.id + \"|\" + row.name + \"|\" + row.age);  } } else {  io:println(\"Select data from student table failed: \" + <string>selectRet.detail().message); }  To re-iterate the same table multiple times, set the loadToMemory argument to true within the select remote function. var selectRet = testDB->select(\"SELECT * FROM student\", Student, loadToMemory = true); if (selectRet is table<Student>) {  // Iterating data first time.  foreach var row in selectRet {  io:println(\"Student:\" + row.id + \"|\" + row.name + \"|\" + row.age);  }  // Iterating data second time.  foreach var row in selectRet {  io:println(\"Student:\" + row.id + \"|\" + row.name + \"|\" + row.age);  } } else {  io:println(\"Select data from student table failed: \" + <string>selectRet.detail().message); }  Updating data This example demonstrates modifying data by executing an UPDATE statement via the update remote function of the client var returned = testDB->update(\"UPDATE student SET name = 'Jones' WHERE age = ?\", 23); if (returned is sql:UpdateResult) {  io:println(\"Updated row count in Students table: \" + returned.updatedRowCount); } else {  io:println(\"Insert to Students table failed: \" + <string>returned.detail().message); }  Batch updating data This example demonstrates how to insert multiple records with a single INSERT statement that is executed via the batchUpdate remote function of the client. This is done by first creating multiple parameter arrays, each representing a single record, and then passing those arrays to the batchUpdate operation. Similarly, multiple UPDATE statements can also be executed via batchUpdate. // Create the first batch of parameters. sql:Parameter para1 = { sqlType: sql:TYPE_VARCHAR, value: \"Alex\" }; sql:Parameter para2 = { sqlType: sql:TYPE_INTEGER, value: 12 }; sql:Parameter[] parameters1 = [para1, para2];  // Create the second batch of parameters. sql:Parameter para3 = { sqlType: sql:TYPE_VARCHAR, value: \"Peter\" }; sql:Parameter para4 = { sqlType: sql:TYPE_INTEGER, value: 6 }; sql:Parameter[] parameters2 = [para3, para4];  // Do the batch update by passing the batches. var retBatch = testDB->batchUpdate(\"INSERT INTO Students(name, age) values (?, ?)\", parameters1, parameters2); if (retBatch is int[]) {  io:println(\"Batch item 1 update count: \" + retBatch[0]);  io:println(\"Batch item 2 update count: \" + retBatch[1]); } else {  io:println(\"Batch update operation failed: \" + <string>retBatch.detail().message); }  Calling stored procedures The following examples demonstrate executing stored procedures via the call remote function of the client. The first example shows how to create and call a simple stored procedure that inserts data. // Create the stored procedure. var returned = testDB->update(\"CREATE PROCEDURE INSERTDATA (IN pName VARCHAR(255), IN pAge INT)  BEGIN  INSERT INTO Students(name, age) values (pName, pAge);  END\"); if (returned is sql:UpdateResult) {  io:println(\"Stored proc creation status: : \" + returned.updatedRowCount); } else {  io:println(\"Stored proc creation failed: \" + <string>returned.detail().message); }  // Call the stored procedure. var retCall = testDB->call(\"{CALL INSERTDATA(?,?)}\", (), \"George\", 15); if (retCall is ()|table<record {}>[]) {  io:println(\"Call operation successful\"); } else {  io:println(\"Stored procedure call failed: \" + <string>retCall.detail().message); }  This next example shows how to create and call a stored procedure that accepts INOUT and OUT parameters. // Create the stored procedure. var returned = testDB->update(\"CREATE PROCEDURE GETCOUNT (INOUT pID INT, OUT pCount INT)  BEGIN  SELECT COUNT(*) INTO pID FROM Students WHERE id = pID;  SELECT COUNT(*) INTO pCount FROM Students WHERE id = 2;  END\"); if (returned is sql:UpdateResult) {  io:println(\"Stored proc creation status: : \" + returned.updatedRowCount); } else {  io:println(\"Stored procedure creation failed: \" + <string>returned.detail().message); }  // Call the stored procedure. sql:Parameter param1 = { sqlType: sql:TYPE_INTEGER, value: 3, direction: sql:DIRECTION_INOUT }; sql:Parameter param2 = { sqlType: sql:TYPE_INTEGER, direction: sql:DIRECTION_OUT }; var retCall = testDB->call(\"{CALL GETCOUNT(?,?)}\", (), param1, param2); if (retCall is ()|table<record {}>[]) {  io:println(\"Call operation successful\");  io:print(\"Student count with ID = 3: \");  io:println(param1.value);  io:print(\"Student count with ID = 2: \");  io:println(param2.value); } else {  io:println(\"Stored procedure call failed: \" + <string>retCall.detail().message); }    Module Detail  Records  Record  Description  The Client endpoint configuration for SQL databases.   Endpoints  Endpoint  Description  Represents a JDBC SQL client endpoint.   public type ClientEndpointConfig  The Client endpoint configuration for SQL databases.   Field Name  Data Type  Default Value  Description  url  URL of the database to connect   username  Username for the database connection   password  Password for the database connection   poolOptions  Properties for the connection pool configuration. Refer sql:PoolOptions for more details   dbOptions  {}  A map of DB specific properties. These properties will have an effect only if the dataSourceClassName is provided in poolOptions   Endpoint Client  Represents a JDBC SQL client endpoint.   <Client>  call(string sqlQuery, typedesc[]? recordType, string|int|boolean|float|decimal|byte[][]|sql:Parameter? parameters) returns (table<$anonType$0>[]|null|error<>) The call remote function implementation for JDBC Client to invoke stored procedures/functions.   Parameter Name  Data Type  Default Value  Description  sqlQuery  The SQL stored procedure to execute   recordType  Array of record types of the returned tables if there is any   parameters  ||||||  The parameters to be passed to the procedure/function call. The number of parameters is variable   Return Type  Description  ||error<>  A table[] if there are tables returned by the call action and else nil, error will be returned if there is any error   <Client>  select(string sqlQuery, typedesc? recordType, boolean loadToMemory, string|int|boolean|float|decimal|byte[][]|sql:Parameter? parameters) returns (table<$anonType$1>|error<>) The select remote function implementation for JDBC Client to select data from tables.   Parameter Name  Data Type  Default Value  Description  sqlQuery  SQL query to execute   recordType  Type of the returned table   loadToMemory  false  Indicates whether to load the retrieved data to memory or not   parameters  ||||||  The parameters to be passed to the select query. The number of parameters is variable   Return Type  Description  |  A table returned by the sql query statement else error will be returned if there is any error   <Client>  update(string sqlQuery, string[]? keyColumns, string|int|boolean|float|decimal|byte[][]|sql:Parameter? parameters) returns (sql:UpdateResult|error<>) The update remote function implementation for JDBC Client to update data and schema of the database.   Parameter Name  Data Type  Default Value  Description  sqlQuery  SQL statement to execute   keyColumns  ()  Names of auto generated columns for which the auto generated key values are returned   parameters  ||||||  The parameters to be passed to the update query. The number of parameters is variable   Return Type  Description  |  sql:UpdateResult with the updated row count and key column values, else error will be returned if there is any error   <Client>  batchUpdate(string sqlQuery, string|int|boolean|float|decimal|byte[][][]|sql:Parameter? parameters) returns (int[]|error<>) The batchUpdate remote function implementation for JDBC Client to batch data insert.   Parameter Name  Data Type  Default Value  Description  sqlQuery  SQL statement to execute   parameters  ||||||  Variable number of parameter arrays each representing the set of parameters of belonging to each individual update   Return Type  Description  |  An int[] - The elements in the array returned by the remote function may be one of the following or else anerror will be returned if there is any error. A number greater than or equal to zero - indicates that the command was processed successfully and is an update count giving the number of rows A value of -2 - Indicates that the command was processed successfully but that the number of rows affected is unknown A value of -3 - Indicates that the command failed to execute successfully and occurs only if a driver continues to process commands after a command fails   PRIMITIVE TYPES  BALLERINA MODULES   BALLERINAX MODULES"},{"page":"/learn/api-docs/ballerinax/docker.html","name":"ballerinax/docker module","summary":"@docker:Config annotation to configure docker artifact generation.@docker:CopyFile annotation to copy external files to docker image.@docker:Expose annotation to expose ballerina ports.\n                               ...","content":"<iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-PSL2TX4\"  height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe>  TABLE OF CONTENTS  »  »  »  ballerinax/docker module ballerinax/docker module Module Detail  Records  Record  Description  Docker annotation configuration.   Expose ports for docker.  External file type for docker.   External File configurations for docker.   Annotations  Name  Attaches To  Data Type  Description  Config  service, listener  @docker:Config annotation to configure docker artifact generation.   CopyFiles  service, listener  @docker:CopyFile annotation to copy external files to docker image.   Expose  listener  @docker:Expose annotation to expose ballerina ports.   public type DockerConfiguration  Docker annotation configuration.   Field Name  Data Type  Default Value  Description  name  Name of the docker image   registry  Docker registry url   tag  Docker image tag   username  Docker registry username   password  Docker registry password   baseImage  Base image for Dockerfile   push  Enable pushing docker image to registry   buildImage  Enable docker image build   enableDebug  Enable ballerina debug   debugPort  Ballerina debug port   dockerHost  Docker host IP and docker PORT. ( e.g minikube IP and docker PORT)   dockerCertPath  Docker certificate path   public type ExposeConfig  Expose ports for docker.  public type FileConfig  External file type for docker.   Field Name  Data Type  Default Value  Description  source  source path of the file (in your machine)   target  target path (inside container)   isBallerinaConf  Flag to specify ballerina config file   public type FileConfigs  External File configurations for docker.   Field Name  Data Type  Default Value  Description  files  Array of PRIMITIVE TYPES  BALLERINA MODULES   BALLERINAX MODULES"},{"page":"/learn/api-docs/ballerinax/istio.html","name":"ballerinax/istio module","summary":"Types of protocols of a port.TLS mode enforced by the proxy.@istio:Gateway annotation to generate istio gateways.@istio:VirtualService annotation to generate istio virtual service.\n                             ...","content":"<iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-PSL2TX4\"  height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe>  TABLE OF CONTENTS  »  »  »  ballerinax/istio module ballerinax/istio module Module Detail  Records  Record  Description  Configuration to a network addressable service.   Configuration for weight for destination to traffic route.   Istio gateway annotation configuration.   Configurations for conditions and actions for routing HTTP.   Port of a service.   Istio gateway server configuration to describe the properties of the proxy on a given load balancer.   Istio gateway server tls option configurations.   Virtual service configuration for @istio:VirtualService annotation.   Type Definitions  Type  Values  Description  PortProtocol  TLS | TCP | MONGO | HTTPS | HTTP2 | HTTP | GRPC  Types of protocols of a port.   TLSOptionMode  SIMPLE | PASSTHROUGH | MUTUAL  TLS mode enforced by the proxy.   Annotations  Name  Attaches To  Data Type  Description  Gateway  service, listener  @istio:Gateway annotation to generate istio gateways.   VirtualService  service, listener  @istio:VirtualService annotation to generate istio virtual service.   public type DestinationConfig  Configuration to a network addressable service.   Field Name  Data Type  Default Value  Description  host  Host of a service.   subset  Subset within the service.   port  The port on the host that is being addressed.   public type DestinationWeightConfig  Configuration for weight for destination to traffic route.   Field Name  Data Type  Default Value  Description  destination  Destination to forward to.   weight  Weight for the destination.   public type GatewayConfig  Istio gateway annotation configuration.   Field Name  Data Type  Default Value  Description  name  Name of the resource   labels  Map of labels for the resource   annotations  Map of annotations for resource   selector  Specific set of pods/VMs on which this gateway configuration should be applied.   servers  List of servers to pass.   public type HTTPRouteConfig  Configurations for conditions and actions for routing HTTP.   Field Name  Data Type  Default Value  Description  route  Route destination.   timeout  Timeout for requests in seconds.   appendHeaders  Additional header to add before forwarding/directing.   public type PortConfig  Port of a service.   Field Name  Data Type  Default Value  Description  number  The port number.   protocol  The protocol exposed by the port.   name  Label for the port.   public type ServerConfig  Istio gateway server configuration to describe the properties of the proxy on a given load balancer.   Field Name  Data Type  Default Value  Description  port  The port of the proxy.   hosts  List of hosts exposed by the gateway.   tls  TLS options.   public type TLSOptionConfig  Istio gateway server tls option configurations.   Field Name  Data Type  Default Value  Description  httpsRedirect  false  If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.   mode  Indicates whether connections to this port should be secured using TLS. The value of this field determines how TLS is enforced.   serverCertificate  REQUIRED if mode is SIMPLE or MUTUAL. The path to the file holding the server-side TLS certificate to use.   privateKey  REQUIRED if mode is SIMPLE or MUTUAL. The path to the file holding the server’s private key.   caCertificates  REQUIRED if mode is MUTUAL. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.   subjectAltNames  A list of alternate names to verify the subject identity in the certificate presented by the client.   public type VirtualServiceConfig  Virtual service configuration for @istio:VirtualService annotation.   Field Name  Data Type  Default Value  Description  name  Name of the resource   labels  Map of labels for the resource   annotations  Map of annotations for resource   hosts  Destination which traffic should be sent.   gateways  Names of the gateways which the service should listen to.   http  Route rules for HTTP traffic.   PRIMITIVE TYPES  BALLERINA MODULES   BALLERINAX MODULES"},{"page":"/learn/api-docs/ballerinax/kubernetes.html","name":"ballerinax/kubernetes module","summary":"Image pull policy type field for kubernetes deployment and jobs.Scopes for kubernetes resource quotasRestart policy type field for kubernetes jobs.Service type field for kubernetes services.Session affinity field for kubernetes services.@kubernetes:ConfigMap annotation to configure config maps.@kubernetes:Deployment annotation to configure deplyoment yaml.@kubernetes:HPA annotation to configure horizontal pod autoscaler yaml.@kubernetes:Ingress annotation to configure ...","content":"<iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-PSL2TX4\"  height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe>  TABLE OF CONTENTS  »  »  »  ballerinax/kubernetes module ballerinax/kubernetes module Module Detail  Records  Record  Description  Extend building of the docker image.   Kubernetes Config Map volume mount.   Value from config map key.   Value for config map key.   Secret volume mount configurations for kubernetes.   Kubernetes deployment configuration.   Value from field.   Value for a field.   External file type for docker.   Kubernetes ingress configuration.   Kubernetes job configuration.   Metadata for artifacts   Build Config configuration for OpenShift.   Kubernetes Persistent Volume Claim.   Persistent Volume Claims configurations for kubernetes.   Kubernetes Horizontal Pod Autoscaler configuration   Probing configuration.   Value from resource field.   Value for resource field.   Kubernetes Resource Quota   Resource Quota configuration for kubernetes.   Kubernetes secret volume mount.   Value from secret key.   Value for a secret key.   Secret volume mount configurations for kubernetes.   Kubernetes service configuration.   Type Definitions  Type  Values  Description  ImagePullPolicy  Never | IfNotPresent | Always  Image pull policy type field for kubernetes deployment and jobs.   ResourceQuotaScope  Terminating | NotTerminating | NotBestEffort | BestEffort  Scopes for kubernetes resource quotas   RestartPolicy  OnFailure | Never | Always  Restart policy type field for kubernetes jobs.   ServiceType  NodePort | LoadBalancer | ClusterIP  Service type field for kubernetes services.   SessionAffinity  None | ClientIP  Session affinity field for kubernetes services.   Annotations  Name  Attaches To  Data Type  Description  ConfigMap  service, function  @kubernetes:ConfigMap annotation to configure config maps.   Deployment  service, function, listener  @kubernetes:Deployment annotation to configure deplyoment yaml.   HPA  service, function  @kubernetes:HPA annotation to configure horizontal pod autoscaler yaml.   Ingress  service, listener  @kubernetes:Ingress annotation to configure ingress yaml.   Job  function  @kubernetes:Job annotation to configure kubernetes jobs.   PersistentVolumeClaim  service, function  @kubernetes:PersistentVolumeClaim annotation to configure Persistent Volume Claims.   ResourceQuota  service, function  @kubernetes:ResourcesQuotas annotation to configure Resource Quotas.   Secret  service, function  @kubernetes:Secret annotation to configure secrets.   Service  service, listener  @kubernetes:Service annotation to configure service yaml.   public type BuildExtension  Extend building of the docker image.   Field Name  Data Type  Default Value  Description  openshift  Openshift build config.   public type ConfigMap  Kubernetes Config Map volume mount.   Field Name  Data Type  Default Value  Description  mountPath  Mount path   readOnly  true  Is mount read only   data  Paths to data files   public type ConfigMapKeyRef  Value from config map key.   Field Name  Data Type  Default Value  Description  configMapKeyRef  Reference for config map key.   public type ConfigMapKeyValue  Value for config map key.   Field Name  Data Type  Default Value  Description  name  name of the config.   key  key of the config.   public type ConfigMapMount  Secret volume mount configurations for kubernetes.   Field Name  Data Type  Default Value  Description  conf  path to ballerina configuration file   configMaps  Array of public type DeploymentConfiguration  Kubernetes deployment configuration.   Field Name  Data Type  Default Value  Description  namespace  Kubernetes namespace to be used on all artifacts   podAnnotations  Map of annotations for pods   replicas  Number of replicas   livenessProbe  false  Enable/Disable liveness probe and configure it.   readinessProbe  false  Enable/Disable readiness probe and configure it.   imagePullPolicy  IMAGE_PULL_POLICY_IF_NOT_PRESENT  Kubernetes image pull policy   image  Docker image with tag   env  Environment varialbe map for containers   buildImage  Docker image to be build or not   dockerHost  Docker host IP and docker PORT. (e.g minikube IP and docker PORT)   registry  Docker registry url   username  Username for docker registry   password  Password for docker registry   buildExtension  Docker image build extensions   baseImage  Base image for docker image building   push  Push to remote registry   dockerCertPath  Docker certificate path   copyFiles  Array of for docker image   singleYAML  true  Generate a single yaml file with all kubernetes artifacts (services,deployment,ingress,)   dependsOn  Services this deployment depends on   imagePullSecrets  Image pull secrets   public type FieldRef  Value from field.   Field Name  Data Type  Default Value  Description  fieldRef  Reference for a field.   public type FieldValue  Value for a field.   Field Name  Data Type  Default Value  Description  fieldPath  Path of the field   public type FileConfig  External file type for docker.   Field Name  Data Type  Default Value  Description  source  source path of the file (in your machine)   target  target path (inside container)   public type IngressConfiguration  Kubernetes ingress configuration.   Field Name  Data Type  Default Value  Description  listenerName  Name of the listener ingress attached   hostname  Host name of the ingress   path  Resource path   targetPath  Target path for url rewrite   ingressClass  Ingress class   enableTLS  Enable/Disable ingress TLS   public type JobConfig  Kubernetes job configuration.   Field Name  Data Type  Default Value  Description  namespace  Kubernetes namespace to be used on all artifacts   restartPolicy  RESTART_POLICY_NEVER  Restart policy   backoffLimit  Backoff limit   activeDeadlineSeconds  Active deadline seconds   schedule  Schedule for cron jobs   env  Environment varialbes for container   imagePullPolicy  IMAGE_PULL_POLICY_IF_NOT_PRESENT  Policy for pulling an image   image  Docker image with tag   buildImage  true  Docker image to be build or not   dockerHost  Docker host IP and docker PORT. (e.g minikube IP and docker PORT)   username  Username for docker registry   password  Password for docker registry   baseImage  Base image for docker image building   push  false  Push to remote registry   dockerCertPath  Docker cert path   copyFiles  Array of for docker image   imagePullSecrets  Image pull secrets   singleYAML  true  Generate a single yaml file with all kubernetes artifacts (services,deployment,ingress,)   public type Metadata  Metadata for artifacts   Field Name  Data Type  Default Value  Description  name  Name of the resource   labels  Map of labels for the resource   annotations  Map of annotations for resource   public type OpenShiftBuildConfigConfiguration  Build Config configuration for OpenShift.   Field Name  Data Type  Default Value  Description  forcePullDockerImage  false  Set force pull images when building docker image.   buildDockerWithNoCache  false  Build docker image with no cache enabled.   public type PersistentVolumeClaimConfig  Kubernetes Persistent Volume Claim.   Field Name  Data Type  Default Value  Description  mountPath  Mount Path   accessMode  Access mode   volumeClaimSize  Size of the volume claim   readOnly  Is mount read only   public type PersistentVolumeClaims  Persistent Volume Claims configurations for kubernetes.   Field Name  Data Type  Default Value  Description  volumeClaims  Array of public type PodAutoscalerConfig  Kubernetes Horizontal Pod Autoscaler configuration   Field Name  Data Type  Default Value  Description  minReplicas  Minimum number of replicas   maxReplicas  Maximum number of replicas   cpuPercentage  CPU percentage to start scaling   public type ProbeConfiguration  Probing configuration.   Field Name  Data Type  Default Value  Description  port  Port to check for tcp connection.   initialDelaySeconds  Initial delay for pobing in seconds.   periodSeconds  Interval between probes in seconds.   public type ResourceFieldRef  Value from resource field.   Field Name  Data Type  Default Value  Description  resourceFieldRef  Reference for resource field.   public type ResourceFieldValue  Value for resource field.   Field Name  Data Type  Default Value  Description  containerName  Name of the container.   resource  Resource field   public type ResourceQuotaConfig  Kubernetes Resource Quota   Field Name  Data Type  Default Value  Description  hard  Quotas for the resources   scopes  []  Scopes of the quota   public type ResourceQuotas  Resource Quota configuration for kubernetes.   Field Name  Data Type  Default Value  Description  resourceQuotas  Array of public type Secret  Kubernetes secret volume mount.   Field Name  Data Type  Default Value  Description  mountPath  Mount path   readOnly  true  Is mount read only   data  Paths to data files as an array   public type SecretKeyRef  Value from secret key.   Field Name  Data Type  Default Value  Description  secretKeyRef  Reference for secret key.   public type SecretKeyValue  Value for a secret key.   Field Name  Data Type  Default Value  Description  name  Name of the secret.   key  Key of the secret.   public type SecretMount  Secret volume mount configurations for kubernetes.   Field Name  Data Type  Default Value  Description  secrets  Array of public type ServiceConfiguration  Kubernetes service configuration.   Field Name  Data Type  Default Value  Description  port  Service port   targetPort  Port of the pods   sessionAffinity  SESSION_AFFINITY_NONE  Session affinity for pods   serviceType  SERVICE_TYPE_CLUSTER_IP  Service type of the service   PRIMITIVE TYPES  BALLERINA MODULES   BALLERINAX MODULES"},{"page":"/learn/api-docs/ballerinax/openshift.html","name":"ballerina/openshift module","summary":"@kubernetes:OpenShiftRoute annotation to generate openshift routes.\n                                             ...","content":"<iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-PSL2TX4\"  height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe>  TABLE OF CONTENTS  »  »  »  ballerina/openshift module ballerina/openshift module Module Detail  Records  Record  Description  Route configuration for @kubernetes:OpenShiftRoute.   Domain for OpenShift Route configuration.   Annotations  Name  Attaches To  Data Type  Description  Route  service, listener  @kubernetes:OpenShiftRoute annotation to generate openshift routes.   public type RouteConfiguration  Route configuration for @kubernetes:OpenShiftRoute.   Field Name  Data Type  Default Value  Description  name  Name of the resource   labels  Map of labels for the resource   annotations  Map of annotations for resource   host  The host of the route.   public type RouteDomainConfig  Domain for OpenShift Route configuration.   Field Name  Data Type  Default Value  Description  domain  The domain of the hostname.   PRIMITIVE TYPES  BALLERINA MODULES   BALLERINAX MODULES"},{"page":"/learn/by-example/404.html","name":"Ballerina","summary":"Sorry, we couldn't find that! Check out the ?\n        by  |  |  | \n       ...","content":"Sorry, we couldn't find that! Check out the ?  by | | |"},{"page":"/learn/by-example/abstract-objects.html","name":"Abstract Objects","summary":"In Ballerina, objects can be abstract. Abstract objects only describe the fields and the signatures of the methods.\n An abstract object cannot be initialized and does not have a default value.Defines an abstract object called Person. It should only contain\n fields and method declarations. An abstract object cannot have\n an ...","content":"/  /  / Abstract Objects  import ballerina/io; type Person abstract object {  public int age;  public string firstName;  public string lastName;  function getFullName() returns string; function checkAndModifyAge(int condition, int a); }; type Employee object {  public int age;  public string firstName;  public string lastName;  function __init(int age, string firstName, string lastName) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  }  function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  } function checkAndModifyAge(int condition, int a) {  if (self.age < condition) {  self.age = a;  }  } };public function main() {  Person p = new Employee(5, \"John\", \"Doe\");  io:println(p.getFullName());  p.checkAndModifyAge(10, 50); io:println(p.age); }    Abstract Objects  In Ballerina, objects can be abstract. Abstract objects only describe the fields and the signatures of the methods.  An abstract object cannot be initialized and does not have a default value.    import ballerina/io;    type Person abstract object {  public int age;  public string firstName;  public string lastName;    Defines an abstract object called Person. It should only contain  fields and method declarations. An abstract object cannot have  an initializer or method definitions.   function getFullName() returns string;    Method declarations can be within the object. However, the method cannot  have a body.   function checkAndModifyAge(int condition, int a); };    type Employee object {  public int age;  public string firstName;  public string lastName;    Defines a non-abstract object called Employee, which is structurally equivalent  to Person. A non-abstract object cannot have any methods  without a body.   function __init(int age, string firstName, string lastName) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  }    Non-abstract objects can have initializers.   function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }    Methods should have a body.   function checkAndModifyAge(int condition, int a) {  if (self.age < condition) {  self.age = a;  }  } };    public function main() {    An abstract object type cannot be initialized. It does not have  an implicit initial value.   Person p = new Employee(5, \"John\", \"Doe\");  io:println(p.getFullName());  p.checkAndModifyAge(10, 50);    Initializes a value using the non-abstract object Employee,  and then assigns the value to the abstract object type variable.   io:println(p.age); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run abstract_objects.bal John Doe 50"},{"page":"/learn/ballerina-streaming-reference/","name":"Ballerina Streaming Reference Guide","summary":"Ballerina streaming is designed to process event streams in a streaming manner, detect complex event occurrences,\nand produce notifications in real-time.Note: Ballerina Streaming capabilities are shipped as the experimental feature in the latest release. Please use --experimental flag when compiling Ballerina files which have streaming constructs.For example, following scenarios are supported ...","content":"/  / Ballerina Streaming Reference Guide  Ballerina Streaming Reference Guide  Ballerina streaming is designed to process event streams in a streaming manner, detect complex event occurrences, and produce notifications in real-time.  Note: Ballerina Streaming capabilities are shipped as the experimental feature in the latest release. Please use --experimental flag when compiling Ballerina files which have streaming constructs.  For example, following scenarios are supported by Ballerina stream processing:    Data preprocessing  Generating alerts based on thresholds  Calculating aggregations over a short window or a long time period  Joining multiple data streams  Correlating data while finding missing and erroneous events   The following topics explains the high level concepts about Ballerina streaming    Stream  A stream is a logical series of events ordered in time. Its schema is defined/constrained via the record definition. A record definition contains a unique name and a set of uniquely identifiable attributes with specific types within the record. All the events of a specific stream have the same schema (i.e., have the same attributes in the same order).  Purpose  Defining a schema unifies common types of events together. This enables them to be processed via queries using their defined attributes, in a streaming manner.  Syntax  The syntax for defining a new stream is as follows.  type <record name> record {  <attribute type> <attribute name>;  <attribute type> <attribute name>;  <attribute type> <attribute name>;  ... };  stream<record name> <stream name> = new;  The following parameters are configured in a stream definition.    Parameter  Description  stream name  The name of the created stream.  record name  The name of the record that constrains the stream.  attribute name  The uniquely identifiable attribute name. The schema of a record is defined by its attributes.  attribute type  The type of each attribute defined in the record.  Example type Employee record {  string name;  int age;  string status; };  stream<Employee> employeeStream = new;   The code given above creates a stream named employeeStream that is constrained by the Employee type having the following attributes.    name of type string  age of type int  status of type string   Forever Statement The forever statement block can include one or more streaming queries defining stream processing and complex event processing rules.  Purpose  The forever statement block let streaming queries to run continuously till the Ballerina program is exited. Here each streaming query within the forever block executes as an independent isolated processing unit to one another.  Grammar  One or more streaming queries can be defined in a single forever statement block as shown in the syntax given below.  foreverStatement  : FOREVER LEFT_BRACE streamingQueryStatement+ RIGHT_BRACE  ;  streamingQueryStatement  : FROM (streamingInput (joinStreamingInput)? | patternClause)  selectClause?  orderByClause?  outputRateLimit?  streamingAction  ;   Sample query  This query filters out the sensor events, which have the temperature greater than 30 celsius, and for every 100 sensor events, it groups them based on their type, count number of sensor events for each type and publishes all the types have more than one event to the highTemperatureSensorStream stream.   forever {  from sensorTemperatureStream  where sensorTemperatureStream.temperature > 30  window lengthBatch (100)  select sensorTemperatureStream.type, count() as totalCount  group by sensorTemperatureStream.type  having totalCount > 1  => (HighTemperature [] values) {  foreach var value in values {  highTemperatureSensorStream.publish(value);  }  }  }   Query  Each streaming query can consume one or more streams, process the events continuously in a streaming manner, and simultaneously generate output.  Purpose  A query enables you to perform complex event processing and stream processing operations by processing incoming events one by one in the order they arrive.  Syntax  Each query contains an input and an output section. Some also contain a projection section. The following is a simple query with all three sections.  from <input stream> select <attribute name>, <attribute name>, ... => (<array type> <parameter name>) {  ...  ... }   Example  This query consumes events from the tempStream stream (that is already defined) and outputs the room temperature and the room number to the roomTempStream stream.  type temperature record {  int deviceID;  int roomNo;  float value; };  type roomTemperature record {  int roomNo;  float value; };  stream<temperature> tempStream = new; stream<roomTemperature> roomTempStream = new;  public function initQuery() {  forever {  from tempStream  select tempStream.roomNo, tempStream.value  => (roomTemperature[] temperatures) {  foreach var value in temperatures {  roomTempStream.publish(value);  }  }  } }   For more information about streaming queries, see the following subsections:    Query Projection  Streaming queries support the following for query projections.    Action  Description  Selecting required objects for projection  This involves selecting only some of the attributes from the input stream to be inserted into an output stream.  e.g., The following query selects only the `roomNo` and `temp` attributes from the `tempStream` stream.  from tempStreamselect tempStream.roomNo, tempStream.temp=> ( ) { }  Selecting all attributes for projection  This involves selecting all the attributes in an input stream to be inserted into an output stream. This can be done by using an asterisk ( * ) or by omitting the `select` statement.  e.g., The following query select all the attributes in the `tempStream` stream.  from tempStreamselect *=> ( ) { }  Renaming attributes  This selects attributes from the input streams and inserts them into the output stream with different names.  e.g., This query renames `roomNo` to `roomNumber` and `temp` to `temperature`.  from tempStream select tempStream.roomNo as roomNumber, tempStream.temp as temperature=> ( ) { }  Introducing the constant value  This adds constant values by assigning it to an attribute using `as`.  </br>  e.g., This query specifies 'C' to be used as the constant value for the `scale` attribute.  from tempStreamselect tempStream.roomNo, tempStream.temp, 'C' as scale=> ( ) { }  Using mathematical and logical expressions  This uses attributes with mathematical and logical expressions in the precedence order given below, and assigns them to the output attribute using `as`.  Operator precedence  Operator  Distribution  Example  ()  Scope  (cost + tax) * 0.05  == ()  Nil check  deviceID == ()  !  Logical NOT  ! (price > 10)  * / %  Multiplication, division, modulo  temp * 9/5 + 32  + -  Addition, substraction  temp * 9/5 - 32  < <= > >=  Comparators: less-than, greater-than-equal, greater-than, less-than-equal  totalCost >= price * quantity  == !=  Comparisons: equal, not equal  totalCost != price * quantity  &&  Logical AND  temp < 40 && (humidity < 40 or humidity >= 60)  ||  Logical OR  temp < 40 || (humidity < 40 && humidity >= 60)  e.g., This query converts Celsius to Fahrenheit, and identifies rooms of which the room number is between 10 and 15 as server rooms.  from tempStreamselect tempStream.roomNo, tempStream.temp * 9/5 + 32 as temp, 'F' as scale, tempStream.roomNo > 10 && tempStream.roomNo < 15 as isServerRoom=> (RoomFahrenheit [] events ) { }  </tr> </table>  #### Filter  Filters are included in queries to filter information from input streams based on a specified condition.  ###### Purpose  A filter allows you to separate events that match a specific condition as the output or for further processing.  ###### Syntax  Filter conditions should be defined with the `where` keyword next to the input stream name as shown below.  ```ballerina from where select , , ... => ( ) {  } ```  ###### Example  This query filters all the server rooms of which the room number is within the range of 100-210, and that have temperature greater than 40 degrees from the `tempStream` stream, and inserts the results into the `highTempStream` stream.  ```ballerina from tempStream where (tempStream.roomNo >= 100 && tempStream.roomNo < 210) && tempStream.temp > 40 select tempStream.roomNo, tempStream.temp => (RoomTemperature [] values) {  foreach var value in values {  highTempStream.publish(value);  } } ```   #### Window  Windows allow you to capture a subset of events based on a specific criterion from an input stream for calculation. Each input stream can only have a maximum of one window.  ###### Purpose  To create subsets of events within a stream based on time duration, number of events, etc for processing. A window can operate in a sliding or tumbling (batch) manner.  ###### Syntax  The `window` prefix should be inserted next to the relevant stream in order to use a window.  ```ballerina from window (, , ... ) select , , ... => ( ) {  } ``` Note : Filter condition can be applied both before and/or after the window  ###### Example  If you want to identify the maximum temperature out of the last 10 events, you need to define a `length` window of 10 events.  This window operates in a sliding mode where the following 3 subsets are calculated when a list of 12 events are received in a sequential order.  |Subset|Event Range| |------|-----------| | 1 | 1-10 | | 2 | 2-11 | |3| 3-12 |  The following query finds the maximum temperature out of **last 10 events** from the `tempStream` stream, and inserts the results into the `maxTempStream` stream.  ```ballerina from tempStream window length(10) select max(tempStream.temp) as maxTemp => ( ) {  } ```  If you define the maximum temperature reading out of every 10 events, you need to define a `lengthBatch` window of 10 events. This window operates as a batch/tumbling mode where the following 3 subsets are calculated when a list of 30 events are received in a sequential order.  |Subset|Event Range| |------|-----------| | 1 | 1-10 | | 2 | 11-20 | | 3 | 21-30 |  The following query finds the maximum temperature out of **every 10 events** from the `tempStream` stream, and inserts the results into the `maxTempStream` stream.  ```ballerina from tempStream window lengthBatch(10) select max(tempStream.temp) as maxTemp => ( ) {  } ```  Note : Similar operations can be done based on time via `time` windows and `timeBatch` windows and for others.  Code segments such as `window time(10000)` considers events that arrive during the last 10 seconds in a sliding manner, and the `window timeBatch(2000)` considers events that arrive every 2 seconds in a tumbling manner.  Following are some inbuilt windows shipped with Ballerina Streams.  * time * timeBatch * timeLength * length * lengthBatch * sort * externalTime * externalTimeBatch * uniqueLength * delay * timeAccum * hopping * timeOrder   1. time window   `time(int windowTime)`   A sliding time window that holds events that arrived during the last `windowTime` period at a given time, and  gets updated for each event arrival and expiry.  2. timeBatch window   `timeBatch(int windowTime)`   A batch (tumbling) time window that holds events that arrive during `windowTime` periods, and gets updated for  each `windowTime`.  3. timeLength window   `timelength(int windowTime, int windowLength)`   A sliding time window that, at a given time holds the last `windowLength` events that arrived during last  `windowTime` period, and gets updated for every event arrival and expiry.  4. length window  `length(int windowLength)`   A sliding length window that holds the last `windowLength` events at a given time, and gets updated for each  arrival and expiry.  5. lengthBatch window   `lengthBatch(int windowLength)`   A batch (tumbling) length window that holds a number of events specified as the `windowLength`. The window is  updated each time a batch of events that equals the number specified as the `windowLength` arrives.  6. externalTime window   `externalTime(timeStamp, int windowTime)`   A sliding time window based on external time. It holds events that arrived during the last `windowTime` period  from the external `timestamp`, and gets updated on every monotonically increasing `timestamp`. Here the  `timeStamp` should be an attribute of the record which is used as the constraint type of relevant input stream.  As the `timeStamp` parameter you should pass `.`.  7. externalTimeBatch window   `externalTimeBatch(timeStamp, int windowTime, int? startTime, int? timeout, boolean? replaceTimestampWithBatchEndTime)`   A batch (tumbling) time window based on external time, that holds events arrived during `windowTime` periods, and  gets updated for every `windowTime`. Here the `timeStamp` should be an attribute of the record which is used as  the constraint type of relevant input stream. As the `timeStamp` parameter you should pass `  .`. Parameters `startTime` and `timeout` are optional parameters. `startTime` can be used to  specify a user defined time to start the first batch. `timeout` is time to wait for arrival of new event, before  flushing and giving output for events belonging to a specific batch. Usually `timeout` is greater than  `windowTime`. If `replaceTimestampWithBatchEndTime` is true replaces the event time with the current time batch’s end time.  8. uniqueLength window   `uniqueLength(uniqueAttribute, int windowLength)`   A sliding length window that returns unique events within the `windowLength` based on the given `uniqueAttribute`  . Here the `uniqueAttribute` should be an attribute of the record which is used as the constraint type of  relevant input stream.  9. delay window   `delay(int delayTime)`   A delay window holds events for a specific time period(`delayTime`) that is regarded as a delay period before  processing them.  10. sort window   `sort(int windowLength, attributeName, string order)`   A sort sort window holds a batch of events that equal the number specified as the `windowLength` and sorts them  in the given `order` of given `attributeName`. Here the `attributeName` should be an attribute of the record  which is used as the constraint type of relevant input stream. You can have multiple `attributeName` fields  followed by it's `order`.  11. timeAccum window   `timeAccum(int timePeriod)`   A sliding window that accumulates events until no more events arrive within the `timePeriod`, and only then  releases the accumulated events.  12. hopping window   `hopping(int windowTime, int hoppingTime)`   A hopping window holds the events arrived within last `windowTime` and release them in every `hoppingTime` period.  13. timeOrder window   `timeOrder(timestamp, int windowTime, boolean dropOlderEvents)`   A timeOrder window orders events that arrive out-of-order, using timestamp values provided by `timestamp`, and  bycomparing that `timestamp` value to system time. `windowTime` is the window duration. `dropOlderEvents` flag  determines whether to drop the events which has timestamp value less than the tail-time of current window.  Tail-time is the time, an amount of `windowTime` before the system time. Here the `timeStamp` should be an  attribute of the record which is used as the constraint type of relevant input stream. As the `timeStamp`  parameter you should pass `.`.   #### Aggregate function  Aggregate functions perform aggregate calculations in the query. When a window is defined the aggregation is restricted within that window. If no window is provided aggregation is performed from the start.  ###### Syntax  ```ballerina from window (, , ... ) select (, , ... ) as ,  , ... => ( ) {  } ```  **Aggregate Parameters**  Aggregate parameters can be attributes, constant values, results of other functions or aggregates, results of mathematical or logical expressions, or time parameters. Aggregate parameters configured in a query depends on the aggregate function being called.  ###### Example  The following query calculates the average value for the `temp` attribute of the `tempStream` stream. This calculation is done for the last 10 minutes in a sliding manner, and the result is output as `avgTemp` to the `avgTempStream` output stream.  ```ballerina from tempStream window time(600000) select avg(tempStream.temp) as avgTemp, tempStream.roomNo, tempStream.deviceID => (AvgTemperature [] values) {  foreach var value in values {  avgTempStream.publish(value);  } } ``` Following are some inbuilt aggregation functions shipped with Ballerina, for more aggregation functions, see execution.  * avg : Calculates the average for a given argument for all the events. * sum : Returns the sum of a given argument for all the events. * max : Returns the maximum value of a given argument for all the events. * min : Returns the minimum value of a given argument for all the events. * count : Returns the count of all the events. * distinctCount : Returns the count of distinct occurrences for a given argument. * maxForever : This stores the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front. * minForever : This stores the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front. * stdDev : Returns the calculated standard deviation of a given argument for all the events.  ###### More samples with above aggregation functions.   * The following query calculates the distinct count of page visits of each user.  ```ballerina from pageVisitStream window time(5000) select pageVisitStream.userID, pageVisitStream.pageID,  distinctCount(pageVisitStream.pageID) as distinctPages group by pageVisitStream.userID => (UserPageVisit [] visits) {  foreach var visit in visits {  outputStream.publish(visit);  } } ```   * The following query calculates the forever max temperature of the room.  ```ballerina from tempStream select tempStream.room, tempStream.timestamp, maxForever(tempStream.temperature) as maxTemp => (RoomTemperature [] roomTemps) {  foreach var roomTemp in roomTemps {  maxTempStream.publish(roomTemp);  } } ```   * The following query calculates standard deviation value of the stock price for the price change of each 1000 stock.  ```ballerina from stockExchangeStream window lengthBatch(1000) select stdDev(stockExchangeStream.price) as deviation, stockExchangeStream.symbol => (SymbolDeviation[] deviations) {  foreach var deviation in deviations {  priceDeviationStream.publish(deviation);  } } ```   #### Group By  The `group by` clause allows you to group the aggregate based on specified attributes.  ###### Syntax  The syntax for the `group by` aggregate function is as follows:  ```ballerina from window (...) select ( , , ...) as ,  , ... group by , ... => ( ) {  } ```  ###### Example  The following query calculates the average temperature per `roomNo` and `deviceID` combination, for events that arrive at the `tempStream` stream for a sliding time window of 10 minutes.  ```ballerina from tempStream window time(600000) select avg(tempStream.temp) as avgTemp, tempStream.roomNo, tempStream.deviceID group by tempStream.roomNo, tempStream.deviceID => (AvgTemperature [] values) {  foreach var value in values {  avgTempStream.publish(value);  } } ```  #### Having  The `having` clause allows you to filter events after processing the `select` statement.  ###### Purpose  This allows you to filter the aggregation output.  ###### Syntax  The syntax for the `having` clause is as follows:  ```ballerina from window ( ... ) select ( , , ...) as ,  , ... group by , ... having => ( ) {  } ```  ###### Example  The following query calculates the average temperature per room for the last 10 minutes, and alerts if it exceeds 30 degrees. ```ballerina from tempStream window time(600000) select avg(tempStream.temp) as avgTemp, tempStream.roomNo group by tempStream.roomNo having avgTemp > 30 => (Alert [] values) {  foreach var value in values {  alertStream.publish(value);  } } ```  #### Order By  The `order by` clause allows you to order the aggregated result in ascending and/or descending order based on specified attributes. By default ordering will be done in ascending manner. User can use `descending` keyword to order in descending manner.  ###### Syntax  The syntax for the `order by` clause is as follows:  ```ballerina from window ( ... ) select ( , , ...) as ,  , ... group by , ... having order by (ascending | descending)?,  (<ascending | descending>)?, ... => ( ) {  } ```  ###### Example  The following query calculates the average temperature per per `roomNo` and `deviceID` combination for every 10 minutes, and generate output events by ordering them in the ascending order of the room's avgTemp and then by the descending order of roomNo.  ```ballerina from tempStream window timeBatch(600000) select avg(tempStream.temp) as avgTemp, tempStream.roomNo, tempStream.deviceID group by tempStream.roomNo, tempStream.deviceID order by avgTemp, roomNo descending => (AvgTemperature [] values) {  foreach var value in values {  avgTempStream.publish(value);  } } ```  #### Join Joins allow you to get a combined result from two streams in real-time based on a specified condition.  ###### Purpose  Streams are stateless. Therefore, in order to join two streams, they need to be connected to a window so that there is a pool of events that can be used for joining. Joins also accept conditions to join the appropriate events from each stream.  During the joining process each incoming event of each stream is matched against all the events in the other stream's window based on the given condition, and the output events are generated for all the matching event pairs.   ###### Syntax  The syntax for a `join` is as follows:  ```ballerina from window (, ... )  {unidirectional} {as }  join window (, ... )  {unidirectional} {as }  on select , , ... => ( ) {  } ``` Here, the `` allows you to match the attributes from both the streams.  **Unidirectional join operation**  By default, events arriving at either stream can trigger the joining process. However, if you want to control the join execution, you can add the `unidirectional` keyword next to a stream in the join definition as depicted in the syntax in order to enable that stream to trigger the join operation. Here, events arriving at other stream only update the  window of that stream, and this stream does not trigger the join operation.  Note : The `unidirectional` keyword cannot be applied to both the input streams because the default behaviour already allows both streams to trigger the join operation.  ###### Example  Assuming that the temperature of regulators are updated every minute. Following is a streaming query that controls the temperature regulators if they are not already `on` for all the rooms with a room temperature greater than 30 degrees.  ```ballerina from tempStream where (tempStream.temp > 30.0) window time(60000) as T  join regulatorStream where (regulatorStream.isOn == false) window length(1) as R  on T.roomNo == R.roomNo select T.roomNo, R.deviceID, 'start' as action => (RegulatorAction [] values) {  foreach var value in values {  regulatorActionStream.publish(value);  } } ```  **Supported join types**  Following are the supported operations of a join clause.   * **Inner join (join)**   This is the default behaviour of a join operation. `join` is used as the keyword to join both  the streams. The output is generated only if there is a matching event in both the streams.   * **Left outer join**   The left outer join operation allows you to join two streams to be merged based on a condition.  `left outer join` is used as the keyword to join both the streams.   Here, it returns all the events of left stream even if there are no matching events in the right  stream by having null values for the attributes of the right stream.   ###### Example   The following query generates output events for all events from the `stockStream` stream  regardless of whether a matching symbol exists in the `twitterStream` stream or not.   ```ballerina  from stockStream window time(60000) as S  left outer join twitterStream window length(1) as T  on S.symbol== T.symbol  select S.symbol as symbol, T.tweet, S.price  => ( ) {   }  ```   * **Right outer join**   This is similar to a left outer join. `right outer join` is used as the keyword to join both  the streams. It returns all the events of the right stream even if there are no matching events  in the left stream.   * **Full outer join**   The full outer join combines the results of left outer join and right outer join. `full outer join` is used as the keyword to join both the streams.  Here, output events are generated for each incoming event even if there are no matching events in  the other stream.   ###### Example   The following query generates output events for all the incoming events of each stream regardless of whether there is a  match for the `symbol` attribute in the other stream or not.   ```ballerina  from stockStream window time(60000) as S  full outer join twitterStream window length(1) as T  on S.symbol== T.symbol  select S.symbol as symbol, T.tweet, S.price  => ( ) {   }  ```   #### Table Operations Ballerina provides extensive support to deal with tables. It provides various types of operations such as create, insert, delete, etc. with in-memory or external storage tables.  ###### Purpose In Streaming context, a table is a stored version of a stream or a table of events. Ballerina provides support to interactively query the state of the stored events in the table when processing events which are arrived through a stream. We could perform operations such as add, delete, update and join with tables.  ###### Example - Add In the following example, query events that arrive in `stockStream` are added into the table `itemStockTable` after projecting a few attributes from the event.  ```ballerina import ballerina/io; import ballerina/runtime;  //This is the record that holds item details in the stockTable. type Item record {|  string name;  float price;  int stockAmount; |};  //This is the record that holds stock details. type Stock record {|  string name;  float price;  int stockAmount;  string manufactureName;  int manufactureId; |};  // This is the input stream that uses `Stock` as the constraint type. stream stockStream = new;  // This is the table that holds the item stock data. table itemStockTable = table {  { name, price, stockAmount },  [  {\"Book\", 100.0, 10},  {\"Pen\", 20.0, 4}  ] };  public function main() {  initQuery();   Stock d = {name : \"FOO\", price: 100.3, stockAmount: 2000, manufactureName: \"BAR\", manufactureId: 23};  stockStream.publish(d);   runtime:sleep(2000);   io:println(\"Records in table after inserting new record: \");  while(itemStockTable.hasNext()) {  io:println(\" \", itemStockTable.getNext());  } }  public function initQuery() {  forever {  from stockStream  select stockStream.name, stockStream.price, stockStream.stockAmount  => (Item[] items) {  foreach var item in items {  _ = checkpanic itemStockTable.add(item);  }  }  } } ```   ###### Example - Join with Table In the following query, we perform a join operation between the event stream and table. Whenever an order event is published to `orderStream`, it is matched against the `itemStockTable` through the `queryItemTable` function. If there is a match, an alert event is published to `orderAlertStream`.  ```ballerina import ballerina/io; import ballerina/runtime;  //This is the record that holds item details in the stockTable. type Item record {  string name;  float price;  int stockAmount; };  // This is the record that holds order events from the customer. type Order record {  string itemName;  int orderingAmount; };  //This is the record that holds alert events. type OutOfStockAlert record {  string itemName;  int stockAmount; };  // This is the input stream that uses `Order` as the constraint type. stream orderStream = new;  // This is the table that holds the item stock data. table itemStockTable = table {  { name, price, stockAmount },  [  {\"Book\", 100.0, 10},  {\"Pen\", 20.0, 4}  ] };  // This is the output stream that contains the events/alerts that are generated based on streaming logic. stream orderAlertStream = new;  function initOutOfStockAlert() {  forever {  from orderStream window length(1) as itemOrder  join queryItemTable(itemOrder.itemName, itemOrder.orderingAmount) as item  select item.name as itemName, item.stockAmount  => (OutOfStockAlert[] alerts) {  foreach var alert in alerts {  orderAlertStream.publish(alert);  }  }  } }  //`queryItemTable` function returns a table of items whose stock is not enough to satisfy the order. public function queryItemTable(string itemName, int orderingAmount)  returns table {  table result = table {  { name, price, stockAmount }, []  };  foreach var item in itemStockTable {  if (item.name == itemName && orderingAmount > item.stockAmount) {  var ret = result.add(item);  }  }  return result; }  public function main() {   initOutOfStockAlert();   Order o1 = {itemName: \"Book\", orderingAmount: 20};  Order o2 = {itemName: \"Pen\", orderingAmount: 3};   orderAlertStream.subscribe(function(OutOfStockAlert alert) {  io:println(\"Aert: Stocks unavailable for: \", alert.itemName, \" Available stocks: \", alert.stockAmount);  });   orderStream.publish(o1);  orderStream.publish(o2);   runtime:sleep(2000); } ```"},{"page":"/learn/by-example/anonymous-functions.html","name":"Anonymous Functions","summary":"In Ballerina, anonymous functions are a syntactic shortcut for defining inline functions.\n The only difference between an anonymous function and a normal function definition is that\n an anonymous function does not have a name.Defines an anonymous function.Defines an anonymous function with var.If an anonymous function contains only the return statement ...","content":"/  /  / Anonymous Functions  import ballerina/io;public function main() {  function (string, string) returns string anonFunction =  function (string x, string y) returns string {  return x + y;  };  io:println(\"Output: \", anonFunction(\"Hello \", \"World.!!!\"));  var anonFunction2 = function (string x, string y, string... z) returns string {  string value = x + y;  foreach var item in z {  value += item;  }  return value;  };  io:println(\"Output: \", anonFunction2(\"Ballerina \", \"is \", \"an \", \"open \",  \"source \", \"programming \", \"language.\"));  function (string, string) returns string arrowExpr = (x, y) => x + y;  io:println(\"Output: \", arrowExpr(\"Hello \", \"World.!!!\")); }    Anonymous Functions  In Ballerina, anonymous functions are a syntactic shortcut for defining inline functions.  The only difference between an anonymous function and a normal function definition is that  an anonymous function does not have a name.    import ballerina/io;    public function main() {    function (string, string) returns string anonFunction =  function (string x, string y) returns string {  return x + y;  };  io:println(\"Output: \", anonFunction(\"Hello \", \"World.!!!\"));    Defines an anonymous function.   var anonFunction2 = function (string x, string y, string... z) returns string {  string value = x + y;  foreach var item in z {  value += item;  }  return value;  };  io:println(\"Output: \", anonFunction2(\"Ballerina \", \"is \", \"an \", \"open \",  \"source \", \"programming \", \"language.\"));    Defines an anonymous function with var.   function (string, string) returns string arrowExpr = (x, y) => x + y;  io:println(\"Output: \", arrowExpr(\"Hello \", \"World.!!!\")); }    If an anonymous function contains only the return statement in the body,  you can use the arrow function expression instead of the anonymous function.  The types of the input parameters are inferred from the left-hand side.  The return of the arrow function expression is determined by the  evaluation of the expression on the right-hand side of the => symbol.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run anonymous_functions.bal Output: Hello World.!!! Output: Ballerina is an open source programming language. Output: Hello World.!!!"},{"page":"/learn/by-example/access-mutate-java-fields.html","name":"Access/Mutate Java Fields","summary":"Java fields (both static and instance) can be read and updated in Ballerina.\n From the Ballerina side, they will appear as function calls. This example shows how to read a field value.\n Similarly, the @java:FieldSet annotation can be used to create a Ballerina function with\n an external function that acts ...","content":"/  /  / Access/Mutate Java Fields  import ballerina/io; import ballerina/java; public function pi() returns float = @java:FieldGet {  name: \"PI\",  class: \"java/lang/Math\" } external;public function main() {  float r = 4;  float l = 2 * pi() * r;  io:println(l); }    Access/Mutate Java Fields  Java fields (both static and instance) can be read and updated in Ballerina.  From the Ballerina side, they will appear as function calls. This example shows how to read a field value.  Similarly, the @java:FieldSet annotation can be used to create a Ballerina function with  an external function that acts as a field setter.    import ballerina/io; import ballerina/java;    public function pi() returns float = @java:FieldGet {  name: \"PI\",  class: \"java/lang/Math\" } external;    Define a Ballerina function which will act as a Java field getter.   public function main() {  float r = 4;    float l = 2 * pi() * r;  io:println(l); }    If a field is an instance field, the receiver instance has to be provided as the first parameter.   # To run this sample, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run access_mutate_java_fields.bal 25.132741228718345"},{"page":"/learn/by-example/anonymous-objects.html","name":"Anonymous Objects","summary":"Object types can be defined in-line as well. These types do not have a type name associated with them.\n Such anonymous object types can be used in instances in which there is no need to refer to the object type by its name\n (e.g., objects as fields of records or ...","content":"/  /  / Anonymous Objects  import ballerina/io;public type Person record {  string name;  int age;  object {  public string city;  public string country; public function __init(string city, string country) {  self.city = city;  self.country = country;  } public function value() returns string {  return self.city + \", \" + self.country;  }  } address; };public function main() {  Person john = {  name: \"John Doe\",  age: 25,  address: new (\"Colombo\", \"Sri Lanka\")  };  io:println(john.address.city);  object {  public string city;  public string country; public function __init(string city, string country) {  self.city = city;  self.country = country;  } public function value() returns string {  return self.city + \", \" + self.country;  }  } adr = new (\"London\", \"UK\"); Person jane = {name: \"Jane Doe\", age: 20, address: adr};  io:println(jane.address.country); }    Anonymous Objects  Object types can be defined in-line as well. These types do not have a type name associated with them.  Such anonymous object types can be used in instances in which there is no need to refer to the object type by its name  (e.g., objects as fields of records or objects or objects as function parameters).    import ballerina/io;    public type Person record {  string name;  int age;    object {  public string city;  public string country;    This is an anonymous object type descriptor. All the fields and  methods are made public. This is done to allow the declaration of  variables equivalent to this object type (since two public object types  are considered unequivalent if either of the objects have  any private members).   public function __init(string city, string country) {  self.city = city;  self.country = country;  }    public function value() returns string {  return self.city + \", \" + self.country;  }  } address; };    public function main() {    Person john = {  name: \"John Doe\",  age: 25,  address: new (\"Colombo\", \"Sri Lanka\")  };  io:println(john.address.city);    There is no difference in how objects of anonymous types are created.   object {  public string city;  public string country;    Since anonymous objects do not have a type name associated with them,  the object descriptor itself has to be specified when declaring  variables of an anonymous object type.   public function __init(string city, string country) {  self.city = city;  self.country = country;  }    public function value() returns string {  return self.city + \", \" + self.country;  }  } adr = new (\"London\", \"UK\");    Person jane = {name: \"Jane Doe\", age: 20, address: adr};  io:println(jane.address.country); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run anonymous_objects.bal Colombo UK"},{"page":"/learn/by-example/any-type.html","name":"Any Type","summary":"The any type can represent a variable of any type except the error type.\n When you do not have prior knowledge of the type of a variable, you can assign it to a variable of type any.\n Values of these variables can come from dynamic content such as the request ...","content":"/  /  / Any Type  import ballerina/io;type Person object {  string fname;  string lname; function __init(string fname, string lname) {  self.fname = fname;  self.lname = lname;  } function getFullName() returns string {  return self.fname + \" \" + self.lname;  } }; function getValue() returns any {  string name = \"cat\";  return name; }public function main() {  any a = new Person(\"John\", \"Doe\");  Person john = <Person>a;  io:println(\"Full name: \", john.getFullName()); if (a is Person) {  io:println(\"First name: \", john.fname);  }  int[] ia = [1, 3, 5, 6];  any ar = ia;  io:println(ar); io:println(getValue()); }    Any Type  The any type can represent a variable of any type except the error type.  When you do not have prior knowledge of the type of a variable, you can assign it to a variable of type any.  Values of these variables can come from dynamic content such as the request and response message references and  reference variable types.    import ballerina/io;    type Person object {  string fname;  string lname;    function __init(string fname, string lname) {  self.fname = fname;  self.lname = lname;  }    function getFullName() returns string {  return self.fname + \" \" + self.lname;  } };    function getValue() returns any {  string name = \"cat\";  return name; }    This function returns a value of the any type.   public function main() {    any a = new Person(\"John\", \"Doe\");    In this example, the variable named a of the any type holds  a Person object.   Person john = <Person>a;  io:println(\"Full name: \", john.getFullName());    Before anything useful can be done with a, it is required to ascertain  its type. A type cast or a type guard can be used for this.   if (a is Person) {  io:println(\"First name: \", john.fname);  }    int[] ia = [1, 3, 5, 6];  any ar = ia;  io:println(ar);    Variables of type any can hold values of any type except for error.   io:println(getValue()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run any_type.bal Full name: John Doe First name: John 1 3 5 6 cat"},{"page":"/learn/by-example/anonymous-records.html","name":"Anonymous Records","summary":"Record types can be defined in-line as well. These types do not have a type name associated with them.\n Such anonymous record types can be used in instances where there is no need to refer to the record type by its name\n (e.g., records as record or object fields, records ...","content":"/  /  / Anonymous Records  import ballerina/io;public type Person record {  string name;  int age;  record {|  string city;  string country;  |} address; };public function main() {  Person john = {  name: \"John Doe\",  age: 25,  address: {city: \"Colombo\", country: \"Sri Lanka\"}  };  io:println(john);  record {|  string city;  string country;  |} adr = {city: \"London\", country: \"UK\"}; Person jane = {name: \"Jane Doe\", age: 20, address: adr};  io:println(jane); anydata[] fields = toFieldsArray(john);  io:println(fields); } function toFieldsArray(record {} anydataRecord) returns anydata[] {  anydata[] fields = []; foreach var recField in anydataRecord {  fields.push(recField);  } return fields; }    Anonymous Records  Record types can be defined in-line as well. These types do not have a type name associated with them.  Such anonymous record types can be used in instances where there is no need to refer to the record type by its name  (e.g., records as record or object fields, records as function parameters).    import ballerina/io;    public type Person record {  string name;  int age;    record {|  string city;  string country;  |} address; };    This is an anonymous record type descriptor.   public function main() {    Person john = {  name: \"John Doe\",  age: 25,  address: {city: \"Colombo\", country: \"Sri Lanka\"}  };  io:println(john);    There is no difference in how we create normal records vs.  how we create anonymous records.   record {|  string city;  string country;  |} adr = {city: \"London\", country: \"UK\"};    Since anonymous records do not have a type name associated with them,  the record descriptor itself has to be specified when declaring  variables of an anonymous record type.   Person jane = {name: \"Jane Doe\", age: 20, address: adr};  io:println(jane);    anydata[] fields = toFieldsArray(john);  io:println(fields); }    function toFieldsArray(record {} anydataRecord) returns anydata[] {  anydata[] fields = [];    This function accepts any record with anydata-typed fields.  Anonymous record types are implicitly public.   foreach var recField in anydataRecord {  fields.push(recField);  }    return fields; }    # To run this sample, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run anonymous_records.bal name=John Doe age=25 address=city=Colombo country=Sri Lanka name=Jane Doe age=20 address=city=London country=UK John Doe 25 city=Colombo country=Sri Lanka"},{"page":"/learn/by-example/anydata-type.html","name":"Anydata Type","summary":"The anydata type consists of pure values whose basic type is not error. Thus, the anydata type is\n equivalent to ()|boolean|int|float|decimal|string|(anydata|error)[]|map<anydata|error>|xml|table.\n Although json and byte are not explicitly mentioned, they are subsets of the aforementioned union.\n The same is true for a record of which the type of each individual ...","content":"/  /  / Anydata Type  import ballerina/io; function getValue() returns anydata {  string name = \"cat\";  return name; }public function main() {  anydata a = 5;  io:println(a);  int intVal = <int>a;  io:println(intVal + 10); if (a is int) {  io:println(a + 20);  }  int[] ia = [1, 3, 5, 6];  anydata ar = ia;  io:println(ar); io:println(getValue()); }    Anydata Type  The anydata type consists of pure values whose basic type is not error. Thus, the anydata type is  equivalent to ()|boolean|int|float|decimal|string|(anydata|error)[]|map<anydata|error>|xml|table.  Although json and byte are not explicitly mentioned, they are subsets of the aforementioned union.  The same is true for a record of which the type of each individual field is a subtype of anydata(including the rest field in open records).  anydata variables can be used in places where you expect pure values (sans error).    import ballerina/io;    function getValue() returns anydata {  string name = \"cat\";  return name; }    This function returns a value of the anydata type.   public function main() {    anydata a = 5;  io:println(a);    In this example, the variable named a of the anydata type holds an int value.   int intVal = <int>a;  io:println(intVal + 10);    Before using the value of a in arithmetic operations, we need to  ascertain that it is indeed an int. A type cast or  a type guard can be used for this.   if (a is int) {  io:println(a + 20);  }    int[] ia = [1, 3, 5, 6];  anydata ar = ia;  io:println(ar);    A variable of type anydata can hold any value of an anydata compatible type.   io:println(getValue()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run anydata_type.bal 5 15 25 1 3 5 6 cat"},{"page":"/learn/by-example/async.html","name":"Async","summary":"Async functionality in Ballerina is a way to execute operations in an asynchronous manner by returning a future.\n The future can be used to extract the result of the async function call (if available), check the running status of an execution,\n or cancel the operation if needed. You can wait ...","content":"/  /  / Async  import ballerina/http; import ballerina/io; import ballerina/runtime;int count = 0;http:Client clientEndpoint = new (\"http://postman-echo.com\");public function main() {  future<int> f1 = start sum(40, 50);  int result = squarePlusCube(f1);  _ = wait f1;  io:println(\"SQ + CB = \", result);  future<()> f2 = start countInfinity();  f2.cancel();  io:println(\"Counting done in one second: \", count);  future<http:Response|error> f3 = @strand {thread:\"any\"} start clientEndpoint-> get(\"/get?test=123\");  http:Response|error response = wait f3;  if (response is http:Response) {  io:println(response.getJsonPayload());  } else {  io:println(response.detail()?.message);  }  future<int> f4 = start square(20);  future<string> f5 = start greet(\"Bert\");  int|string anyResult = wait f4|f5;  io:println(anyResult);  future<int> f6 = start sum(40, 60);  future<int> f7 = start cube(3);  future<string> f8 = start greet(\"Moose\");  runtime:sleep(2000);  map<int|string> resultMap = wait {first_field: f6, second_field: f7,  third_field: f8};  io:println(resultMap);  record {int first_field; int second_field; string third_field;} rec =  wait {first_field: f6, second_field: f7, third_field: f8};  io:println(\"first field of record --> \", rec.first_field);  io:println(\"second field of record --> \", rec.second_field);  io:println(\"third field of record --> \", rec.third_field); }function sum(int a, int b) returns int {  return a + b; }function square(int n) returns int {  return n * n; }function cube(int n) returns int {  return n * n * n; }function greet(string name) returns string {  runtime:sleep(2000);  return \"Hello \" + name + \"!!\"; }function squarePlusCube(future<int> f) returns int {  worker w1 {  int n = wait f;  int sq = square(n);  sq -> w2;  }  worker w2 returns int {  int n = wait f;  int cb = cube(n);  int sq;  sq = <- w1;  return sq + cb;  }  return wait w2; }function countInfinity() {  while (true) {  runtime:sleep(1);  count += 1;  } }    Async  Async functionality in Ballerina is a way to execute operations in an asynchronous manner by returning a future.  The future can be used to extract the result of the async function call (if available), check the running status of an execution,  or cancel the operation if needed. You can wait for a future to complete using the wait action.    import ballerina/http; import ballerina/io; import ballerina/runtime;    int count = 0;    http:Client clientEndpoint = new (\"http://postman-echo.com\");    public function main() {    future<int> f1 = start sum(40, 50);    Asynchronously calls the function named sum().   int result = squarePlusCube(f1);    You can pass the value of the future variable  and call its results later.   _ = wait f1;  io:println(\"SQ + CB = \", result);    Waits for the future f1 to finish.   future<()> f2 = start countInfinity();    Calls the countInfinity() function, which runs forever  in asynchronous mode.   f2.cancel();  io:println(\"Counting done in one second: \", count);    Cancels the asynchronous execution.   future<http:Response|error> f3 = @strand {thread:\"any\"} start clientEndpoint-> get(\"/get?test=123\");    Asynchronously invokes the action call get().  By default this async call runs on the same physical thread of the caller.  @strand annotation allows the invocation to run parallel.   http:Response|error response = wait f3;    Waits for action call f3 to finish.   if (response is http:Response) {  io:println(response.getJsonPayload());  } else {  io:println(response.detail()?.message);  }    Prints the response payload of the action call if successful or prints the  reason for the failure.   future<int> f4 = start square(20);  future<string> f5 = start greet(\"Bert\");    Asynchronously invokes the functions named square() and greet().   int|string anyResult = wait f4|f5;  io:println(anyResult);    You can wait for any one of the given futures to complete.  In this example,f4 will finish before f5 since runtime:sleep() is called  in the greet() function to delay its execution. The value returned  by the future that finishes first will be taken as the result.   future<int> f6 = start sum(40, 60);  future<int> f7 = start cube(3);  future<string> f8 = start greet(\"Moose\");    Asynchronously invokes the functions named sum(), cube(), and greet().   runtime:sleep(2000);    A runtime:sleep is added to delay the execution.   map<int|string> resultMap = wait {first_field: f6, second_field: f7,  third_field: f8};  io:println(resultMap);    You can wait for all the given futures to complete.  The result of this wait action can be assigned to a map or a record.  If the result is a map, it will contain the returned values from each  future with the key as the name of the future (if a key is not provided).   record {int first_field; int second_field; string third_field;} rec =  wait {first_field: f6, second_field: f7, third_field: f8};  io:println(\"first field of record --> \", rec.first_field);  io:println(\"second field of record --> \", rec.second_field);  io:println(\"third field of record --> \", rec.third_field); }    If the result is a record, it will contain the returned values from each  future with the field name as the name of the future (if a field name is  not provided).   function sum(int a, int b) returns int {  return a + b; }    function square(int n) returns int {  return n * n; }    function cube(int n) returns int {  return n * n * n; }    function greet(string name) returns string {    runtime:sleep(2000);  return \"Hello \" + name + \"!!\"; }    A runtime:sleep is added to delay the execution.   function squarePlusCube(future<int> f) returns int {  worker w1 {  int n = wait f;  int sq = square(n);  sq -> w2;  }  worker w2 returns int {  int n = wait f;  int cb = cube(n);  int sq;  sq = <- w1;  return sq + cb;  }    return wait w2; }    Waits for the worker W2 to complete.   function countInfinity() {  while (true) {  runtime:sleep(1);  count += 1;  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run async.bal SQ + CB = 737100 Counting done in one second: 0 args=test=123 headers=x-forwarded-proto=https host=postman-echo.com user-agent=ballerina/1.2.0 x-forwarded-port=80 url=https://postman-echo.com/get?test=123 400 first_field=100 second_field=27 third_field=Hello Moose!! first field of record --> 100 second field of record --> 27 third field of record --> Hello Moose!!"},{"page":"/learn/by-example/awslambda-deployment.html","name":"AWS Lambda Deployment","summary":"AWS Lambda is an event driven, serverless computing platform.\n Ballerina functions can be deployed in AWS Lambda by annotating a\n a Ballerina function with “@awslambda:Function”, which should have\n the function signature function (awslambda:Context, json) returns json|error.The @awslambda:Function annotation marks a function to\n generate an AWS Lambda functionThe awslambda:Context object contains ...","content":"/  /  / AWS Lambda Deployment  import ballerinax/awslambda; import ballerina/system; @awslambda:Function public function echo(awslambda:Context ctx, json input) returns json|error {  return input; }@awslambda:Function public function uuid(awslambda:Context ctx, json input) returns json|error {  return system:uuid(); }@awslambda:Function public function ctxinfo(awslambda:Context ctx, json input) returns json|error {  json result = { RequestID: ctx.getRequestId(),  DeadlineMS: ctx.getDeadlineMs(),  InvokedFunctionArn: ctx.getInvokedFunctionArn(),  TraceID: ctx.getTraceId(),  RemainingExecTime: ctx.getRemainingExecutionTime() };  return result; }# Prerequisites: AWS CLI tools installation and configuration    AWS Lambda Deployment  AWS Lambda is an event driven, serverless computing platform.  Ballerina functions can be deployed in AWS Lambda by annotating a  a Ballerina function with “@awslambda:Function”, which should have  the function signature function (awslambda:Context, json) returns json|error.    import ballerinax/awslambda; import ballerina/system;    @awslambda:Function public function echo(awslambda:Context ctx, json input) returns json|error {  return input; }    The @awslambda:Function annotation marks a function to  generate an AWS Lambda function   @awslambda:Function public function uuid(awslambda:Context ctx, json input) returns json|error {  return system:uuid(); }    @awslambda:Function    public function ctxinfo(awslambda:Context ctx, json input) returns json|error {  json result = { RequestID: ctx.getRequestId(),  DeadlineMS: ctx.getDeadlineMs(),  InvokedFunctionArn: ctx.getInvokedFunctionArn(),  TraceID: ctx.getTraceId(),  RemainingExecTime: ctx.getRemainingExecutionTime() };  return result; }    The awslambda:Context object contains request execution  context information   # Prerequisites: AWS CLI tools installation and configuration    # Build the Ballerina program to generate the AWS Lambda functions $ ballerina build aws_lambda_deployment.bal Compiling source \taws_lambda_deployment.bal Generating executables \taws_lambda_deployment-executable.jar \t@awslambda:Function: echo, uuid, ctxinfo    The Ballerina AWS Lambda layer information can be found at https://ballerina.io/deployment/aws-lambda.    Run the following commands to deploy each Ballerina AWS Lambda function: \taws lambda create-function --function-name <FUNCTION_NAME> --zip-file fileb://aws-ballerina-lambda-functions.zip --handler aws_lambda_deployment-executable.<FUNCTION_NAME> --runtime provided --role <LAMBDA_ROLE_ARN> --timeout 10 --memory-size 1024 \taws lambda update-function-configuration --function-name <FUNCTION_NAME> --layers <BALLERINA_LAYER_ARN>    Run the following command to re-deploy an updated Ballerina AWS Lambda function: \taws lambda update-function-code --function-name <FUNCTION_NAME> --zip-file fileb://aws-ballerina-lambda-functions.zip    # Execute the AWS CLI commands to create and publish the functions, and your AWS <LAMBDA_ROLE_ARN> and the <BALLERINA_LAYER_ARN> for a specific Ballerina release should be used, following values are just examples $ aws lambda create-function --function-name echo --zip-file fileb://aws-ballerina-lambda-functions.zip --handler aws_lambda_deployment.echo --runtime provided --role arn:aws:iam::908363916111:role/lambda-role  --timeout 10 --memory-size 1024 $ aws lambda create-function --function-name uuid --zip-file fileb://aws-ballerina-lambda-functions.zip --handler aws_lambda_deployment.uuid --runtime provided --role arn:aws:iam::908363916111:role/lambda-role  --timeout 10 --memory-size 1024 $ aws lambda create-function --function-name ctxinfo --zip-file fileb://aws-ballerina-lambda-functions.zip --handler aws_lambda_deployment.ctxinfo --runtime provided --role arn:aws:iam::908363916111:role/lambda-role  --timeout 10 --memory-size 1024 $ aws lambda update-function-configuration --function-name echo --layers arn:aws:lambda:us-west-2:908363916138:layer:ballerina-x_xxx_x-runtime:1 $ aws lambda update-function-configuration --function-name uuid --layers arn:aws:lambda:us-west-2:908363916138:layer:ballerina-x_xxx_x-runtime:1 $ aws lambda update-function-configuration --function-name ctxinfo --layers arn:aws:lambda:us-west-2:908363916138:layer:ballerina-x_xxx_x-runtime:1    # Invoke the functions $ aws lambda invoke --function-name echo --payload '{\"MESSAGE\":\"HELLO\"}' echo-response.txt {  \"ExecutedVersion\": \"$LATEST\", \"StatusCode\": 200 } $ cat echo-response.txt {\"MESSAGE\":\"HELLO\"}    $ aws lambda invoke --function-name uuid uuid-response.txt {  \"ExecutedVersion\": \"$LATEST\", \"StatusCode\": 200 } $ cat uuid-response.txt \"711cd328-1937-40cc-9078-c3628c6edb02\"    $ aws lambda invoke --function-name ctxinfo ctxinfo-response.txt {  \"ExecutedVersion\": \"$LATEST\", \"StatusCode\": 200 } $ cat ctxinfo-response.txt {\"RequestID\":\"d55f7d06-f2ab-4b6e-8606-482607785a91\", \"DeadlineMS\":1548069389978, \"InvokedFunctionArn\":\"arn:aws:lambda:us-west-2:908363916138:function:ctxinfo\", \"TraceID\":\"Root=1-5c45aa03-f8aff4c9e24dc4fbf48f2990;Parent=17ad3b290def98fd;Sampled=0\", \"RemainingExecTime\":9946}"},{"page":"/learn/by-example/arrays.html","name":"Arrays","summary":"Arrays are mutable lists of values of dynamic length in which each member in the list is\n of the same type.\n A fixed length array can be created by specifying the length of the array at the time of declaration.Creates an int array of length 0.Creates an array specifying an ...","content":"/  /  / Arrays  import ballerina/io;public function main() {  int[] a = [];  io:println(a.length());  int[] b = [1, 2, 3, 4, 5, 6, 7, 8];  io:println(b[0]);  io:println(b.length());  int[] bReveresed = b.reverse();  io:println(\"Reversed: \", bReveresed); io:println(\"Before pop: \", b);  int poppedValue = b.pop();  io:println(\"Popped value: \", poppedValue);  io:println(\"After pop: \", b);  int[] doubled = b.map(function (int value) returns int {  return value * 2;  });  io:println(\"Doubled: \", doubled);  b[999] = 23;  io:println(b[999]);  io:println(b.length());  int[][] iarray = [[1, 2, 3], [10, 20, 30], [5, 6, 7]];  io:println(iarray.length());  io:println(iarray[0].length());  iarray = [];  int[] d = [9];  iarray[0] = d;  io:println(iarray[0][0]);  int[5] e = [1, 2, 3, 4, 5];  io:println(e.length());  int[*] g = [1, 2, 3, 4];  io:println(g.length()); }    Arrays  Arrays are mutable lists of values of dynamic length in which each member in the list is  of the same type.  A fixed length array can be created by specifying the length of the array at the time of declaration.    import ballerina/io;    public function main() {    int[] a = [];  io:println(a.length());    Creates an int array of length 0.   int[] b = [1, 2, 3, 4, 5, 6, 7, 8];  io:println(b[0]);  io:println(b.length());    Creates an array specifying an array literal.   int[] bReveresed = b.reverse();  io:println(\"Reversed: \", bReveresed);    Arrays support several inbuilt functions such as .reverse(), .pop(), .push(), and .removeAll().   io:println(\"Before pop: \", b);  int poppedValue = b.pop();  io:println(\"Popped value: \", poppedValue);  io:println(\"After pop: \", b);    int[] doubled = b.map(function (int value) returns int {  return value * 2;  });  io:println(\"Doubled: \", doubled);    Arrays are an iterable type and arrays support functional iteration operations such as .map(), .filter(), and  .reduce().   b[999] = 23;  io:println(b[999]);  io:println(b.length());    Unless the length is explicitly specified or is expected to be inferred, arrays are unbounded in length.  They can grow up to any length based on the given index.  In this example, the length of the array is 1000.   int[][] iarray = [[1, 2, 3], [10, 20, 30], [5, 6, 7]];  io:println(iarray.length());  io:println(iarray[0].length());    Initializes a two dimensional int array.   iarray = [];    Initializes the outermost array to an empty array.   int[] d = [9];  iarray[0] = d;    Adds a new array as the first element.   io:println(iarray[0][0]);    Prints the first value of the two-dimensional array.   int[5] e = [1, 2, 3, 4, 5];  io:println(e.length());    Creates an int array with the fixed length of five.   int[*] g = [1, 2, 3, 4];  io:println(g.length()); }    To infer the size of the array from the array literal, use the following syntax.  The length of the array is set to four here.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run arrays.bal 0 1 8 Reversed: 8 7 6 5 4 3 2 1 Before pop: 1 2 3 4 5 6 7 8 Popped value: 8 After pop: 1 2 3 4 5 6 7 Doubled: 2 4 6 8 10 12 14 23 1000 3 3 9 5 4"},{"page":"/learn/by-example/ballerina-to-openapi.html","name":"Ballerina To OpenAPI","summary":"The Ballerina to OpenApi tool is used to generate an OpenAPI Specification(OAS) v3 definition of a Ballerina service.\n This tool’s command structure is as below.\n ballerina openapi gen-contract [<module>:]<service-name> [-i <ballerina-file>] [-o <contract-file>] [-s|--skip-bind] [-h|--help] ...","content":"/  /  / Ballerina To OpenAPI  import ballerina/http; import ballerina/log;listener http:Listener helloEp = new (9090);service hello on helloEp {  resource function hi(http:Caller caller, http:Request request) {  http:Response res = new;  res.setPayload(\"Hello World!\"); var result = caller->respond(res);  if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    Ballerina To OpenAPI  The Ballerina to OpenApi tool is used to generate an OpenAPI Specification(OAS) v3 definition of a Ballerina service.  This tool’s command structure is as below.  ballerina openapi gen-contract [<module>:]<service-name> [-i <ballerina-file>] [-o <contract-file>] [-s|--skip-bind] [-h|--help]    import ballerina/http; import ballerina/log;    listener http:Listener helloEp = new (9090);    service hello on helloEp {  resource function hi(http:Caller caller, http:Request request) {  http:Response res = new;  res.setPayload(\"Hello World!\");    var result = caller->respond(res);  if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    # To export the OpenAPI definition of ballerina service `hello`, navigate to the directory that contains the # `ballerina_to_openapi.bal` file, and execute `ballerina openapi gen-contract` command. $ ballerina openapi gen-contract hello -i ballerina_to_openapi.bal Note: This is an Experimental tool ship under ballerina hence this will only support limited set of functionality. Successfully generated the ballerina contract at location /examples/ballerina-to-openapi/hello.openapi.yaml"},{"page":"/learn/by-example/basic-documentation.html","name":"Basic documentation","summary":"Documentation attachments allow you to document different Ballerina constructs such as functions, records, objects, and listeners that are defined in modules.\n These attachments are used by Docerina (i.e., the Ballerina documentation generation tool) to generate API documentation for the modules.This is the documentation attachment of the DummyObject object.This is the ...","content":"/  /  / Basic documentation  import ballerina/io;public function main() {  io:println(\"Documentation attachments are non executable constructs.\"); } # The `DummyObject` is a user-defined object. # This `DummyObject` has two `string` data fields and a # function definition (i.e., `doThatOnObject`), which performs a certain # functionality on the associated `DummyObject` instance. # # + fieldOne - This is the description of the `DummyObject`'s `fieldOne` field. # + fieldTwo - This is the description of the `DummyObject`'s `fieldTwo` field. public type DummyObject abstract object { public string fieldOne;  public string fieldTwo;  # The `doThatOnObject` function is attached to the `DummyObject` object.  #  # + paramOne - This is the description of the parameter of  # the `doThatOnObject` function.  # + return - This is the description of the return value of  # the `doThatOnObject` function.  public function doThatOnObject(string paramOne) returns boolean; }; # `DummyRecord` is a user-defined record. # This `DummyRecord` has a `string` data field and an `int` data field. # # + fieldOne - This is the description of the `DummyRecord`'s `fieldOne` field. # + fieldTwo - This is the description of the `DummyRecord`'s `fieldTwo` field. public type DummyRecord record {  string fieldOne;  int fieldTwo; }; # This function returns the `fieldTwo` field of the `DummyRecord`-typed # record value passed as an argument. # # + recordValue - Parameter of type `DummyRecord`. # + return - The `fieldTwo` field of the record value passed as an argument. public function dummyFunction(DummyRecord recordValue) returns int {  return recordValue.fieldTwo; }    Basic documentation  Documentation attachments allow you to document different Ballerina constructs such as functions, records, objects, and listeners that are defined in modules.  These attachments are used by Docerina (i.e., the Ballerina documentation generation tool) to generate API documentation for the modules.    import ballerina/io;    public function main() {  io:println(\"Documentation attachments are non executable constructs.\"); }    # The `DummyObject` is a user-defined object. # This `DummyObject` has two `string` data fields and a # function definition (i.e., `doThatOnObject`), which performs a certain # functionality on the associated `DummyObject` instance. # # + fieldOne - This is the description of the `DummyObject`'s `fieldOne` field. # + fieldTwo - This is the description of the `DummyObject`'s `fieldTwo` field. public type DummyObject abstract object {    This is the documentation attachment of the DummyObject object.   public string fieldOne;  public string fieldTwo;    # The `doThatOnObject` function is attached to the `DummyObject` object.  #  # + paramOne - This is the description of the parameter of  # the `doThatOnObject` function.  # + return - This is the description of the return value of  # the `doThatOnObject` function.  public function doThatOnObject(string paramOne) returns boolean; };    This is the documentation attachment of the doThatOnObject function.   # `DummyRecord` is a user-defined record. # This `DummyRecord` has a `string` data field and an `int` data field. # # + fieldOne - This is the description of the `DummyRecord`'s `fieldOne` field. # + fieldTwo - This is the description of the `DummyRecord`'s `fieldTwo` field. public type DummyRecord record {  string fieldOne;  int fieldTwo; };    This is the documentation attachment of the DummyRecord record.   # This function returns the `fieldTwo` field of the `DummyRecord`-typed # record value passed as an argument. # # + recordValue - Parameter of type `DummyRecord`. # + return - The `fieldTwo` field of the record value passed as an argument. public function dummyFunction(DummyRecord recordValue) returns int {  return recordValue.fieldTwo; }    This is the documentation attachment of the dummyFunction function.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run basic_documentation.bal Documentation attachments are non executable constructs."},{"page":"/learn/by-example/base-path-and-path.html","name":"Base Path and Path","summary":"Ballerina supports writing RESTful services according to the JAX-RS specification.\n You can use BasePath, Path, and HTTP verb annotations such as POST and GET to\n constrain your service in a RESTful manner.The basePath attribute associates a path to the service.\n When bound to a listener endpoint, the service will be ...","content":"/  /  / Base Path and Path  import ballerina/http; import ballerina/log; @http:ServiceConfig {  basePath: \"/foo\" } service echo on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/bar\"  }  resource function echo(http:Caller caller, http:Request req) {  var payload = req.getJsonPayload();  http:Response res = new;  if (payload is json) {  res.setJsonPayload(<@untainted>payload);  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>payload.detail()?.message);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Base Path and Path  Ballerina supports writing RESTful services according to the JAX-RS specification.  You can use BasePath, Path, and HTTP verb annotations such as POST and GET to  constrain your service in a RESTful manner.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/foo\" } service echo on new http:Listener(9090) {    The basePath attribute associates a path to the service.  When bound to a listener endpoint, the service will be accessible at the specified path.   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/bar\"  }  resource function echo(http:Caller caller, http:Request req) {    When the methods attribute is used, it confines the resource to the HTTP methods specified.  In this instance, only POST requests are allowed.  The path attribute associates a subpath to the resource (i.e., relative to the basePath given in the ServiceConfig annotation).   var payload = req.getJsonPayload();  http:Response res = new;  if (payload is json) {    This method retrieves the request payload as a JSON.   res.setJsonPayload(<@untainted>payload);  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>payload.detail()?.message);  }    Since the JSON is known to be valid, untaint the data denoting that the data is trusted and set the JSON to the response.   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Reply to the client with the response.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run base_path_and_path.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    Run this curl command to use the client. $ curl http://localhost:9090/foo/bar -d \"{\\\"hello\\\": \\\"world\\\"}\" -H \"Content-Type: application/json\" {\"hello\": \"world\"}"},{"page":"/learn/by-example/basic-https-listener-client.html","name":"Basic HTTPS Listener Client","summary":"This example demonstrates how the Ballerina https client can be configured to connect to an https listener through 1-way SSL connection (i.e., the server is verified by the client). This example uses the Ballerina https listener to host a service and the https client sends requests for that listener.helloWorldEP listener ...","content":"/  /  / Basic HTTPS Listener Client  import ballerina/config; import ballerina/http; import ballerina/log; http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };listener http:Listener helloWorldEP = new (9095, config = helloWorldEPConfig);@http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Failed to respond\", result);  }  } }import ballerina/config; import ballerina/http; import ballerina/log; http:ClientConfiguration clientEPConfig = {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };public function main() {  http:Client clientEP = new(\"https://localhost:9095\", clientEPConfig);  var resp = clientEP->get(\"/hello/\");  if (resp is http:Response) {  var payload = resp.getTextPayload();  if (payload is string) {  log:printInfo(payload);  } else {  log:printError(<string>payload.detail()[\"message\"]);  }  } else {  log:printError(<string>resp.detail()[\"message\"]);  } }    Basic HTTPS Listener Client  This example demonstrates how the Ballerina https client can be configured to connect to an https listener through 1-way SSL connection (i.e., the server is verified by the client). This example uses the Ballerina https listener to host a service and the https client sends requests for that listener.    import ballerina/config; import ballerina/http; import ballerina/log;    http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };    helloWorldEP listener endpoint is configured to communicate through HTTPS.  It is configured to listen on port 9095. As this is an HTTPS Listener,  it is required to give the PKCS12 keystore file location and its password.   listener http:Listener helloWorldEP = new (9095, config = helloWorldEPConfig);    @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Failed to respond\", result);  }  } }    Send the response back to the caller.   # To start the service and run the main function, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command along with the Ballerina home path as a config. $ ballerina run basic_https_listener.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9095    import ballerina/config; import ballerina/http; import ballerina/log;    http:ClientConfiguration clientEPConfig = {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };    This is a client endpoint configured to connect to the HTTPS service.  As this is a 1-way SSL connection, the client needs to provide  trust store file path and its password.   public function main() {    http:Client clientEP = new(\"https://localhost:9095\", clientEPConfig);    Create an HTTP client to interact with the created listener endpoint.   var resp = clientEP->get(\"/hello/\");  if (resp is http:Response) {    Sends an outbound request.   var payload = resp.getTextPayload();  if (payload is string) {    If the request is successful, retrieve the text payload from the  response.   log:printInfo(payload);  } else {    Log the retrieved text paylod.   log:printError(<string>payload.detail()[\"message\"]);  }  } else {    If an error occurs when retrieving the text payload, log the error.   log:printError(<string>resp.detail()[\"message\"]);  } }    If an error occurs when getting the response, log the error.   # To start the service and run the main function, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command along with the Ballerina home path as a config. $ ballerina run https_client.bal --b7a.home=<ballerina_home_path> INFO [] - Hello World!"},{"page":"/learn/by-example/byte-io.html","name":"Byte I/O","summary":"This example demonstrates how bytes can be read and written through the I/O API.Copies the content from the source channel to a destination channel.The below example shows how to read all the content from\n the source and copy it to the destination.The operation attempts to read a maximum of 1000 ...","content":"/  /  / Byte I/O  import ballerina/io; import ballerina/log; function copy(io:ReadableByteChannel src,  io:WritableByteChannel dst) returns error? {  while (true) {  byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {  int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; } function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }public function main() returns @tainted error? {  string srcPath = \"./files/ballerina.jpg\";  string dstPath = \"./files/ballerinaCopy.jpg\";  io:ReadableByteChannel srcCh = check io:openReadableFile(srcPath);  io:WritableByteChannel dstCh = check io:openWritableFile(dstPath);  io:println(\"Start to copy files from \" + srcPath + \" to \" + dstPath);  var result = copy(srcCh, dstCh);  if (result is error) {  log:printError(\"error occurred while performing copy \", result);  } else {  io:println(\"File copy completed. The copied file is located at \" +  dstPath);  }  close(srcCh);  close(dstCh); }    Byte I/O  This example demonstrates how bytes can be read and written through the I/O API.    import ballerina/io; import ballerina/log;    function copy(io:ReadableByteChannel src,  io:WritableByteChannel dst) returns error? {    Copies the content from the source channel to a destination channel.   while (true) {    The below example shows how to read all the content from  the source and copy it to the destination.   byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {    The operation attempts to read a maximum of 1000 bytes and returns  with the available content, which could be < 1000.   int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }    The operation writes the given content into the channel.   function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes a given readable or writable byte channel.   public function main() returns @tainted error? {  string srcPath = \"./files/ballerina.jpg\";  string dstPath = \"./files/ballerinaCopy.jpg\";    io:ReadableByteChannel srcCh = check io:openReadableFile(srcPath);    Initializes the readable byte channel.   io:WritableByteChannel dstCh = check io:openWritableFile(dstPath);  io:println(\"Start to copy files from \" + srcPath + \" to \" + dstPath);    Initializes the writable byte channel.   var result = copy(srcCh, dstCh);  if (result is error) {  log:printError(\"error occurred while performing copy \", result);  } else {  io:println(\"File copy completed. The copied file is located at \" +  dstPath);  }    Copies the source byte channel to the target byte channel.   close(srcCh);  close(dstCh); }    Closes the connections.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run byte_io.bal Start to copy files from ./files/ballerina.jpg to ./files/ballerinaCopy.jpg File copy completed. The copied file could be located in ./files/ballerinaCopy.jpg"},{"page":"/learn/by-example/binary-bitwise-expressions.html","name":"Binary Bitwise Expressions","summary":"Ballerina supports three bitwise binary expressions; AND, OR, and XOR.\n Both operands should have static types that are subtypes of the int type.\n All bitwise binary operations are based on the 64-bit representations of the values.For a bitwise “AND” (&) expression, if the type of either operand is a subtype ...","content":"/  /  / Binary Bitwise Expressions  import ballerina/io; import ballerina/lang.'int;public function main() {  int a = 385;  'int:Unsigned8 b = 128;  'int:Unsigned8 res1 = a & b;  io:println(\"`int` 385 & `int:Unsigned8` 128: \", res1); 'int:Signed16 c = -32700;  int d = 249;  int res2 = c & d;  io:println(\"`int:Signed16` -32700 & `int` 249: \", res2); 'int:Unsigned8 e = 254;  'int:Unsigned16 f = 511;  'int:Unsigned8 res3 = e | f;  io:println(\"`int:Unsigned8` 254 | `int:Unsigned16` 511: \", res3);  'int:Unsigned8 res4 = e ^ f;  io:println(\"`int:Unsigned8` 254 ^ `int:Unsigned16` 511: \", res4); int g = 12345678;  'int:Signed8 h = -127;  int res5 = g | h;  io:println(\"`int` 12345678 | `int:Signed8` -127: \", res5);  int res6 = g ^ h;  io:println(\"`int` 12345678 ^ `int:Signed8` -127: \", res6); }    Binary Bitwise Expressions  Ballerina supports three bitwise binary expressions; AND, OR, and XOR.  Both operands should have static types that are subtypes of the int type.  All bitwise binary operations are based on the 64-bit representations of the values.    import ballerina/io; import ballerina/lang.'int;    public function main() {  int a = 385;  'int:Unsigned8 b = 128;    'int:Unsigned8 res1 = a & b;  io:println(\"`int` 385 & `int:Unsigned8` 128: \", res1);    For a bitwise “AND” (&) expression, if the type of either operand is a subtype of  int:UnsignedK when K is 8, 16 or 32, then the type of the result is int:UnsignedN  where N is the smallest such K.   'int:Signed16 c = -32700;  int d = 249;    int res2 = c & d;  io:println(\"`int:Signed16` -32700 & `int` 249: \", res2);    Else, if neither operand is of a type that is a subtype of an unsigned int type,  the type of the result for a bitwise “AND” expression is int.   'int:Unsigned8 e = 254;  'int:Unsigned16 f = 511;    'int:Unsigned8 res3 = e | f;  io:println(\"`int:Unsigned8` 254 | `int:Unsigned16` 511: \", res3);  'int:Unsigned8 res4 = e ^ f;  io:println(\"`int:Unsigned8` 254 ^ `int:Unsigned16` 511: \", res4);    For bitwise “OR” (|) and “XOR” (^) expressions, if the types of both operands are  subtypes of int:UnsignedK when K is 8, 16 or 32, then the type of the result is  int:UnsignedN where N is the smallest such K.   int g = 12345678;  'int:Signed8 h = -127;    int res5 = g | h;  io:println(\"`int` 12345678 | `int:Signed8` -127: \", res5);  int res6 = g ^ h;  io:println(\"`int` 12345678 ^ `int:Signed8` -127: \", res6); }    Else, if at least one operand’s type is not a subtype of an unsigned int type,  the type of the result for a bitwise “OR” or “XOR” expression is int.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run binary_bitwise_expressions.bal `int` 385 & `int:Unsigned8` 128: 128 `int:Signed16` -32700 & `int` 249: 64 `int:Unsigned8` 254 | `int:Unsigned16` 511: 255 `int:Unsigned8` 254 ^ `int:Unsigned16` 511: 1 `int` 12345678 | `int:Signed8` -127: -49 `int` 12345678 ^ `int:Signed8` -127: -12345649"},{"page":"/learn/by-example/byte-type.html","name":"Byte Type","summary":"The byte type is just shorthand for 0|1|2|…|255.\n Along with the general byte array there is also a special syntax to define base16 and base64 based arrays of\n bytes. This example demonstrates how byte and byte array can be used in Ballerina programs.Define a byte variable.Create a byte array using ...","content":"/  /  / Byte Type  import ballerina/io;public function main() {  byte a = 12;  io:println(a);  byte[] arr1 = [5, 24, 56, 243];  byte[] arr2 = base16 `aeeecdefabcd12345567888822`;  byte[] arr3 = base64 `aGVsbG8gYmFsbGVyaW5hICEhIQ==`; io:println(arr1.length());  io:println(arr1[1]); io:println(arr2.length());  io:println(arr2[2]); io:println(arr3.length());  io:println(arr3[3]); byte[][] arr4 = [[1, 2, 3], [23, 45, 117, 213], [45, 3, 254, 65, 78, 99]];  io:println(arr4.length());  io:println(arr4[2].length()); }    Byte Type  The byte type is just shorthand for 0|1|2|…|255.  Along with the general byte array there is also a special syntax to define base16 and base64 based arrays of  bytes. This example demonstrates how byte and byte array can be used in Ballerina programs.    import ballerina/io;    public function main() {    byte a = 12;  io:println(a);    Define a byte variable.   byte[] arr1 = [5, 24, 56, 243];    Create a byte array using the list constructor.   byte[] arr2 = base16 `aeeecdefabcd12345567888822`;    Create a byte array using the base16 byte array literal.   byte[] arr3 = base64 `aGVsbG8gYmFsbGVyaW5hICEhIQ==`;    Create a byte array using the base64 byte array literal.   io:println(arr1.length());  io:println(arr1[1]);    io:println(arr2.length());  io:println(arr2[2]);    io:println(arr3.length());  io:println(arr3[3]);    byte[][] arr4 = [[1, 2, 3], [23, 45, 117, 213], [45, 3, 254, 65, 78, 99]];  io:println(arr4.length());  io:println(arr4[2].length()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run byte_type.bal 12 4 24 13 205 19 108 3 6"},{"page":"/learn/by-example/cache.html","name":"Cache","summary":"The ballerina/cache module is provides capability to extend custom cache\n storage and eviction policies while providing a in-memory storage and LRU\n eviction policy by default.This creates a new cache of size 10. The eviction factor is set to 0.2,\n which means at the time of eviction 10*0.2=2 entries get removed ...","content":"/  /  / Cache  import ballerina/cache; import ballerina/io; import ballerina/runtime;public function main() returns error? {  cache:Cache cache = new({  capacity: 10,  evictionFactor: 0.2,  defaultMaxAgeInSeconds: 2,  cleanupIntervalInSeconds: 3  });  _ = check cache.put(\"key1\", \"value1\");  _ = check cache.put(\"key2\", \"value2\", 3600);  if (cache.hasKey(\"key1\")) {  string value = <string> check cache.get(\"key1\");  io:println(\"key1: \" + value);  }  runtime:sleep(4000);  string[] keys = cache.keys();  io:println(\"keys: [\" + keys.toString() + \"]\");  int size = cache.size();  int capacity = cache.capacity();  _ = check cache.invalidate(\"key2\");  _ = check cache.invalidateAll(); }    Cache  The ballerina/cache module is provides capability to extend custom cache  storage and eviction policies while providing a in-memory storage and LRU  eviction policy by default.    import ballerina/cache; import ballerina/io; import ballerina/runtime;    public function main() returns error? {    cache:Cache cache = new({  capacity: 10,  evictionFactor: 0.2,  defaultMaxAgeInSeconds: 2,  cleanupIntervalInSeconds: 3  });    This creates a new cache of size 10. The eviction factor is set to 0.2,  which means at the time of eviction 10*0.2=2 entries get removed from  the cache.  The default max age of the cache entry is set to 2 seconds. The cache  cleanup task runs every 3 seconds and clears all the expired entries.   _ = check cache.put(\"key1\", \"value1\");    Adds a new entry to the cache.   _ = check cache.put(\"key2\", \"value2\", 3600);    Adds a new entry to the cache by overriding the default max age.   if (cache.hasKey(\"key1\")) {    Checks for the cached key availability.   string value = <string> check cache.get(\"key1\");  io:println(\"key1: \" + value);  }    Fetches the cached value.   runtime:sleep(4000);    This sends the current worker to the sleep mode for 4 seconds.  No execution takes place during this period.   During this period, the cache entry with the key ‘key1’ should be removed  since the max of it is set to 2 seconds by default. However, the cache  entry with the key ‘key2’ should exist in the cache.   string[] keys = cache.keys();  io:println(\"keys: [\" + keys.toString() + \"]\");    Get the keys of the cache entries.   int size = cache.size();    Get the size of the cache.   int capacity = cache.capacity();    Get the capacity of the cache.   _ = check cache.invalidate(\"key2\");    Discard the given cache entry.   _ = check cache.invalidateAll(); }    Discard all the cache entries of the cache.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run cache.bal key1: value1 keys: [key2]"},{"page":"/learn/by-example/character-io.html","name":"Read/Write Files","summary":"This demonstrates how characters could be read and written through I/O APIs.This function reads content from a file,\n appends the additional string, and writes the content.Reads the characters from the source channel.Writes the characters to the destination channel.Closes the readable character channel.Closes the writable character channel.This example uses the /examples/character-io/files/sample.txt ...","content":"/  /  / Read/Write Files  import ballerina/io; import ballerina/log; function process(io:ReadableCharacterChannel sc,  io:WritableCharacterChannel dc) returns @tainted error? {  string intermediateCharacterString = \" my name is \";  string greetingText = check sc.read(5);  string name = check sc.read(15);  var writeCharResult = check dc.write(greetingText, 0);  var writeCharResult1 = check dc.write(intermediateCharacterString, 0);  var writeCharResult2 = check dc.write(name, 1);  return; } function closeRc(io:ReadableCharacterChannel ch) {  var cr = ch.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } } function closeWc(io:WritableCharacterChannel ch) {  var cr = ch.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }public function main() returns @tainted error? {  io:ReadableByteChannel readableFieldResult =  check io:openReadableFile(\"./files/sample.txt\");  io:ReadableCharacterChannel sourceChannel =  new (readableFieldResult, \"UTF-8\");  io:WritableByteChannel writableFileResult =  check io:openWritableFile(\"./files/sampleResponse.txt\");  io:WritableCharacterChannel destinationChannel =  new (writableFileResult, \"UTF-8\");  io:println(\"Started to process the file.\");  var result = process(sourceChannel, destinationChannel);  if (result is error) {  log:printError(\"error occurred while processing chars \", result);  } else {  io:println(\"File processing complete.\");  }  closeRc(sourceChannel);  closeWc(destinationChannel); }    Read/Write Files  This demonstrates how characters could be read and written through I/O APIs.    import ballerina/io; import ballerina/log;    function process(io:ReadableCharacterChannel sc,  io:WritableCharacterChannel dc) returns @tainted error? {  string intermediateCharacterString = \" my name is \";    This function reads content from a file,  appends the additional string, and writes the content.   string greetingText = check sc.read(5);  string name = check sc.read(15);    Reads the characters from the source channel.   var writeCharResult = check dc.write(greetingText, 0);  var writeCharResult1 = check dc.write(intermediateCharacterString, 0);  var writeCharResult2 = check dc.write(name, 1);  return; }    Writes the characters to the destination channel.   function closeRc(io:ReadableCharacterChannel ch) {  var cr = ch.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes the readable character channel.   function closeWc(io:WritableCharacterChannel ch) {  var cr = ch.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes the writable character channel.   public function main() returns @tainted error? {    io:ReadableByteChannel readableFieldResult =  check io:openReadableFile(\"./files/sample.txt\");  io:ReadableCharacterChannel sourceChannel =  new (readableFieldResult, \"UTF-8\");    This example uses the /examples/character-io/files/sample.txt file as the  source file, which includes the text “Hello Ballerina!!”.  You can replace this with the file path of a preferred text file.   io:WritableByteChannel writableFileResult =  check io:openWritableFile(\"./files/sampleResponse.txt\");  io:WritableCharacterChannel destinationChannel =  new (writableFileResult, \"UTF-8\");  io:println(\"Started to process the file.\");    This example creates the /examples/character-io/files/sampleResponse.txt  destination file and writes the text “Hello my name is Ballerina!!”“.  You can replace this with the file path of a preferred text file.   var result = process(sourceChannel, destinationChannel);  if (result is error) {  log:printError(\"error occurred while processing chars \", result);  } else {  io:println(\"File processing complete.\");  }    Processes the given string.   closeRc(sourceChannel);    Closes the readable channel.   closeWc(destinationChannel); }    Closes the writable channel.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run character_io.bal Started to process the file. File processing complete."},{"page":"/learn/by-example/check.html","name":"Check","summary":"The check expression is a unary expression that is used to handle errors.\n The check expression checks the result of the sub expression and returns if the result is of type error.\n Hence, check can only be used in a function which has error in its return type.The parse() function ...","content":"/  /  / Check  import ballerina/io; import ballerina/lang.'int; function parse(string num) returns int|error {  return 'int:fromString(num); }function scale(string num) returns int|error {  int x = check parse(num);  return x * 10; }public function main() {  int|error w = parse(\"12\");  io:println(w);  int|error x = parse(\"invalid\");  io:println(x); int|error y = scale(\"12\");  io:println(y); int|error z = scale(\"Invalid\");  io:println(z); }    Check  The check expression is a unary expression that is used to handle errors.  The check expression checks the result of the sub expression and returns if the result is of type error.  Hence, check can only be used in a function which has error in its return type.    import ballerina/io; import ballerina/lang.'int;    function parse(string num) returns int|error {  return 'int:fromString(num); }    The parse() function takes a string argument and attempts to convert it to an int.   function scale(string num) returns int|error {    int x = check parse(num);  return x * 10; }    The check unary operator can be used to return early on error.  Here, check is used to return the error if the parse()  function evaluates to error. If the actual value returned  by the parse() function is an error, this function immediately returns  the error, else the int value returned by parse() is set to x and  execution continues. If check is used within a function, the return type  of the function must include error in its return signature.   public function main() {    int|error w = parse(\"12\");  io:println(w);    Passing a valid integer as a string will return an int.   int|error x = parse(\"invalid\");  io:println(x);    Passing a random string will return an error.   int|error y = scale(\"12\");  io:println(y);    int|error z = scale(\"Invalid\");  io:println(z); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run check.bal 12 error {ballerina/lang.int}NumberParsingError message='string' value 'invalid' cannot be converted to 'int' 120 error {ballerina/lang.int}NumberParsingError message='string' value 'Invalid' cannot be converted to 'int'"},{"page":"/learn/by-example/client-generation.html","name":"Client Generation","summary":"This example generates a client for a Ballerina service.\n Add the @openapi:ClientEndpoint annotation to mark the listener(s) that are used for client generation.\n Add the @openapi:ClientConfig {generate: true} annotation to the service to enable client generation.\n The generated client can be found in the <project.home>/target/bin/client/ or <program.dir>/client/ directory.Add the @openapi:ClientEndpoint ...","content":"/  /  / Client Generation  import ballerina/http; import ballerina/log; import ballerina/openapi; @openapi:ClientEndpoint listener http:Listener helloEp = new (9090); @openapi:ClientConfig {  generate: true } @http:ServiceConfig {  basePath: \"/sample\" } service Hello on helloEp { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/hello\"  }  resource function hello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello\");  if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    Client Generation  This example generates a client for a Ballerina service.  Add the @openapi:ClientEndpoint annotation to mark the listener(s) that are used for client generation.  Add the @openapi:ClientConfig {generate: true} annotation to the service to enable client generation.  The generated client can be found in the <project.home>/target/bin/client/ or <program.dir>/client/ directory.    import ballerina/http; import ballerina/log; import ballerina/openapi;    @openapi:ClientEndpoint listener http:Listener helloEp = new (9090);    Add the @openapi:ClientEndpoint annotation to the listener that is to be used for client generation.   @openapi:ClientConfig {  generate: true } @http:ServiceConfig {  basePath: \"/sample\" } service Hello on helloEp {    Add the @openapi:ClientConfig {generate: true} annotation to the service to enable client generation for it.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/hello\"  }  resource function hello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello\");  if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina build` command. $ ballerina build client_generation.bal Compiling source  client_generation.bal Generating executables  client_generation.jar"},{"page":"/learn/by-example/clone.html","name":"Cloning Values","summary":"The .clone() method can be used to make a copy of an anydata value.\n anydata is equivalent to ()|boolean|int|float|decimal|string|(anydata|error)[]|map<anydata|error>|xml|table.\n Clone is defined for all structured types that belong to anydata.\n The resultant copy is a deep copy.\n A deep copy copies all fields and makes copies of the dynamically-allocated memory ...","content":"/  /  / Cloning Values  import ballerina/io; public type Person record {  string name;  int age;  boolean married;  float salary;  Address address; }; public type Address record {  string country;  string state;  string city;  string street; };public function main() {  Address address = {  country: \"USA\",  state: \"NC\",  city: \"Raleigh\",  street: \"Daniels St\"  };  Person person = {  name: \"Alex\",  age: 24,  married: false,  salary: 8000.0,  address: address  };  Person result = person.clone(); io:println(\"Source value: \", person);  io:println(\"Cloned value: \", result);  io:println(\"Source and Clone are at two different memory locations: \", result !== person); }    Cloning Values  The .clone() method can be used to make a copy of an anydata value.  anydata is equivalent to ()|boolean|int|float|decimal|string|(anydata|error)[]|map<anydata|error>|xml|table.  Clone is defined for all structured types that belong to anydata.  The resultant copy is a deep copy.  A deep copy copies all fields and makes copies of the dynamically-allocated memory that is pointed to by the fields.  It preserves cycles, storage type, and immutability.  Cloning an immutable value will return the value itself.    import ballerina/io;    public type Person record {  string name;  int age;  boolean married;  float salary;  Address address; };    A record representing a Person.   public type Address record {  string country;  string state;  string city;  string street; };    A record representing an Address.   public function main() {    Address address = {  country: \"USA\",  state: \"NC\",  city: \"Raleigh\",  street: \"Daniels St\"  };    Define an Address value.   Person person = {  name: \"Alex\",  age: 24,  married: false,  salary: 8000.0,  address: address  };    Define a Person value.   Person result = person.clone();    Invoke the .clone() method. The return type is also Person.  Provided that the type of the value being cloned belongs to anydata, the return type of .clone() would be  the same as the type of the value being cloned.  E.g., anydata result = anydataValue.clone(); where anydataValue is a variable of type anydata.   io:println(\"Source value: \", person);  io:println(\"Cloned value: \", result);    io:println(\"Source and Clone are at two different memory locations: \", result !== person); }    Check reference inequality between the original value and the cloned value.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run clone.bal Source value: name=Alex age=24 married=false salary=8000.0 address=country=USA state=NC city=Raleigh street=Daniels St Cloned value: name=Alex age=24 married=false salary=8000.0 address=country=USA state=NC city=Raleigh street=Daniels St Source and Clone are at two different memory locations: true"},{"page":"/learn/by-example/checkpanic.html","name":"Check Panic","summary":"checkpanic is a unary expression that is used to handle errors.\n The checkpanic expression checks the result of the sub expression and panics if the result is error.\n Hence, checkpanic can be considered as a built-in type-guard for errors where the program will panic\n if the result is an error.The ...","content":"/  /  / Check Panic  import ballerina/io; import ballerina/lang.'int; function parse(string num) returns int|error {  return 'int:fromString(num); }public function main() {  int y = checkpanic parse(\"120\");  io:println(y);  int z = checkpanic parse(\"Invalid\");  io:println(z); }    Check Panic  checkpanic is a unary expression that is used to handle errors.  The checkpanic expression checks the result of the sub expression and panics if the result is error.  Hence, checkpanic can be considered as a built-in type-guard for errors where the program will panic  if the result is an error.    import ballerina/io; import ballerina/lang.'int;    function parse(string num) returns int|error {  return 'int:fromString(num); }    The parse() function takes a string argument and attempts to convert it to an int.   public function main() {    int y = checkpanic parse(\"120\");  io:println(y);    The checkpanic unary operator can be used to terminate execution on error.  Here, checkpanic is used to panic if the parse()  function evaluates to error. If the actual value returned  by the function is an error, the function immediately panics  with the error.  Passing a valid integer as a string will return an int.   int z = checkpanic parse(\"Invalid\");  io:println(z); }    Passing a random string will result in a panic.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run checkpanic.bal 120 error: {ballerina/lang.int}NumberParsingError message='string' value 'Invalid' cannot be converted to 'int'  at ballerina.lang_int:fromString(int.bal:113)  checkpanic:parse(checkpanic.bal:6)  checkpanic:main(checkpanic.bal:20)"},{"page":"/learn/by-example/config-api.html","name":"Config","summary":"The ballerina/config module provides an API to read configurations from various sources such as files, environment variables and CLI parameters.The Ballerina Config API allows you to look up values from configuration\n files, CLI parameters and environment variables. The precedence order for\n configuration resolution is as follows:CLI parametersEnvironment variablesConfiguration filesIf a ...","content":"/  /  / Config  import ballerina/config; import ballerina/http; import ballerina/log; listener http:Listener helloWorldEP  = new (config:getAsInt(\"hello.http.port\", 9095), config = {  secureSocket: {  keyStore: {  path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\",  password: config:getAsString(\"hello.keystore.password\")  }  } });@http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } }    Config  The ballerina/config module provides an API to read configurations from various sources such as files, environment variables and CLI parameters.    import ballerina/config; import ballerina/http; import ballerina/log;    listener http:Listener helloWorldEP  = new (config:getAsInt(\"hello.http.port\", 9095), config = {  secureSocket: {  keyStore: {  path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\",  password: config:getAsString(\"hello.keystore.password\")  }  } });    The Ballerina Config API allows you to look up values from configuration  files, CLI parameters and environment variables. The precedence order for  configuration resolution is as follows:   CLI parameters  Environment variables  Configuration files   If a specific configuration defined in the file is also defined as an  environment variable, the environment variable takes precedence. Similarly,  if the same is set as a CLI parameter, it replaces the environment  variable value.  The configuration file is in TOML(v0.4) format.  The configuration API is particularly useful for configuring services.  In this example, the port and keystore password are read through the  configuration API instead of hard coding it in the source file. The  configuration APIs accept a key and an optional default value. If a  mapping does not exist for the specified key, the default value  is returned as the configuration value. The default values of these  optional configurations are the default values of the return types of  the functions.   @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } }    # Sensitive data such as passwords can be encrypted and accessed securely in code. To encrypt a value, the # `ballerina encrypt` command is used. It prompts the user to enter the value and a secret. In this example, # `ballerina` is the value and `12345` is the secret. $ ballerina encrypt Enter value:    Enter secret:    Re-enter secret to verify:    Add the following to the configuration file: <key>=\"@encrypted:{69P5VGO+hOomLWhoY28gJiGPmBzWvzlmGGWA9X3uWZM=}\"    Or provide it as a command line argument: --<key>=@encrypted:{69P5VGO+hOomLWhoY28gJiGPmBzWvzlmGGWA9X3uWZM=}    # The secret needs to be provided if a configuration contains an encrypted value. The secret can be provided # via a `secret.txt` file or via the CLI. In this example, the CLI is used. $ ballerina run config_api.bal ballerina: enter secret for config value decryption:    # To specify a configuration file explicitly, use the `--b7a.config.file=<path_to_configuration_file>` property. # If this property is not set, Ballerina looks for a `ballerina.conf` file in the current directory. The path # to the configuration file can be either an absolute or a relative path. # To run this example, place the following configurations in a file and provide its path. # ``` # [hello.http] # port=8085 # [hello.keystore] # password=\"@encrypted:{69P5VGO+hOomLWhoY28gJiGPmBzWvzlmGGWA9X3uWZM=}\" # # ``` $ ballerina run config_api.bal --b7a.config.file=path/to/conf/file/custom-config-file-name.conf ballerina: enter secret for config value decryption:    ballerina: started HTTPS/WSS listener 0.0.0.0:8085    # The same configurations given via a configuration file can also be given via CLI parameters. <br> # e.g., hello.http.port $ ballerina run config_api.bal --hello.http.port=8085 --hello.keystore.password=@encrypted:{69P5VGO+hOomLWhoY28gJiGPmBzWvzlmGGWA9X3uWZM=} ballerina: enter secret for config value decryption:    ballerina: started HTTPS/WSS listener 0.0.0.0:8085"},{"page":"/learn/by-example/closures.html","name":"Closures","summary":"In Ballerina, a closure is an inner anonymous function that has visibility to\n the scope of its enclosing environment. It can access its own scope, its enclosing\n environment’s scope, and variables defined in the global scope.A basic example in which an anonymous function with an if block accesses its outer ...","content":"/  /  / Closures  import ballerina/io;int globalA = 5; function basicClosure() returns (function (int) returns int) {  int a = 3;  var foo = function (int b) returns int {  int c = 34;  if (b == 3) {  c = c + b + a + globalA;  }  return c + a;  };  return foo; } function multilevelClosure() returns (function (int) returns int) {  int a = 2;  var func1 = function (int x) returns int {  int b = 23;  a = a + 8;  var func2 = function (int y) returns int {  int c = 7;  var func3 = function (int z) returns int {  b = b + 1;  return x + y + z + a + b + c;  };  return func3(8) + y + x;  };  return func2(4) + x;  };  return func1; } function functionPointers(int a) returns  (function (int) returns (function (int) returns int)) {  return function (int b) returns (function (int) returns int) {  return function (int c) returns int {  return a + b + c;  };  }; }public function main() {  var foo = basicClosure();  int result1 = foo(3);  io:println(\"Answer: \", result1);  var bar = multilevelClosure();  int result2 = bar(5);  io:println(\"Answer: \", result2);  var baz1 = functionPointers(7);  var baz2 = baz1(5);  int result3 = baz2(3);  io:println(\"Answer: \", result3); }    Closures  In Ballerina, a closure is an inner anonymous function that has visibility to  the scope of its enclosing environment. It can access its own scope, its enclosing  environment’s scope, and variables defined in the global scope.    import ballerina/io;    int globalA = 5;    function basicClosure() returns (function (int) returns int) {  int a = 3;  var foo = function (int b) returns int {  int c = 34;  if (b == 3) {  c = c + b + a + globalA;  }  return c + a;  };  return foo; }    A basic example in which an anonymous function with an if block accesses its outer scope  variables.   function multilevelClosure() returns (function (int) returns int) {  int a = 2;  var func1 = function (int x) returns int {  int b = 23;    An example function with multiple levels of anonymous functions in which the  innermost anonymous function has access to all of its outer scope variables.   a = a + 8;  var func2 = function (int y) returns int {  int c = 7;  var func3 = function (int z) returns int {    The variable a defined in the outer scope is modified.  The original value of a will be changed to 10.   b = b + 1;  return x + y + z + a + b + c;  };  return func3(8) + y + x;  };  return func2(4) + x;  };  return func1; }    The variable b defined in the func1 function is modified.  The original value of b will be changed to 24.   function functionPointers(int a) returns  (function (int) returns (function (int) returns int)) {  return function (int b) returns (function (int) returns int) {  return function (int c) returns int {  return a + b + c;  };  }; }    An Example to represent how function pointers are passed with closures  so that the inner scope anonymous function can access the outer scope variables.   public function main() {    var foo = basicClosure();  int result1 = foo(3);  io:println(\"Answer: \", result1);    Invokes the function that shows basic closure support.   var bar = multilevelClosure();  int result2 = bar(5);  io:println(\"Answer: \", result2);    The function invocation that represents multiple levels of anonymous functions  with closure support.   var baz1 = functionPointers(7);  var baz2 = baz1(5);  int result3 = baz2(3);  io:println(\"Answer: \", result3); }    This function invocation shows how function pointers with closures  are passed around.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run closures.bal Answer: 48 Answer: 72 Answer: 15"},{"page":"/learn/by-example/compound-assignment-operators.html","name":"Compound Assignment Operators","summary":"Compound assignment operators can be used to simplify the code and increase readability. These operators can only be\n used as statements (i.e., they cannot be used as expressions).Compound add operator.Compound subtract operator.Compound divide operator.Compound multiply operator.Compound and operator.Compound or operator.Compound xor operator.Compound left shift operator.Compound right shift operator.Compound logical shift ...","content":"/  /  / Compound Assignment Operators  import ballerina/io;public function main() {  int value = 1;  io:println(\"value: \", value);  value += 7;  io:println(\"value += 7: \", value);  value -= 2;  io:println(\"value -= 2: \", value);  value /= 3;  io:println(\"value /= 3: \", value);  value *= 2;  io:println(\"value *= 2: \", value);  value &= 4;  io:println(\"value &= 4: \", value);  value |= 3;  io:println(\"value |= 3: \", value);  value ^= 5;  io:println(\"value ^= 5: \", value);  value <<= 1;  io:println(\"value <<= 1: \", value);  value >>= 1;  io:println(\"value >>= 1: \", value);  value >>>= 1;  io:println(\"value >>>= 1: \", value); }    Compound Assignment Operators  Compound assignment operators can be used to simplify the code and increase readability. These operators can only be  used as statements (i.e., they cannot be used as expressions).    import ballerina/io;    public function main() {  int value = 1;  io:println(\"value: \", value);    value += 7;  io:println(\"value += 7: \", value);    Compound add operator.   value -= 2;  io:println(\"value -= 2: \", value);    Compound subtract operator.   value /= 3;  io:println(\"value /= 3: \", value);    Compound divide operator.   value *= 2;  io:println(\"value *= 2: \", value);    Compound multiply operator.   value &= 4;  io:println(\"value &= 4: \", value);    Compound and operator.   value |= 3;  io:println(\"value |= 3: \", value);    Compound or operator.   value ^= 5;  io:println(\"value ^= 5: \", value);    Compound xor operator.   value <<= 1;  io:println(\"value <<= 1: \", value);    Compound left shift operator.   value >>= 1;  io:println(\"value >>= 1: \", value);    Compound right shift operator.   value >>>= 1;  io:println(\"value >>>= 1: \", value); }    Compound logical shift operator.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run compound_assignment_operators.bal value: 1 value += 7: 8 value -= 2: 6 value /= 3: 2 value *= 2: 4 value &= 4: 4 value |= 3: 7 value ^= 5: 2 value <<= 1: 4 value >>= 1: 2 value >>>= 1: 1"},{"page":"/learn/by-example/constants.html","name":"Constants","summary":"Constants are values known at compile time. As of now, only value-type constants (i.e., constants of boolean, byte,\n decimal, float, int, and string types) are supported. Constants are useful for defining enumeration types.These constants can be used just like any other value-type variable except the value of these constants cannot ...","content":"/  /  / Constants  import ballerina/io; const string GET = \"GET\"; const POST = \"POST\"; type ACTION GET|POST; const int I = 125; const map<string> data = {\"user\": \"Ballerina\", \"ID\": \"1234\"}; const map<map<string>> complexData = {\"data\": data, \"data2\": {\"user\": \"WSO2\"}};public function main() {  ACTION get = GET;  testAction(get); ACTION post = \"POST\";  testAction(POST);  int value = I + 10;  io:println(value); io:println(data);  io:println(complexData);  io:println(complexData[\"data\"][\"user\"]); }function testAction(ACTION action) {  if (action == GET) {  io:println(\"GET action\");  } else if (action == POST) {  io:println(\"POST action\");  } }    Constants  Constants are values known at compile time. As of now, only value-type constants (i.e., constants of boolean, byte,  decimal, float, int, and string types) are supported. Constants are useful for defining enumeration types.  These constants can be used just like any other value-type variable except the value of these constants cannot be  changed after initializing. The difference between the final variables and constants is that the value of the final  variables can be initialized at runtime. However, constants must be initialized at compile time.    import ballerina/io;    const string GET = \"GET\";    Constants are defined using the const modifier.   const POST = \"POST\";    Constants can be defined without the type. Then, the type is inferred from the right hand side.   type ACTION GET|POST;    Constants can be used to create type definitions. The type definition below specifies that a variable of the type  ACTION can only hold either GET or POST as its value.   const int I = 125;    An integer constant.   const map<string> data = {\"user\": \"Ballerina\", \"ID\": \"1234\"};    Constants of the map type can be defined as well. The constraint of these constant maps should be either a simple type  or another map type, which should eventually have a simple type constraint. var cannot be used to declare  constant maps. Therefore, the correct type should be present when declaring the constant.   const map<map<string>> complexData = {\"data\": data, \"data2\": {\"user\": \"WSO2\"}};    Constant with nested map literals.   public function main() {    ACTION get = GET;  testAction(get);    This is identical to the code line ACTION get = \"GET\";.   ACTION post = \"POST\";  testAction(POST);    int value = I + 10;  io:println(value);    I can be concatenated with any other integer value.   io:println(data);  io:println(complexData);    io:println(complexData[\"data\"][\"user\"]);    Values of a constant map can be accessed and used as usual.   }    However, updating a constant map will produce a compile-time error. E.g., -  data.ID = “4321”;  data.newField = 10;   function testAction(ACTION action) {  if (action == GET) {  io:println(\"GET action\");  } else if (action == POST) {  io:println(\"POST action\");  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run constant.bal GET action POST action 135 user=Ballerina ID=1234 data=user=Ballerina ID=1234 data2=user=WSO2 Ballerina"},{"page":"/learn/by-example/content-based-routing.html","name":"Content-Based Routing","summary":"The Content-Based Router service reads the content of a request and routes it to a specific recipient based on the content.Use resourceConfig annotation to declare the HTTP method.Define the attributes associated with the client endpoint here.Get the json payload from the request message.Get the string value relevant to the key ...","content":"/  /  / Content-Based Routing  import ballerina/http; import ballerina/log;@http:ServiceConfig {  basePath: \"/cbr\" } service contentBasedRouting on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/route\"  }  resource function cbrResource(http:Caller outboundEP, http:Request req) {  http:Client locationEP = new (\"http://www.mocky.io\");  var jsonMsg = req.getJsonPayload(); if (jsonMsg is json) {  json|error nameString = jsonMsg.name;  http:Response|error clientResponse;  if (nameString is json) {  if (nameString.toString() == \"sanFrancisco\") {  clientResponse =  locationEP->post(\"/v2/594e018c1100002811d6d39a\", ()); } else {  clientResponse =  locationEP->post(\"/v2/594e026c1100004011d6d39c\", ());  }  if (clientResponse is http:Response) {  var result = outboundEP->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>clientResponse.detail()?.message);  var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>nameString.detail()?.message); var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>jsonMsg.detail()?.message); var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    Content-Based Routing  The Content-Based Router service reads the content of a request and routes it to a specific recipient based on the content.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/cbr\" } service contentBasedRouting on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/route\"  }  resource function cbrResource(http:Caller outboundEP, http:Request req) {    Use resourceConfig annotation to declare the HTTP method.   http:Client locationEP = new (\"http://www.mocky.io\");    Define the attributes associated with the client endpoint here.   var jsonMsg = req.getJsonPayload();    Get the json payload from the request message.   if (jsonMsg is json) {    json|error nameString = jsonMsg.name;  http:Response|error clientResponse;  if (nameString is json) {  if (nameString.toString() == \"sanFrancisco\") {    Get the string value relevant to the key name.   clientResponse =  locationEP->post(\"/v2/594e018c1100002811d6d39a\", ());    Here, post remote function represents the POST operation of  the HTTP client.  This routes the payload to the relevant service when the server  accepts the enclosed entity.   } else {  clientResponse =  locationEP->post(\"/v2/594e026c1100004011d6d39c\", ());  }    if (clientResponse is http:Response) {  var result = outboundEP->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>clientResponse.detail()?.message);  var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>nameString.detail()?.message);    Use the remote function respond to send the client response  back to the caller.   var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>jsonMsg.detail()?.message);    var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run content_based_routing.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    $ curl http://localhost:9090/cbr/route -d '{\"name\" : \"sanFrancisco\"}' -H \"Content-Type:application/json\" {  \"name\": \"San Francisco Test Station,USA\",  \"longitude\": -122.43,  \"latitude\": 37.76,  \"altitude\": 150,  \"rank\": 1 }    $ curl http://localhost:9090/cbr/route -d '{\"name\" : \"london\"}' -H \"Content-Type:application/json\" {  \"name\": \"London Test Station,England\",  \"longitude\": -156.49,  \"latitude\": 57.76,  \"altitude\": 430,  \"rank\": 5 }"},{"page":"/learn/by-example/counter-metrics.html","name":"Counter-Based Metrics","summary":"Ballerina supports Observability out of the box, and Metrics is one of the three important aspect of the\n Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.\n The developers can define and use metrics to measure their own logic. A counter is one type ...","content":"/  /  / Counter-Based Metrics  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/observe; observe:Counter globalCounter = new (\"total_orders\",  desc = \"Total quantity required\"); @http:ServiceConfig {  basePath: \"/online-store-service\" } service onlineStoreService on new http:Listener(9090) { @http:ResourceConfig {  path: \"/make-order\"  }  resource function makeOrder(http:Caller caller, http:Request req) {  globalCounter.increment();  observe:Counter localCounter = new (\"local_operations\");  localCounter.increment();  localCounter.increment(20);  observe:Counter registeredCounter = new (\"total_product_order_quantity\",  desc = \"Total quantity required\",  tags = {prodName: \"HeadPhone\", prodType: \"Electronics\"});  error? result = registeredCounter.register();  if (result is error) {  log:printError(\"Error in registering counter\", result);  }  registeredCounter.increment(10);  io:println(\"------------------------------------------\");  io:println(\"Global Counter = \", globalCounter.getValue());  io:println(\"Local Counter = \", localCounter.getValue());  io:println(\"Registered Counter = \", registeredCounter.getValue());  io:println(\"------------------------------------------\");  http:Response res = new;  res.setPayload(\"Order Processed!\");  result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Counter-Based Metrics  Ballerina supports Observability out of the box, and Metrics is one of the three important aspect of the  Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.  The developers can define and use metrics to measure their own logic. A counter is one type of metric that is  supported by default in Ballerina, and it is a cumulative metric that represents a single monotonically increasing  counter whose value can only increase or be reset to zero.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/observe;    observe:Counter globalCounter = new (\"total_orders\",  desc = \"Total quantity required\");    Create a counter as a global variable in the service with optional field description.   @http:ServiceConfig {  basePath: \"/online-store-service\" } service onlineStoreService on new http:Listener(9090) {    Make sure you start the service with ‘–b7a.observability.enabled=true’, or metrics enabled.   @http:ResourceConfig {  path: \"/make-order\"  }  resource function makeOrder(http:Caller caller, http:Request req) {    globalCounter.increment();    Incrementing the global counter defined with the default value 1.   observe:Counter localCounter = new (\"local_operations\");  localCounter.increment();    Create a counter with simply a name.   localCounter.increment(20);    Increment the value of the counter by 20.   observe:Counter registeredCounter = new (\"total_product_order_quantity\",  desc = \"Total quantity required\",  tags = {prodName: \"HeadPhone\", prodType: \"Electronics\"});    Create a counter with optional fields description, and tags.   error? result = registeredCounter.register();  if (result is error) {  log:printError(\"Error in registering counter\", result);  }    Register the counter instance, therefore it is stored in the global registry and can be reported to the metrics server such as Prometheus. Additionally, this operation will register to the global registry for the first invocation and will throw an error if there is already a registration of different metrics instance or type. Subsequent invocations of register() will simply retrieve the stored metrics instance for the provided name and tags fields, and use that instance for the subsequent operations on the counter instance.   registeredCounter.increment(10);    Increase the amount of the registered counter instance by amount 10.   io:println(\"------------------------------------------\");  io:println(\"Global Counter = \", globalCounter.getValue());  io:println(\"Local Counter = \", localCounter.getValue());  io:println(\"Registered Counter = \", registeredCounter.getValue());  io:println(\"------------------------------------------\");    Get the value of the counter instances.   http:Response res = new;    Send reponse to the client.   res.setPayload(\"Order Processed!\");    Use a util method to set a string payload.   result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Send the response back to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command with the '--b7a.observability.enabled=true' property. $ ballerina run counter_metrics.bal --b7a.observability.enabled=true [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 ------------------------------------------ Global Counter = 1 Local Counter = 21 Registered Counter = 10 ------------------------------------------ ------------------------------------------ Global Counter = 2 Local Counter = 21 Registered Counter = 20 ------------------------------------------ ------------------------------------------ Global Counter = 3 Local Counter = 21 Registered Counter = 30 ------------------------------------------    $ curl http://localhost:9090/online-store-service/make-order Order Processed! $ curl http://localhost:9090/online-store-service/make-order Order Processed! $ curl http://localhost:9090/online-store-service/make-order Order Processed!    Invoke the service using cURL three times."},{"page":"/learn/by-example/create-java-objects.html","name":"Create Java Objects","summary":"jBallerina is an implementation of the Ballerina language specification that targets the JVM.\n Java interoperability in jBallerina enables developers to call existing Java code from Ballerina.\n Ballerina spec describes a reference type called handle. A handle value is a reference to\n storage managed externally to a Ballerina program. Handle values ...","content":"/  /  / Create Java Objects  import ballerina/io; import ballerina/java; function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external; function newArrayDequeWithInitialCapacity(int numElements) returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\",  paramTypes: [\"int\"] } external;public function main() {  var arrayDeque = newArrayDeque();  io:println(arrayDeque);  var arrayDequeWithCapacity = newArrayDequeWithInitialCapacity(10);  io:println(arrayDequeWithCapacity); }    Create Java Objects  jBallerina is an implementation of the Ballerina language specification that targets the JVM.  Java interoperability in jBallerina enables developers to call existing Java code from Ballerina.  Ballerina spec describes a reference type called handle. A handle value is a reference to  storage managed externally to a Ballerina program. Handle values cannot be created within a Ballerina program.  They can be created only by functions with an external function body. In jBallerina handle value refers to  Java reference value, i.e., a Java object. Also, in jBallerina, Java constructors and Java methods can provide  the implementations of Ballerina functions that are marked as external.  In this example, let’s look at how to create Java objects by invoking their constructors from Ballerina.    import ballerina/io; import ballerina/java;    function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;    The @java:Constructor annotation links the default constructor of  the class java.util.ArrayDeque with this Ballerina function declaration.   function newArrayDequeWithInitialCapacity(int numElements) returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\",  paramTypes: [\"int\"] } external;    This ballerina function is linked with the java.util.ArrayDeque constructor that takes the initial capacity.  There are other overloaded constructors that take a single parameter in this class.  To link with the exact constructor, you can specify the paramTypes field. Refer to the Overloaded  Methods/Constructors section for more details on dealing with overloaded methods and constructors.  This function returns a handle value, which refers to an object of java.util.ArrayDeque class.   public function main() {    var arrayDeque = newArrayDeque();  io:println(arrayDeque);    Create a new java.util.ArrayDeque object by invoking the default constructor via newArrayDeque function.   var arrayDequeWithCapacity = newArrayDequeWithInitialCapacity(10);  io:println(arrayDequeWithCapacity); }    Create a new java.util.ArrayDeque object by invoking the constructor that takes an int argument  via newArrayDeque function.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run create-java-objects.bal [] []"},{"page":"/learn/by-example/crypto.html","name":"Cryptographic Operations","summary":"The crypto stdlib provides functions usable to perform different cryptographic operations such as hashing,\n HMAC generation, checksum generation and digitally signing data.Input value for crypto operations.Hashing input value using MD5 hashing algorithm, and printing hash value using Hex encoding.Hashing input value using SHA1 hashing algorithm, and printing hash value using ...","content":"/  /  / Cryptographic Operations  import ballerina/crypto; import ballerina/io; import ballerina/lang.'string; import ballerina/math;public function main() returns error? {  string input = \"Hello Ballerina!\";  byte[] inputArr = input.toBytes();  byte[] output = crypto:hashMd5(inputArr);  io:println(\"Hex encoded hash with MD5: \" + output.toBase16());  output = crypto:hashSha1(inputArr);  io:println(\"Base64 encoded hash with SHA1: \" + output.toBase64());  output = crypto:hashSha256(inputArr);  io:println(\"Hex encoded hash with SHA256: \" + output.toBase16());  output = crypto:hashSha384(inputArr);  io:println(\"Base64 encoded hash with SHA384: \" + output.toBase64());  output = crypto:hashSha512(inputArr);  io:println(\"Hex encoded hash with SHA512: \" + output.toBase16());  string key = \"somesecret\";  byte[] keyArr = key.toBytes();  output = crypto:hmacMd5(inputArr, keyArr);  io:println(\"Hex encoded HMAC with MD5: \" + output.toBase16());  output = crypto:hmacSha1(inputArr, keyArr);  io:println(\"Base64 encoded HMAC with SHA1: \" + output.toBase64());  output = crypto:hmacSha256(inputArr, keyArr);  io:println(\"Hex encoded HMAC with SHA256: \" + output.toBase16());  output = crypto:hmacSha384(inputArr, keyArr);  io:println(\"Base64 encoded HMAC with SHA384: \" + output.toBase64());  output = crypto:hmacSha512(inputArr, keyArr);  io:println(\"Hex encoded HMAC with SHA512: \" + output.toBase16());  io:println(\"CRC32B for text: \" + crypto:crc32b(inputArr));  xml xmlContent = xml `<foo>Hello Ballerina</foo>`;  io:println(\"CRC32 for xml content: \" + crypto:crc32b(xmlContent.toString().toBytes()));  crypto:KeyStore keyStore = {path: \"./sampleKeystore.p12\", password: \"ballerina\"};  var privateKey = crypto:decodePrivateKey(keyStore, \"ballerina\", \"ballerina\"); if (privateKey is crypto:PrivateKey) {  output = check crypto:signRsaMd5(inputArr, privateKey);  io:println(\"Hex encoded RSA-MD5 signature: \" + output.toBase16());  output = check crypto:signRsaSha1(inputArr, privateKey);  io:println(\"Base64 encoded RSA-SHA1 signature: \" + output.toBase64());  output = check crypto:signRsaSha256(inputArr, privateKey);  io:println(\"Hex encoded RSA-SHA256 signature: \" + output.toBase16());  output = check crypto:signRsaSha384(inputArr, privateKey);  io:println(\"Base64 encoded RSA-SHA384 signature: \" + output.toBase64());  output = check crypto:signRsaSha512(inputArr, privateKey);  io:println(\"Hex encoded RSA-SHA512 signature: \" + output.toBase16());  } else {  io:println(\"Invalid private key\");  }  byte[16] rsaKeyArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  rsaKeyArr[i] = <byte>(math:randomInRange(0, 255));  }  byte[16] ivArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  ivArr[i] = <byte>(math:randomInRange(0, 255));  }  output = check crypto:encryptAesCbc(inputArr, rsaKeyArr, ivArr);  output = check crypto:decryptAesCbc(output, rsaKeyArr, ivArr);  io:println(\"AES CBC PKCS5 decrypted value: \" + check 'string:fromBytes(output));  output = check crypto:encryptAesCbc(inputArr, rsaKeyArr, ivArr, crypto:NONE);  output = check crypto:decryptAesCbc(output, rsaKeyArr, ivArr, crypto:NONE);  io:println(\"AES CBC no padding decrypted value: \" + check 'string:fromBytes(output));  output = check crypto:encryptAesGcm(inputArr, rsaKeyArr, ivArr);  output = check crypto:decryptAesGcm(output, rsaKeyArr, ivArr);  io:println(\"AES GCM PKCS5 decrypted value: \" + check 'string:fromBytes(output));  output = check crypto:encryptAesGcm(inputArr, rsaKeyArr, ivArr, crypto:NONE);  output = check crypto:decryptAesGcm(output, rsaKeyArr, ivArr, crypto:NONE);  io:println(\"AES GCM no padding decrypted value: \" + check 'string:fromBytes(output));  output = check crypto:encryptAesEcb(inputArr, rsaKeyArr);  output = check crypto:decryptAesEcb(output, rsaKeyArr);  io:println(\"AES ECB PKCS5 decrypted value: \" + check 'string:fromBytes(output));  output = check crypto:encryptAesEcb(inputArr, rsaKeyArr, crypto:NONE);  output = check crypto:decryptAesEcb(output, rsaKeyArr, crypto:NONE);  io:println(\"AES ECB no padding decrypted value: \" + check 'string:fromBytes(output));  crypto:PublicKey rsaPublicKey = check crypto:decodePublicKey(keyStore, \"ballerina\");  crypto:PrivateKey rsaPrivateKey = check crypto:decodePrivateKey(keyStore, \"ballerina\",  \"ballerina\");  output = check crypto:encryptRsaEcb(inputArr, rsaPublicKey);  output = check crypto:decryptRsaEcb(output, rsaPrivateKey);  io:println(\"RSA ECB PKCS1 decrypted value: \" + check 'string:fromBytes(output));  output = check crypto:encryptRsaEcb(inputArr, rsaPublicKey,  crypto:OAEPwithSHA512andMGF1);  output = check crypto:decryptRsaEcb(output, rsaPrivateKey,  crypto:OAEPwithSHA512andMGF1);  io:println(\"RSA ECB OAEPwithSHA512andMGF1 decrypted value: \" +  check 'string:fromBytes(output)); }    Cryptographic Operations  The crypto stdlib provides functions usable to perform different cryptographic operations such as hashing,  HMAC generation, checksum generation and digitally signing data.    import ballerina/crypto; import ballerina/io; import ballerina/lang.'string; import ballerina/math;    public function main() returns error? {    string input = \"Hello Ballerina!\";  byte[] inputArr = input.toBytes();    Input value for crypto operations.   byte[] output = crypto:hashMd5(inputArr);  io:println(\"Hex encoded hash with MD5: \" + output.toBase16());    Hashing input value using MD5 hashing algorithm, and printing hash value using Hex encoding.   output = crypto:hashSha1(inputArr);  io:println(\"Base64 encoded hash with SHA1: \" + output.toBase64());    Hashing input value using SHA1 hashing algorithm, and printing hash value using Base64 encoding.   output = crypto:hashSha256(inputArr);  io:println(\"Hex encoded hash with SHA256: \" + output.toBase16());    Hashing input value using SHA256 hashing algorithm, and printing hash value using Hex encoding.   output = crypto:hashSha384(inputArr);  io:println(\"Base64 encoded hash with SHA384: \" + output.toBase64());    Hashing input value using SHA384 hashing algorithm, and printing hash value using Base64 encoding.   output = crypto:hashSha512(inputArr);  io:println(\"Hex encoded hash with SHA512: \" + output.toBase16());    Hashing input value using SHA512 hashing algorithm, and printing hash value using Hex encoding.   string key = \"somesecret\";  byte[] keyArr = key.toBytes();    The key used for HMAC generation.   output = crypto:hmacMd5(inputArr, keyArr);  io:println(\"Hex encoded HMAC with MD5: \" + output.toBase16());    HMAC generation for input value using MD5 hashing algorithm, and printing HMAC value using Hex encoding.   output = crypto:hmacSha1(inputArr, keyArr);  io:println(\"Base64 encoded HMAC with SHA1: \" + output.toBase64());    HMAC generation for input value using SHA1 hashing algorithm, and printing HMAC value using Base64 encoding.   output = crypto:hmacSha256(inputArr, keyArr);  io:println(\"Hex encoded HMAC with SHA256: \" + output.toBase16());    HMAC generation for input value using SHA256 hashing algorithm, and printing HMAC value using Hex encoding.   output = crypto:hmacSha384(inputArr, keyArr);  io:println(\"Base64 encoded HMAC with SHA384: \" + output.toBase64());    HMAC generation for input value using SHA384 hashing algorithm, and printing HMAC value using Base64 encoding.   output = crypto:hmacSha512(inputArr, keyArr);  io:println(\"Hex encoded HMAC with SHA512: \" + output.toBase16());    HMAC generation for input value using SHA512 hashing algorithm, and printing HMAC value using Hex encoding.   io:println(\"CRC32B for text: \" + crypto:crc32b(inputArr));    Hex encoded CRC32B checksum generation for input value.   xml xmlContent = xml `<foo>Hello Ballerina</foo>`;  io:println(\"CRC32 for xml content: \" + crypto:crc32b(xmlContent.toString().toBytes()));    Hex encoded CRC32B checksum generation for XML data.   crypto:KeyStore keyStore = {path: \"./sampleKeystore.p12\", password: \"ballerina\"};  var privateKey = crypto:decodePrivateKey(keyStore, \"ballerina\", \"ballerina\");    Obtaining reference to a RSA private key stored within a PKCS#12 or PFX format archive file.   if (privateKey is crypto:PrivateKey) {    output = check crypto:signRsaMd5(inputArr, privateKey);  io:println(\"Hex encoded RSA-MD5 signature: \" + output.toBase16());    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.   output = check crypto:signRsaSha1(inputArr, privateKey);  io:println(\"Base64 encoded RSA-SHA1 signature: \" + output.toBase64());    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Base64 encoding.   output = check crypto:signRsaSha256(inputArr, privateKey);  io:println(\"Hex encoded RSA-SHA256 signature: \" + output.toBase16());    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.   output = check crypto:signRsaSha384(inputArr, privateKey);  io:println(\"Base64 encoded RSA-SHA384 signature: \" + output.toBase64());    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Base64 encoding.   output = check crypto:signRsaSha512(inputArr, privateKey);  io:println(\"Hex encoded RSA-SHA512 signature: \" + output.toBase16());  } else {  io:println(\"Invalid private key\");  }    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.   byte[16] rsaKeyArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  rsaKeyArr[i] = <byte>(math:randomInRange(0, 255));  }    Randomly generate a 128 bit key for AES encryption.   byte[16] ivArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  ivArr[i] = <byte>(math:randomInRange(0, 255));  }    Randomly generate a 128 bit IV for AES encryption.   output = check crypto:encryptAesCbc(inputArr, rsaKeyArr, ivArr);  output = check crypto:decryptAesCbc(output, rsaKeyArr, ivArr);  io:println(\"AES CBC PKCS5 decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES CBC PKCS5 padding.   output = check crypto:encryptAesCbc(inputArr, rsaKeyArr, ivArr, crypto:NONE);  output = check crypto:decryptAesCbc(output, rsaKeyArr, ivArr, crypto:NONE);  io:println(\"AES CBC no padding decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES CBC without padding.   output = check crypto:encryptAesGcm(inputArr, rsaKeyArr, ivArr);  output = check crypto:decryptAesGcm(output, rsaKeyArr, ivArr);  io:println(\"AES GCM PKCS5 decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES GCM PKCS5 padding.   output = check crypto:encryptAesGcm(inputArr, rsaKeyArr, ivArr, crypto:NONE);  output = check crypto:decryptAesGcm(output, rsaKeyArr, ivArr, crypto:NONE);  io:println(\"AES GCM no padding decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES GCM without padding.   output = check crypto:encryptAesEcb(inputArr, rsaKeyArr);  output = check crypto:decryptAesEcb(output, rsaKeyArr);  io:println(\"AES ECB PKCS5 decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES ECB PKCS5 padding.   output = check crypto:encryptAesEcb(inputArr, rsaKeyArr, crypto:NONE);  output = check crypto:decryptAesEcb(output, rsaKeyArr, crypto:NONE);  io:println(\"AES ECB no padding decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt input value using AES ECB without padding.   crypto:PublicKey rsaPublicKey = check crypto:decodePublicKey(keyStore, \"ballerina\");    Public key used for RSA encryption.   crypto:PrivateKey rsaPrivateKey = check crypto:decodePrivateKey(keyStore, \"ballerina\",  \"ballerina\");    Private key used for RSA decryption.   output = check crypto:encryptRsaEcb(inputArr, rsaPublicKey);  output = check crypto:decryptRsaEcb(output, rsaPrivateKey);  io:println(\"RSA ECB PKCS1 decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using RSA ECB PKCS1 padding.   output = check crypto:encryptRsaEcb(inputArr, rsaPublicKey,  crypto:OAEPwithSHA512andMGF1);  output = check crypto:decryptRsaEcb(output, rsaPrivateKey,  crypto:OAEPwithSHA512andMGF1);  io:println(\"RSA ECB OAEPwithSHA512andMGF1 decrypted value: \" +  check 'string:fromBytes(output)); }    Encrypt and decrypt an input value using RSA ECB OAEPwithSHA512andMGF1 padding.   # To run this sample, navigate to the directory that contains the # `.bal` file, make sure `sampleKeystore.p12` file is present in the # same folder and issue the `ballerina run` command. $ ballerina run crypto.bal Hex encoded hash with MD5: 0605402ee16d8e96511a58ff105bc24a Base64 encoded hash with SHA1: /8fwbGIevBvv2Nl3gEL9DtWas+Q= Hex encoded hash with SHA256: a984a643c350b17f0738bac0fef17f2cd91d91e04596351d0  af670c79adc12d5 Base64 encoded hash with SHA384: lselzItgAZHQmqNbkf/s2aRjBSd93O3ayc0PB0Dxk6AEo1  s44zyTz/Qp0FJO1n6b Hex encoded hash with SHA512: a6f0770f1582f49396a97fbd5973ac22a3a578ac6a991786427  dfec17dbd984d8d6289771ac6f44176160a3dcd59f4a8c6b3ab97bef0caa5c67a3fac78c8e946 Hex encoded HMAC with MD5: b69fa2cc698e0923a7eea9d8f2b156fe Base64 encoded HMAC with SHA1: AkWFajkb/gml703Zf4pPgxrjam4= Hex encoded HMAC with SHA256: 13a3369b8ba326fd311d4500b06a5214a02ed2a033917108f6b  9af58b7ede381 Base64 encoded HMAC with SHA384: 0AjKoWLhNPgdobGTPJs0PdkA0W9wkJtzUvXigzC1ZmXDJJsx  p4icks4JrPiwHGm6 Hex encoded HMAC with SHA512: 27588ad08e772a6bba5fca5f45cf467819c8de69a70a42be6fe  3eb09ceb3bfeb8b2976bda8ea5c10dcfa2294b12cb0b50b22a06309bada98af21857904a03205 CRC32B for text: db9230c5 CRC32 for xml content: 7d5c0879 Hex encoded RSA-MD5 signature: 2cfd121e4ff2409d1b2482ebbf37d0c035884d6d858e307e44  60b092d79cb20abb624a0dfae76b73b1fc85447be3060a36b318813f0115b1919e5efa7a7f9b1  173ec869f56fd9448d99770e1565db1c69a04fd0075fa0e33423a7e829a8b9c25a4dd2c68f3ee  e021c0c4ff27979750b395384e280afd87af5274c8d2d99ad4438d9bfc9b2c5a2814212ba29ce  6ff70cbe30a5c23f86b0330e143c4d8813ff10092cd313c6861706d37df5f4bb4e9fc72354975  ee1786cf24c79b9edfa909968f198c4da37464f3d214a68fb39956717e92d667bb5a9a7f5986b  a055d431813d4053a028873499f98c94fd6b5c6fd5aefad432669f957ab4ce9e91c5e77b36ec0 Base64 encoded RSA-SHA1 signature: bYMHKKVkjbOUp9ly3AdW9/euxF94krkkF9SDk2FfbVEc0m  qpGIxVoZlPiFxszurZF1YPcqOSeOehDkaHXUMfQkTjBq7XlcePtkywy0fChqw8/SWqZR8nbYv97tt  8+MVTkymbm26syQLwYNLiGp/EsN6X+fJpkdakwHE+TrdE+rEFrNysGyAm1DWwc4c+l7MEmSYMUnh/  GWPY5r2knOOdDA3mr+XyrsxzFRWZgO7ebVvEQfq9XkRp8kdiGVgpLS5au0jKj3EpbCdS1prFgy3gr  kuSJTTUQCwgPo7WSjWbuehFGni7rbas8HIqNlyWF0qUyznJ3eqbUwZ95QqOoVWZoQ== Hex encoded RSA-SHA256 signature: 215c6ea96c9e82348430c6bb02e715560b4fbd3afcf24fb  eb41ff12d4d68a797d61c4d6f822807688e4dc604e212b3cc7ac563b3cbe4e5690e2aebaf4e3d  f35c19d4b0f7043f50501f390634303577053b029d495104c0e98bc887f0be744ef6f726f7192  01907ad4e86cef82eb030b60c384f7034a85159081e598e197bb8904a9123f39d190796dc7fd9  46157547c10523999b8fa956d4119dbfe3c1435911c0585cf3c537964516706772e87f2470557  40cc4867ac6b99d7bf699fce1b59956c7f55368c8c88c9d47e51ef120ed3f27c3e555691a6971  42c78cbd72c23b81b43fa5ab67164a35f8e8c6bf1da187d3feb866add13f1fb9576a2f7887535  311 Base64 encoded RSA-SHA384 signature: BjQ40dffGiRQ4zo1s+ld+zKhJL21RbO5sW3L2+4xmonU  t126u9D4/FZ2sM1QGGamj8btB9otiYmWr9sFm4fTs1EX6vrxcCGCAiDdkMxiRs7kShaz2x/BjJQ7c  Od9OY+amwo7DQ/FAk9mNOt4lFUpjc9WyEW9F1PEJRXZQvMmVabDu8lp/Fh02lmEquG15DT5qT0jRx  RJiS8CNa+97cMZdOmF2KeADfRbNJSz70mZ76MrsNxYIXYIiJzJBQod0efQr0Sr/HDn4JDVph9rpDM  3p8m94TyXvSOwxwxzZWRLEwB0ANdfDmbrW4bOpxfZZFmy1hltqNJQ9G0BcKOHsZDj6Q== Hex encoded RSA-SHA512 signature: 15428fdc7b26d18b1f3eae4569399ae6ebfd430c8f073bf  2fa77ebfe1ad5645640374ea4a4aeadd252af3a198e55e69ad2a910e28470d9b54748887de06a  5c3ed7ab12399a404359332553e051e8ae0f3ef741faa15a21ad17a9c235e5f91d567bcca0e5a  6117689dccada4a33ee897514f7a8a32f12dac0087f5dcbb094c93c792f672e1685618ac5d93a  a9d30f6d8e306145ef2d1b9cfdc04d6c61b43376089a78471e8e03d97ee3b57e1b734a23f4436  6a99234a0abeb1d36d01c474833b4c2beaf430dae06ab95a1c951645fb1e0a5e7b9eed44d40e3  5036f2cd2764df6cc04fe1248e1bb772a53c8201a974109333a318ce57930494d4cb5e41d0dc8  f1c AES CBC PKCS5 decrypted value: Hello Ballerina! AES CBC no padding decrypted value: Hello Ballerina! AES GCM PKCS5 decrypted value: Hello Ballerina! AES GCM no padding decrypted value: Hello Ballerina! AES ECB PKCS5 decrypted value: Hello Ballerina! AES ECB no padding decrypted value: Hello Ballerina! RSA ECB PKCS1 decrypted value: Hello Ballerina! RSA ECB OAEPwithSHA512andMGF1 decrypted value: Hello Ballerina!"},{"page":"/learn/by-example/data-io.html","name":"Data I/O","summary":"This sample demonstrates how data i/o APIs could be used to read/write data.Serializes the record into binary.Deserializes the record from binary.Reads a 32-bit-signed integer.Reads a UTF-8-encoded string represented through the specified amounts of bytes.Reads a 16-bit-signed integer.Reads a 64-bit-signed float.Reads a boolean.Finally closes the data channel.Serializes and writes the record ...","content":"/  /  / Data I/O  import ballerina/io; import ballerina/log;public type Person record {|  string name = \"\";  int age = 0;  float income = 0.0;  boolean isMarried = false; |}; function serialize(Person p, io:WritableByteChannel byteChannel) {  io:WritableDataChannel dc = new io:WritableDataChannel(byteChannel);  var length = p.name.toBytes().length();  var lengthResult = dc.writeInt32(length);  var nameResult = dc.writeString(p.name, \"UTF-8\");  var ageResult = dc.writeInt16(p.age);  var incomeResult = dc.writeFloat64(p.income);  var maritalStatusResult = dc.writeBool(p.isMarried);  var closeResult = dc.close(); } function deserialize(io:ReadableByteChannel byteChannel) returns Person {  Person person = {};  int nameLength = 0;  string nameValue;  io:ReadableDataChannel dc = new io:ReadableDataChannel(byteChannel);  var int32Result = dc.readInt32();  if (int32Result is int) {  nameLength = int32Result;  } else {  log:printError(\"Error occurred while reading name length\",  err = int32Result);  }  var strResult = dc.readString(nameLength, \"UTF-8\");  if (strResult is string) {  person.name = strResult;  } else {  log:printError(\"Error occurred while reading name\", strResult);  }  var int16Result = dc.readInt16();  if (int16Result is int) {  person.age = int16Result;  } else {  log:printError(\"Error occurred while reading age\",  err = int16Result);  }  var float64Result = dc.readFloat64();  if (float64Result is float) {  person.income = float64Result;  } else {  log:printError(\"Error occurred while reading income\",  err = float64Result);  }  var boolResult = dc.readBool();  if (boolResult is boolean) {  person.isMarried = boolResult;  } else {  log:printError(\"Error occurred while reading marital status\",  err = boolResult);  }  var closeResult = dc.close();  return person; } function writeRecordToFile(Person p, string path) returns error? {  io:WritableByteChannel wc = check io:openWritableFile(path);  serialize(p, wc); } function readRecordFromFile(string path) returns @tainted Person|error {  io:ReadableByteChannel rc = check io:openReadableFile(path);  return deserialize(rc); }public function main() returns error? {  Person wPerson = {  name: \"Ballerina\",  age: 21,  income: 1543.12,  isMarried: true  };  check writeRecordToFile(wPerson, \"./files/person.bin\");  io:println(\"Person record successfully written to file\");  Person rPerson = check readRecordFromFile(\"./files/person.bin\");  io:println(\"Reading person record from file\");  io:println(rPerson); }    Data I/O  This sample demonstrates how data i/o APIs could be used to read/write data.    import ballerina/io; import ballerina/log;    public type Person record {|  string name = \"\";  int age = 0;  float income = 0.0;  boolean isMarried = false; |};    function serialize(Person p, io:WritableByteChannel byteChannel) {  io:WritableDataChannel dc = new io:WritableDataChannel(byteChannel);  var length = p.name.toBytes().length();  var lengthResult = dc.writeInt32(length);  var nameResult = dc.writeString(p.name, \"UTF-8\");  var ageResult = dc.writeInt16(p.age);  var incomeResult = dc.writeFloat64(p.income);  var maritalStatusResult = dc.writeBool(p.isMarried);  var closeResult = dc.close(); }    Serializes the record into binary.   function deserialize(io:ReadableByteChannel byteChannel) returns Person {  Person person = {};  int nameLength = 0;  string nameValue;  io:ReadableDataChannel dc = new io:ReadableDataChannel(byteChannel);    Deserializes the record from binary.   var int32Result = dc.readInt32();  if (int32Result is int) {  nameLength = int32Result;  } else {  log:printError(\"Error occurred while reading name length\",  err = int32Result);  }    Reads a 32-bit-signed integer.   var strResult = dc.readString(nameLength, \"UTF-8\");  if (strResult is string) {  person.name = strResult;  } else {  log:printError(\"Error occurred while reading name\", strResult);  }    Reads a UTF-8-encoded string represented through the specified amounts of bytes.   var int16Result = dc.readInt16();  if (int16Result is int) {  person.age = int16Result;  } else {  log:printError(\"Error occurred while reading age\",  err = int16Result);  }    Reads a 16-bit-signed integer.   var float64Result = dc.readFloat64();  if (float64Result is float) {  person.income = float64Result;  } else {  log:printError(\"Error occurred while reading income\",  err = float64Result);  }    Reads a 64-bit-signed float.   var boolResult = dc.readBool();  if (boolResult is boolean) {  person.isMarried = boolResult;  } else {  log:printError(\"Error occurred while reading marital status\",  err = boolResult);  }    Reads a boolean.   var closeResult = dc.close();  return person; }    Finally closes the data channel.   function writeRecordToFile(Person p, string path) returns error? {  io:WritableByteChannel wc = check io:openWritableFile(path);  serialize(p, wc); }    Serializes and writes the record to a file.   function readRecordFromFile(string path) returns @tainted Person|error {  io:ReadableByteChannel rc = check io:openReadableFile(path);  return deserialize(rc); }    Reads the serialized record from the file.   public function main() returns error? {  Person wPerson = {  name: \"Ballerina\",  age: 21,  income: 1543.12,  isMarried: true  };    check writeRecordToFile(wPerson, \"./files/person.bin\");  io:println(\"Person record successfully written to file\");    Writes the record to a file.   Person rPerson = check readRecordFromFile(\"./files/person.bin\");  io:println(\"Reading person record from file\");  io:println(rPerson); }    Reads record from a file.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run data_io.bal Person record successfully written to file Reading person record from file name=Ballerina age=21 income=1543.12 isMarried=true"},{"page":"/learn/by-example/csv-io.html","name":"CSV I/O","summary":"This sample demonstrates how to read/write from/to a CSV file using the CSV channel of the I/O APIThis function reads records one by one and prints the records.Reads all the records from the provided file\n until there are no more records.Reads the records.Prints the records.Specifies the location of the .CSV ...","content":"/  /  / CSV I/O  import ballerina/io; import ballerina/log;type Employee record {  string id;  string name;  float salary; }; function process(io:ReadableCSVChannel csvChannel)  returns @tainted error? {  while (csvChannel.hasNext()) {  var records = check csvChannel.getNext();  if (records is string[]) {  io:println(records);  }  }  return; } public function main() returns @tainted error? {  string srcFileName = \"./files/sample.csv\";  io:WritableCSVChannel wCsvChannel =  check io:openWritableCsvFile(srcFileName);  string[][] data = [[\"1\", \"James\", \"10000\"], [\"2\", \"Nathan\", \"150000\"],  [\"3\", \"Ronald\", \"120000\"], [\"4\", \"Roy\", \"6000\"],  [\"5\", \"Oliver\", \"1100000\"]];  writeDataToCSVChannel(wCsvChannel, ...data);  closeWritableCSVChannel(wCsvChannel);  io:ReadableCSVChannel rCsvChannel =  check io:openReadableCsvFile(srcFileName);  io:println(\"Start processing the CSV file from \", srcFileName);  var processedResult = process(rCsvChannel);  if (processedResult is error) {  log:printError(\"An error occurred while processing the records: \",  err = processedResult);  }  io:println(\"Processing completed.\");  closeReadableCSVChannel(rCsvChannel);  io:ReadableCSVChannel rCsvChannel2 =  check io:openReadableCsvFile(srcFileName);  io:println(\"Reading \" + srcFileName + \" as a table\");  var tblResult = rCsvChannel2.getTable(Employee);  if (tblResult is table<record {}>) {  table<Employee> empTable = <table<Employee>> tblResult;  foreach var rec in empTable {  io:println(rec);  }  } else {  log:printError(\"An error occurred while creating table: \",  err = tblResult);  }  closeReadableCSVChannel(rCsvChannel2);  string targetFileName = \"./files/output.csv\";  io:WritableCSVChannel wCsvChannel2 =  check io:openWritableCsvFile(targetFileName);  io:println(\"Creating a table and adding data\");  table<Employee> employeeTable = createTableAndAddData();  io:println(\"Writing the table to \" + targetFileName);  foreach var entry in employeeTable {  string[] rec = [entry.id, entry.name, entry.salary.toString()];  writeDataToCSVChannel(wCsvChannel2, rec);  }  closeWritableCSVChannel(wCsvChannel2); } function createTableAndAddData() returns table<Employee> {  table<Employee> employeeTable = table {};  Employee[] employees = [];  employees[0] = {id: \"1\", name: \"Allen\", salary: 300000.0};  employees[1] = {id: \"2\", name: \"Wallace\", salary: 200000.0};  employees[2] = {id: \"3\", name: \"Sheldon\", salary: 1000000.0};  foreach var employee in employees {  var result = employeeTable.add(employee);  if (result is error) {  log:printError(\"Error occurred while adding data to table: \",  err = result);  }  }  return employeeTable; } function writeDataToCSVChannel(io:WritableCSVChannel csvChannel,  string[]... data) {  foreach var rec in data {  var returnedVal = csvChannel.write(rec);  if (returnedVal is error) {  log:printError(\"Error occurred while writing to target file: \",  err = returnedVal);  }  } } function closeReadableCSVChannel(io:ReadableCSVChannel csvChannel) {  var result = csvChannel.close();  if (result is error) {  log:printError(\"Error occurred while closing the channel: \",  err = result);  } } function closeWritableCSVChannel(io:WritableCSVChannel csvChannel) {  var result = csvChannel.close();  if (result is error) {  log:printError(\"Error occurred while closing the channel: \",  err = result);  } }    CSV I/O  This sample demonstrates how to read/write from/to a CSV file using the CSV channel of the I/O API    import ballerina/io; import ballerina/log;    type Employee record {  string id;  string name;  float salary; };    function process(io:ReadableCSVChannel csvChannel)  returns @tainted error? {    This function reads records one by one and prints the records.   while (csvChannel.hasNext()) {    Reads all the records from the provided file  until there are no more records.   var records = check csvChannel.getNext();    Reads the records.   if (records is string[]) {  io:println(records);  }  }  return; }    Prints the records.   public function main() returns @tainted error? {  string srcFileName = \"./files/sample.csv\";    Specifies the location of the .CSV file.   io:WritableCSVChannel wCsvChannel =  check io:openWritableCsvFile(srcFileName);  string[][] data = [[\"1\", \"James\", \"10000\"], [\"2\", \"Nathan\", \"150000\"],  [\"3\", \"Ronald\", \"120000\"], [\"4\", \"Roy\", \"6000\"],  [\"5\", \"Oliver\", \"1100000\"]];  writeDataToCSVChannel(wCsvChannel, ...data);  closeWritableCSVChannel(wCsvChannel);    Opens a CSV channel in the write mode and writes some data to  the ./files/sample.csv file for later use.  The record separator of the .CSV file is a  new line and the field separator is a comma (,).   io:ReadableCSVChannel rCsvChannel =  check io:openReadableCsvFile(srcFileName);  io:println(\"Start processing the CSV file from \", srcFileName);  var processedResult = process(rCsvChannel);  if (processedResult is error) {  log:printError(\"An error occurred while processing the records: \",  err = processedResult);  }  io:println(\"Processing completed.\");    Opens a CSV channel in the read mode, which is the default mode.   closeReadableCSVChannel(rCsvChannel);    Closes the CSV channel.   io:ReadableCSVChannel rCsvChannel2 =  check io:openReadableCsvFile(srcFileName);    Opens a CSV channel in the read mode, which is the default mode.   io:println(\"Reading \" + srcFileName + \" as a table\");  var tblResult = rCsvChannel2.getTable(Employee);  if (tblResult is table<record {}>) {  table<Employee> empTable = <table<Employee>> tblResult;  foreach var rec in empTable {  io:println(rec);  }  } else {  log:printError(\"An error occurred while creating table: \",  err = tblResult);  }  closeReadableCSVChannel(rCsvChannel2);    Reads the .CSV file as a table.   string targetFileName = \"./files/output.csv\";  io:WritableCSVChannel wCsvChannel2 =  check io:openWritableCsvFile(targetFileName);  io:println(\"Creating a table and adding data\");  table<Employee> employeeTable = createTableAndAddData();  io:println(\"Writing the table to \" + targetFileName);  foreach var entry in employeeTable {  string[] rec = [entry.id, entry.name, entry.salary.toString()];  writeDataToCSVChannel(wCsvChannel2, rec);  }  closeWritableCSVChannel(wCsvChannel2); }    Opens a CSV channel in the “write” mode and writes the table to a .CSV file.   function createTableAndAddData() returns table<Employee> {  table<Employee> employeeTable = table {};  Employee[] employees = [];  employees[0] = {id: \"1\", name: \"Allen\", salary: 300000.0};  employees[1] = {id: \"2\", name: \"Wallace\", salary: 200000.0};  employees[2] = {id: \"3\", name: \"Sheldon\", salary: 1000000.0};  foreach var employee in employees {  var result = employeeTable.add(employee);  if (result is error) {  log:printError(\"Error occurred while adding data to table: \",  err = result);  }  }  return employeeTable; }    Creates a table and adds some data.   function writeDataToCSVChannel(io:WritableCSVChannel csvChannel,  string[]... data) {  foreach var rec in data {  var returnedVal = csvChannel.write(rec);  if (returnedVal is error) {  log:printError(\"Error occurred while writing to target file: \",  err = returnedVal);  }  } }    Writes data to a given CSV Channel.   function closeReadableCSVChannel(io:ReadableCSVChannel csvChannel) {  var result = csvChannel.close();  if (result is error) {  log:printError(\"Error occurred while closing the channel: \",  err = result);  } }    Closes the Readable CSV channel.   function closeWritableCSVChannel(io:WritableCSVChannel csvChannel) {  var result = csvChannel.close();  if (result is error) {  log:printError(\"Error occurred while closing the channel: \",  err = result);  } }    Closes the Writable CSV channel.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run csv_io.bal Start processing the CSV file from ./files/sample.csv 1 James 10000 2 Nathan 150000 3 Ronald 120000 4 Roy 6000 5 Oliver 1100000 Processing completed. Reading ./files/sample.csv as a table id=1 name=James salary=10000.0 id=2 name=Nathan salary=150000.0 id=3 name=Ronald salary=120000.0 id=4 name=Roy salary=6000.0 id=5 name=Oliver salary=1100000.0 Creating a table and adding data Writing the table to ./files/output.csv"},{"page":"/learn/by-example/deprecation.html","name":"Deprecation","summary":"In Ballerina, type definitions, functions, object methods, and constants can be deprecated using the @deprecated annotation.\n The compiler will generate warnings if a user uses a deprecated construct. If the deprecated construct contains documentation,\n the user has to add some additional documentation called Deprecated documentation.\n The Deprecated documentation should ideally ...","content":"/  /  / Deprecation  import ballerina/io; # Country code for Sri Lanka. # # Deprecated # This constant is deprecated. Use the constant `LK` instead. @deprecated public const string LKA = \"LKA\";# New country code for Sri Lanka. public const string LK = \"LK\";# Country code for USA. public const string USA = \"USA\"; public type CountryCode LK|LKA|USA; @deprecated public type Address record {|  string street;  string city;  CountryCode countryCode; |}; @deprecated public type Person object {  public string firstName = \"John\";  public string lastName = \"Doe\";  Address addr = {  street: \"Palm Grove\",  city: \"Colombo 3\",  countryCode: LKA  };  @deprecated  public function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }}; # Creates and returns a `Person` object given the parameters. # # + fname - First name of the person # + lname - Last name of the person # + street - Street the person is living at # + city - The city the person is living in # + countryCode - The country code for the country the person is living in # + return - A new `Person` object # # # Deprecated # This function is deprecated since the `Person` type is deprecated. @deprecated public function createPerson(string fname, string lname, string street,  string city, CountryCode countryCode) returns Person {  Person p = new; p.firstName = fname;  p.lastName = lname;  p.addr = {street, city, countryCode};  return p; }public function main() {  Person p = createPerson(\"Jane\", \"Doe\", \"Castro Street\", \"Mountain View\", USA);  io:println(p.getFullName());}    Deprecation  In Ballerina, type definitions, functions, object methods, and constants can be deprecated using the @deprecated annotation.  The compiler will generate warnings if a user uses a deprecated construct. If the deprecated construct contains documentation,  the user has to add some additional documentation called Deprecated documentation.  The Deprecated documentation should ideally include details on why the construct was deprecated and suitable alternate options, which should be used instead.    import ballerina/io;    # Country code for Sri Lanka. # # Deprecated # This constant is deprecated. Use the constant `LK` instead. @deprecated public const string LKA = \"LKA\";    The constant LKA is marked as deprecated using the @deprecated annotation.  Since it has documentation, the # # Deprecated documentation needs to be added as well.  This will appear in the generated documentation.   # New country code for Sri Lanka. public const string LK = \"LK\";    # Country code for USA. public const string USA = \"USA\";    public type CountryCode LK|LKA|USA;    The type definition contains both the deprecated constant and its replacement.   @deprecated public type Address record {|  string street;  string city;  CountryCode countryCode; |};    The Address record type is deprecated, but does not have the # # Deprecated documentation.   @deprecated public type Person object {  public string firstName = \"John\";  public string lastName = \"Doe\";    The Person object type is deprecated, but does not have the # # Deprecated documentation.   Address addr = {  street: \"Palm Grove\",  city: \"Colombo 3\",    Usage of the deprecated record Address.   countryCode: LKA  };    Usage of the deprecated constant LKA.   @deprecated  public function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }    Object methods can also be deprecated.   };    # Creates and returns a `Person` object given the parameters. # # + fname - First name of the person # + lname - Last name of the person # + street - Street the person is living at # + city - The city the person is living in # + countryCode - The country code for the country the person is living in # + return - A new `Person` object # # # Deprecated # This function is deprecated since the `Person` type is deprecated. @deprecated public function createPerson(string fname, string lname, string street,  string city, CountryCode countryCode) returns Person {    The function createPerson is marked as deprecated using the @deprecated annotation.  Since it has documentation, the # # Deprecated documentation needs to be added as well.   Person p = new;    Usage of the deprecated object Person.   p.firstName = fname;  p.lastName = lname;  p.addr = {street, city, countryCode};  return p; }    public function main() {    Person p = createPerson(\"Jane\", \"Doe\", \"Castro Street\", \"Mountain View\", USA);    Usage of the deprecated object Person and function createPerson.   io:println(p.getFullName());    Usage of the deprecated object method getFullName   }    # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run deprecation.bal warning: .::deprecation.bal:35:5: usage of construct 'Address' is deprecated warning: .::deprecation.bal:39:22: usage of construct 'LKA' is deprecated warning: .::deprecation.bal:68:5: usage of construct 'Person' is deprecated warning: .::deprecation.bal:78:5: usage of construct 'Person' is deprecated warning: .::deprecation.bal:78:16: usage of construct 'createPerson' is deprecated warning: .::deprecation.bal:81:16: usage of construct 'Person.getFullName' is deprecated Running executables    Jane Doe"},{"page":"/learn/by-example/different-payload-types.html","name":"Handling Different Payload Types","summary":"Ballerina supports different payload types to be used directly with HTTP client actions\n(eg: POST, PUT, DELETE etc..) and service respond calls.Client endpoint.Service to test HTTP client remote functions with different payload types.GET remote function without any payload.GET remote function with request as message.POST remote function without any payload.POST remote function ...","content":"/  /  / Handling Different Payload Types  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime; http:Client clientEP = new (\"http://localhost:9091/backEndService\"); service actionService on new http:Listener(9090) { resource function messageUsage(http:Caller caller, http:Request req) {  var response = clientEP->get(\"/greeting\");  handleResponse(response);  http:Request request = new;  response = clientEP->get(\"/greeting\", message = request);  handleResponse(response);  response = clientEP->post(\"/echo\", ());  handleResponse(response);  response = clientEP->post(\"/echo\", \"Sample Text\");  handleResponse(response);  response = clientEP->post(\"/echo\", xml `<yy>Sample Xml</yy>`);  handleResponse(response);  response = clientEP->post(\"/echo\", {name: \"apple\", color: \"red\"});  handleResponse(response);  string textVal = \"Sample Text\";  byte[] binaryValue = textVal.toBytes();  response = clientEP->post(\"/echo\", binaryValue);  handleResponse(response);  var bChannel = io:openReadableFile(\"./files/logo.png\"); if (bChannel is io:ReadableByteChannel) {  response = clientEP->post(\"/image\", <@untainted>bChannel);  handleResponse(response);  mime:Entity part1 = new;  part1.setJson({\"name\": \"Jane\"});  mime:Entity part2 = new;  part2.setText(\"Hello\");  mime:Entity[] bodyParts = [part1, part2];  response = clientEP->post(\"/echo\", bodyParts);  handleResponse(response); var result = caller->respond(\"Client actions successfully executed!\");  handleError(result);  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>bChannel.detail()?.message);  var result = caller->respond(res);  handleError(result);  }  } } service backEndService on new http:Listener(9091) { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/greeting\"  }  resource function replyText(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } @http:ResourceConfig {  methods: [\"POST\"],  path: \"/echo\"  }  resource function directResponse(http:Caller caller, http:Request req) {  if (req.hasHeader(\"content-type\")) {  string baseType = getBaseType(req.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var returnValue = req.getTextPayload();  string textValue = \"\";  if (returnValue is string) {  textValue = returnValue;  } else {  textValue = <string>returnValue.detail()?.message;  }  var result = caller->respond(<@untainted>textValue);  handleError(result);  } else if (mime:APPLICATION_XML == baseType) {  var xmlValue = req.getXmlPayload();  if (xmlValue is xml) {  var result = caller->respond(<@untainted>xmlValue);  handleError(result);  } else {  sendErrorMsg(caller, xmlValue);  }  } else if (mime:APPLICATION_JSON == baseType) {  var jsonValue = req.getJsonPayload();  if (jsonValue is json) {  var result = caller->respond(<@untainted>jsonValue);  handleError(result);  } else {  sendErrorMsg(caller, jsonValue);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var blobValue = req.getBinaryPayload();  if (blobValue is byte[]) {  var result = caller->respond(<@untainted>blobValue);  handleError(result);  } else {  sendErrorMsg(caller, blobValue);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  var bodyParts = req.getBodyParts();  if (bodyParts is mime:Entity[]) {  var result = caller->respond(<@untainted>bodyParts);  handleError(result);  } else {  sendErrorMsg(caller, bodyParts);  }  }  } else {  var result = caller->respond(());  handleError(result);  }  } @http:ResourceConfig {  methods: [\"POST\"],  path: \"/image\"  }  resource function sendByteChannel(http:Caller caller, http:Request req) {  var bytes = req.getBinaryPayload();  if (bytes is byte[]) {  http:Response response = new;  response.setBinaryPayload(<@untainted>bytes,  contentType = mime:IMAGE_PNG);  var result = caller->respond(response);  handleError(result);  } else {  sendErrorMsg(caller, bytes);  }  } } function handleResponse(http:Response|error response) {  if (response is http:Response) {  if (response.hasHeader(\"content-type\")) {  string baseType = getBaseType(response.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", payload);  }  } else if (mime:APPLICATION_XML == baseType) {  var payload = response.getXmlPayload();  if (payload is xml) {  string strValue = io:sprintf(\"%s\", payload);  log:printInfo(\"Xml data: \" + strValue);  } else {  log:printError(\"Error in parsing xml data\", payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  var payload = response.getJsonPayload();  if (payload is json) {  log:printInfo(\"Json data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing json data\", payload);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Response contains binary data: \" + payload);  } else {  log:printError(\"Error in parsing binary data\", payload);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  log:printInfo(\"Response contains body parts: \");  var payload = response.getBodyParts();  if (payload is mime:Entity[]) {  handleBodyParts(payload);  } else {  log:printError(\"Error in parsing multipart data\", payload);  }  } else if (mime:IMAGE_PNG == baseType) {  log:printInfo(\"Response contains an image\");  }  } else {  log:printInfo(\"Entity body is not available\");  }  } else {  log:printError(response.reason(), response);  } }function sendErrorMsg(http:Caller caller, error err) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>err.detail()?.message);  var result = caller->respond(res);  handleError(result); }function handleError(error? result) {  if (result is error) {  log:printError(result.reason(), result);  } } function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } } function handleBodyParts(mime:Entity[] bodyParts) {  foreach var bodyPart in bodyParts {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_JSON == baseType) {  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"Json Part: \" + payload.toJsonString());  } else {  log:printError(payload.reason(), payload);  }  }  if (mime:TEXT_PLAIN == baseType) {  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text Part: \" + payload);  } else {  log:printError(payload.reason(), payload);  }  }  } }    Handling Different Payload Types  Ballerina supports different payload types to be used directly with HTTP client actions (eg: POST, PUT, DELETE etc..) and service respond calls.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEP = new (\"http://localhost:9091/backEndService\");    Client endpoint.   service actionService on new http:Listener(9090) {    Service to test HTTP client remote functions with different payload types.   resource function messageUsage(http:Caller caller, http:Request req) {    var response = clientEP->get(\"/greeting\");  handleResponse(response);    GET remote function without any payload.   http:Request request = new;  response = clientEP->get(\"/greeting\", message = request);  handleResponse(response);    GET remote function with request as message.   response = clientEP->post(\"/echo\", ());  handleResponse(response);    POST remote function without any payload.   response = clientEP->post(\"/echo\", \"Sample Text\");  handleResponse(response);    POST remote function with text as payload.   response = clientEP->post(\"/echo\", xml `<yy>Sample Xml</yy>`);  handleResponse(response);    POST remote function with xml as payload.   response = clientEP->post(\"/echo\", {name: \"apple\", color: \"red\"});  handleResponse(response);    POST remote function with json as payload.   string textVal = \"Sample Text\";  byte[] binaryValue = textVal.toBytes();  response = clientEP->post(\"/echo\", binaryValue);  handleResponse(response);    POST remote function with byte[] as payload.   var bChannel = io:openReadableFile(\"./files/logo.png\");    Get a byte channel to a given file.   if (bChannel is io:ReadableByteChannel) {    response = clientEP->post(\"/image\", <@untainted>bChannel);  handleResponse(response);    POST remote function with byte channel as payload. Since the file path is static untaint is used to denote that the byte channel is trusted .   mime:Entity part1 = new;  part1.setJson({\"name\": \"Jane\"});    Create a JSON body part.   mime:Entity part2 = new;  part2.setText(\"Hello\");    Create a text body part.   mime:Entity[] bodyParts = [part1, part2];  response = clientEP->post(\"/echo\", bodyParts);  handleResponse(response);    POST remote function with body parts as payload.   var result = caller->respond(\"Client actions successfully executed!\");  handleError(result);  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>bChannel.detail()?.message);  var result = caller->respond(res);  handleError(result);  }  } }    service backEndService on new http:Listener(9091) {    Back end service that send out different payload types as response.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/greeting\"  }  resource function replyText(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  }    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/echo\"  }  resource function directResponse(http:Caller caller, http:Request req) {  if (req.hasHeader(\"content-type\")) {  string baseType = getBaseType(req.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var returnValue = req.getTextPayload();  string textValue = \"\";  if (returnValue is string) {  textValue = returnValue;  } else {  textValue = <string>returnValue.detail()?.message;  }  var result = caller->respond(<@untainted>textValue);  handleError(result);  } else if (mime:APPLICATION_XML == baseType) {  var xmlValue = req.getXmlPayload();  if (xmlValue is xml) {  var result = caller->respond(<@untainted>xmlValue);  handleError(result);  } else {  sendErrorMsg(caller, xmlValue);  }  } else if (mime:APPLICATION_JSON == baseType) {  var jsonValue = req.getJsonPayload();  if (jsonValue is json) {  var result = caller->respond(<@untainted>jsonValue);  handleError(result);  } else {  sendErrorMsg(caller, jsonValue);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var blobValue = req.getBinaryPayload();  if (blobValue is byte[]) {  var result = caller->respond(<@untainted>blobValue);  handleError(result);  } else {  sendErrorMsg(caller, blobValue);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  var bodyParts = req.getBodyParts();  if (bodyParts is mime:Entity[]) {  var result = caller->respond(<@untainted>bodyParts);  handleError(result);  } else {  sendErrorMsg(caller, bodyParts);  }  }  } else {  var result = caller->respond(());  handleError(result);  }  }    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/image\"  }  resource function sendByteChannel(http:Caller caller, http:Request req) {  var bytes = req.getBinaryPayload();  if (bytes is byte[]) {  http:Response response = new;  response.setBinaryPayload(<@untainted>bytes,  contentType = mime:IMAGE_PNG);  var result = caller->respond(response);  handleError(result);  } else {  sendErrorMsg(caller, bytes);  }  } }    function handleResponse(http:Response|error response) {  if (response is http:Response) {    Handle response data received from HTTP client remote functions.   if (response.hasHeader(\"content-type\")) {  string baseType = getBaseType(response.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", payload);  }  } else if (mime:APPLICATION_XML == baseType) {  var payload = response.getXmlPayload();  if (payload is xml) {  string strValue = io:sprintf(\"%s\", payload);  log:printInfo(\"Xml data: \" + strValue);  } else {  log:printError(\"Error in parsing xml data\", payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  var payload = response.getJsonPayload();  if (payload is json) {  log:printInfo(\"Json data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing json data\", payload);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Response contains binary data: \" + payload);  } else {  log:printError(\"Error in parsing binary data\", payload);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  log:printInfo(\"Response contains body parts: \");  var payload = response.getBodyParts();  if (payload is mime:Entity[]) {  handleBodyParts(payload);  } else {  log:printError(\"Error in parsing multipart data\", payload);  }  } else if (mime:IMAGE_PNG == baseType) {  log:printInfo(\"Response contains an image\");  }  } else {  log:printInfo(\"Entity body is not available\");  }  } else {  log:printError(response.reason(), response);  } }    Print the content type of the received data.   function sendErrorMsg(http:Caller caller, error err) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>err.detail()?.message);  var result = caller->respond(res);  handleError(result); }    function handleError(error? result) {  if (result is error) {  log:printError(result.reason(), result);  } }    function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }    Get the base type from a given content type.   function handleBodyParts(mime:Entity[] bodyParts) {  foreach var bodyPart in bodyParts {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_JSON == baseType) {  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"Json Part: \" + payload.toJsonString());  } else {  log:printError(payload.reason(), payload);  }  }  if (mime:TEXT_PLAIN == baseType) {  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text Part: \" + payload);  } else {  log:printError(payload.reason(), payload);  }  }  } }    Loop through body parts and print its content.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run different_payload_types.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9091 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2018-12-04 21:17:59,696 INFO [ballerina/log] - Text data: Hello 2018-12-04 21:17:59,717 INFO [ballerina/log] - Text data: Hello 2018-12-04 21:17:59,727 INFO [ballerina/log] - Entity body is not available 2018-12-04 21:17:59,737 INFO [ballerina/log] - Text data: Sample Text 2018-12-04 21:18:00,005 INFO [ballerina/log] - Xml data: <yy>Sample Xml</yy> 2018-12-04 21:18:00,026 INFO [ballerina/log] - Json data: {\"name\":\"apple\", \"color\":\"red\"} 2018-12-04 21:18:00,036 INFO [ballerina/log] - Response contains binary data: Sample Text 2018-12-04 21:18:00,051 INFO [ballerina/log] - Response contains an image 2018-12-04 21:18:00,081 INFO [ballerina/log] - Response contains body parts: 2018-12-04 21:18:00,084 INFO [ballerina/log] - Json Part: {\"name\":\"Jane\"} 2018-12-04 21:18:00,085 INFO [ballerina/log] - Text Part: Hello"},{"page":"/learn/by-example/docker-deployment.html","name":"Docker Deployment","summary":"Ballerina supports generating Docker images, Dockerfile based on annotations.\nA single Ballerina module is mapped to a single Docker Image.\nDocker should be configured to run the sample.Adding the @docker:Expose{} annotation to a listener endpoint exposes the endpoint port.Adding the @docker:Config{} annotation to a service modifies the generated Docker image and Dockerfile.\nThis ...","content":"/  /  / Docker Deployment  import ballerina/http; import ballerina/log; import ballerina/docker; @docker:Expose {} listener http:Listener helloWorldEP = new(9090); @docker:Config {  name: \"helloworld\",  tag: \"v1.0\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {  resource function sayHello(http:Caller outboundEP, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello World from Docker ! \\n\");  var responseResult = outboundEP->respond(response);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    Docker Deployment  Ballerina supports generating Docker images, Dockerfile based on annotations. A single Ballerina module is mapped to a single Docker Image. Docker should be configured to run the sample.    import ballerina/http; import ballerina/log; import ballerina/docker;    @docker:Expose {} listener http:Listener helloWorldEP = new(9090);    Adding the @docker:Expose{} annotation to a listener endpoint exposes the endpoint port.   @docker:Config {    Adding the @docker:Config{} annotation to a service modifies the generated Docker image and Dockerfile. This sample generates a Docker image as helloworld:v1.0.0.   name: \"helloworld\",    Docker image name should be helloworld.   tag: \"v1.0\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {  resource function sayHello(http:Caller outboundEP, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello World from Docker ! \\n\");  var responseResult = outboundEP->respond(response);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    Docker image version should be v1.0.   # Build the Ballerina program to generate the Docker image and Dockerfile. $ ballerina build docker_deployment.bal Compiling source \tdocker_deployment.bal Generating executables \tdocker_deployment.jar    Generating docker artifacts... \t@docker - complete 2/2 Run the following command to start a Docker container: \tdocker run -d -p 9090:9090 helloworld:v1.0    # Verify if the Docker image is generated $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE helloworld v1.0 8d5b2f26145b 2 seconds ago 127MB    # Run the generated Docker image $ docker run -d -p 9090:9090 helloworld:v1.0    # Access the service $ curl http://localhost:9090/helloWorld/sayHello Hello World from Docker!"},{"page":"/learn/by-example/elvis-operator.html","name":"Elvis","summary":"The Elvis operator is a conditional operator that handles nil. It evaluates an expression\n and if the value is nil (()), it executes the second expression.The elvis operator takes two operands and uses the ‘?:’ symbol to form it as shown in the syntax below.\n      ...","content":"/  /  / Elvis  import ballerina/io;public function main() {  string? x = ();  string output = x is string ? \"value is string: \" + x : \"value is nil\";  io:println(\"The output from the type-guard: \" + output);  string elvisOutput = x ?: \"value is nil\";  io:println(\"The output from the elvis operator: \" + elvisOutput); }    Elvis  The Elvis operator is a conditional operator that handles nil. It evaluates an expression  and if the value is nil (()), it executes the second expression.  The elvis operator takes two operands and uses the ‘?:’ symbol to form it as shown in the syntax below.  expression ?: expressionIfNil    import ballerina/io;    public function main() {  string? x = ();    string output = x is string ? \"value is string: \" + x : \"value is nil\";  io:println(\"The output from the type-guard: \" + output);    If you need to get the value of x if it is a string, or assign some  other string value if x is (), you can do it using the type-guard  as follows.   string elvisOutput = x ?: \"value is nil\";  io:println(\"The output from the elvis operator: \" + elvisOutput); }    You can achieve the same using the elvis operator as follows.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run elvis_operator.bal The output from the type-guard: value is nil The output from the elvis operator: value is nil"},{"page":"/learn/by-example/directory-listener.html","name":"Directory Listener","summary":"The Directory Listener is used to listen to a directory in the local file system. It notifies when new files are created in the directory or when the existing files are deleted or modified.In this example, the listener monitors any modifications done to a specific directoy.\n Before running the example, ...","content":"/  /  / Directory Listener  import ballerina/file; import ballerina/log; listener file:Listener inFolder = new ({  path: \"/home/ballerina/fs-server-connector/observed-dir\",  recursive: false }); service localObserver on inFolder {  resource function onCreate(file:FileEvent m) {  string msg = \"Create: \" + m.name;  log:printInfo(msg);  }  resource function onDelete(file:FileEvent m) {  string msg = \"Delete: \" + m.name;  log:printInfo(msg);  }  resource function onModify(file:FileEvent m) {  string msg = \"Modify: \" + m.name;  log:printInfo(msg);  } }    Directory Listener  The Directory Listener is used to listen to a directory in the local file system. It notifies when new files are created in the directory or when the existing files are deleted or modified.    import ballerina/file; import ballerina/log;    listener file:Listener inFolder = new ({  path: \"/home/ballerina/fs-server-connector/observed-dir\",  recursive: false });    In this example, the listener monitors any modifications done to a specific directoy.  Before running the example, change the value of the ‘path’ field  to indicate the path of the directory that you want the listener to monitor.  As the recursive property is set to false,  the listener does not monitor the child directories of the main directory  that it listens to.   service localObserver on inFolder {    The directory listener should have at least one of these predefined resources.   resource function onCreate(file:FileEvent m) {  string msg = \"Create: \" + m.name;  log:printInfo(msg);  }    This resource is invoked once a new file is created in the listening directory.   resource function onDelete(file:FileEvent m) {  string msg = \"Delete: \" + m.name;  log:printInfo(msg);  }    This resource is invoked once an existing file is deleted from the listening directory.   resource function onModify(file:FileEvent m) {  string msg = \"Modify: \" + m.name;  log:printInfo(msg);  } }    This resource is invoked once an existing file is modified in the listening directory.   # Before running the sample, create a new file called `test1.txt` in the directory called `observed-dir` and modify and delete it. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run directory_listener.bal Create: /home/ballerina/fs-server-connector/observed-dir/test1.txt Modify: /home/ballerina/fs-server-connector/observed-dir/test1.txt Delete: /home/ballerina/fs-server-connector/observed-dir/test1.txt"},{"page":"/learn/by-example/equality.html","name":"Equality","summary":"Ballerina provides the below equality operators:\n == for deep value equality of anydata|error typed values.\n === for reference equality.\n != and !== as the negations.The == and != are used with the values of compatible anydata|error types and serves as deep value equality checks.The === and !== are used with ...","content":"/  /  / Equality  import ballerina/io;type Employee record {  string name;  int id; };type Person record {  string name; };final Employee globalEmployee = {name: \"John\", id: 2102};public function main() {  int i1 = 1;  int i2 = 1;  boolean isEqual = i1 == i2;  io:println(i1, \" == \", i2, \" is \", isEqual); int i3 = 2;  boolean isNotEqual = i1 != i3;  io:println(i1, \" != \", i3, \" is \", isNotEqual); [string|int, float, boolean] t1 = [1, 1.0, false];  [int, float|string, boolean] t2 = [1, 1.0, false];  isEqual = t1 == t2;  io:println(t1, \" == \", t2, \" is \", isEqual); [int, float|string, boolean] t3 = [11, 1.0, true];  isNotEqual = t1 != t3;  io:println(t1, \" != \", t3, \" is \", isNotEqual); Employee e1 = {name: \"Jane\", id: 1100};  Employee e2 = {name: \"Jane\", id: 1100};  isNotEqual = e1 != e2;  io:println(e1, \" != \", e2, \" is \", isNotEqual); Employee e3 = {name: \"Anne\", id: 1100};  isEqual = e1 == e3;  io:println(e1, \" == \", e3, \" is \", isEqual);  Employee e4 = getGlobalEmployee();  Person e5 = getGlobalEmployee();  boolean isRefEqual = e4 === e5;  io:println(\"e4 === e5 is \", isRefEqual); e4 = {name: \"John\", id: 2102};  boolean isNotRefEqual = e4 !== e5;  io:println(\"e4 !== e5 is \", isNotRefEqual);  float f1 = 1.1;  float f2 = 1.1;  isRefEqual = f1 === f2;  io:println(\"f1 === f2 is \", isRefEqual); f2 = 12.1;  isNotRefEqual = f1 !== f2;  io:println(\"f1 !== f2 is \", isNotRefEqual); }function getGlobalEmployee() returns Employee {  return globalEmployee; }    Equality  Ballerina provides the below equality operators:  == for deep value equality of anydata|error typed values.  === for reference equality.  != and !== as the negations.    import ballerina/io;    type Employee record {  string name;  int id; };    type Person record {  string name; };    final Employee globalEmployee = {name: \"John\", id: 2102};    public function main() {    int i1 = 1;  int i2 = 1;  boolean isEqual = i1 == i2;  io:println(i1, \" == \", i2, \" is \", isEqual);    The == and != are used with the values of compatible anydata|error types and serves as deep value equality checks.   int i3 = 2;  boolean isNotEqual = i1 != i3;  io:println(i1, \" != \", i3, \" is \", isNotEqual);    [string|int, float, boolean] t1 = [1, 1.0, false];  [int, float|string, boolean] t2 = [1, 1.0, false];  isEqual = t1 == t2;  io:println(t1, \" == \", t2, \" is \", isEqual);    [int, float|string, boolean] t3 = [11, 1.0, true];  isNotEqual = t1 != t3;  io:println(t1, \" != \", t3, \" is \", isNotEqual);    Employee e1 = {name: \"Jane\", id: 1100};  Employee e2 = {name: \"Jane\", id: 1100};  isNotEqual = e1 != e2;  io:println(e1, \" != \", e2, \" is \", isNotEqual);    Employee e3 = {name: \"Anne\", id: 1100};  isEqual = e1 == e3;  io:println(e1, \" == \", e3, \" is \", isEqual);    Employee e4 = getGlobalEmployee();  Person e5 = getGlobalEmployee();  boolean isRefEqual = e4 === e5;  io:println(\"e4 === e5 is \", isRefEqual);    The === and !== are used with values of compatible types and serves as reference equality checks.   e4 = {name: \"John\", id: 2102};  boolean isNotRefEqual = e4 !== e5;  io:println(\"e4 !== e5 is \", isNotRefEqual);    float f1 = 1.1;  float f2 = 1.1;  isRefEqual = f1 === f2;  io:println(\"f1 === f2 is \", isRefEqual);    === for non-reference types is the same as ==.   f2 = 12.1;  isNotRefEqual = f1 !== f2;  io:println(\"f1 !== f2 is \", isNotRefEqual); }    function getGlobalEmployee() returns Employee {  return globalEmployee; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run equality.bal 1 == 1 is true 1 != 2 is true 1 1.0 false == 1 1.0 false is true 1 1.0 false != 11 1.0 true is true name=Jane id=1100 != name=Jane id=1100 is false name=Jane id=1100 == name=Anne id=1100 is false e4 === e5 is true e4 !== e5 is true f1 === f2 is true f1 !== f2 is true"},{"page":"/learn/by-example/error-handling.html","name":"Error Handling","summary":"Ballerina distinguishes ordinary errors such as failing to open a file or\n failing to send a network response, from an exceptional condition\n in the code, such as type cast errors.\n Error handling in Ballerina incorporates two different strategies\n depending on the type of error. For ordinary errors such as failing ...","content":"/  /  / Error Handling  import ballerina/io;const ACCOUNT_NOT_FOUND = \"AccountNotFound\"; const INVALID_ACCOUNT_ID = \"InvalidAccountID\";function getAccountBalance(int accountID) returns int|error {  if (accountID < 0) {  return error(INVALID_ACCOUNT_ID, accountID = accountID);  } else if (accountID > 100) {  return error(ACCOUNT_NOT_FOUND, accountID = accountID);  }  return 600; }public function main() {  error simpleError = error(\"SimpleErrorType\", message = \"Simple error occurred\");  io:println(\"Error: \", simpleError.reason(),  \", Message: \", simpleError.detail()?.message); int|error result = getAccountBalance(-1);  if (result is int) {  io:println(\"Account Balance: \", result);  } else {  io:println(\"Error: \", result.reason(),  \", Account ID: \", result.detail()[\"accountID\"]);  } }    Error Handling  Ballerina distinguishes ordinary errors such as failing to open a file or  failing to send a network response, from an exceptional condition  in the code, such as type cast errors.  Error handling in Ballerina incorporates two different strategies  depending on the type of error. For ordinary errors such as failing to  open a file or failing to send a network response,  the error value is returned.  When the Ballerina runtime encounters exceptional conditions the runtime  panics resulting in abrupt completion of execution,  unless the error is explicitly handled.  Ballerina provides language constructs to handle both returned error values  and panics. This example demonstrates how errors can be created,  returned, and how returned errors can be handled.  Ballerina error values are immutable structured values composed of  an error reason string, a stack trace representing the execution stack  at the point at which the error value was created,  and an error detail record.    import ballerina/io;    const ACCOUNT_NOT_FOUND = \"AccountNotFound\"; const INVALID_ACCOUNT_ID = \"InvalidAccountID\";    function getAccountBalance(int accountID) returns int|error {  if (accountID < 0) {    return error(INVALID_ACCOUNT_ID, accountID = accountID);  } else if (accountID > 100) {    Return an error with “InvalidAccountID” as the reason if accountID is less than zero.   return error(ACCOUNT_NOT_FOUND, accountID = accountID);  }    Return an error with “AccountNotFound” as the reason if accountID is greater than hundred.   return 600; }    Return a value if accountID is in between zero and hundred inclusive.   public function main() {    error simpleError = error(\"SimpleErrorType\", message = \"Simple error occurred\");    Define an error of the generic error type using the default error constructor.  The error reason must be the first and only positional argument to the default error constructor and the type of the  value must be a subtype of string. Additional fields providing more details can be passed as named arguments to the constructor  and the type of each of those must be a subtype of anydata|error.   io:println(\"Error: \", simpleError.reason(),  \", Message: \", simpleError.detail()?.message);    Print the error reason and the message field from the error detail.  The .reason() and .detail() methods can be invoked on error values  to retrieve the reason and details of the error.  message is an optional field in the generic error Detail record.   int|error result = getAccountBalance(-1);    if (result is int) {  io:println(\"Account Balance: \", result);    If the result is an int, then print the value.   } else {  io:println(\"Error: \", result.reason(),  \", Account ID: \", result.detail()[\"accountID\"]);  } }    If an error is returned, print the reason and the account ID from the detail record.  Each additional error detail field provided to the error constructor is available as a field in the error detail record.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run error_handling.bal Error: SimpleErrorType, Message: Simple error occurred Error: InvalidAccountID, Account ID: -1"},{"page":"/learn/by-example/error-destructure-binding-pattern.html","name":"Error Destructure Binding Pattern","summary":"Error destructuring binding patterns are used to destructure the reason string and the detail mapping values from an\n error value, and assign the values to existing variable references.This error-destructure binding pattern will destructure an error value of the type SampleError\n and assign the values to the relevant variable references.\n The ...","content":"/  /  / Error Destructure Binding Pattern  import ballerina/io;type SampleErrorData record {  string message?;  error cause?;  string info;  boolean fatal; };type SampleError error<string, SampleErrorData>;public function main() {  string reason;  string info;  boolean fatal;  error(reason, info = info, fatal = fatal) = getSampleError();  io:println(\"Reason String: \" + reason);  io:println(\"Info: \", info);  io:println(\"Fatal: \", fatal); string reasonTwo;  map<anydata|error> params;  error(reasonTwo, ...params) = getSampleError();  io:println(\"Reason String: \", reasonTwo);  io:println(\"Detail Map: \", params);  string? detailMsg;  error(_, detailMsg = detailMsg) = getRecordConstrainedError();  io:println(\"Detail Message: \", detailMsg); }function getSampleError() returns SampleError {  SampleError e = error(\"Sample Error\", info = \"Detail Info\", fatal = true);  return e; }type Foo record {|  string message?;  error cause?;  string detailMsg;  boolean isFatal; |};function getRecordConstrainedError() returns error<string, Foo> {  error<string, Foo> e = error(\"Some Error\", detailMsg = \"Failed Message\", isFatal = true);  return e; }    Error Destructure Binding Pattern  Error destructuring binding patterns are used to destructure the reason string and the detail mapping values from an  error value, and assign the values to existing variable references.    import ballerina/io;    type SampleErrorData record {  string message?;  error cause?;  string info;  boolean fatal; };    type SampleError error<string, SampleErrorData>;    public function main() {  string reason;  string info;  boolean fatal;    error(reason, info = info, fatal = fatal) = getSampleError();  io:println(\"Reason String: \" + reason);  io:println(\"Info: \", info);  io:println(\"Fatal: \", fatal);    This error-destructure binding pattern will destructure an error value of the type SampleError  and assign the values to the relevant variable references.  The value of the reason string in the SampleError will be assigned to the variable reason.  The values in the detail mapping will be assigned to the relevant variables.   string reasonTwo;  map<anydata|error> params;    error(reasonTwo, ...params) = getSampleError();  io:println(\"Reason String: \", reasonTwo);  io:println(\"Detail Map: \", params);  The detail mapping can be destructured into an existing map<anydata|error>-typed variable by using a rest parameter.   string? detailMsg;  error(_, detailMsg = detailMsg) = getRecordConstrainedError();  io:println(\"Detail Message: \", detailMsg); }    The underscore ‘_’ sign can be used to ignore either the reason string or the detail mapping.   function getSampleError() returns SampleError {  SampleError e = error(\"Sample Error\", info = \"Detail Info\", fatal = true);  return e; }    type Foo record {|  string message?;  error cause?;  string detailMsg;  boolean isFatal; |};    function getRecordConstrainedError() returns error<string, Foo> {  error<string, Foo> e = error(\"Some Error\", detailMsg = \"Failed Message\", isFatal = true);  return e; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run error_destructure_binding_pattern.bal Reason String: Sample Error Info: Detail Info Fatal: true Reason String: Sample Error Detail Map: info=Detail Info fatal=true Detail Message: Failed Message"},{"page":"/learn/by-example/error-match-statement.html","name":"Error Match","summary":"The match statement in Ballerina only supports value-based match patterns. There are static and structured\n match patterns that can be used with the match clauses. Structured match patterns will take structured\n binding patterns for matching. Error binding pattern is one of the structured binding patterns that can be used\n with ...","content":"/  /  / Error Match  import ballerina/io;type SampleError error<string, Foo>;const INVALID_ID = \"Invalid ID\"; type InvalidIdError error<INVALID_ID, InvalidIdDetail>;type Foo record {|  string message?;  error cause?;  boolean fatal; |};type InvalidIdDetail record {|  string message?;  error cause?;  string id; |};public function main() {  [string, string] v1 = [\"Sample String\", \"Sample String 2\"];  Foo v2 = {message: \"A\", fatal: false};  error e1 = error(\"Generic Error\", message = \"Failed\");  SampleError e2 = error(\"Sample Error\", message = \"Fatal\", fatal = true);  InvalidIdError e3 = InvalidIdError(id = \"33456\"); basicMatch(v1);  basicMatch(v2);  basicMatch(e1);  basicMatch(e2);  basicMatch(e3); }function basicMatch(any|error v) {  match v {  var [tVar1, tVar2] => {  io:println(\"Matched a value with a tuple shape\");  }  var {message, fatal} => {  io:println(\"Matched a value with a record shape\");  }  var InvalidIdError(id = id) => {  io:println(\"Matched `InvalidError` id=\", id);  }  var error(reason, message = message) => {  io:println(\"Matched an error value : \",  io:sprintf(\"reason: %s, message: %s\", reason, message));  }  var error(reason, message = message, ...rest) => {  io:println(\"Matched an error value : \",  io:sprintf(\"reason: %s, rest detail: %s\", reason, rest));  }  } }    Error Match  The match statement in Ballerina only supports value-based match patterns. There are static and structured  match patterns that can be used with the match clauses. Structured match patterns will take structured  binding patterns for matching. Error binding pattern is one of the structured binding patterns that can be used  with the match statement.    import ballerina/io;    type SampleError error<string, Foo>;    const INVALID_ID = \"Invalid ID\"; type InvalidIdError error<INVALID_ID, InvalidIdDetail>;    type Foo record {|  string message?;  error cause?;  boolean fatal; |};    type InvalidIdDetail record {|  string message?;  error cause?;  string id; |};    public function main() {  [string, string] v1 = [\"Sample String\", \"Sample String 2\"];  Foo v2 = {message: \"A\", fatal: false};  error e1 = error(\"Generic Error\", message = \"Failed\");  SampleError e2 = error(\"Sample Error\", message = \"Fatal\", fatal = true);  InvalidIdError e3 = InvalidIdError(id = \"33456\");    basicMatch(v1);  basicMatch(v2);  basicMatch(e1);  basicMatch(e2);  basicMatch(e3); }    function basicMatch(any|error v) {  match v {  var [tVar1, tVar2] => {  io:println(\"Matched a value with a tuple shape\");  }  var {message, fatal} => {  io:println(\"Matched a value with a record shape\");  }    var InvalidIdError(id = id) => {  io:println(\"Matched `InvalidError` id=\", id);  }    If the variable ‘v’ contains an error values of shape that matches  InvalidIdError it will be matched to InvalidIdError indirect  error match pattern.   var error(reason, message = message) => {  io:println(\"Matched an error value : \",  io:sprintf(\"reason: %s, message: %s\", reason, message));  }    If the variable v contains an error value, it will be matched  to this pattern and the reason string and the detail record will be  destructed within the pattern block.   var error(reason, message = message, ...rest) => {  io:println(\"Matched an error value : \",  io:sprintf(\"reason: %s, rest detail: %s\", reason, rest));  }  } }    If a rest binding pattern is used, the error details that are not  matched will be recorded in a map.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run error_match_statement.bal Matched a value with a tuple shape Matched a value with a record shape Matched an error value : reason: Generic Error, message: Failed Matched an error value : reason: Sample Error, rest detail: fatal=true Matched `InvalidError` id=33456"},{"page":"/learn/by-example/error-typed-binding-pattern.html","name":"Error-Typed Binding Pattern","summary":"Error-type binding patterns are used in declaring and defining new variables by destructuring an error value.\n The error-type binding pattern statement must have an assignment expression on the right hand side.This error-type binding pattern will destructure an error of the type SampleError, and create two variables as follows:\n The value ...","content":"/  /  / Error-Typed Binding Pattern  import ballerina/io;type SampleErrorData record {  string message?;  error cause?;  string info;  boolean fatal; };type SampleError error<string, SampleErrorData>;public function main() {  var error(reason, info = info, fatal = fatal) = getSampleError();  io:println(\"Reason String: \" + reason);  io:println(\"Info: \", info);  io:println(\"Fatal: \", fatal);  var error(reasonTwo, ...params) = getSampleError();  io:println(\"Reason String: \", reasonTwo);  io:println(\"Detail Mapping: \", params);  var error(reasonThree, info = info2, ...filteredParams) = getSampleError();  io:println(\"Detail Mapping: \", filteredParams);  var error(_, detailMsg = detailMsg, isFatal = isFatal) = getRecordConstrainedError();  io:println(\"Detail Message: \", detailMsg); }function getSampleError() returns SampleError {  SampleError e = error(\"Sample Error\", info = \"Detail Msg\", fatal = true);  return e; }type Foo record {|  string message?;  error cause?;  string detailMsg;  boolean isFatal; |};function getRecordConstrainedError() returns error<string, Foo> {  error<string, Foo> e = error(\"Some Error\", detailMsg = \"Failed Message\", isFatal = true);  return e; }    Error-Typed Binding Pattern  Error-type binding patterns are used in declaring and defining new variables by destructuring an error value.  The error-type binding pattern statement must have an assignment expression on the right hand side.    import ballerina/io;    type SampleErrorData record {  string message?;  error cause?;  string info;  boolean fatal; };    type SampleError error<string, SampleErrorData>;    public function main() {    var error(reason, info = info, fatal = fatal) = getSampleError();  io:println(\"Reason String: \" + reason);  io:println(\"Info: \", info);  io:println(\"Fatal: \", fatal);    This error-type binding pattern will destructure an error of the type SampleError, and create two variables as follows:  The value of the reason string in theSampleError will be set to a new string variable reason.  The values in the detail mapping will be set to new variables info and fatal.   var error(reasonTwo, ...params) = getSampleError();  io:println(\"Reason String: \", reasonTwo);  io:println(\"Detail Mapping: \", params);    The detail mapping can also be destructured using a rest parameter.  params will be of the type map<anydata|error>, and will have the  info and fatal fields.   var error(reasonThree, info = info2, ...filteredParams) = getSampleError();  io:println(\"Detail Mapping: \", filteredParams);  When some error detail field names are provided rest parameter will only contain detail field that are not matched.   var error(_, detailMsg = detailMsg, isFatal = isFatal) = getRecordConstrainedError();  io:println(\"Detail Message: \", detailMsg); }    The underscore ‘_’ sign can be used to ignore either the reason string or the detail mapping.   function getSampleError() returns SampleError {  SampleError e = error(\"Sample Error\", info = \"Detail Msg\", fatal = true);  return e; }    type Foo record {|  string message?;  error cause?;  string detailMsg;  boolean isFatal; |};    function getRecordConstrainedError() returns error<string, Foo> {  error<string, Foo> e = error(\"Some Error\", detailMsg = \"Failed Message\", isFatal = true);  return e; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run error_type_binding_pattern.bal Reason String: Sample Error Info: Detail Msg Fatal: true Reason String: Sample Error Detail Mapping: info=Detail Msg fatal=true Detail Mapping: fatal=true Detail Message: Failed Message"},{"page":"/learn/by-example/expression-bodied-functions.html","name":"Expression-bodied Functions","summary":"A function body can be a single expression. Such a function is called an expression-bodied function and the\n expression function body takes the form => E. This is equivalent to the block function body { return E; }.Note the syntactic difference in the function body of an expression-bodied function\n compared ...","content":"/  /  / Expression-bodied Functions  import ballerina/io; function add(int a, int b) returns int => a + b;public function main() {  int sum = add(10, 20);  io:println(sum);  var toEmployee = function (Person p, string pos) returns Employee => {  name: p.fname + \" \" + p.lname,  designation: pos  }; Person john = { fname: \"John\", lname: \"Doe\", age: 25 };  Employee johnEmp = toEmployee(john, \"Software Engineer\"); io:println(johnEmp); }type Person record {|  string fname;  string lname;  int age; |};type Employee record {|  string name;  string designation; |};    Expression-bodied Functions  A function body can be a single expression. Such a function is called an expression-bodied function and the  expression function body takes the form => E. This is equivalent to the block function body { return E; }.    import ballerina/io;    function add(int a, int b) returns int => a + b;    Note the syntactic difference in the function body of an expression-bodied function  compared to a regular block function body. This is equivalent to  function add(int a, int b) returns int { return a + b; }. The static type of  the expression should either be the same or a subtype of the return type  of the function.   public function main() {    int sum = add(10, 20);  io:println(sum);    There is no difference in how you call an expression-bodied function.   var toEmployee = function (Person p, string pos) returns Employee => {  name: p.fname + \" \" + p.lname,  designation: pos  };    Anonymous functions can have expression bodies as well.  Here, an expression bodied anonymous function is used to easily map a  record to another record type.   Person john = { fname: \"John\", lname: \"Doe\", age: 25 };  Employee johnEmp = toEmployee(john, \"Software Engineer\");    io:println(johnEmp); }    type Person record {|  string fname;  string lname;  int age; |};    type Employee record {|  string name;  string designation; |};    # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run expression_bodied_functions.bal 30 name=John Doe designation=Software Engineer"},{"page":"/learn/by-example/filepath.html","name":"File Path","summary":"The Ballerina File Path API contains utility functions to manipulate the file path in a way compatible with the\n target operating system.Get the absolute representation of the path.Check whether the path is absolute.Get the base name of the path.Get the enclosing parent directory.Get the shortest path name equivalent to path ...","content":"/  /  / File Path  import ballerina/filepath; import ballerina/io;public function main() {  string absValue = checkpanic filepath:absolute(\"test.txt\");  boolean isAbs = checkpanic filepath:isAbsolute(\"/A/B/C\");  io:println(\"/A/B/C is absolute: \", isAbs);  string name = checkpanic filepath:filename(\"/A/B/C\");  io:println(\"Filename of /A/B/C: \", name); // returns C  string parentPath = checkpanic filepath:parent(\"/A/B/C\");  io:println(\"Parent of /A/B/C: \", parentPath); // returns B  string normalizedPath = checkpanic filepath:normalize(\"foo/../bar\");  io:println(\"Normalized path of foo/../bar: \", normalizedPath); // returns bar  string[] parts = checkpanic filepath:split(\"/A/B/C\");  io:println(io:sprintf(\"Path elements of /A/B/C: %s\", parts)); // returns {\"A\", \"B\", \"C\"}  string path = checkpanic filepath:build(\"/\", \"foo\", \"bar\");  io:println(\"Built path of '/', 'foo', 'bar': \", path); // On Unix : returns /foo/bar  string ext = checkpanic filepath:extension(\"path.bal\");  io:println(\"Extension of path.bal: \", ext); // returns bal  string relPath = checkpanic filepath:relative(\"a/b/c\", \"a/c/d\");  io:println(\"Relative path between 'a/b/c' and 'a/c/d': \", relPath); // On Unix : returns ../../c/d}    File Path  The Ballerina File Path API contains utility functions to manipulate the file path in a way compatible with the  target operating system.    import ballerina/filepath; import ballerina/io;    public function main() {    string absValue = checkpanic filepath:absolute(\"test.txt\");    Get the absolute representation of the path.   boolean isAbs = checkpanic filepath:isAbsolute(\"/A/B/C\");  io:println(\"/A/B/C is absolute: \", isAbs);    Check whether the path is absolute.   string name = checkpanic filepath:filename(\"/A/B/C\");  io:println(\"Filename of /A/B/C: \", name); // returns C    Get the base name of the path.   string parentPath = checkpanic filepath:parent(\"/A/B/C\");  io:println(\"Parent of /A/B/C: \", parentPath); // returns B    Get the enclosing parent directory.   string normalizedPath = checkpanic filepath:normalize(\"foo/../bar\");  io:println(\"Normalized path of foo/../bar: \", normalizedPath); // returns bar    Get the shortest path name equivalent to path by purely lexical processing.   string[] parts = checkpanic filepath:split(\"/A/B/C\");  io:println(io:sprintf(\"Path elements of /A/B/C: %s\", parts)); // returns {\"A\", \"B\", \"C\"}    Get the list of path elements joined by the OS-specific Path Separator.   string path = checkpanic filepath:build(\"/\", \"foo\", \"bar\");  io:println(\"Built path of '/', 'foo', 'bar': \", path); // On Unix : returns /foo/bar    Join any number of path elements into a single path.   string ext = checkpanic filepath:extension(\"path.bal\");  io:println(\"Extension of path.bal: \", ext); // returns bal    Get the extension of the file path.   string relPath = checkpanic filepath:relative(\"a/b/c\", \"a/c/d\");  io:println(\"Relative path between 'a/b/c' and 'a/c/d': \", relPath); // On Unix : returns ../../c/d    Returns a relative path that is logically equivalent to the target path when joined to the base path.   }    # To run this sample, navigate to the directory that contains the # `.bal` file and issue the `ballerina run` command. $ ballerina run filepath.bal On Unix: /A/B/C is absolute: true Filename of /A/B/C: C Parent of /A/B/C: /A/B Normalized path of foo/../bar: bar Path elements of /A/B/C: A B C Built path of '/', 'foo', 'bar': /foo/bar Extension of path.bal: bal Relative path between 'a/b/c' and 'a/c/d': ../../c/d    On Windows: /A/B/C is absolute: false Filename of /A/B/C: C Parent of /A/B/C: \\A\\B Normalized path of foo/../bar: bar Path elements of /A/B/C: A B C Built path of '/', 'foo', 'bar': \\foo\\bar Extension of path.bal: bal Relative path between 'a/b/c' and 'a/c/d': ..\\..\\c\\d"},{"page":"/learn/by-example/file.html","name":"File","summary":"The Ballerina File API contains functions to perform file-system operations.Get the path of the current directory.Create a new directory.Create a new directory with any none-existent parents.Create a file in the given file path.Get metadata information of the file.Check whether the file or directory of the provided path exists.Copy the file ...","content":"/  /  / File  import ballerina/file; import ballerina/filepath; import ballerina/io;public function main() {  io:println(\"Current directory: \" + file:getCurrentDirectory());  string|error createDirResults = file:createDir(\"foo\");  if (createDirResults is string) {  io:println(\"Created directory path: \" + createDirResults);  }  string dirPath = checkpanic filepath:build(\"foo\", \"bar\");  createDirResults = file:createDir(dirPath, true);  if (createDirResults is string) {  io:println(\"Created nested directory path: \" + createDirResults);  }  string|error createFileResults = file:createFile(\"bar.txt\");  if (createFileResults is string) {  io:println(\"Created file path: \" + createFileResults);  }  file:FileInfo|error fileInfoResults = file:getFileInfo(\"bar.txt\");  if (fileInfoResults is file:FileInfo) {  io:println(\"File name: \" + fileInfoResults.getName());  io:println(\"File size: \" + fileInfoResults.getSize().toString());  io:println(\"Is directory: \" + fileInfoResults.isDir().toString());  io:println(\"Modified at \" +  fileInfoResults.getLastModifiedTime().toString());  }  boolean fileExists = file:exists(\"bar.txt\");  io:println(\"bar.txt file exists: \" + fileExists.toString());  string filePath = checkpanic filepath:build(\"foo\", \"bar\", \"bar.txt\");  error? copyDirResults = file:copy(\"bar.txt\", filePath, true);  if (copyDirResults is ()) {  io:println(\"bar.txt file is copied to new path \" + filePath);  }  string newFilePath = checkpanic filepath:build(\"foo\", \"bar1.txt\");  error? renameResults = file:rename(\"bar.txt\", newFilePath);  if (renameResults is ()) {  io:println(\"bar.txt file is moved to new path \" + newFilePath);  }  string tempDirPath = file:tempDir();  io:println(\"Temporary directory: \" + tempDirPath);  file:FileInfo[]|error readDirResults = file:readDir(\"foo\");  error? removeResults = file:remove(newFilePath);  if (removeResults is ()) {  io:println(\"Remove file at \" + newFilePath);  }  removeResults = file:remove(\"foo\", true);  if (removeResults is ()) {  io:println(\"Remove foo directory with all child elements.\");  } }    File  The Ballerina File API contains functions to perform file-system operations.    import ballerina/file; import ballerina/filepath; import ballerina/io;    public function main() {    io:println(\"Current directory: \" + file:getCurrentDirectory());    Get the path of the current directory.   string|error createDirResults = file:createDir(\"foo\");  if (createDirResults is string) {  io:println(\"Created directory path: \" + createDirResults);  }    Create a new directory.   string dirPath = checkpanic filepath:build(\"foo\", \"bar\");  createDirResults = file:createDir(dirPath, true);  if (createDirResults is string) {  io:println(\"Created nested directory path: \" + createDirResults);  }    Create a new directory with any none-existent parents.   string|error createFileResults = file:createFile(\"bar.txt\");  if (createFileResults is string) {  io:println(\"Created file path: \" + createFileResults);  }    Create a file in the given file path.   file:FileInfo|error fileInfoResults = file:getFileInfo(\"bar.txt\");  if (fileInfoResults is file:FileInfo) {  io:println(\"File name: \" + fileInfoResults.getName());  io:println(\"File size: \" + fileInfoResults.getSize().toString());  io:println(\"Is directory: \" + fileInfoResults.isDir().toString());  io:println(\"Modified at \" +  fileInfoResults.getLastModifiedTime().toString());  }    Get metadata information of the file.   boolean fileExists = file:exists(\"bar.txt\");  io:println(\"bar.txt file exists: \" + fileExists.toString());    Check whether the file or directory of the provided path exists.   string filePath = checkpanic filepath:build(\"foo\", \"bar\", \"bar.txt\");  error? copyDirResults = file:copy(\"bar.txt\", filePath, true);  if (copyDirResults is ()) {  io:println(\"bar.txt file is copied to new path \" + filePath);  }    Copy the file or directory to the new path.   string newFilePath = checkpanic filepath:build(\"foo\", \"bar1.txt\");  error? renameResults = file:rename(\"bar.txt\", newFilePath);  if (renameResults is ()) {  io:println(\"bar.txt file is moved to new path \" + newFilePath);  }    Rename(Move) the file or directory to the new path.   string tempDirPath = file:tempDir();  io:println(\"Temporary directory: \" + tempDirPath);    Get the default directory used for temporary files.   file:FileInfo[]|error readDirResults = file:readDir(\"foo\");    Get the list of files in the directory.   error? removeResults = file:remove(newFilePath);  if (removeResults is ()) {  io:println(\"Remove file at \" + newFilePath);  }    Remove the file or directory in the specified file path.   removeResults = file:remove(\"foo\", true);  if (removeResults is ()) {  io:println(\"Remove foo directory with all child elements.\");  } }    Remove the directory in the specified file path with all its children.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run file.bal Current directory: /A/B Created directory path: /A/B/foo Created nested directory path: /A/B/foo/bar Created file path: /A/B/bar.txt File name: bar.txt File size: 0 Is directory: false Modified at time=1567597039000 zone=id=Z offset=0 bar.txt file exists: true bar.txt file is copied to new path foo/bar/bar.txt bar.txt file is moved to new path foo/bar1.txt Temporary directory: /var/folders/4z/xvlnvsp54ks9793d6k5_6bw40000gn/T/ Remove file at foo/bar1.txt Remove foo directory with all child elements."},{"page":"/learn/by-example/fork-variable-access.html","name":"Fork Variable Access","summary":"Workers within a fork can access the variables that are declared within the scope of that block.\n The variables can be value-type variables or reference -ype variables.\n Both value-type variables such as string, int, float, and byte and reference-type\n variables such as map, json, xml, and record are passed into ...","content":"/  /  / Fork Variable Access  import ballerina/io; public function main() {  int i = 100;  string s = \"WSO2\";  map<string> m = {\"name\": \"Bert\", \"city\": \"New York\", \"postcode\": \"10001\"}; string name = <string>m[\"name\"];  string city = <string>m[\"city\"];  string postcode = <string>m[\"postcode\"]; io:println(\"[value type variables] before fork: \" +  \"value of integer variable is [\", i, \"] \",  \"value of string variable is [\", s, \"]\"); io:println(\"[reference type variables] before fork: value \" +  \"of name is [\", name , \"] value of city is [\", city, \"] value of \" +  \"postcode is [\", postcode, \"]\");  fork {  worker W1 {  i = 23;  m[\"name\"] = \"Moose\"; fork {  worker W3 {  string street = \"Wall Street\";  m[\"street\"] = street;  i = i + 100;  }  }  wait W3;  } worker W2 {  s = \"Ballerina\";  m[\"city\"] = \"Manhattan\";  }  }  _ = wait {W1, W2};  io:println(\"[value type variables] after fork: \" +  \"value of integer variable is [\", i, \"] \",  \"value of string variable is [\", s, \"]\");  name = <string>m[\"name\"];  city = <string>m[\"city\"];  string street = <string>m[\"street\"];  io:println(\"[reference type variables] after fork: \" +  \"value of name is [\", name,  \"] value of city is [\", city, \"] value of street is [\", street,  \"] value of postcode is [\", postcode, \"]\"); }    Fork Variable Access  Workers within a fork can access the variables that are declared within the scope of that block.  The variables can be value-type variables or reference -ype variables.  Both value-type variables such as string, int, float, and byte and reference-type  variables such as map, json, xml, and record are passed into the workers as a reference to the  original data. Therefore, if you update the value of these variables within a worker, the value gets  updated for the entire function. You may wait until the worker finishes by using the wait expression.    import ballerina/io;    public function main() {    The in-scope variables can be accessed by the workers inside the fork block.   int i = 100;  string s = \"WSO2\";  map<string> m = {\"name\": \"Bert\", \"city\": \"New York\", \"postcode\": \"10001\"};    These variables can be accessed by the forked workers.   string name = <string>m[\"name\"];  string city = <string>m[\"city\"];  string postcode = <string>m[\"postcode\"];    io:println(\"[value type variables] before fork: \" +  \"value of integer variable is [\", i, \"] \",  \"value of string variable is [\", s, \"]\");    io:println(\"[reference type variables] before fork: value \" +  \"of name is [\", name , \"] value of city is [\", city, \"] value of \" +  \"postcode is [\", postcode, \"]\");    fork {  worker W1 {    Declares the fork block.   i = 23;    Changes the value of the integer variable i within the worker W1.   m[\"name\"] = \"Moose\";    Changes the value of the map variable m within the worker W1.   fork {  worker W3 {    string street = \"Wall Street\";  m[\"street\"] = street;    Changes the value of the map variable m within  the worker W3.   i = i + 100;  }  }    Changes the value of the integer variable i within  the worker W3.   wait W3;  }    Waits for the worker W3 to finish.   worker W2 {    s = \"Ballerina\";    Changes the value of the string variable s within the worker W2.   m[\"city\"] = \"Manhattan\";  }  }    Changes the value of the map variable m within the worker W2.   _ = wait {W1, W2};    Waits for both workers W1 and W2 to finish.   Prints the values after the fork block to check if the values of the  variables have changed.   io:println(\"[value type variables] after fork: \" +  \"value of integer variable is [\", i, \"] \",  \"value of string variable is [\", s, \"]\");    The value-type variables have changed since the original variables are passed in.   name = <string>m[\"name\"];  city = <string>m[\"city\"];    The internal content of the reference-type variables have got updated  since they are passed in as a reference to the workers.   string street = <string>m[\"street\"];  io:println(\"[reference type variables] after fork: \" +  \"value of name is [\", name,  \"] value of city is [\", city, \"] value of street is [\", street,  \"] value of postcode is [\", postcode, \"]\"); }    Gets the value of the new field added to the map variable m inside the worker W3.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run fork_variable_access.bal [value type variables] before fork: value of integer variable is [100] value of string variable is [WSO2] [reference type variables] before fork: value of name is [Bert] value of city is [New York] value of postcode is [10001]    # The value-type variables have changed since the original variables are passed in to the workers. [value type variables] after fork: value of integer variable is [123] value of string variable is [Ballerina]    # The content of the reference-type variables have got updated since they are passed in as a reference to the workers. [reference type variables] after fork: value of name is [Moose] value of city is [Manhattan] value of street is [Wall Street] value of postcode is [10001]"},{"page":"/learn/by-example/foreach.html","name":"Foreach","summary":"The foreach statement is a looping construct that traverses through the items of a collection of data such as\n arrays, maps, JSON, XML, and tables.The foreach statement can be used to iterate an array. Each iteration returns an element in the array.\n The index of the corresponding element is not ...","content":"/  /  / Foreach  import ballerina/io;public function main() {  io:println(\"Iterating a string array :\");  string[] fruits = [\"apple\", \"banana\", \"cherry\"];  foreach var v in fruits {  io:println(\"fruit: \", v);  } io:println(\"\\nIterating a map :\");  map<string> words = {a: \"apple\", b: \"banana\", c: \"cherry\"};  foreach var fruit in words {  io:println(fruit);  }  foreach var [k, v] in words.entries() {  io:println(\"letter: \", k, \", word: \", v);  } io:println(\"\\nIterating a JSON object :\");  json apple = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};  map<json> mapValue = <map<json>>apple;  foreach var value in mapValue {  if (value is string) {  io:println(\"string value: \", value);  } else if (value is int) {  io:println(\"int value: \", value);  } else if (value is json[]) {  io:println(\"json array value: \", value);  } else {  io:println(\"non-string value: \", value);  }  } io:println(\"\\nIterating a JSON array :\");  json[] colors = <json[]>apple.colors;  int counter = 0;  foreach var j in colors {  io:println(\"color \", counter, \": \", j);  counter += 1;  } io:println(\"\\nIterating XML :\");  xml book = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  </book>`;  counter = 0;  foreach var x in book/<*> {  io:println(\"xml at \", counter, \": \", x);  counter += 1;  } io:println(\"\\nIterating a closed integer range :\");  int endValue = 10;  int sum = 0;  foreach var i in 1 ... endValue {  sum = sum + i;  }  io:println(\"summation from 1 to \", endValue, \" is \", sum); io:println(\"\\nIterating a half open integer range :\");  sum = 0;  foreach var i in 1 ..< endValue {  sum = sum + i;  }  io:println(\"summation from 1 to \", endValue,  \" excluding \", endValue, \" is \", sum); }    Foreach  The foreach statement is a looping construct that traverses through the items of a collection of data such as  arrays, maps, JSON, XML, and tables.    import ballerina/io;    public function main() {  io:println(\"Iterating a string array :\");  string[] fruits = [\"apple\", \"banana\", \"cherry\"];    foreach var v in fruits {  io:println(\"fruit: \", v);  }    The foreach statement can be used to iterate an array. Each iteration returns an element in the array.  The index of the corresponding element is not returned.   io:println(\"\\nIterating a map :\");  map<string> words = {a: \"apple\", b: \"banana\", c: \"cherry\"};    foreach var fruit in words {  io:println(fruit);  }    Iterating a map will return the values in the map.   foreach var [k, v] in words.entries() {  io:println(\"letter: \", k, \", word: \", v);  }    Calling the .entries()' method on amapand iterating it will return the key (string) and the value as a tuple` variable. Tuple destructuring can be used to split the tuple variable into two variables.   io:println(\"\\nIterating a JSON object :\");  json apple = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};    map<json> mapValue = <map<json>>apple;  foreach var value in mapValue {  if (value is string) {  io:println(\"string value: \", value);  } else if (value is int) {  io:println(\"int value: \", value);  } else if (value is json[]) {  io:println(\"json array value: \", value);  } else {    Iterating a JSON is only supported with map<json> or json[].  To iterate a JSON, first cast it to the relevant iterable type.   io:println(\"non-string value: \", value);  }  }    JSON is a union type for () or null|int|float|decimal|string|json[]|map<json>.  The else block will be reached if j is neither string, int, or json[].   io:println(\"\\nIterating a JSON array :\");    json[] colors = <json[]>apple.colors;  int counter = 0;  foreach var j in colors {  io:println(\"color \", counter, \": \", j);  counter += 1;  }    To iterate a JSON array, you need to first cast it into a JSON array (json[]).   io:println(\"\\nIterating XML :\");  xml book = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  </book>`;    counter = 0;  foreach var x in book/<*> {  io:println(\"xml at \", counter, \": \", x);  counter += 1;  }    Iterating an XML will return each element in each iteration.   io:println(\"\\nIterating a closed integer range :\");  int endValue = 10;  int sum = 0;    foreach var i in 1 ... endValue {  sum = sum + i;  }  io:println(\"summation from 1 to \", endValue, \" is \", sum);    A closed integer range in the foreach statement represents an incremental integer value range from the start  expression (1) to the end expression (endValue) inclusively.   io:println(\"\\nIterating a half open integer range :\");  sum = 0;    foreach var i in 1 ..< endValue {  sum = sum + i;  }  io:println(\"summation from 1 to \", endValue,  \" excluding \", endValue, \" is \", sum); }    A half-open integer range in the foreach statement represents an incremental integer value range from the start  expression (1) inclusively, to the end expression (endValue) exclusively.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run foreach.bal Iterating a string array : fruit: apple fruit: banana fruit: cherry    Iterating a map : apple banana cherry letter: a, word: apple letter: b, word: banana letter: c, word: cherry    Iterating a JSON object : string value: apple json array value: red green int value: 5    Iterating a JSON array : color 0: red color 1: green    Iterating XML : xml at 0: <name>Sherlock Holmes</name> xml at 1: <author>Sir Arthur Conan Doyle</author>    Iterating a closed integer range : summation from 1 to 10 is 55    Iterating a half open integer range : summation from 1 to 10 excluding 10 is 45"},{"page":"/learn/by-example/fork.html","name":"Fork","summary":"The fork block allows you to start any number of workers simultaneously. Workers are visible outside the fork block as futures.\n These futures behave similar to the futures returned by asynchronous functions created by start. You may wait until the worker\n finishes by using the wait expression.\n You can only ...","content":"/  /  / Fork  import ballerina/io;public function main() {  fork {  worker w1 returns [int, string] {  int i = 23;  string s = \"Colombo\";  io:println(\"[w1] i: \", i, \" s: \", s);  return [i, s];  } worker w2 returns float {  float f = 10.344;  io:println(\"[w2] f: \", f);  return f;  }  }  record {[int, string] w1; float w2;} results = wait {w1, w2};  var [iW1, sW1] = results.w1;  var fW2 = results.w2;  io:println(\"[main] iW1: \", iW1, \" sW1: \", sW1, \" fW2: \", fW2); }    Fork  The fork block allows you to start any number of workers simultaneously. Workers are visible outside the fork block as futures.  These futures behave similar to the futures returned by asynchronous functions created by start. You may wait until the worker  finishes by using the wait expression.  You can only send anydata variables from a worker of one fork to another worker in the same fork.    import ballerina/io;    public function main() {    fork {  worker w1 returns [int, string] {  int i = 23;  string s = \"Colombo\";  io:println(\"[w1] i: \", i, \" s: \", s);    The fork block allows you to spawn (fork) multiple workers  within any execution flow of a Ballerina program.   return [i, s];  }    Return of worker w1.   worker w2 returns float {  float f = 10.344;  io:println(\"[w2] f: \", f);    return f;  }  }    Return of worker w2.   record {[int, string] w1; float w2;} results = wait {w1, w2};    Workers are visible outside the fork as futures.  The wait action will wait for both workers w1 and w2 to finish.   var [iW1, sW1] = results.w1;  var fW2 = results.w2;  io:println(\"[main] iW1: \", iW1, \" sW1: \", sW1, \" fW2: \", fW2); }    The resulting record contains returned values from each worker with  the field name as the worker name (if a field name is not provided).   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run fork.bal [w1] i: 23 s: Colombo [w2] f: 10.344 [main] iW1: 23 sW1: Colombo fW2: 10.344"},{"page":"/learn/by-example/function-pointers.html","name":"Function Pointers","summary":"A function pointer is a Ballerina type that allows you to use functions as variables,\n arguments to functions, and function return values. The name of a function serves as\n a pointer to that function when called from other functions or operations. The definition\n of the function name provides the type ...","content":"/  /  / Function Pointers  import ballerina/io; import ballerina/lang.'int; function test(string s, int... x) returns float {  int|error y = 'int:fromString(s);  float f = 0.0; if (y is int) {  foreach var item in x {  f += item * 1.0 * y;  }  } else {  panic y;  }  return f; } function foo(int x, function (string, int...) returns float bar)  returns float {  return x * bar(\"2\", 2, 3, 4, 5); } function getFunctionPointer() returns  (function (string, int...) returns float) {  return test; }public function main() {  io:println(\"Answer: \", foo(10, test));  io:println(\"Answer: \", foo(10, getFunctionPointer()));  function (string, int...) returns float f = getFunctionPointer(); io:println(\"Answer: \", foo(10, f)); }    Function Pointers  A function pointer is a Ballerina type that allows you to use functions as variables,  arguments to functions, and function return values. The name of a function serves as  a pointer to that function when called from other functions or operations. The definition  of the function name provides the type of the pointer in terms of a function signature.    import ballerina/io; import ballerina/lang.'int;    function test(string s, int... x) returns float {  int|error y = 'int:fromString(s);  float f = 0.0;    The test function acts as a variable function pointer in the main function.   if (y is int) {  foreach var item in x {  f += item * 1.0 * y;  }  } else {    panic y;  }  return f; }    The type of y within the else block would be error.   function foo(int x, function (string, int...) returns float bar)  returns float {  return x * bar(\"2\", 2, 3, 4, 5); }    A function pointer as a parameter. A function pointer can be invoked similar to how a normal function is invoked.   function getFunctionPointer() returns  (function (string, int...) returns float) {  return test; }    A function pointer as a return type.   public function main() {    io:println(\"Answer: \", foo(10, test));  io:println(\"Answer: \", foo(10, getFunctionPointer()));    Value test will serve as a function pointer for the foo function.   function (string, int...) returns float f = getFunctionPointer();    A function pointer as a variable.   io:println(\"Answer: \", foo(10, f)); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run function_pointers.bal Answer: 280.0 Answer: 280.0 Answer: 280.0"},{"page":"/learn/by-example/functional-iteration.html","name":"Functional Iteration","summary":"Iterable operations are a set of built-in operations that are available for\n iterable collections such as arrays, maps, JSON, XML, and more.Defines a map of string values.The length() function returns the number of elements in the container.The map() function applies the given function to each item of the container\n and ...","content":"/  /  / Functional Iteration  import ballerina/io;public function main() {  map<string> words = {  a: \"ant\",  b: \"bear\",  c: \"cat\",  d: \"dear\",  e: \"elephant\"  };  io:println(\"Number of elements in 'words': \", words.length());  map<string> animals = words.map(toUpper);  io:println(animals);  int[] numbers = [-5, -3, 2, 7, 12];  int[] positive = numbers.filter(function (int i) returns boolean {  return i >= 0;  });  io:println(\"Positive numbers: \", positive);  numbers.forEach(function(int i) {  io:println(i);  });  int total = numbers.reduce(sum, 0);  io:println(\"Total: \", total); int totalWithInitialValue = numbers.reduce(sum, 5);  io:println(\"Total with initial value: \", totalWithInitialValue); io:println(\"\\nExecution Order:-\");  map<json> j = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};  j.map(function (json value) returns string {  string result = value.toString();  io:println(\"- map operation's value: \", result);  return result;  }).forEach(function (string s) {  io:println(\"-- foreach operation's value: \", s);  });}function toUpper(string value) returns string {  return value.toUpperAscii(); }function sum(int accumulator, int currentValue) returns int {  return accumulator + currentValue; }    Functional Iteration  Iterable operations are a set of built-in operations that are available for  iterable collections such as arrays, maps, JSON, XML, and more.    import ballerina/io;    public function main() {    map<string> words = {  a: \"ant\",  b: \"bear\",  c: \"cat\",  d: \"dear\",  e: \"elephant\"  };    Defines a map of string values.   io:println(\"Number of elements in 'words': \", words.length());    The length() function returns the number of elements in the container.   map<string> animals = words.map(toUpper);  io:println(animals);    The map() function applies the given function to each item of the container  and returns a new container of the same type and length.   int[] numbers = [-5, -3, 2, 7, 12];    Defines an array of int values.   int[] positive = numbers.filter(function (int i) returns boolean {  return i >= 0;  });  io:println(\"Positive numbers: \", positive);    The filter() function returns a new container of the same type with  all the elements that satisfy the input predicate function.   numbers.forEach(function(int i) {  io:println(i);  });    The forEach() function executes a specified function once for each of  the elements in the container.   int total = numbers.reduce(sum, 0);  io:println(\"Total: \", total);    The reduce() function uses the given combining function to produce  a single value. The combining function takes the combined value so far  and an element of the container and returns a new combined value.   int totalWithInitialValue = numbers.reduce(sum, 5);  io:println(\"Total with initial value: \", totalWithInitialValue);    io:println(\"\\nExecution Order:-\");    map<json> j = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};  j.map(function (json value) returns string {  string result = value.toString();  io:println(\"- map operation's value: \", result);  return result;  }).forEach(function (string s) {  io:println(\"-- foreach operation's value: \", s);  });    The forEach() function applies the given function to each item of the container.   }    function toUpper(string value) returns string {  return value.toUpperAscii(); }    function sum(int accumulator, int currentValue) returns int {  return accumulator + currentValue; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run functional_iteration.bal Number of elements in 'words': 5 a=ANT b=BEAR c=CAT d=DEAR e=ELEPHANT Positive numbers: 2 7 12 -5 -3 2 7 12 Total: 13 Total with initial value: 18    Execution Order:- - map operation's value: apple - map operation's value: red green - map operation's value: 5 -- foreach operation's value: apple -- foreach operation's value: red green -- foreach operation's value: 5"},{"page":"/learn/by-example/functions-with-defaultable-parameters.html","name":"Defaultable Parameters","summary":"Ballerina functions can have defaultable parameters. Defaultable parameters are optional parameters that have a default\n value. A function with defaultable parameters can be invoked without providing values for the defaultable parameters.\n When invoking the function, arguments for the defaultable parameters can be passed as key-value pairs in which case\n the ...","content":"/  /  / Defaultable Parameters  import ballerina/io; function printSalaryDetails(int baseSalary,  int annualIncrement = 20,  float bonusRate = 0.02) { io:println(\"Base Salary: \", baseSalary, \" | Annual Increment: \", annualIncrement,  \" | Bonus Rate: \", bonusRate); }public function main() {  printSalaryDetails(2500);  printSalaryDetails(2500, annualIncrement = 100);  printSalaryDetails(2500, 100);  printSalaryDetails(2500, bonusRate = 0.1);  printSalaryDetails(2500, 20, 0.1);  printSalaryDetails(2500, annualIncrement = 100, bonusRate = 0.1);  printSalaryDetails(annualIncrement = 100, baseSalary = 2500, bonusRate = 0.1); }    Defaultable Parameters  Ballerina functions can have defaultable parameters. Defaultable parameters are optional parameters that have a default  value. A function with defaultable parameters can be invoked without providing values for the defaultable parameters.  When invoking the function, arguments for the defaultable parameters can be passed as key-value pairs in which case  the placement of the arguments within the function call does not matter. However, all arguments after the first named  argument (key-value pair) need to be passed as named arguments.  Arguments for defaultable parameters can also be passed as positional arguments, in which case the arguments need to  be passed in order.    import ballerina/io;    function printSalaryDetails(int baseSalary,  int annualIncrement = 20,  float bonusRate = 0.02) {    This function takes the base salary, annual increment, and bonus rate as input  parameters and prints them. The first parameter baseSalary is a required  parameter. The next two parameters annualIncrement and bonusRate are  two defaultable parameters. They are optional parameters that have default  values of 20 and 0.02 respectively. Defaultable parameters must always be  defined after the required parameters.   io:println(\"Base Salary: \", baseSalary, \" | Annual Increment: \", annualIncrement,  \" | Bonus Rate: \", bonusRate); }    public function main() {    printSalaryDetails(2500);    Call the function by passing a value only for the baseSalary parameter.  The annualIncrement and bonusRate parameters default to  20 and 0.02 respectively.   printSalaryDetails(2500, annualIncrement = 100);    Call the function by passing values only for the baseSalary and annualIncrement  parameters. The value for the annualIncrement parameter is passed as a named argument.  The bonusRate parameter defaults to 0.02.   printSalaryDetails(2500, 100);    Call the function again by passing values only for the baseSalary and annualIncrement  parameters, now passing the value for the annualIncrement parameter as a positional argument.  The bonusRate parameter defaults to 0.02.   printSalaryDetails(2500, bonusRate = 0.1);    Call the function by passing values only for the baseSalary and bonusRate parameters.  The annualIncrement parameter defaults to 20.   printSalaryDetails(2500, 20, 0.1);    In order to pass the value for bonusRate as a positional argument, a value would  have to be specified for the annualIncrement parameter too.  All arguments are positional arguments here.   printSalaryDetails(2500, annualIncrement = 100, bonusRate = 0.1);    Call the function by passing values for all three parameters, the first argument as  a positional argument and the rest as named arguments.   printSalaryDetails(annualIncrement = 100, baseSalary = 2500, bonusRate = 0.1); }    Call the function by passing all three arguments as named arguments.  Any and all arguments after the first named argument need to be specified  as named arguments but could be specified in any order.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run functions_with_defaultable_parameters.bal Base Salary: 2500 | Annual Increment: 20 | Bonus Rate: 0.02 Base Salary: 2500 | Annual Increment: 100 | Bonus Rate: 0.02 Base Salary: 2500 | Annual Increment: 100 | Bonus Rate: 0.02 Base Salary: 2500 | Annual Increment: 20 | Bonus Rate: 0.1 Base Salary: 2500 | Annual Increment: 20 | Bonus Rate: 0.1 Base Salary: 2500 | Annual Increment: 100 | Bonus Rate: 0.1 Base Salary: 2500 | Annual Increment: 100 | Bonus Rate: 0.1"},{"page":"/learn/by-example/functions-with-rest-parameter.html","name":"Rest Parameters","summary":"A Ballerina function can have only one rest parameter and the rest parameter\n can take zero or more values. The rest parameter inside a function is equivalent to a list of\n the same type.\n When values are passed for the rest parameter, other arguments also need to be passed as ...","content":"/  /  / Rest Parameters  import ballerina/io; function printDetails(string name,  int age = 18,  string... modules) {  string detailString = \"Name: \" + name + \", Age: \" + age.toString(); if (modules.length() == 0) {  io:println(detailString);  return;  } int index = 0;  string moduleString = \"Module(s): \"; foreach string module in modules {  if (index == 0) {  moduleString += module;  } else {  moduleString += \", \" + module;  }  index += 1;  } io:println(detailString, \", \", moduleString); }public function main() {  printDetails(\"Alice\");  printDetails(\"Bob\", 20);  printDetails(\"Corey\", 19, \"Math\");  printDetails(\"Diana\", 20, \"Math\", \"Physics\");  string[] modules = [\"Math\", \"Physics\"];  printDetails(\"Diana\", 20, ...modules); }    Rest Parameters  A Ballerina function can have only one rest parameter and the rest parameter  can take zero or more values. The rest parameter inside a function is equivalent to a list of  the same type.  When values are passed for the rest parameter, other arguments also need to be passed as positional  arguments (i.e., they cannot be passed as named arguments).    import ballerina/io;    function printDetails(string name,  int age = 18,  string... modules) {  string detailString = \"Name: \" + name + \", Age: \" + age.toString();    This function takes one required parameter, one defaultable parameter, and  one rest parameter of the type string. A function can have only one rest  parameter. The rest parameter can take any number of values and is  equivalent to a list of the same type.   if (modules.length() == 0) {  io:println(detailString);  return;  }    int index = 0;  string moduleString = \"Module(s): \";    foreach string module in modules {  if (index == 0) {  moduleString += module;  } else {  moduleString += \", \" + module;  }  index += 1;  }    io:println(detailString, \", \", moduleString); }    public function main() {    printDetails(\"Alice\");    Call the function by passing only the required parameter.   printDetails(\"Bob\", 20);    Call the function by passing the required parameter and  the defaultable parameter. Named arguments can also be used  since values are not passed for the rest parameter.   printDetails(\"Corey\", 19, \"Math\");    Call the function by passing the required parameter, the defaultable  parameter, and one value for the rest parameter.  Arguments cannot be passed as named arguments since values are specified  for the rest parameter.   printDetails(\"Diana\", 20, \"Math\", \"Physics\");    Call the function by passing the required parameter, defaultable parameter,  and multiple values for the rest parameter.   string[] modules = [\"Math\", \"Physics\"];  printDetails(\"Diana\", 20, ...modules); }    Pass an array as the rest parameter instead of calling the  function by passing each value separately.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run functions_with_rest_parameter.bal Name: Alice, Age: 18 Name: Bob, Age: 20 Name: Corey, Age: 19, Module(s): Math Name: Diana, Age: 20, Module(s): Math, Physics Name: Diana, Age: 20, Module(s): Math, Physics"},{"page":"/learn/by-example/functions-with-required-parameters.html","name":"Required Parameters","summary":"Ballerina functions can have required parameters. Invoking a function with required parameters requires arguments\n to be specified for each and every required parameter.This function accepts three int values, performs a calculation,\n and returns the result as an integer.\n All three parameters are required parameters.Call the calculate() function to retrieve the ...","content":"/  /  / Required Parameters  import ballerina/io; function calculate(int a, int b, int c) returns int {  return a + 2 * b + 3 * c; }public function main() {  int result = calculate(5, 6, 7);  io:println(result);  result = calculate(5, c = 7, b = 6);  io:println(result); }    Required Parameters  Ballerina functions can have required parameters. Invoking a function with required parameters requires arguments  to be specified for each and every required parameter.    import ballerina/io;    function calculate(int a, int b, int c) returns int {  return a + 2 * b + 3 * c; }    This function accepts three int values, performs a calculation,  and returns the result as an integer.  All three parameters are required parameters.   public function main() {    int result = calculate(5, 6, 7);    Call the calculate() function to retrieve the integer result.  Arguments for required parameters can be passed as positional arguments.  Positional arguments need to be passed in the expected order.   io:println(result);    Print the result.   result = calculate(5, c = 7, b = 6);    Arguments for required parameters can also be passed as named arguments.  All arguments after the first named argument need to be passed by name.  Named arguments do not have to be specified in the order in which the parameters are defined.   io:println(result); }    Print the result.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run functions_with_required_parameters.bal 38 38"},{"page":"/learn/by-example/gauge-metrics.html","name":"Gauge-Based Metrics","summary":"Ballerina supports Observability out of the box, and Metrics is one of the three important aspect of the\n Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.\n The developers can define and use metrics to measure their own logic. A gauge is one type ...","content":"/  /  / Gauge-Based Metrics  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/observe; observe:Gauge globalGauge = new (\"global_gauge\", \"Global gauge defined\"); @http:ServiceConfig {  basePath: \"/online-store-service\" } service onlineStoreService on new http:Listener(9090) { @http:ResourceConfig {  path: \"/make-order\"  }  resource function makeOrder(http:Caller caller, http:Request req) {  io:println(\"------------------------------------------\");  globalGauge.increment(15.0);  printGauge(globalGauge);  observe:Gauge localGauge = new (\"local_operations\");  localGauge.increment();  localGauge.increment(20.0);  localGauge.decrement();  localGauge.decrement(10.0);  printGauge(localGauge);  observe:Gauge registeredGaugeWithTags = new (\"registered_gauge_with_tags\",  \"RegisteredGauge\",  {property: \"gaugeProperty\", gaugeType: \"RegisterType\"});  error? result = registeredGaugeWithTags.register();  if (result is error) {  log:printError(\"Error in registering gauge\", result);  }  registeredGaugeWithTags.increment();  float value = registeredGaugeWithTags.getValue();  float newValue = value * 12;  registeredGaugeWithTags.setValue(newValue);  printGauge(registeredGaugeWithTags);  observe:StatisticConfig[] statsConfigs = [];  observe:Gauge gaugeWithNoStats = new (\"gauge_with_no_stats\",  \"Some description\", (), statsConfigs);  gaugeWithNoStats.setValue(100);  printGauge(gaugeWithNoStats);  observe:StatisticConfig config = {  timeWindow: 30000,  percentiles: [0.33, 0.5, 0.9, 0.99],  buckets: 3  };  statsConfigs[0] = config;  observe:Gauge gaugeWithCustomStats = new (\"gauge_with_custom_stats\",  \"Some description\", (), statsConfigs);  int i = 1;  while (i < 6) {  gaugeWithCustomStats.setValue(100.0 * i);  i = i + 1;  }  printGauge(gaugeWithCustomStats); io:println(\"------------------------------------------\");  http:Response res = new;  res.setPayload(\"Order Processed!\");  result = caller->respond(res); if (result is error) {  log:printError(\"Error sending response\", result);  }  } }function printGauge(observe:Gauge gauge) {  io:print(\"Gauge - \" + gauge.name + \" Snapshot: \");  observe:Snapshot[]? snapshots = gauge.getSnapshot();  json|error snapshotAsAJson = json.constructFrom(snapshots);  if snapshotAsAJson is json {  io:println(snapshotAsAJson.toJsonString());  }  io:println(\"Gauge - \", gauge.name, \" Current Value: \"  , gauge.getValue()); }    Gauge-Based Metrics  Ballerina supports Observability out of the box, and Metrics is one of the three important aspect of the  Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.  The developers can define and use metrics to measure their own logic. A gauge is one type of metric that is  supported by default in Ballerina, and it represents a single numerical value that can arbitrarily go up and down,  and also based on the statistics configurations provided to the Gauge, it can also report the statistics such as max,  min, mean, percentiles, etc.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/observe;    observe:Gauge globalGauge = new (\"global_gauge\", \"Global gauge defined\");    Create a gauge as a global variable in the service with optional field description, and default statistics configurations = { timeWindow: 600000, buckets: 5,  percentiles: [0.33, 0.5, 0.66, 0.99] }.   @http:ServiceConfig {  basePath: \"/online-store-service\" } service onlineStoreService on new http:Listener(9090) {    Make sure you start the service with the ‘–b7a.observability.enabled=true’ property or with metrics enabled.   @http:ResourceConfig {  path: \"/make-order\"  }  resource function makeOrder(http:Caller caller, http:Request req) {  io:println(\"------------------------------------------\");    globalGauge.increment(15.0);    Incrementing the global gauge defined by 15.0.   printGauge(globalGauge);    Log the current state of global gauge.   observe:Gauge localGauge = new (\"local_operations\");    Create a gauge with simply a name, and default statistics configurations.   localGauge.increment();    Increment the local gauge by default value 1.0.   localGauge.increment(20.0);    Increment the value of the gauge by 20.   localGauge.decrement();    Decrement the local gauge by default value 1.0.   localGauge.decrement(10.0);    Decrement the value of the gauge by 20.   printGauge(localGauge);    Log the current state of local gauge.   observe:Gauge registeredGaugeWithTags = new (\"registered_gauge_with_tags\",  \"RegisteredGauge\",  {property: \"gaugeProperty\", gaugeType: \"RegisterType\"});    Create a gauge with optional fields description, and tags defined.   error? result = registeredGaugeWithTags.register();  if (result is error) {  log:printError(\"Error in registering gauge\", result);  }    Register the gauge instance, therefore it is stored in the global registry and can be reported to the metrics server such as Prometheus. Additionally, this operation will register to the global registry for the first invocation and will throw an error if there is already a registration of different metrics instance or type. And subsequent invocations of register() will simply retrieve the stored metrics instance for the provided name and tags fields, and use that instance for the subsequent operations on the counter instance.   registeredGaugeWithTags.increment();  float value = registeredGaugeWithTags.getValue();  float newValue = value * 12;  registeredGaugeWithTags.setValue(newValue);    Set the value of the gauge with the new value.   printGauge(registeredGaugeWithTags);    Log the current state of registered gauge with tags.   observe:StatisticConfig[] statsConfigs = [];  observe:Gauge gaugeWithNoStats = new (\"gauge_with_no_stats\",  \"Some description\", (), statsConfigs);  gaugeWithNoStats.setValue(100);  printGauge(gaugeWithNoStats);    Create a gauge with statistics disabled by passing empty statistics config array.   observe:StatisticConfig config = {  timeWindow: 30000,  percentiles: [0.33, 0.5, 0.9, 0.99],  buckets: 3  };  statsConfigs[0] = config;  observe:Gauge gaugeWithCustomStats = new (\"gauge_with_custom_stats\",  \"Some description\", (), statsConfigs);  int i = 1;  while (i < 6) {  gaugeWithCustomStats.setValue(100.0 * i);  i = i + 1;  }    Create gauge with custom statistics config.   printGauge(gaugeWithCustomStats);    Log the current state of registered gauge with tags.   io:println(\"------------------------------------------\");    http:Response res = new;    Send response to the client.   res.setPayload(\"Order Processed!\");    Use a util method to set a string payload.   result = caller->respond(res);    Send the response back to the caller.   if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    function printGauge(observe:Gauge gauge) {    io:print(\"Gauge - \" + gauge.name + \" Snapshot: \");  observe:Snapshot[]? snapshots = gauge.getSnapshot();  json|error snapshotAsAJson = json.constructFrom(snapshots);  if snapshotAsAJson is json {  io:println(snapshotAsAJson.toJsonString());  }    Get the statistics snapshot of the gauge.   io:println(\"Gauge - \", gauge.name, \" Current Value: \"  , gauge.getValue()); }    Get the current value of the gauge.   $ curl http://localhost:9090/online-store-service/make-order Order Processed! $ curl http://localhost:9090/online-store-service/make-order Order Processed! $ curl http://localhost:9090/online-store-service/make-order Order Processed!    Invoke the service using cURL three times."},{"page":"/learn/by-example/functions.html","name":"Functions","summary":"Functions operate in the same way as in any other language. It is a mechanism to create a reusable unit of\n functionality within a program.This function takes a string argument. However, it does not return a value.This function takes in two int values as arguments and returns their\n sum as ...","content":"/  /  / Functions  import ballerina/io; function printValue(string value) {  io:println(value); } function add(int a, int b) returns int {  return a + b; }function printAndReturnValue(string s) returns string {  string t = \"Hello \".concat(s);  io:println(t);  return t; } public function main() {  printValue(\"This is a sample text\");  int result = add(5, 6);  io:println(result);  _ = printAndReturnValue(\"World\"); }    Functions  Functions operate in the same way as in any other language. It is a mechanism to create a reusable unit of  functionality within a program.    import ballerina/io;    function printValue(string value) {  io:println(value); }    This function takes a string argument. However, it does not return a value.   function add(int a, int b) returns int {  return a + b; }    This function takes in two int values as arguments and returns their  sum as an integer.   function printAndReturnValue(string s) returns string {  string t = \"Hello \".concat(s);  io:println(t);  return t; }    public function main() {    A public function named main is considered as a default entry point of a  Ballerina program.   printValue(\"This is a sample text\");    Call the printValue() function that prints the value provided.   int result = add(5, 6);    Call the add() function to retrieve the result of adding two given values.   io:println(result);    Print the result.   _ = printAndReturnValue(\"World\"); }    Ballerina does not allow ignoring the return value of a function  invocation implicitly unless the return type is (). A return value can be ignored  using _ if the value may never be an error (i.e., the return type of the  function does not contain error).   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run functions.bal This is a sample text 11 Hello World"},{"page":"/learn/by-example/grpc-bidirectional-streaming.html","name":"Bidirectional Streaming","summary":"The gRPC Server Connector exposes the gRPC service over http2.\n This sample demonstrates how the gRPC bidirectional streaming service and the non blocking client operate when each of them sends a sequence of messages using a read-write stream. In such scenarios, the two streams operate independently. Therefore, clients and servers ...","content":"/  /  / Bidirectional Streaming  syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service Chat { \trpc chat (stream ChatMessage)  returns (stream google.protobuf.StringValue); } message ChatMessage { \tstring name = 1; \tstring message = 2; } import ballerina/grpc; import ballerina/log;map<grpc:Caller> consMap = {};@grpc:ServiceConfig {  name: \"Chat\",  clientStreaming: true,  serverStreaming: true } service Chat on new grpc:Listener(9090) {  resource function onOpen(grpc:Caller caller) {  log:printInfo(string `${caller.getId()} connected to chat`);  consMap[caller.getId().toString()] = <@untainted>caller;  }  resource function onMessage(grpc:Caller caller, ChatMessage chatMsg) {  grpc:Caller ep;  string msg = string `${chatMsg.name}: ${chatMsg.message}`;  log:printInfo(\"Server received message: \" + msg);  foreach var [callerId, connection] in consMap.entries() {  ep = connection;  grpc:Error? err = ep->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server message to caller \" + callerId  + \" sent successfully.\");  }  }  }  resource function onError(grpc:Caller caller, error err) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }  resource function onComplete(grpc:Caller caller) {  grpc:Caller ep;  string msg = string `${caller.getId()} left the chat`;  log:printInfo(msg);  var v = consMap.remove(caller.getId().toString());  foreach var [callerId, connection] in consMap.entries() {  ep = connection;  grpc:Error? err = ep->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server message to caller \" + callerId  + \" sent successfully.\");  }  }  } }# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_bidirectional_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.# Add new Ballerina file `grpc_bidirectional_streaming.bal` inside the `service` module and add service implementation. import ballerina/grpc; import ballerina/io; import ballerina/runtime;int total = 0; public function main() {  ChatClient chatEp = new (\"http://localhost:9090\"); grpc:StreamingClient ep;  var res = chatEp->chat(ChatMessageListener); if (res is grpc:Error) {  io:println(\"Error from Connector: \" + res.reason() + \" - \"  + <string>res.detail()[\"message\"]);  return;  } else {  io:println(\"Initialized connection sucessfully.\");  ep = res;  }  ChatMessage mes = {name: \"Sam\", message: \"Hi \"};  grpc:Error? connErr = ep->send(mes); if (connErr is grpc:Error) {  io:println(\"Error from Connector: \" + connErr.reason() + \" - \"  + <string>connErr.detail()[\"message\"]);  }  runtime:sleep(6000);  grpc:Error? result = ep->complete();  if (result is grpc:Error) {  io:println(\"Error in sending complete message\", result);  } }service ChatMessageListener = service {  resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }  resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }  resource function onComplete() {  io:println(\"Server Complete Sending Responses.\");  } };# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_bidirectional_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.# Add new Ballerina file `grpc_bidirectional_streaming_client.bal` inside the `client` module and add client implementation.    Bidirectional Streaming  The gRPC Server Connector exposes the gRPC service over http2.  This sample demonstrates how the gRPC bidirectional streaming service and the non blocking client operate when each of them sends a sequence of messages using a read-write stream. In such scenarios, the two streams operate independently. Therefore, clients and servers can read and write in any order.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service Chat { \trpc chat (stream ChatMessage)  returns (stream google.protobuf.StringValue); } message ChatMessage { \tstring name = 1; \tstring message = 2; }    This is the service definition for the bidirectional streaming scenario.   # Create new Protocol Buffers definition file `grpc_bidirectional_streaming.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. $ ballerina grpc --input grpc_bidirectional_streaming.proto --output stubs    # Once you run the command, `grpc_bidirectional_streaming_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the bidirectional streaming scenario.   map<grpc:Caller> consMap = {};    @grpc:ServiceConfig {  name: \"Chat\",  clientStreaming: true,  serverStreaming: true } service Chat on new grpc:Listener(9090) {    resource function onOpen(grpc:Caller caller) {  log:printInfo(string `${caller.getId()} connected to chat`);  consMap[caller.getId().toString()] = <@untainted>caller;  }    This resource is triggered when a new caller connection is initialized.   resource function onMessage(grpc:Caller caller, ChatMessage chatMsg) {  grpc:Caller ep;  string msg = string `${chatMsg.name}: ${chatMsg.message}`;  log:printInfo(\"Server received message: \" + msg);  foreach var [callerId, connection] in consMap.entries() {  ep = connection;  grpc:Error? err = ep->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server message to caller \" + callerId  + \" sent successfully.\");  }  }  }    This resource is triggered when the caller sends a request message to the service.   resource function onError(grpc:Caller caller, error err) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    This resource is triggered when the server receives an error message from the caller.   resource function onComplete(grpc:Caller caller) {  grpc:Caller ep;  string msg = string `${caller.getId()} left the chat`;  log:printInfo(msg);  var v = consMap.remove(caller.getId().toString());  foreach var [callerId, connection] in consMap.entries() {  ep = connection;  grpc:Error? err = ep->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server message to caller \" + callerId  + \" sent successfully.\");  }  }  } }    This resource is triggered when the caller sends a notification to the server to indicate that it has finished sending messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_bidirectional_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_bidirectional_streaming.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. $ ballerina build service    # Run the service using the following command. $ ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io; import ballerina/runtime;    This is client implementation for bidirectional streaming scenario.   int total = 0; public function main() {    ChatClient chatEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:StreamingClient ep;    var res = chatEp->chat(ChatMessageListener);    Executes unary non-blocking call registering server message listener.   if (res is grpc:Error) {  io:println(\"Error from Connector: \" + res.reason() + \" - \"  + <string>res.detail()[\"message\"]);  return;  } else {  io:println(\"Initialized connection sucessfully.\");  ep = res;  }    ChatMessage mes = {name: \"Sam\", message: \"Hi \"};  grpc:Error? connErr = ep->send(mes);    Sends multiple messages to the server.   if (connErr is grpc:Error) {  io:println(\"Error from Connector: \" + connErr.reason() + \" - \"  + <string>connErr.detail()[\"message\"]);  }  runtime:sleep(6000);    grpc:Error? result = ep->complete();  if (result is grpc:Error) {  io:println(\"Error in sending complete message\", result);  } }    Once all messages are sent, client send complete message to notify the server, I’m done.   service ChatMessageListener = service {    resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }    Resource registered to receive server messages.   resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    Resource registered to receive server error messages.   resource function onComplete() {  io:println(\"Server Complete Sending Responses.\");  } };    Resource registered to receive server completed message.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_bidirectional_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_bidirectional_streaming_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. $ ballerina build client    # Run the client using the following command. $ ballerina run target/bin/client.jar"},{"page":"/learn/by-example/grpc-client-streaming.html","name":"Client Streaming","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This sample includes a gRPC client streaming service and non-blocking client. The client writes a sequence of messages and sends them to the server via a stream.\n Once the client has finished writing the messages, it waits for ...","content":"/  /  / Client Streaming  syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc lotsOfGreetings (stream google.protobuf.StringValue)  returns (google.protobuf.StringValue); } import ballerina/grpc; import ballerina/log;@grpc:ServiceConfig {  name: \"HelloWorld\",  clientStreaming: true } service HelloWorld on new grpc:Listener(9090) {  resource function onOpen(grpc:Caller caller) {  log:printInfo(\"Client connected sucessfully.\");  }  resource function onMessage(grpc:Caller caller, string name) {  log:printInfo(\"Server received greet: \" + name);  }  resource function onError(grpc:Caller caller, error err) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }  resource function onComplete(grpc:Caller caller) {  grpc:Error? err = caller->send(\"Ack\");  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server send response : Ack\");  }  } }# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_client_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.# Add new Ballerina file `grpc_client_streaming.bal` inside the `service` module and add service implementation. import ballerina/grpc; import ballerina/io;int total = 0; public function main() {  HelloWorldClient helloWorldEp = new (\"http://localhost:9090\"); grpc:StreamingClient ep;  var res = helloWorldEp->lotsOfGreetings(HelloWorldMessageListener); if (res is grpc:Error) {  io:println(\"Error from Connector: \" + res.reason() + \" - \"  + <string>res.detail()[\"message\"]);  return;  } else {  io:println(\"Initialized connection sucessfully.\");  ep = res;  }  string[] greets = [\"Hi\", \"Hey\", \"GM\"];  var name = \"John\";  foreach string greet in greets {  grpc:Error? connErr = ep->send(greet + \" \" + name);  if (connErr is grpc:Error) {  io:println(\"Error from Connector: \" + connErr.reason() + \" - \"  + <string>connErr.detail()[\"message\"]);  } else {  io:println(\"send greeting: \" + greet + \" \" + name);  }  }  grpc:Error? result = ep->complete();  if (result is grpc:Error) {  io:println(\"Error in sending complete message\", result);  } while (total == 0) {}  io:println(\"completed successfully\"); } service HelloWorldMessageListener = service {  resource function onMessage(string message) {  total = 1;  io:println(\"Response received from server: \" + message);  }  resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }  resource function onComplete() {  total = 1;  io:println(\"Server Complete Sending Responses.\");  } };# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_client_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.# Add new Ballerina file `grpc_client_streaming_client.bal` inside the `client` module and add client implementation.    Client Streaming  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This sample includes a gRPC client streaming service and non-blocking client. The client writes a sequence of messages and sends them to the server via a stream.  Once the client has finished writing the messages, it waits for the server to read them and return a response.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc lotsOfGreetings (stream google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the client streaming scenario.   # Create new Protocol Buffers definition file `grpc_client_streaming.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. $ ballerina grpc --input grpc_client_streaming.proto --output stubs    # Once you run the command, `grpc_client_streaming_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the client streaming scenario.   @grpc:ServiceConfig {  name: \"HelloWorld\",  clientStreaming: true } service HelloWorld on new grpc:Listener(9090) {    resource function onOpen(grpc:Caller caller) {  log:printInfo(\"Client connected sucessfully.\");  }    This resource is triggered when a new caller connection is initialized.   resource function onMessage(grpc:Caller caller, string name) {  log:printInfo(\"Server received greet: \" + name);  }    This resource is triggered when the caller sends a request message to the service.   resource function onError(grpc:Caller caller, error err) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    This resource is triggered when the server receives an error message from the caller.   resource function onComplete(grpc:Caller caller) {  grpc:Error? err = caller->send(\"Ack\");  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server send response : Ack\");  }  } }    This resource is triggered when the caller sends a notification to the server to indicate that it has finished sending messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_client_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_client_streaming.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. $ ballerina build service    # Run the service using the following command. $ ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is the client implementation for the client streaming scenario.   int total = 0; public function main() {    HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:StreamingClient ep;    var res = helloWorldEp->lotsOfGreetings(HelloWorldMessageListener);    Execute the unary non-blocking call that registers a server message listener.   if (res is grpc:Error) {  io:println(\"Error from Connector: \" + res.reason() + \" - \"  + <string>res.detail()[\"message\"]);  return;  } else {  io:println(\"Initialized connection sucessfully.\");  ep = res;  }    string[] greets = [\"Hi\", \"Hey\", \"GM\"];  var name = \"John\";  foreach string greet in greets {  grpc:Error? connErr = ep->send(greet + \" \" + name);  if (connErr is grpc:Error) {  io:println(\"Error from Connector: \" + connErr.reason() + \" - \"  + <string>connErr.detail()[\"message\"]);  } else {  io:println(\"send greeting: \" + greet + \" \" + name);  }  }    Send multiple messages to the server.   grpc:Error? result = ep->complete();  if (result is grpc:Error) {  io:println(\"Error in sending complete message\", result);  }    Once all the messages are sent, the server notifies the caller with a complete message.   while (total == 0) {}  io:println(\"completed successfully\"); }    service HelloWorldMessageListener = service {    Server Message Listener.   resource function onMessage(string message) {  total = 1;  io:println(\"Response received from server: \" + message);  }    Resource registered to receive server messages.   resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    Resource registered to receive server error messages.   resource function onComplete() {  total = 1;  io:println(\"Server Complete Sending Responses.\");  } };    Resource registered to receive server completed messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_client_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_client_streaming_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. $ ballerina build client    # Run the client using the following command. $ ballerina run target/bin/client.jar"},{"page":"/learn/by-example/grpc-secured-unary.html","name":"Secured Unary","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This sample demonstrates how a gRPC secured unary service interacts with a gRPC secured blocking client.This is the service definition for the secured connection (HTTPS) scenario.This is the server implementation for the secured connection (HTTPS) scenario.Server endpoint configuration ...","content":"/  /  / Secured Unary  syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); } import ballerina/config; import ballerina/grpc; import ballerina/log; listener grpc:Listener ep = new (9090, {  host: \"localhost\",  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });service HelloWorld on ep {  resource function hello(grpc:Caller caller, string name) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;  grpc:Error? err = caller->send(message); if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server send response : \" + message);  }  grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_secured_unary_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.# Add new Ballerina file `grpc_secured_unary.bal` inside the `service` module and add service implementation. import ballerina/config; import ballerina/grpc; import ballerina/io;public function main() {  HelloWorldBlockingClient helloWorldBlockingEp = new (\"https://localhost:9090\", {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  });  var unionResp = helloWorldBlockingEp->hello(\"WSO2\");  if (unionResp is grpc:Error) {  io:println(\"Error from Connector: \" + unionResp.reason() + \" - \"  + <string>unionResp.detail()[\"message\"]);  } else {  string result;  [result, _] = unionResp;  io:println(\"Client Got Response : \" + result);  } }# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_secured_unary_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.# Add new Ballerina file `grpc_secured_unary_client.bal` inside the `client` module and add client implementation.    Secured Unary  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This sample demonstrates how a gRPC secured unary service interacts with a gRPC secured blocking client.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the secured connection (HTTPS) scenario.   # Create new Protocol Buffers definition file `grpc_secured_unary.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. $ ballerina grpc --input grpc_secured_unary.proto --output stubs    # Once you run the command, `grpc_secured_unary_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/config; import ballerina/grpc; import ballerina/log;    This is the server implementation for the secured connection (HTTPS) scenario.   listener grpc:Listener ep = new (9090, {  host: \"localhost\",  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    Server endpoint configuration with the SSL configurations.   service HelloWorld on ep {  resource function hello(grpc:Caller caller, string name) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;    grpc:Error? err = caller->send(message);    Send a response message to the caller.   if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server send response : \" + message);  }    grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }    Send the completed notification to the caller.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_secured_unary_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_secured_unary.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. $ ballerina build service    # To run the service, execute the below command by passing Ballerina home path as a system property. $ ballerina run target/bin/service.jar --b7a.home=<ballerina_home_path>    import ballerina/config; import ballerina/grpc; import ballerina/io;    This is the client implementation of the secured connection (HTTPS) scenario.   public function main() {    HelloWorldBlockingClient helloWorldBlockingEp = new (\"https://localhost:9090\", {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  });    Client endpoint configuration with SSL configurations.   var unionResp = helloWorldBlockingEp->hello(\"WSO2\");  if (unionResp is grpc:Error) {  io:println(\"Error from Connector: \" + unionResp.reason() + \" - \"  + <string>unionResp.detail()[\"message\"]);  } else {  string result;  [result, _] = unionResp;  io:println(\"Client Got Response : \" + result);  } }    Executes unary blocking secured call.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_secured_unary_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_secured_unary_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. $ ballerina build client    # To run the client, execute the below command by passing the path to the Ballerina home directory using the --`b7a.home` parameter. $ ballerina run target/bin/client.jar --b7a.home=<ballerina_home_path>"},{"page":"/learn/by-example/grpc-server-streaming.html","name":"Server Streaming","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This sample includes a gRPC server streaming service and a non-blocking client. The\n client sends a request to the server and gets a stream to read the messages until all the messages are read.This is the service definition ...","content":"/  /  / Server Streaming  syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc lotsOfReplies (google.protobuf.StringValue)  returns (stream google.protobuf.StringValue); } import ballerina/grpc; import ballerina/log;service HelloWorld on new grpc:Listener(9090) {  @grpc:ResourceConfig {streaming: true}  resource function lotsOfReplies(grpc:Caller caller, string name) { log:printInfo(\"Server received hello from \" + name);  string[] greets = [\"Hi\", \"Hey\", \"GM\"];  foreach string greet in greets {  string msg = greet + \" \" + name;  grpc:Error? err = caller->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Send reply: \" + msg);  }  }  grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_server_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.# Add new Ballerina file `grpc_server_streaming.bal` inside the `service` module and add service implementation. import ballerina/grpc; import ballerina/io;int total = 0; public function main() {  HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");  grpc:Error? result = helloWorldEp->lotsOfReplies(\"Sam\",  HelloWorldMessageListener);  if (result is grpc:Error) {  io:println(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  } else {  io:println(\"Connected successfully\");  } while (total == 0) {}  io:println(\"Client got response successfully.\"); } service HelloWorldMessageListener = service {  resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }  resource function onError(error err) {  io:println(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }  resource function onComplete() {  total = 1;  io:println(\"Server Complete Sending Responses.\");  } };# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_server_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.# Add new Ballerina file `grpc_server_streaming_client.bal` inside the `client` module and add client implementation.    Server Streaming  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This sample includes a gRPC server streaming service and a non-blocking client. The  client sends a request to the server and gets a stream to read the messages until all the messages are read.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc lotsOfReplies (google.protobuf.StringValue)  returns (stream google.protobuf.StringValue); }    This is the service definition for the server streaming scenario.   # Create new Protocol Buffers definition file `grpc_server_streaming.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. $ ballerina grpc --input grpc_server_streaming.proto --output stubs    # Once you run the command, `grpc_server_streaming_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the server streaming scenario.   service HelloWorld on new grpc:Listener(9090) {    @grpc:ResourceConfig {streaming: true}  resource function lotsOfReplies(grpc:Caller caller, string name) {    The annotation indicates how the service resource operates as server streaming.   log:printInfo(\"Server received hello from \" + name);  string[] greets = [\"Hi\", \"Hey\", \"GM\"];    foreach string greet in greets {  string msg = greet + \" \" + name;  grpc:Error? err = caller->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Send reply: \" + msg);  }  }    Send multiple messages to the caller.   grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }    Once all the messages are sent, the server notifies the caller with a complete message.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_server_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_server_streaming.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. $ ballerina build service    # Run the service using the following command. $ ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is the client implementation for the server streaming scenario.   int total = 0; public function main() {    HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:Error? result = helloWorldEp->lotsOfReplies(\"Sam\",  HelloWorldMessageListener);  if (result is grpc:Error) {  io:println(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  } else {  io:println(\"Connected successfully\");  }    Execute the unary non-blocking call that registers the server message listener.   while (total == 0) {}  io:println(\"Client got response successfully.\"); }    service HelloWorldMessageListener = service {    Server Message Listener.   resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }    The resource registered to receive server messages   resource function onError(error err) {  io:println(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    The resource registered to receive server error messages   resource function onComplete() {  total = 1;  io:println(\"Server Complete Sending Responses.\");  } };    The resource registered to receive server completed messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_server_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_server_streaming_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. $ ballerina build client    # Run the client using the following command. $ ballerina run target/bin/client.jar"},{"page":"/learn/by-example/grpc-unary-non-blocking.html","name":"Unary Non-Blocking","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This sample demonstrates how the gRPC unary service interacts with the gRPC non-blocking client.This is the service definition for the unary blocking/unblocking scenario.This is the server implementation for the unary blocking/unblocking scenario.Bind the service to the port.Send a ...","content":"/  /  / Unary Non-Blocking  syntax = \"proto3\"; package service; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); } import ballerina/grpc; import ballerina/log; service HelloWorld on new grpc:Listener(9090) { resource function hello(grpc:Caller caller, string name) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;  grpc:Error? result = caller->send(message);  if (result is grpc:Error) {  log:printError(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  }  result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  }  } }# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_non_blocking_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.# Add new Ballerina file `grpc_unary_non_blocking.bal` inside the `service` module and add service implementation. import ballerina/grpc; import ballerina/io;int total = 0; public function main() {  HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");  grpc:Error? result = helloWorldEp->hello(\"WSO2\", HelloWorldMessageListener); if (result is grpc:Error) {  io:println(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  } else {  io:println(\"Connected successfully\");  } while (total == 0) {}  io:println(\"Client got response successfully.\"); } service HelloWorldMessageListener = service {  resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }  resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }  resource function onComplete() {  io:println(\"Server Complete Sending Response.\");  total = 1;  } };# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_non_blocking_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.# Add new Ballerina file `grpc_unary_non_blocking_client.bal` inside the `client` module and add client implementation.    Unary Non-Blocking  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This sample demonstrates how the gRPC unary service interacts with the gRPC non-blocking client.    syntax = \"proto3\"; package service; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the unary blocking/unblocking scenario.   # Create new Protocol Buffers definition file `grpc_unary_non_blocking.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. $ ballerina grpc --input grpc_unary_non_blocking.proto --output stubs    # Once you run the command, `grpc_unary_non_blocking_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the unary blocking/unblocking scenario.   service HelloWorld on new grpc:Listener(9090) {    Bind the service to the port.   resource function hello(grpc:Caller caller, string name) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;    grpc:Error? result = caller->send(message);  if (result is grpc:Error) {  log:printError(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  }    Send a response message to the caller.   result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  }  } }    Send the completed notification to the caller.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_non_blocking_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_unary_non_blocking.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. $ ballerina build service    # Run the service using the following command. $ ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is the client implementation for the unary non blocking scenario.   int total = 0; public function main() {    HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:Error? result = helloWorldEp->hello(\"WSO2\", HelloWorldMessageListener);    Execute the unary non-blocking call that registers the server message listener.   if (result is grpc:Error) {  io:println(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  } else {  io:println(\"Connected successfully\");  }    while (total == 0) {}  io:println(\"Client got response successfully.\"); }    service HelloWorldMessageListener = service {    Server Message Listener.   resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }    The resource registered to receive server messages.   resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    The resource registered to receive server error messages.   resource function onComplete() {  io:println(\"Server Complete Sending Response.\");  total = 1;  } };    The resource registered to receive server completed messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_non_blocking_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_unary_non_blocking_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. $ ballerina build client    # Run the client using the following command. $ ballerina run target/bin/client.jar"},{"page":"/learn/by-example/grpc-unary-blocking.html","name":"Unary Blocking","summary":"The gRPC Server Connector exposes the gRPC service over http2.\n This sample demonstrates how the gRPC unary service interacts with the gRPC blocking client, and how\n header values are handled.This is the service definition for the unary blocking/unblocking scenario.This is the server implementation for the unary blocking/unblocking scenario.Reads custom headers ...","content":"/  /  / Unary Blocking  syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); } import ballerina/grpc; import ballerina/log;service HelloWorld on new grpc:Listener(9090) { resource function hello(grpc:Caller caller, string name,  grpc:Headers headers) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;  string reqHeader = headers.get(\"client_header_key\") ?: \"none\";  log:printInfo(\"Server received header value: \" + reqHeader);  grpc:Headers resHeader = new;  resHeader.setEntry(\"server_header_key\", \"Response Header value\");  grpc:Error? err = caller->send(message, resHeader);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }  grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_blocking_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.# Add new Ballerina file `grpc_unary_blocking.bal` inside the `service` module and add service implementation. import ballerina/grpc; import ballerina/io;public function main() {  HelloWorldBlockingClient helloWorldBlockingEp = new (\"http://localhost:9090\");  grpc:Headers headers = new;  headers.setEntry(\"client_header_key\", \"Request Header Value\");  var unionResp = helloWorldBlockingEp->hello(\"WSO2\", headers);  if (unionResp is grpc:Error) {  io:println(\"Error from Connector: \" + unionResp.reason() + \" - \"  + <string>unionResp.detail()[\"message\"]);  } else {  string result;  grpc:Headers resHeaders;  [result, resHeaders] = unionResp;  io:println(\"Client Got Response : \" + result);  string headerValue = resHeaders.get(\"server_header_key\") ?: \"none\";  io:println(\"Headers: \" + headerValue);  } }# Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_blocking_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.# Add new Ballerina file `grpc_unary_blocking_client.bal` inside the `client` module and add client implementation.    Unary Blocking  The gRPC Server Connector exposes the gRPC service over http2.  This sample demonstrates how the gRPC unary service interacts with the gRPC blocking client, and how  header values are handled.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the unary blocking/unblocking scenario.   # Create new Protocol Buffers definition file `grpc_unary_blocking.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. $ ballerina grpc --input grpc_unary_blocking.proto --output stubs    # Once you run the command, `grpc_unary_blocking_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the unary blocking/unblocking scenario.   service HelloWorld on new grpc:Listener(9090) {    resource function hello(grpc:Caller caller, string name,  grpc:Headers headers) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;    string reqHeader = headers.get(\"client_header_key\") ?: \"none\";  log:printInfo(\"Server received header value: \" + reqHeader);    Reads custom headers in request message.   grpc:Headers resHeader = new;  resHeader.setEntry(\"server_header_key\", \"Response Header value\");    Writes custom headers to response message.   grpc:Error? err = caller->send(message, resHeader);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    Sends response message with headers.   grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }    Sends completed notification to caller.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_blocking_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_unary_blocking.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. $ ballerina build service    # Run the service using the following command. $ ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is client implementation for unary blocking scenario.   public function main() {    HelloWorldBlockingClient helloWorldBlockingEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:Headers headers = new;  headers.setEntry(\"client_header_key\", \"Request Header Value\");    Writes custom headers to request message.   var unionResp = helloWorldBlockingEp->hello(\"WSO2\", headers);    Executes unary blocking call with headers.   if (unionResp is grpc:Error) {  io:println(\"Error from Connector: \" + unionResp.reason() + \" - \"  + <string>unionResp.detail()[\"message\"]);  } else {  string result;  grpc:Headers resHeaders;  [result, resHeaders] = unionResp;  io:println(\"Client Got Response : \" + result);  string headerValue = resHeaders.get(\"server_header_key\") ?: \"none\";  io:println(\"Headers: \" + headerValue);  } }    Reads message and headers from response.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_blocking_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_unary_blocking_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. $ ballerina build client    # Run the client using the following command. $ ballerina run target/bin/client.jar"},{"page":"/learn/by-example/header-based-routing.html","name":"Header-Based Routing","summary":"The Header-Based Router service reads a particular Header of a request and routes it to a specific recipient based on the Header value.Service is invoked using basePath value “/hbr”.http:resourceConfig{} annotation with ‘GET’ method declares the\n HTTP method.Create a new outbound request to handle client call.Check whether x-type header exists in ...","content":"/  /  / Header-Based Routing  import ballerina/config; import ballerina/http; import ballerina/log;http:ClientConfiguration weatherEPConfig = {  followRedirects: {enabled: true, maxCount: 5},  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }; @http:ServiceConfig {  basePath: \"/hbr\" }service headerBasedRouting on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/route\"  } resource function hbrResource(http:Caller caller, http:Request req) {  http:Client weatherEP = new (\"http://samples.openweathermap.org\",  weatherEPConfig);  http:Client locationEP = new (\"http://www.mocky.io\");  http:Request newRequest = new;  if (!req.hasHeader(\"x-type\")) {  http:Response errorResponse = new;  errorResponse.statusCode = 500;  json errMsg = {\"error\": \"'x-type' header is not found\"};  errorResponse.setPayload(errMsg); var result = caller->respond(errorResponse); if (result is error) {  log:printError(\"Error sending response\", result);  }  return;  }  string nameString = req.getHeader(\"x-type\"); http:Response|error response;  if (nameString == \"location\") {  response = locationEP->post(\"/v2/5adddd66300000bd2a4b2912\",  newRequest); } else {  response =  weatherEP->get(\"/data/2.5/weather?lat=35&lon=139&appid=b1b1\",  newRequest); } if (response is http:Response) { var result = caller->respond(response); if (result is error) {  log:printError(\"Error sending response\", result);  } } else {  http:Response errorResponse = new;  errorResponse.statusCode = 500;  errorResponse.setPayload(<string>response.detail()?.message);  var result = caller->respond(errorResponse); if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    Header-Based Routing  The Header-Based Router service reads a particular Header of a request and routes it to a specific recipient based on the Header value.    import ballerina/config; import ballerina/http; import ballerina/log;    http:ClientConfiguration weatherEPConfig = {  followRedirects: {enabled: true, maxCount: 5},  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } };    @http:ServiceConfig {  basePath: \"/hbr\" }    Service is invoked using basePath value “/hbr”.   service headerBasedRouting on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/route\"  }    http:resourceConfig{} annotation with ‘GET’ method declares the  HTTP method.   resource function hbrResource(http:Caller caller, http:Request req) {  http:Client weatherEP = new (\"http://samples.openweathermap.org\",  weatherEPConfig);  http:Client locationEP = new (\"http://www.mocky.io\");    http:Request newRequest = new;    Create a new outbound request to handle client call.   if (!req.hasHeader(\"x-type\")) {  http:Response errorResponse = new;  errorResponse.statusCode = 500;  json errMsg = {\"error\": \"'x-type' header is not found\"};  errorResponse.setPayload(errMsg);    Check whether x-type header exists in the request.   var result = caller->respond(errorResponse);    if (result is error) {  log:printError(\"Error sending response\", result);  }  return;  }    string nameString = req.getHeader(\"x-type\");    getHeader() returns header value of the specified header name.   http:Response|error response;  if (nameString == \"location\") {    response = locationEP->post(\"/v2/5adddd66300000bd2a4b2912\",  newRequest);    post() remote function represents the ‘POST’ operation  of the HTTP client.  Route payload to the relevant service.   } else {    response =  weatherEP->get(\"/data/2.5/weather?lat=35&lon=139&appid=b1b1\",  newRequest);    get() remote function can be used to make an http GET call.   }    if (response is http:Response) {    respond() sends back the inbound clientResponse to the caller  if no error occurs.   var result = caller->respond(response);    if (result is error) {  log:printError(\"Error sending response\", result);  }    } else {  http:Response errorResponse = new;  errorResponse.statusCode = 500;  errorResponse.setPayload(<string>response.detail()?.message);  var result = caller->respond(errorResponse);    if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command along with the # Ballerina home path as a config. $ ballerina run header_based_routing.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    $ curl http://localhost:9090/hbr/route -H \"x-type:location\" {  \"name\": \"Colombo,Sri Lanka\",  \"longitude\": -556.49,  \"latitude\": 257.76,  \"altitude\": 230 }    $ curl http://localhost:9090/hbr/route -H \"x-type:weather\" {\"coord\":{\"lon\":139.01,\"lat\":35.02},\"weather\":[{\"id\":800, \"main\":\"Clear\",\"description\":\"clear sky\",\"icon\":\"01n\"}], \"base\":\"stations\",\"main\":{\"temp\":285.514,\"pressure\":1013.75, \"humidity\":100,\"temp_min\":285.514,\"temp_max\":285.514, \"sea_level\":1023.22,\"grnd_level\":1013.75}, \"wind\":{\"speed\":5.52,\"deg\":311},\"clouds\":{\"all\":0}, \"dt\":1485792967,\"sys\":{\"message\":0.0025,\"country\":\"JP\", \"sunrise\":1485726240,\"sunset\":1485763863}, \"id\":1907296,\"name\":\"Tawarano\",\"cod\":200}"},{"page":"/learn/by-example/hello-world-client.html","name":"Hello World Client","summary":"Ballerina clients can be used to connect to and interact with HTTP endpoints.\n Ballerina creates an HTTP/1.1 client by default.Create an HTTP client to interact with a remote endpoint.Send a GET request to the server.If the request is successful, retrieve the text payload from the\n response.Log the retrieved text payload.If ...","content":"/  /  / Hello World Client  import ballerina/http; import ballerina/io;public function main() {  http:Client clientEP = new (\"http://www.mocky.io\");  var resp = clientEP->get(\"/v2/5ae082123200006b00510c3d/\"); if (resp is http:Response) {  var payload = resp.getTextPayload();  if (payload is string) {  io:println(payload);  } else {  io:println(payload.detail());  }  } else {  io:println(resp.detail());  } }    Hello World Client  Ballerina clients can be used to connect to and interact with HTTP endpoints.  Ballerina creates an HTTP/1.1 client by default.    import ballerina/http; import ballerina/io;    public function main() {    http:Client clientEP = new (\"http://www.mocky.io\");    Create an HTTP client to interact with a remote endpoint.   var resp = clientEP->get(\"/v2/5ae082123200006b00510c3d/\");    Send a GET request to the server.   if (resp is http:Response) {    var payload = resp.getTextPayload();  if (payload is string) {    If the request is successful, retrieve the text payload from the  response.   io:println(payload);  } else {    Log the retrieved text payload.   io:println(payload.detail());  }  } else {    If an error occurs while retrieving the text payload, print  the detail mapping of the error.   io:println(resp.detail());  } }    If an error occurs when getting the response, print the detail  mapping of the error.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run hello_world_client.bal Hello World"},{"page":"/learn/by-example/hello-world-service.html","name":"Hello World Service","summary":"In Ballerina, services represent collections of network-accessible entry points.\n Resources represent one such entry point.\n How a resource is exposed over a network protocol depends on the listener to which a service is attached.By default, Ballerina exposes an HTTP service via HTTP/1.1.Resource functions are invoked with the HTTP caller and ...","content":"/  /  / Hello World Service  import ballerina/http; import ballerina/log; service hello on new http:Listener(9090) {  resource function sayHello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello, World!\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Hello World Service  In Ballerina, services represent collections of network-accessible entry points.  Resources represent one such entry point.  How a resource is exposed over a network protocol depends on the listener to which a service is attached.    import ballerina/http; import ballerina/log;    service hello on new http:Listener(9090) {    By default, Ballerina exposes an HTTP service via HTTP/1.1.   resource function sayHello(http:Caller caller, http:Request req) {    Resource functions are invoked with the HTTP caller and the  incoming request as arguments.   var result = caller->respond(\"Hello, World!\");    Send a response back to the caller.   if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Log the error in case of a failure.   # To start the service, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run hello_world_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    $ curl http://localhost:9090/hello/sayHello Hello, World!    Invoke the service using this “curl” command."},{"page":"/learn/by-example/hello-world-parallel.html","name":"Hello World Parallel","summary":"This example uses Ballerina to print “Hello, World!” in parallel using workers.\n A worker is a sequence of statements that is executed concurrently with all\n other workers in the function.Use one or more workers to define a function execution.\n The function invocation starts all the workers. ...","content":"/  /  / Hello World Parallel  import ballerina/io; public function main() {  @strand {thread: \"any\"}  worker w1 {  io:println(\"Hello, World! #m\");  } @strand {thread: \"any\"}  worker w2 {  io:println(\"Hello, World! #n\");  } @strand {thread: \"any\"}  worker w3 {  io:println(\"Hello, World! #k\");  } }    Hello World Parallel  This example uses Ballerina to print “Hello, World!” in parallel using workers.  A worker is a sequence of statements that is executed concurrently with all  other workers in the function.    import ballerina/io;    public function main() {  @strand {thread: \"any\"}  worker w1 {  io:println(\"Hello, World! #m\");  }    Use one or more workers to define a function execution.  The function invocation starts all the workers.   @strand {thread: \"any\"}  worker w2 {  io:println(\"Hello, World! #n\");  }    @strand {thread: \"any\"}  worker w3 {  io:println(\"Hello, World! #k\");  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run hello_world_parallel.bal Hello, World! #m Hello, World! #k Hello, World! #n"},{"page":"/learn/by-example/hello-world.html","name":"Hello World Main","summary":"Let’s print “Hello, World!” using a main function in Ballerina.\n A public function named main is considered as an entry point to a Ballerina program.The main function, which acts as the entry point. ...","content":"/  /  / Hello World Main  import ballerina/io; public function main() {  io:println(\"Hello, World!\"); }    Hello World Main  Let’s print “Hello, World!” using a main function in Ballerina.  A public function named main is considered as an entry point to a Ballerina program.    import ballerina/io;    public function main() {  io:println(\"Hello, World!\"); }    The main function, which acts as the entry point.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run hello_world.bal Hello, World!"},{"page":"/learn/by-example/http-1-1-to-2-0-protocol-switch.html","name":"HTTP 1.1 to 2.0 Protocol Switch","summary":"In this example, the Ballerina HTTP service receives a message over the HTTP/1.1 protocol and forwards it\n to another service over the HTTP/2.0 protocol.HTTP version is set to 2.0.Forward the clientRequest to the http2 service.Handle the errors that are returned when invoking the\n forward function.Send the response back to the ...","content":"/  /  / HTTP 1.1 to 2.0 Protocol Switch  import ballerina/http; import ballerina/log; http:Client http2serviceClientEP = new (\"http://localhost:7090\", {httpVersion: \"2.0\"});@http:ServiceConfig {  basePath: \"/http11Service\" } service http11Service on new http:Listener(9090) { @http:ResourceConfig {  path: \"/\"  }  resource function http11Resource(http:Caller caller,  http:Request clientRequest) {  var clientResponse = http2serviceClientEP->forward(\"/http2service\",  clientRequest); http:Response response = new;  if (clientResponse is http:Response) {  response = clientResponse;  } else {  response.statusCode = 500;  response.setPayload(<string>clientResponse.detail()?.message);  }  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error occurred while sending the response\",  err = result);  } } } listener http:Listener http2serviceEP = new (7090,  config = {httpVersion: \"2.0\"});@http:ServiceConfig {  basePath: \"/http2service\" } service http2service on http2serviceEP { @http:ResourceConfig {  path: \"/\"  }  resource function http2Resource(http:Caller caller,  http:Request clientRequest) {  http:Response response = new;  json msg = {\"response\": {\"message\": \"response from http2 service\"}};  response.setPayload(msg);  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error occurred while sending the response\",  err = result);  }  } }    HTTP 1.1 to 2.0 Protocol Switch  In this example, the Ballerina HTTP service receives a message over the HTTP/1.1 protocol and forwards it  to another service over the HTTP/2.0 protocol.    import ballerina/http; import ballerina/log;    http:Client http2serviceClientEP = new (\"http://localhost:7090\", {httpVersion: \"2.0\"});    HTTP version is set to 2.0.   @http:ServiceConfig {  basePath: \"/http11Service\" } service http11Service on new http:Listener(9090) {    @http:ResourceConfig {  path: \"/\"  }  resource function http11Resource(http:Caller caller,  http:Request clientRequest) {    var clientResponse = http2serviceClientEP->forward(\"/http2service\",  clientRequest);    Forward the clientRequest to the http2 service.   http:Response response = new;  if (clientResponse is http:Response) {  response = clientResponse;  } else {    response.statusCode = 500;  response.setPayload(<string>clientResponse.detail()?.message);  }    Handle the errors that are returned when invoking the  forward function.   var result = caller->respond(response);  if (result is error) {  log:printError(\"Error occurred while sending the response\",  err = result);  }    Send the response back to the caller.   } }    listener http:Listener http2serviceEP = new (7090,  config = {httpVersion: \"2.0\"});    HTTP version is set to 2.0.   @http:ServiceConfig {  basePath: \"/http2service\" } service http2service on http2serviceEP {    @http:ResourceConfig {  path: \"/\"  }  resource function http2Resource(http:Caller caller,  http:Request clientRequest) {    http:Response response = new;  json msg = {\"response\": {\"message\": \"response from http2 service\"}};  response.setPayload(msg);    Construct the response message.   var result = caller->respond(response);  if (result is error) {  log:printError(\"Error occurred while sending the response\",  err = result);  }  } }    Send the response back to the caller (http11Service).   # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_1.1_to_2.0_protocol_switch.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:7090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    $ curl http://localhost:9090/http11Service {\"response\":{\"message\":\"response from http2 service\"}}    Invoke the HTTP/1.1 service using “curl”."},{"page":"/learn/by-example/http-100-continue.html","name":"100 Continue","summary":"Convenience functions are provided in the HTTP library for ease of use when handling 100-continue scenarios.\n 100-continue indicates that the server has received the request headers and the client can proceed with sending the request.Check if the client expects a 100-continue response.Send a 100-continue response to the client.Send a 417 ...","content":"/  /  / 100 Continue  import ballerina/http; import ballerina/log;@http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(9090) { @http:ResourceConfig {  path: \"/\"  }  resource function hello(http:Caller caller, http:Request request) {  if (request.expects100Continue()) {  string mediaType = request.getHeader(\"Content-Type\");  if (mediaType.toLowerAscii() == \"text/plain\") {  var result = caller->continue();  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response res = new;  res.statusCode = 417;  res.setPayload(\"Unprocessable Entity\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  return;  }  }  http:Response res = new;  var payload = request.getTextPayload();  if (payload is string) {  log:printInfo(payload);  res.statusCode = 200;  res.setPayload(\"Hello World!\\n\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>payload.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    100 Continue  Convenience functions are provided in the HTTP library for ease of use when handling 100-continue scenarios.  100-continue indicates that the server has received the request headers and the client can proceed with sending the request.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(9090) {    @http:ResourceConfig {  path: \"/\"  }  resource function hello(http:Caller caller, http:Request request) {    if (request.expects100Continue()) {  string mediaType = request.getHeader(\"Content-Type\");  if (mediaType.toLowerAscii() == \"text/plain\") {    Check if the client expects a 100-continue response.   var result = caller->continue();  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {    Send a 100-continue response to the client.   http:Response res = new;  res.statusCode = 417;  res.setPayload(\"Unprocessable Entity\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  return;  }  }    Send a 417 response to ignore the payload since content type is mismatched  with the expected content type.   http:Response res = new;  var payload = request.getTextPayload();  if (payload is string) {  log:printInfo(payload);  res.statusCode = 200;  res.setPayload(\"Hello World!\\n\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>payload.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    The client starts sending the payload once it receives the  100-continue response. Retrieve the payload that is sent by the client.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_expect_header.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2018-12-04 21:37:36,272 INFO [ballerina/log] - TEST 100 CONTINUE    #Run the following curl command to run the client. $ curl -v -d \"TEST 100 CONTINUE\" http://localhost:9090/hello -H 'Expect:100-continue' -H 'Content-Type: text/plain' * Trying 127.0.0.1... * Connected to localhost (127.0.0.1) port 9090 (#0) > POST /hello HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Expect:100-continue > Content-Length: 17 > Content-Type: text/plain > < HTTP/1.1 100 Continue * We are completely uploaded and fine < HTTP/1.1 200 OK < content-type: text/plain < content-length: 13 < Hello World! * Connection #0 to host localhost left intact    # Use the following client to invoke the service using an unsupported media type. Service is supposed to ignore # the payload if the content type does not matched. $ curl -v -d '{\"TEST\":\"100 CONTINUE\"}' http://localhost:9090/hello -H 'Expect:100-continue' -H 'Content-Type: application/json' * Connected to localhost (127.0.0.1) port 9090 (#0) > POST /hello HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Expect:100-continue > Content-Type: application/json > Content-Length: 25 > < HTTP/1.1 417 Expectation Failed < content-type: text/plain < content-length: 20 * HTTP error before end of send, stop sending < * Closing connection 0 Unprocessable Entity"},{"page":"/learn/by-example/http-2-0-server-push.html","name":"HTTP 2.0 Server Push","summary":"This example demonstrates sending and receiving HTTP/2 Server Push messages in Ballerina HTTP Library.\n HTTP/2 Server Push messages allow the server to send resources to the client before the client requests for it.Create an endpoint with port 7090 to accept HTTP requests.\n HTTP version is set to 2.0.Send a Push ...","content":"/  /  / HTTP 2.0 Server Push  import ballerina/http; import ballerina/log; listener http:Listener http2ServiceEP = new (7090,  config = {httpVersion: \"2.0\"});@http:ServiceConfig {  basePath: \"/http2Service\" } service http2Service on http2ServiceEP { @http:ResourceConfig {  path: \"/\"  }  resource function http2Resource(http:Caller caller, http:Request req) {  http:PushPromise promise1 = new (path = \"/resource1\", method = \"GET\");  var promiseResponse1 = caller->promise(promise1);  if (promiseResponse1 is error) {  log:printError(\"Error occurred while sending the promise1\",  err = promiseResponse1);  }  http:PushPromise promise2 = new (path = \"/resource2\", method = \"GET\");  var promiseResponse2 = caller->promise(promise2);  if (promiseResponse2 is error) {  log:printError(\"Error occurred while sending the promise2\",  err = promiseResponse2);  }  http:PushPromise promise3 = new (path = \"/resource3\", method = \"GET\");  var promiseResponse3 = caller->promise(promise3);  if (promiseResponse3 is error) {  log:printError(\"Error occurred while sending the promise3\",  err = promiseResponse3);  }  http:Response res = new;  json msg = {\"response\": {\"name\": \"main resource\"}};  res.setPayload(msg);  var response = caller->respond(res);  if (response is error) {  log:printError(\"Error occurred while sending the response\",  err = response);  }  http:Response push1 = new;  msg = {\"push\": {\"name\": \"resource1\"}};  push1.setPayload(msg);  var pushResponse1 = caller->pushPromisedResponse(promise1, push1);  if (pushResponse1 is error) {  log:printError(\"Error occurred while sending the promised response1\",  err = pushResponse1);  }  http:Response push2 = new;  msg = {\"push\": {\"name\": \"resource2\"}};  push2.setPayload(msg);  var pushResponse2 = caller->pushPromisedResponse(promise2, push2);  if (pushResponse2 is error) {  log:printError(\"Error occurred while sending the promised response2\",  err = pushResponse2);  }  http:Response push3 = new;  msg = {\"push\": {\"name\": \"resource3\"}};  push3.setPayload(msg);  var pushResponse3 = caller->pushPromisedResponse(promise3, push3);  if (pushResponse3 is error) {  log:printError(\"Error occurred while sending the promised response3\",  err = pushResponse3);  }  } }import ballerina/http; import ballerina/log; http:Client clientEP = new (\"http://localhost:7090\", {httpVersion: \"2.0\"});public function main() { http:Request serviceReq = new;  http:HttpFuture httpFuture = new;  var submissionResult = clientEP->submit(\"GET\", \"/http2Service\", serviceReq); if (submissionResult is http:HttpFuture) {  httpFuture = submissionResult;  } else {  log:printError(\"Error occurred while submitting a request\",  err = submissionResult);  return;  } http:PushPromise?[] promises = [];  int promiseCount = 0;  boolean hasPromise = clientEP->hasPromise(httpFuture); while (hasPromise) {  http:PushPromise pushPromise = new;  var nextPromiseResult = clientEP->getNextPromise(httpFuture); if (nextPromiseResult is http:PushPromise) {  pushPromise = nextPromiseResult;  } else {  log:printError(\"Error occurred while fetching a push promise\",  err = nextPromiseResult);  return;  }  log:printInfo(\"Received a promise for \" + pushPromise.path); if (pushPromise.path == \"/resource2\") {  clientEP->rejectPromise(pushPromise); log:printInfo(\"Push promise for resource2 rejected\");  } else {  promises[promiseCount] = pushPromise; promiseCount = promiseCount + 1;  }  hasPromise = clientEP->hasPromise(httpFuture);  } http:Response response = new;  var result = clientEP->getResponse(httpFuture); if (result is http:Response) {  response = result;  } else {  log:printError(\"Error occurred while fetching response\",  err = result);  return;  } var responsePayload = response.getJsonPayload();  if (responsePayload is json) {  log:printInfo(\"Response : \" + responsePayload.toJsonString());  } else {  log:printError(\"Expected response payload not received\",  err = responsePayload);  }  foreach var p in promises {  http:PushPromise promise = <http:PushPromise>p;  http:Response promisedResponse = new;  var promisedResponseResult = clientEP->getPromisedResponse(promise);  if (promisedResponseResult is http:Response) {  promisedResponse = promisedResponseResult;  } else {  log:printError(\"Error occurred while fetching promised response\",  err = promisedResponseResult);  return;  }  var promisedPayload = promisedResponse.getJsonPayload();  if (promisedPayload is json) {  log:printInfo(\"Promised resource : \" + promisedPayload.toJsonString());  } else {  log:printError(\"Expected promised response payload not received\",  err = promisedPayload);  }  } }    HTTP 2.0 Server Push  This example demonstrates sending and receiving HTTP/2 Server Push messages in Ballerina HTTP Library.  HTTP/2 Server Push messages allow the server to send resources to the client before the client requests for it.    import ballerina/http; import ballerina/log;    listener http:Listener http2ServiceEP = new (7090,  config = {httpVersion: \"2.0\"});    Create an endpoint with port 7090 to accept HTTP requests.  HTTP version is set to 2.0.   @http:ServiceConfig {  basePath: \"/http2Service\" } service http2Service on http2ServiceEP {    @http:ResourceConfig {  path: \"/\"  }  resource function http2Resource(http:Caller caller, http:Request req) {    http:PushPromise promise1 = new (path = \"/resource1\", method = \"GET\");  var promiseResponse1 = caller->promise(promise1);  if (promiseResponse1 is error) {  log:printError(\"Error occurred while sending the promise1\",  err = promiseResponse1);  }    Send a Push Promise.   http:PushPromise promise2 = new (path = \"/resource2\", method = \"GET\");  var promiseResponse2 = caller->promise(promise2);  if (promiseResponse2 is error) {  log:printError(\"Error occurred while sending the promise2\",  err = promiseResponse2);  }    Send another Push Promise.   http:PushPromise promise3 = new (path = \"/resource3\", method = \"GET\");  var promiseResponse3 = caller->promise(promise3);  if (promiseResponse3 is error) {  log:printError(\"Error occurred while sending the promise3\",  err = promiseResponse3);  }    Send one more Push Promise.   http:Response res = new;  json msg = {\"response\": {\"name\": \"main resource\"}};  res.setPayload(msg);    Construct the requested resource.   var response = caller->respond(res);  if (response is error) {  log:printError(\"Error occurred while sending the response\",  err = response);  }    Send the requested resource.   http:Response push1 = new;  msg = {\"push\": {\"name\": \"resource1\"}};  push1.setPayload(msg);    Construct promised resource1.   var pushResponse1 = caller->pushPromisedResponse(promise1, push1);  if (pushResponse1 is error) {  log:printError(\"Error occurred while sending the promised response1\",  err = pushResponse1);  }    Push promised resource1.   http:Response push2 = new;  msg = {\"push\": {\"name\": \"resource2\"}};  push2.setPayload(msg);    Construct promised resource2.   var pushResponse2 = caller->pushPromisedResponse(promise2, push2);  if (pushResponse2 is error) {  log:printError(\"Error occurred while sending the promised response2\",  err = pushResponse2);  }    Push promised resource2.   http:Response push3 = new;  msg = {\"push\": {\"name\": \"resource3\"}};  push3.setPayload(msg);    Construct promised resource3.   var pushResponse3 = caller->pushPromisedResponse(promise3, push3);  if (pushResponse3 is error) {  log:printError(\"Error occurred while sending the promised response3\",  err = pushResponse3);  }  } }    Push promised resource3.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_2.0_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:7090    import ballerina/http; import ballerina/log;    http:Client clientEP = new (\"http://localhost:7090\", {httpVersion: \"2.0\"});    Create an HTTP client endpoint that can send HTTP/2 messages.  HTTP version is set to 2.0.   public function main() {    http:Request serviceReq = new;  http:HttpFuture httpFuture = new;    var submissionResult = clientEP->submit(\"GET\", \"/http2Service\", serviceReq);    Submit a request.   if (submissionResult is http:HttpFuture) {  httpFuture = submissionResult;  } else {  log:printError(\"Error occurred while submitting a request\",  err = submissionResult);  return;  }    http:PushPromise?[] promises = [];  int promiseCount = 0;    boolean hasPromise = clientEP->hasPromise(httpFuture);    Check if promises exists.   while (hasPromise) {  http:PushPromise pushPromise = new;    var nextPromiseResult = clientEP->getNextPromise(httpFuture);    Get the next promise.   if (nextPromiseResult is http:PushPromise) {  pushPromise = nextPromiseResult;  } else {  log:printError(\"Error occurred while fetching a push promise\",  err = nextPromiseResult);  return;  }  log:printInfo(\"Received a promise for \" + pushPromise.path);    if (pushPromise.path == \"/resource2\") {    clientEP->rejectPromise(pushPromise);    The client is not interested in receiving /resource2.  Therefore, reject the promise.   log:printInfo(\"Push promise for resource2 rejected\");  } else {    promises[promiseCount] = pushPromise;    Store the required promises.   promiseCount = promiseCount + 1;  }  hasPromise = clientEP->hasPromise(httpFuture);  }    http:Response response = new;    var result = clientEP->getResponse(httpFuture);    Get the requested resource.   if (result is http:Response) {  response = result;  } else {  log:printError(\"Error occurred while fetching response\",  err = result);  return;  }    var responsePayload = response.getJsonPayload();  if (responsePayload is json) {  log:printInfo(\"Response : \" + responsePayload.toJsonString());  } else {  log:printError(\"Expected response payload not received\",  err = responsePayload);  }    foreach var p in promises {  http:PushPromise promise = <http:PushPromise>p;  http:Response promisedResponse = new;  var promisedResponseResult = clientEP->getPromisedResponse(promise);  if (promisedResponseResult is http:Response) {  promisedResponse = promisedResponseResult;  } else {  log:printError(\"Error occurred while fetching promised response\",  err = promisedResponseResult);  return;  }  var promisedPayload = promisedResponse.getJsonPayload();  if (promisedPayload is json) {  log:printInfo(\"Promised resource : \" + promisedPayload.toJsonString());  } else {  log:printError(\"Expected promised response payload not received\",  err = promisedPayload);  }  } }    Fetch required promise responses.   #Run the `http_client.bal` that contains ballerina client. $ ballerina run http_client.bal INFO [ballerina/log] - Received a promise for /resource1 INFO [ballerina/log] - Received a promise for /resource2 INFO [ballerina/log] - Push promise for resource2 rejected INFO [ballerina/log] - Received a promise for /resource3 INFO [ballerina/log] - Response : {\"response\":{\"name\":\"main resource\"}} INFO [ballerina/log] - Promised resource : {\"push\":{\"name\":\"resource1\"}} INFO [ballerina/log] - Promised resource : {\"push\":{\"name\":\"resource3\"}}"},{"page":"/learn/by-example/http-access-logs.html","name":"Access Logs","summary":"Ballerina supports HTTP access logs for HTTP services. The access log format used is the combined log format.Respond with the message “Successful” for each request.Log the error in case of a failure. ...","content":"/  /  / Access Logs  import ballerina/http; import ballerina/log;@http:ServiceConfig {  basePath: \"/hello\" } service helloService on new http:Listener(9095) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function hello(http:Caller caller, http:Request request) {  var result = caller->respond(\"Successful\");  if (result is error) {  log:printError(\"Error occurred while responding\", result);  }  } }    Access Logs  Ballerina supports HTTP access logs for HTTP services. The access log format used is the combined log format.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/hello\" } service helloService on new http:Listener(9095) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function hello(http:Caller caller, http:Request request) {    var result = caller->respond(\"Successful\");    Respond with the message “Successful” for each request.   if (result is error) {  log:printError(\"Error occurred while responding\", result);  }  } }    Log the error in case of a failure.   # At the command line, navigate to the directory that contains the # `.bal` file and do one of the following depending on whether you want the logs to be logged on the console, or in a file. # Run the service by setting the `--b7a.http.accesslog.console=true` property to log to the console. $ ballerina run http_access_logs.bal --b7a.http.accesslog.console=true ballerina: HTTP access log enabled [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 127.0.0.1 - - [30/Oct/2018:11:23:08 +0530] \"GET /hello HTTP/1.1\" 200 10 \"-\" \"curl/7.58.0\"    # Or, run the service by setting `--b7a.http.accesslog.path=path/to/file.txt` to log to the specified file. $ ballerina run http_access_logs.bal --b7a.http.accesslog.path=path/to/file.txt ballerina: HTTP access log enabled [ballerina/http] started HTTP/WS listener 0.0.0.0:9095    # Invoke the service. $ curl -k http://localhost:9095/hello Successful"},{"page":"/learn/by-example/http-compression.html","name":"HTTP Compression","summary":"This sample demonstrates how the Ballerina HTTP service is configured to change the compression behaviour. By default, the server\n compresses the response entity body with the scheme(gzip, deflate) that is specified in the Accept-Encoding request header. When\n the particular header is not present or the header value is “identity”, the ...","content":"/  /  / HTTP Compression  import ballerina/http; import ballerina/log;listener http:Listener listenerEndpoint = new (9090); @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_AUTO  } } service autoCompress on listenerEndpoint {  @http:ResourceConfig {  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request req) {  var result = caller->respond({\"Type\": \"Auto compression\"}); if (result is error) {  log:printError(\"Error sending response\", result);  }  } } @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_ALWAYS,  contentTypes: [\"text/plain\"]  } } service alwaysCompress on listenerEndpoint {  resource function getJson(http:Caller caller, http:Request req) {  json msg = {\"Type\": \"Always but constrained by content-type\"};  var result = caller->respond(msg);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  resource function getString(http:Caller caller, http:Request req) {  var result = caller->respond(\"Type : This is a string\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } } http:Client clientEndpoint = new (\"http://localhost:9090\", {  compression: http:COMPRESSION_ALWAYS  } );service passthrough on new http:Listener(9092) {  @http:ResourceConfig {  path: \"/\"  }  resource function getCompressed(http:Caller caller, http:Request req) {  var response = clientEndpoint->post(\"/backend/echo\", <@untainted>req);  if (response is http:Response) {  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  json err = {\"error\": \"error occurred while invoking service\"};  var result = caller->respond(err);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } } service backend on listenerEndpoint {  resource function echo(http:Caller caller, http:Request req) {  http:Response res = new;  if (req.hasHeader(\"accept-encoding\")) {  string value = req.getHeader(\"accept-encoding\");  res.setPayload(\"Backend response was encoded : \" + <@untainted>value);  } else {  res.setPayload(\"Accept-Encoding header is not present\");  } var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    HTTP Compression  This sample demonstrates how the Ballerina HTTP service is configured to change the compression behaviour. By default, the server  compresses the response entity body with the scheme(gzip, deflate) that is specified in the Accept-Encoding request header. When  the particular header is not present or the header value is “identity”, the server does not perform any compression. Compression  is disabled when the option is set to COMPRESSION_NEVER.”    import ballerina/http; import ballerina/log;    listener http:Listener listenerEndpoint = new (9090);    @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_AUTO  } } service autoCompress on listenerEndpoint {  @http:ResourceConfig {  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request req) {  var result = caller->respond({\"Type\": \"Auto compression\"});    Since compression behaviour of the service is set as COMPRESSION_AUTO, entity body compression is done according  to the scheme indicated in Accept-Encoding request header. Compression is not performed when the header is not  present or the header value is “identity”.   if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_ALWAYS,  contentTypes: [\"text/plain\"]  } } service alwaysCompress on listenerEndpoint {    COMPRESSION_ALWAYS guarantees a compressed response entity body. Compression scheme is set to the  value indicated in Accept-Encoding request header. When particular header is not present or the header  value is “identity”, encoding is done using “gzip” scheme.  By default Ballerina compresses any MIME type unless they are mentioned under contentTypes.  Compression can be constrained to certain MIME types by specifying them as an array of MIME types.  In this example encoding is applied to “text/plain” responses only.   resource function getJson(http:Caller caller, http:Request req) {  json msg = {\"Type\": \"Always but constrained by content-type\"};  var result = caller->respond(msg);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }    Since compression is only constrained to “text/plain” MIME type,  getJson resource does not compress the response entity body.   resource function getString(http:Caller caller, http:Request req) {  var result = caller->respond(\"Type : This is a string\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    The response entity body is always compressed since MIME type has matched.   http:Client clientEndpoint = new (\"http://localhost:9090\", {  compression: http:COMPRESSION_ALWAYS  } );    The HTTP client can indicate the compression behaviour (“AUTO”, “ALWAYS”, “NEVER”) for content negotiation.  Depending on the compression option values, the Accept-Encoding header is sent along with the request.  In this example, the client compression behaviour is set as COMPRESSION_ALWAYS. If you have not specified  Accept-Encoding header, the client specifies it with “deflate, gzip”. Alternatively, the existing header is sent.  When compression is specified as COMPRESSION_AUTO, only the user specified Accept-Encoding header is sent.  If the behaviour is set as COMPRESSION_NEVER, the client makes sure not to send the Accept-Encoding header.   service passthrough on new http:Listener(9092) {  @http:ResourceConfig {  path: \"/\"  }  resource function getCompressed(http:Caller caller, http:Request req) {  var response = clientEndpoint->post(\"/backend/echo\", <@untainted>req);  if (response is http:Response) {  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  json err = {\"error\": \"error occurred while invoking service\"};  var result = caller->respond(err);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    service backend on listenerEndpoint {  resource function echo(http:Caller caller, http:Request req) {  http:Response res = new;  if (req.hasHeader(\"accept-encoding\")) {  string value = req.getHeader(\"accept-encoding\");  res.setPayload(\"Backend response was encoded : \" + <@untainted>value);  } else {  res.setPayload(\"Accept-Encoding header is not present\");  }    The compression behaviour of the service is inferred by COMPRESSION_AUTO, which is the default value  of the compression config   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_compression.bal # Service deployment ballerina: started HTTP/WS listener 0.0.0.0:9092 ballerina: started HTTP/WS listener 0.0.0.0:9090    # To invoke the autoCompress Service, use the following curl command. # Here the `Accept-Encoding` header is specified as `deflate`. $ curl -v --output - http://localhost:9090/autoCompress -H \"Accept-Encoding:deflate\" > GET /autoCompress HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Accept-Encoding:deflate > < HTTP/1.1 200 OK < content-type: application/json < content-encoding: deflate < content-length: 41 < x��V * Connection #0 to host localhost left intact �,HU�Rr,-�WH��-(J-.���S���\u0003��\t�    # To invoke the alwaysCompress Service to get the JSON payload, use the following curl command. # Here the `Accept-Encoding` header is not specified. $ curl -v --output - http://localhost:9090/alwaysCompress/getJson > GET /alwaysCompress/getJson HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: application/json < content-length: 49 < * Connection #0 to host localhost left intact {\"Type\":\"Always but constrained by content-type\"}    # To invoke the alwaysCompress Service to get the String payload, use the following curl command. # Here the `Accept-Encoding` header is not specified. $ curl -v --output - http://localhost:9090/alwaysCompress/getString > GET /alwaysCompress/getString HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < content-encoding: gzip < content-length: 48 < \u001f� * Connection #0 to host localhost left intact �,HU���,V�D�⒢̼t��\u0003ʴ��\u0017    # To invoke the passthrough Service, use the following curl command. $ curl -v --output - http://localhost:9092/passthrough/ > GET /passthrough/ HTTP/1.1 > Host: localhost:9092 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < transfer-encoding: chunked < * Connection #0 to host localhost left intact Backend response was encoded : deflate, gzip"},{"page":"/learn/by-example/http-caching-client.html","name":"HTTP Caching","summary":"HTTP caching is disabled by default in HTTP client endpoints.\n Users can configure caching using the cache field in the endpoint configurations.HTTP caching is disabled by default for client endpoints. Caching can be\n enabled by setting enabled=true in the cache config of the client\n endpoint. In this example, the isShared ...","content":"/  /  / HTTP Caching  import ballerina/http; import ballerina/log;http:Client cachingEP = new (\"http://localhost:8080\",  {cache: {enabled: true, isShared: true}});@http:ServiceConfig {  basePath: \"/cache\" } service cachingProxy on new http:Listener(9090) { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function cacheableResource(http:Caller caller, http:Request req) {  var response = cachingEP->forward(\"/hello\", req); if (response is http:Response) {  var result = caller->respond(response);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>response.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  }  } }json payload = {\"message\": \"Hello, World!\"}; @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) { @http:ResourceConfig {path: \"/\"}  resource function sayHello(http:Caller caller, http:Request req) {  http:Response res = new;  http:ResponseCacheControl resCC = new;  resCC.maxAge = 15;  resCC.mustRevalidate = true;  resCC.isPrivate = false; res.cacheControl = resCC;  res.setETag(payload);  res.setLastModified(); res.setPayload(payload); var result = caller->respond(res);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } }    HTTP Caching  HTTP caching is disabled by default in HTTP client endpoints.  Users can configure caching using the cache field in the endpoint configurations.    import ballerina/http; import ballerina/log;    HTTP caching is disabled by default for client endpoints. Caching can be  enabled by setting enabled=true in the cache config of the client  endpoint. In this example, the isShared field of the cacheConfig is set  to true, as the cache will be a public cache in this particular scenario.  The default caching policy is to cache a response only if it contains a  cache-control header and either an etag header, or a last-modified  header. The user can control this behaviour by setting the policy field of  the cacheConfig. Currently, there are only 2 policies:  CACHE_CONTROL_AND_VALIDATORS (the default policy) and RFC_7234.   http:Client cachingEP = new (\"http://localhost:8080\",  {cache: {enabled: true, isShared: true}});    @http:ServiceConfig {  basePath: \"/cache\" } service cachingProxy on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function cacheableResource(http:Caller caller, http:Request req) {  var response = cachingEP->forward(\"/hello\", req);    if (response is http:Response) {    var result = caller->respond(response);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } else {    If the request was successful, an HTTP response will be  returned. In this example, the received response is  forwarded to the client through the outbound endpoint.   http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>response.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  }  } }    For failed requests, a 500 response is sent back to the  caller.   json payload = {\"message\": \"Hello, World!\"};    @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {    Sample backend service which serves cacheable responses.   @http:ResourceConfig {path: \"/\"}  resource function sayHello(http:Caller caller, http:Request req) {  http:Response res = new;    http:ResponseCacheControl resCC = new;  resCC.maxAge = 15;  resCC.mustRevalidate = true;  resCC.isPrivate = false;    The ResponseCacheControl object in the Response object can be  used for setting the cache control directives associated with the  response. In this example, max-age directive is set to 15 seconds  indicating that the response will be fresh for 15 seconds. The  must-revalidate directive instructs that the cache should not  serve a stale response without validating it with the origin server  first. The public directive is set by setting isPrivate=false.  This indicates that the response can be cached even by intermediary  caches which serve multiple users.   res.cacheControl = resCC;    res.setETag(payload);    The setETag() function can be used for generating ETags for  string, json, and xml types. This uses the getCRC32()  function from the ballerina/crypto module for generating the ETag.   res.setLastModified();    The setLastModified() function sets the current time as the  last-modified header.   res.setPayload(payload);    When sending the response, if the cacheControl field of the  response is set, and the user has not already set a cache-control  header, a cache-control header will be set using the directives set  in the cacheControl object.   var result = caller->respond(res);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } }    # The two services have to be run separately to observe the following output. # For clarity, only the relevant parts of the HTTP trace logs have been included here. # At the command line, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command by setting the `--b7a.http.tracelog.console=true` property to start the service. $ ballerina run caching_proxy.bal --b7a.http.tracelog.console=true ballerina: deploying service(s) in 'caching_proxy.bal' ballerina: started HTTP/WS listener 0.0.0.0:9090 # The caching proxy receives a request from a client. [2019-09-08 12:35:46,581] TRACE {http.tracelog.downstream} - [id: 0x75aee346, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54140] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /cache HTTP/1.1 Host: localhost:9090 User-Agent: curl/7.58.0 Accept: */*    # The proxy in turn, makes a request to the backend service. [2019-09-08 12:35:46,750] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0x75aee346, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] OUTBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 Accept: */* host: localhost:8080 user-agent: ballerina/1.0.0 connection: keep-alive    # The backend service responds with a `200 OK` and it contains `etag` and `cache-control` headers. This response can be cached and as such, the caching client caches it. As seen from the `max-age` directive of the 'cache-control` header, this response is valid for 15 seconds. [2019-09-08 12:35:46,800] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0x75aee346, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] INBOUND: DefaultHttpResponse(decodeResult: success, version: HTTP/1.1) HTTP/1.1 200 OK etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:35:46 +0530 content-type: application/json cache-control: must-revalidate,public,max-age=15 content-length: 27 server: ballerina/1.0.0 date: Sun, 8 Sep 2019 12:35:46 +0530 [2019-09-08 12:35:46,808] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0x75aee346, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] INBOUND: DefaultLastHttpContent(data: PooledSlicedByteBuf(ridx: 0, widx: 27, cap: 27/27, unwrapped: PooledUnsafeDirectByteBuf(ridx: 287, widx: 287, cap: 1024)), decoderResult: success), 27B {\"message\":\"Hello, World!\"}    # The response is sent back to the client. [2019-09-08 12:35:46,814] TRACE {http.tracelog.downstream} - [id: 0x75aee346, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54140] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 27, cap: 27, components=1)) HTTP/1.1 200 OK etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:35:46 +0530 content-type: application/json cache-control: must-revalidate,public,max-age=15 date: Sun, 8 Sep 2019 12:35:46 +0530 server: ballerina/1.0.0 content-length: 27, 27B {\"message\":\"Hello, World!\"}    # Subsequent requests to the proxy within the next 15 seconds are served from the proxy's cache. As seen here, the backend service is not contacted. [2019-09-08 12:36:00,421] TRACE {http.tracelog.downstream} - [id: 0xa8de466e, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54146] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /cache HTTP/1.1 Host: localhost:9090 User-Agent: curl/7.58.0 Accept: */*    # Cached response. [2019-09-08 12:36:00,435] TRACE {http.tracelog.downstream} - [id: 0xa8de466e, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54146] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 27, cap: 27, components=1)) HTTP/1.1 200 OK etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:35:46 +0530 content-type: application/json cache-control: must-revalidate,public,max-age=15 date: Sun, 8 Sep 2019 12:35:46 +0530 age: 14 server: ballerina/1.0.0 content-length: 27, 27B {\"message\":\"Hello, World!\"}    # Another request is sent after remaining idle for a while. [2019-09-08 12:36:11,009] TRACE {http.tracelog.downstream} - [id: 0xc7e78a3e, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54148] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /cache HTTP/1.1 Host: localhost:9090 User-Agent: curl/7.58.0 Accept: */*    # This time, the request is not served from the cache. The backend service is contacted. The `if-none-match` header sends the entity tag of the now stale response, so that the backend service may determine whether this response is still valid. [2019-09-08 12:36:11,022] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0xc7e78a3e, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] OUTBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 if-none-match: c854ce2c if-modified-since: Sun, 8 Sep 2019 12:35:46 +0530 host: localhost:8080 user-agent: ballerina/1.0.0 connection: keep-alive content-length: 0    # The response has not changed. Therefore the backend services respond with a `304 Not Modified` response. Based on this, the proxy will refresh the response, so that it can continue serving the cached response. [2019-09-08 12:36:11,028] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0xc7e78a3e, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] INBOUND: DefaultHttpResponse(decodeResult: success, version: HTTP/1.1) HTTP/1.1 304 Not Modified etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:36:11 +0530 cache-control: must-revalidate,public,max-age=15 content-length: 0 server: ballerina/1.0.0 date: Sun, 8 Sep 2019 12:36:11 +0530    # The cached response is served yet again since the response has not changed. [2019-09-08 12:36:11,039] TRACE {http.tracelog.downstream} - [id: 0xc7e78a3e, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54148] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 27, cap: 27, components=1)) HTTP/1.1 200 OK content-type: application/json cache-control: must-revalidate,public,max-age=15 date: Sun, 8 Sep 2019 12:36:11 +0530 etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:36:11 +0530 age: 0 server: ballerina/1.0.0 content-length: 27, 27B {\"message\":\"Hello, World!\"}    # The output for the mock service. $ ballerina run hello_service.bal --b7a.http.tracelog.console=true ballerina: deploying service(s) in 'hello_service.bal' ballerina: started HTTP/WS listener 0.0.0.0:8080 # For the first request that the caching proxy receives, it sends a request to the hello service. [2019-09-08 12:35:46,758] TRACE {http.tracelog.downstream} - [id: 0xfef23c5c, correlatedSource: n/a, host:/127.0.0.1:8080 - remote:/127.0.0.1:46172] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 Accept: */* host: localhost:8080 user-agent: ballerina/1.0.0 connection: keep-alive    # The service responds with a `200 OK` with the relevant caching headers set. [2019-09-08 12:35:46,792] TRACE {http.tracelog.downstream} - [id: 0xfef23c5c, correlatedSource: n/a, host:localhost/127.0.0.1:8080 - remote:localhost/127.0.0.1:46172] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 27, cap: 27, components=1)) HTTP/1.1 200 OK etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:35:46 +0530 content-type: application/json cache-control: must-revalidate,public,max-age=15 content-length: 27 server: ballerina/1.0.0 date: Sun, 8 Sep 2019 12:35:46 +0530, 27B {\"message\":\"Hello, World!\"}    # The backend service only gets another request when the cached response and the proxy have expired and it wants to validate it again. [2019-09-08 12:36:11,024] TRACE {http.tracelog.downstream} - [id: 0xfef23c5c, correlatedSource: n/a, host:localhost/127.0.0.1:8080 - remote:localhost/127.0.0.1:46172] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 if-none-match: c854ce2c if-modified-since: Sun, 8 Sep 2019 12:35:46 +0530 host: localhost:8080 user-agent: ballerina/1.0.0 connection: keep-alive content-length: 0    # After checking the `if-none-match` header, the service determines that the response is still the same and that the proxy can keep reusing it. [2019-09-08 12:36:11,027] TRACE {http.tracelog.downstream} - [id: 0xfef23c5c, correlatedSource: n/a, host:localhost/127.0.0.1:8080 - remote:localhost/127.0.0.1:46172] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 0, cap: 0, components=1)) HTTP/1.1 304 Not Modified etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:36:11 +0530 cache-control: must-revalidate,public,max-age=15 content-length: 0 server: ballerina/1.0.0 date: Sun, 8 Sep 2019 12:36:11 +0530, 0B    #Run the following curl command to run the client. $ curl -v http://localhost:9090/cache * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /cache HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < etag: c854ce2c < last-modified: Sun, 8 Sep 2019 12:35:46 +0530 < content-type: application/json < cache-control: must-revalidate,public,max-age=15 < date: Sun, 8 Sep 2019 12:35:46 +0530 < server: ballerina/1.0.0-rc1-SNAPSHOT < content-length: 27 < * Connection #0 to host localhost left intact {\"message\":\"Hello, World!\"}    $ curl -v http://localhost:9090/cache * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /cache HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < etag: c854ce2c < last-modified: Sun, 8 Sep 2019 12:35:46 +0530 < content-type: application/json < cache-control: must-revalidate,public,max-age=15 < date: Sun, 8 Sep 2019 12:35:46 +0530 < age: 14 < server: ballerina/1.0.0-rc1-SNAPSHOT < content-length: 27 < * Connection #0 to host localhost left intact {\"message\":\"Hello, World!\"}    $ curl -v http://localhost:9090/cache * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /cache HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: application/json < cache-control: must-revalidate,public,max-age=15 < date: Sun, 8 Sep 2019 12:36:11 +0530 < etag: c854ce2c < last-modified: Sun, 8 Sep 2019 12:36:11 +0530 < age: 0 < server: ballerina/1.0.0-rc1-SNAPSHOT < content-length: 27 < * Connection #0 to host localhost left intact {\"message\":\"Hello, World!\"}"},{"page":"/learn/by-example/http-client-endpoint.html","name":"Client Endpoint","summary":"The HTTP Client Connector can be used to connect to and interact with an HTTP server.Creates a new client with the backend URL.Sends a GET request to the specified endpoint.Handles the response.Sends a POST request to the specified endpoint.Handles the response.Uses the execute() remote function for custom HTTP verbs.Initializes a ...","content":"/  /  / Client Endpoint  import ballerina/http; import ballerina/io; http:Client clientEndpoint = new (\"http://postman-echo.com\");public function main() {  io:println(\"GET request:\");  var response = clientEndpoint->get(\"/get?test=123\");  handleResponse(response); io:println(\"\\nPOST request:\");  response = clientEndpoint->post(\"/post\", \"POST: Hello World\");  handleResponse(response); io:println(\"\\nUse custom HTTP verbs:\");  response = clientEndpoint->execute(\"COPY\", \"/get\", \"CUSTOM: Hello World\");  http:Request req = new;  req.addHeader(\"Sample-Name\", \"http-client-connector\");  response = clientEndpoint->get(\"/get\", req);  if (response is http:Response) {  string contentType = response.getHeader(\"Content-Type\");  io:println(\"Content-Type: \" + contentType); int statusCode = response.statusCode;  io:println(\"Status code: \" + statusCode.toString()); } else {  io:println(\"Error when calling the backend: \",  response.detail()?.message);  } } function handleResponse(http:Response|error response) {  if (response is http:Response) {  var msg = response.getJsonPayload();  if (msg is json) {  io:println(msg.toJsonString());  } else {  io:println(\"Invalid payload received:\", msg.reason());  }  } else {  io:println(\"Error when calling the backend: \",  response.detail()?.message);  } }    Client Endpoint  The HTTP Client Connector can be used to connect to and interact with an HTTP server.    import ballerina/http; import ballerina/io;    http:Client clientEndpoint = new (\"http://postman-echo.com\");    Creates a new client with the backend URL.   public function main() {  io:println(\"GET request:\");    var response = clientEndpoint->get(\"/get?test=123\");    Sends a GET request to the specified endpoint.   handleResponse(response);    Handles the response.   io:println(\"\\nPOST request:\");    response = clientEndpoint->post(\"/post\", \"POST: Hello World\");    Sends a POST request to the specified endpoint.   handleResponse(response);    Handles the response.   io:println(\"\\nUse custom HTTP verbs:\");    response = clientEndpoint->execute(\"COPY\", \"/get\", \"CUSTOM: Hello World\");    Uses the execute() remote function for custom HTTP verbs.   http:Request req = new;  req.addHeader(\"Sample-Name\", \"http-client-connector\");    Initializes a request.   response = clientEndpoint->get(\"/get\", req);  if (response is http:Response) {  string contentType = response.getHeader(\"Content-Type\");  io:println(\"Content-Type: \" + contentType);    The get(), head(), and options() can have the optional message parameter,  which will be a request or a payload.   int statusCode = response.statusCode;  io:println(\"Status code: \" + statusCode.toString());    } else {  io:println(\"Error when calling the backend: \",  response.detail()?.message);  } }    function handleResponse(http:Response|error response) {  if (response is http:Response) {  var msg = response.getJsonPayload();  if (msg is json) {    The below function handles the response received from the remote HTTP endpoint.   io:println(msg.toJsonString());  } else {  io:println(\"Invalid payload received:\", msg.reason());  }  } else {  io:println(\"Error when calling the backend: \",  response.detail()?.message);  } }    Prints the received json response.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run http_client_endpoint.bal GET request: {\"args\":{\"test\":\"123\"}, \"headers\":{\"x-forwarded-proto\":\"https\", \"host\":\"postman-echo.com\", \"user-agent\":\"ballerina/1.0.0-beta\", \"x-forwarded-port\":\"80\"}, \"url\":\"https://postman-echo.com/get?test=123\"}    POST request: {\"args\":{}, \"data\":\"POST: Hello World\", \"files\":{}, \"form\":{}, \"headers\":{\"x-forwarded-proto\":\"https\", \"host\":\"postman-echo.com\", \"content-length\":\"17\", \"content-type\":\"text/plain\", \"user-agent\":\"ballerina/1.0.0-beta\", \"x-forwarded-port\":\"80\"}, \"json\":null, \"url\":\"https://postman-echo.com/post\"}    Use custom HTTP verbs: Content-Type: application/json; charset=utf-8 Status code: 200"},{"page":"/learn/by-example/http-circuit-breaker.html","name":"Circuit Breaker","summary":"The Circuit Breaker is used to gracefully handle network related errors, which occur when using the HTTP Client.The circuit breaker looks for errors across a rolling time window.\n After the circuit is broken, it does not send requests to\n the backend until the resetTime.Configuration options that control the behavior of ...","content":"/  /  / Circuit Breaker  import ballerina/http; import ballerina/log; import ballerina/runtime; http:Client backendClientEP = new (\"http://localhost:8080\", {  circuitBreaker: {  rollingWindow: {  timeWindowInMillis: 10000,  bucketSizeInMillis: 2000,  requestVolumeThreshold: 0 },  failureThreshold: 0.2,  resetTimeInMillis: 10000,  statusCodes: [400, 404, 500] },  timeoutInMillis: 2000  } ); @http:ServiceConfig {  basePath: \"/cb\" } service circuitbreaker on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload(<string>backendResponse.detail()?.message);  var responseToCaller = caller->respond(response);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }int counter = 1;@http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  if (counter % 5 == 0) {  runtime:sleep(5000); var result = caller->respond(\"Hello World!!!\");  handleRespondResult(result);  } else if (counter % 5 == 3) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(  \"Internal error occurred while processing the request.\");  var result = caller->respond(res);  handleRespondResult(result);  } else {  var result = caller->respond(\"Hello World!!!\");  handleRespondResult(result);  }  counter = counter + 1;  } }function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    Circuit Breaker  The Circuit Breaker is used to gracefully handle network related errors, which occur when using the HTTP Client.    import ballerina/http; import ballerina/log; import ballerina/runtime;    http:Client backendClientEP = new (\"http://localhost:8080\", {    The circuit breaker looks for errors across a rolling time window.  After the circuit is broken, it does not send requests to  the backend until the resetTime.   circuitBreaker: {    Configuration options that control the behavior of the circuit  breaker.   rollingWindow: {    Failure calculation window. This is how long the circuit breaker  keeps the statistics for the operations.   timeWindowInMillis: 10000,    Time period in milliseconds for which the failure threshold  is calculated.   bucketSizeInMillis: 2000,    The granularity (in milliseconds) at which the time window  slides.  The RollingWindow is divided into buckets and slides by  these increments.  For an example, if this timeWindowInMillis is set to 10000  milliseconds and bucketSizeInMillis 2000, then  RollingWindow breaks into sub windows with 2-second  buckets. Stats are collected with respect to the buckets. As  time rolls, a new bucket will be appended to the end of the  window and the old bucket will be removed.   requestVolumeThreshold: 0    Minimum number of requests in a RollingWindow that will  trip the circuit.   },    failureThreshold: 0.2,    The threshold for request failures.  When this threshold exceeds, the circuit trips.  This is the ratio between failures and total requests and the  ratio is considered only within the configured RollingWindow.   resetTimeInMillis: 10000,    The time period (in milliseconds) to wait before attempting to  make another request to the upstream service.  When the failure threshold exceeds, the circuit trips to OPEN  state. Once the circuit is in OPEN state circuit breaker waits  for the time configured in resetTimeInMillis and switch the  circuit to the HALF_OPEN state.   statusCodes: [400, 404, 500]    HTTP response status codes that are considered as failures   },  timeoutInMillis: 2000  } );    @http:ServiceConfig {  basePath: \"/cb\" } service circuitbreaker on new http:Listener(9090) {    Create an HTTP service bound to the endpoint (circuitBreakerEP).   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }    Create a REST resource within the API.   resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);    The parameters include a reference to the caller  and an object of the request data.   if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload(<string>backendResponse.detail()?.message);  var responseToCaller = caller->respond(response);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If the backendResponse is an http:Response, it is sent back to  the client. If backendResponse is an http:ClientError, an  internal server error is returned to the client.   int counter = 1;    This sample service is used to mock connection timeouts and service outages.  Mock a service outage by stopping/starting this service.  This should run separately from the circuitBreakerDemo service.   @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  if (counter % 5 == 0) {    runtime:sleep(5000);    Delay the response by 5000 milliseconds to  mimic the network level delays.   var result = caller->respond(\"Hello World!!!\");  handleRespondResult(result);  } else if (counter % 5 == 3) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(  \"Internal error occurred while processing the request.\");  var result = caller->respond(res);  handleRespondResult(result);  } else {  var result = caller->respond(\"Hello World!!!\");  handleRespondResult(result);  }  counter = counter + 1;  } }    function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_circuit_breaker.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 2019-09-04 17:08:02,595 INFO [ballerina/http/resiliency] - CircuitBreaker failure threshold exceeded. Circuit tripped from CLOSE to OPEN state. 2019-09-04 17:08:12,514 INFO [ballerina/http/resiliency] - CircuitBreaker reset timeout reached. Circuit switched from OPEN to HALF_OPEN state. 2019-09-04 17:08:14,993 INFO [ballerina/http/resiliency] - CircuitBreaker trial run was successful. Circuit switched from HALF_OPEN to CLOSE state. 2019-09-04 17:08:20,003 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed 2019-09-04 17:08:22,082 INFO [ballerina/http/resiliency] - CircuitBreaker failure threshold exceeded. Circuit tripped from CLOSE to OPEN state. 2019-09-04 17:08:32,755 INFO [ballerina/http/resiliency] - CircuitBreaker reset timeout reached. Circuit switched from OPEN to HALF_OPEN state. 2019-09-04 17:08:35,268 INFO [ballerina/http/resiliency] - CircuitBreaker trial run was successful. Circuit switched from HALF_OPEN to CLOSE state.    # The first two requests complete without any errors. $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:07:58 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:00 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # The third request responds with a `500 Internal Server Error` because the # mock service sends a `500` http status code when responding to every third # request. $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:00 +0530 < server: ballerina/1.0.0-beta < content-length: 53 < * Connection #0 to host localhost left intact Internal error occurred while processing the request.    # Subsequent requests fail immediately since the reset timeout period has not # elapsed. $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:02 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 8340 milliseconds.    $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:04 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 6079 milliseconds.    $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:07 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 3475 milliseconds.    # The request sent immediately after the timeout period expires, is the trial # request. It is sent to see if the backend service is back to normal. # If this request is successful, the circuit is set to `close` and normal # functionality resumes. $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:12 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # The fifth request times out because the mock service times out when # responding to every fifth request. $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 57 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:17 +0530 < * Connection #0 to host localhost left intact Idle timeout triggered before initiating inbound response    # Subsequent requests fail immediately since the reset timeout period has not # elapsed. $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:22 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 4917 milliseconds.    # The request sent immediately after the timeout period expires, is the trial # request. It is sent to see if the backend service is back to normal. # If this request is successful, the circuit is set to `close` and normal # functionality resumes. $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:32 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # Since the immediate request after the timeout expired was successful, the # requests sent after that complete normally. $ curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:35 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!"},{"page":"/learn/by-example/http-cors.html","name":"CORS","summary":"This sample demonstrates the Ballerina server connector CORS configuration.\nCORS headers can be applied in both the service-level and the resource-level. Service-level CORS headers apply to all the resources\nunless there are headers configured at the resource-level. Ballerina CORS supports both simple and pre-flight requests.Service-level CORS headers apply globally to each resource.Resource-level ...","content":"/  /  / CORS  import ballerina/http; import ballerina/log; @http:ServiceConfig {  cors: {  allowOrigins: [\"http://www.m3.com\", \"http://www.hello.com\"],  allowCredentials: false,  allowHeaders: [\"CORELATION_ID\"],  exposeHeaders: [\"X-CUSTOM-HEADER\"],  maxAge: 84900  } } service crossOriginService on new http:Listener(9092) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/company\",  cors: {  allowOrigins: [\"http://www.bbc.com\"],  allowCredentials: true,  allowHeaders: [\"X-Content-Type-Options\", \"X-PINGOTHER\"]  }  }  resource function companyInfo(http:Caller caller, http:Request req) {  http:Response res = new;  json responseJson = {\"type\": \"middleware\"};  res.setJsonPayload(responseJson);  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/lang\"  }  resource function langInfo(http:Caller caller, http:Request req) {  http:Response res = new;  json responseJson = {\"lang\": \"Ballerina\"};  res.setJsonPayload(responseJson);  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  } }    CORS  This sample demonstrates the Ballerina server connector CORS configuration. CORS headers can be applied in both the service-level and the resource-level. Service-level CORS headers apply to all the resources unless there are headers configured at the resource-level. Ballerina CORS supports both simple and pre-flight requests.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  cors: {  allowOrigins: [\"http://www.m3.com\", \"http://www.hello.com\"],  allowCredentials: false,  allowHeaders: [\"CORELATION_ID\"],  exposeHeaders: [\"X-CUSTOM-HEADER\"],  maxAge: 84900  } } service crossOriginService on new http:Listener(9092) {    Service-level CORS headers apply globally to each resource.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/company\",  cors: {  allowOrigins: [\"http://www.bbc.com\"],  allowCredentials: true,  allowHeaders: [\"X-Content-Type-Options\", \"X-PINGOTHER\"]  }  }  resource function companyInfo(http:Caller caller, http:Request req) {  http:Response res = new;  json responseJson = {\"type\": \"middleware\"};  res.setJsonPayload(responseJson);  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }    Resource-level CORS headers override the service-level CORS headers.   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/lang\"  }  resource function langInfo(http:Caller caller, http:Request req) {  http:Response res = new;  json responseJson = {\"lang\": \"Ballerina\"};  res.setJsonPayload(responseJson);  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  } }    Since there are no resource-level CORS headers defined here, the global service-level CORS headers are applied to this resource.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_cors.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    # Run this curl command to send a CORS simple request. $ curl -v \"http://localhost:9092/crossOriginService/company\" -H \"Origin:http://www.bbc.com\"    < HTTP/1.1 200 OK < Content-Type: application/json < Access-Control-Allow-Origin: http://www.bbc.com < Access-Control-Allow-Credentials: true < Content-Length: 21 {\"type\":\"middleware\"}    # Run this curl command to send a CORS preflight request. $ curl -v \"http://localhost:9092/crossOriginService/lang\" -X OPTIONS -H \"Origin:http://www.m3.com\" -H \"Access-Control-Request-Method:POST\"    < HTTP/1.1 200 OK < Access-Control-Allow-Origin: http://www.m3.com < Access-Control-Allow-Methods: POST < Access-Control-Max-Age: 84900 < Content-Length: 0"},{"page":"/learn/by-example/http-disable-chunking.html","name":"Disable Chunking","summary":"This sample demonstrates how to configure the chunking behavior of an HTTP client endpoint. By default, the HTTP client sends messages with the content-length header.\nIf the message size is larger than the buffer size (8K), messages are chunked. Chunking can be disabled using the connector options.The HTTP client’s chunking behaviour ...","content":"/  /  / Disable Chunking  import ballerina/http; import ballerina/log;http:Client clientEndpoint = new (\"http://localhost:9090\",  {http1Settings: {chunking: http:CHUNKING_NEVER}});service chunkingSample on new http:Listener(9092) { @http:ResourceConfig {  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request req) {  http:Request newReq = new;  newReq.setPayload({\"name\": \"Ballerina\"});  var clientResponse = clientEndpoint->post(\"/echo/\", newReq);  if (clientResponse is http:Response) {  var result = caller->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response errorResponse = new;  json msg = {\"error\": \"An error occurred while invoking the service.\"};  errorResponse.setPayload(msg);  var response = caller->respond(errorResponse);  if (response is error) {  log:printError(\"Error sending response\", response);  }  }  } } service echo on new http:Listener(9090) {  @http:ResourceConfig {  path: \"/\"  }  resource function echoResource(http:Caller caller, http:Request req) {  string value; http:Response res = new;  boolean validationErrorFound = false;  if (req.hasHeader(\"content-length\")) {  value = req.getHeader(\"content-length\");  value = \"Length-\" + value;  } else if (req.hasHeader(\"Transfer-Encoding\")) {  value = req.getHeader(\"Transfer-Encoding\");  if (value != \"chunked\" && value != \"compress\" && value != \"deflate\"  && value != \"gzip\" && value != \"identity\") {  res.statusCode = 400;  res.setPayload(\"Transfer-Encoding contains invalid data\");  validationErrorFound = true;  }  } else {  value =  \"Neither Transfer-Encoding nor content-length header found\";  } if (!validationErrorFound) {  res.setPayload({\"Outbound request content\": <@untainted>value});  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response from echo service\",  err = result);  }  } }function isValid(boolean|error value) returns boolean {  if (value is boolean) {  return value;  }  return false; }    Disable Chunking  This sample demonstrates how to configure the chunking behavior of an HTTP client endpoint. By default, the HTTP client sends messages with the content-length header. If the message size is larger than the buffer size (8K), messages are chunked. Chunking can be disabled using the connector options.    import ballerina/http; import ballerina/log;    The HTTP client’s chunking behaviour can be configured as CHUNKING_AUTO, CHUNKING_ALWAYS, or CHUNKING_NEVER. In this example, it is set to CHUNKING_NEVER, which means that chunking never happens irrespective of how it is specified in the request. When chunking is set to CHUNKING_AUTO, chunking is done as specified in the request.   http:Client clientEndpoint = new (\"http://localhost:9090\",  {http1Settings: {chunking: http:CHUNKING_NEVER}});    service chunkingSample on new http:Listener(9092) {    @http:ResourceConfig {  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request req) {    http:Request newReq = new;  newReq.setPayload({\"name\": \"Ballerina\"});  var clientResponse = clientEndpoint->post(\"/echo/\", newReq);  if (clientResponse is http:Response) {  var result = caller->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response errorResponse = new;  json msg = {\"error\": \"An error occurred while invoking the service.\"};  errorResponse.setPayload(msg);  var response = caller->respond(errorResponse);  if (response is error) {  log:printError(\"Error sending response\", response);  }  }  } }    Create a new outbound request and set the payload.   service echo on new http:Listener(9090) {  @http:ResourceConfig {  path: \"/\"  }  resource function echoResource(http:Caller caller, http:Request req) {  string value;    A sample backend, which responds according to the chunking behaviour.   http:Response res = new;  boolean validationErrorFound = false;    if (req.hasHeader(\"content-length\")) {  value = req.getHeader(\"content-length\");  value = \"Length-\" + value;  } else if (req.hasHeader(\"Transfer-Encoding\")) {  value = req.getHeader(\"Transfer-Encoding\");    Set the response according to the request headers.   if (value != \"chunked\" && value != \"compress\" && value != \"deflate\"  && value != \"gzip\" && value != \"identity\") {  res.statusCode = 400;  res.setPayload(\"Transfer-Encoding contains invalid data\");  validationErrorFound = true;  }  } else {  value =  \"Neither Transfer-Encoding nor content-length header found\";  }    Perform data validation for transfer-encoding.   if (!validationErrorFound) {    res.setPayload({\"Outbound request content\": <@untainted>value});  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response from echo service\",  err = result);  }  } }    Since there is no validation error, mark the value as trusted data and set it to the response.   function isValid(boolean|error value) returns boolean {  if (value is boolean) {  return value;  }  return false; }    # To start the services, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run http_disable_chunking.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    To use the client, execute the below cURL command. $ curl http://localhost:9092/chunkingSample {\"Outbound request content\":\"Length-20\"}    To enable chunking, change the chunking option of the `clientEndpoint` in the `.bal` file to `http:CHUNKING_ALWAYS`. {\"Outbound request content\":\"chunked\"}"},{"page":"/learn/by-example/http-data-binding.html","name":"Data Binding","summary":"HTTP data binding helps access payload through the last resource signature parameter. The parameter name should be\n declared in the resource config under the body annotation. string, json, xml, byte[], record, and record[] are\n supported as parameter types.The body annotation represents the entity body of the inbound request.Accesses the JSON ...","content":"/  /  / Data Binding  import ballerina/http; import ballerina/log;type Student record {  string Name;  int Grade;  map<any> Marks; };@http:ServiceConfig {} service hello on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"POST\"],  body: \"orderDetails\"  }  resource function bindJson(http:Caller caller, http:Request req,  json orderDetails) {  var details = orderDetails.Details;  http:Response res = new;  if (details is json) {  res.setPayload(<@untainted>details);  } else {  res.statusCode = 400;  res.setPayload(\"Order Details unavailable\");  }  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }  @http:ResourceConfig {  methods: [\"POST\"],  body: \"store\",  consumes: [\"application/xml\"]  }  resource function bindXML(http:Caller caller, http:Request req, xml store) {  xml city = store.selectDescendants(\"{http://www.test.com}city\");  http:Response res = new;  res.setPayload(<@untainted>city); var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }  @http:ResourceConfig {  methods: [\"POST\"],  body: \"student\",  consumes: [\"application/json\"]  }  resource function bindStruct(http:Caller caller, http:Request req,  Student student) {  string name = <@untainted>student.Name;  int grade = <@untainted>student.Grade;  string english = <@untained string>student.Marks[\"English\"];  http:Response res = new;  res.setPayload({Name: name, Grade: grade, English: english}); var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  } }    Data Binding  HTTP data binding helps access payload through the last resource signature parameter. The parameter name should be  declared in the resource config under the body annotation. string, json, xml, byte[], record, and record[] are  supported as parameter types.    import ballerina/http; import ballerina/log;    type Student record {  string Name;  int Grade;  map<any> Marks; };    @http:ServiceConfig {} service hello on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"POST\"],  body: \"orderDetails\"  }  resource function bindJson(http:Caller caller, http:Request req,  json orderDetails) {    The body annotation represents the entity body of the inbound request.   var details = orderDetails.Details;  http:Response res = new;  if (details is json) {  res.setPayload(<@untainted>details);  } else {  res.statusCode = 400;  res.setPayload(\"Order Details unavailable\");  }  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }    Accesses the JSON field values.   @http:ResourceConfig {  methods: [\"POST\"],  body: \"store\",  consumes: [\"application/xml\"]  }  resource function bindXML(http:Caller caller, http:Request req, xml store) {    Binds the XML payload of the inbound request to the store variable.   xml city = store.selectDescendants(\"{http://www.test.com}city\");  http:Response res = new;  res.setPayload(<@untainted>city);    Accesses the XML content.   var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }    @http:ResourceConfig {  methods: [\"POST\"],  body: \"student\",  consumes: [\"application/json\"]  }  resource function bindStruct(http:Caller caller, http:Request req,  Student student) {    Binds the JSON payload to a custom record. The payload’s content should match the record.   string name = <@untainted>student.Name;  int grade = <@untainted>student.Grade;  string english = <@untained string>student.Marks[\"English\"];  http:Response res = new;  res.setPayload({Name: name, Grade: grade, English: english});    Accesses the fields of the Student record.   var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_data_binding.bal #Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the `bindJson` resource, execute the below HTTP request. $ curl -v http://localhost:9090/hello/bindJson -d '{ \"Details\": { \"ID\": \"77999\", \"Name\": \"XYZ\"} , \"Location\": { \"No\": \"01\", \"City\": \"Colombo\"}}' -H \"Content-Type:application/json\" # Server response: {\"ID\":\"77999\", \"Name\":\"XYZ\"}    # To invoke the `bindXML` resource, execute the below HTTP request. $ curl -v http://localhost:9090/hello/bindXML -d \"<h:Store id = \\\"AST\\\" xmlns:h=\\\"http://www.test.com\\\"><h:street>Main</h:street><h:city>94</h:city></h:Store>\" -H \"Content-Type:application/xml\" # Server response: <h:city xmlns:h=\"http://www.test.com\">94</h:city>    # To invoke the `bindStruct` resource, execute the below HTTP request. $ curl -v http://localhost:9090/hello/bindStruct -d '{ \"Name\": \"John\", \"Grade\": 12, \"Marks\": {\"English\" : \"85\", \"IT\" : \"100\"}}' -H \"Content-Type:application/json\" # Server response: {\"Name\":\"John\", \"Grade\":12, \"English\":\"85\"}"},{"page":"/learn/by-example/http-failover.html","name":"Failover","summary":"Ballerina users can configure multiple HTTP clients in a given failover group. If one of the HTTP clients (dependencies) fails, Ballerina automatically fails over to another endpoint.Create an endpoint with port 8080 for the mock backend services.Define the failover client endpoint to call the backend services.Define a set of HTTP ...","content":"/  /  / Failover  import ballerina/http; import ballerina/log; import ballerina/runtime; listener http:Listener backendEP = new (8080); http:FailoverClient foBackendEP = new ({  timeoutInMillis: 5000,  failoverCodes: [501, 502, 503],  intervalInMillis: 5000,  targets: [  {url: \"http://nonexistentEP/mock1\"},  {url: \"http://localhost:8080/echo\"},  {url: \"http://localhost:8080/mock\"}  ] });@http:ServiceConfig {  basePath: \"/fo\" } service failoverDemoService on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\", \"POST\"],  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = foBackendEP->get(\"/\", <@untainted>request);  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload(<string>backendResponse.detail()?.message);  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } } @http:ServiceConfig {  basePath: \"/echo\" } service echo on backendEP {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function echoResource(http:Caller caller, http:Request req) {  runtime:sleep(30000); var result = caller->respond(\"echo Resource is invoked\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } } @http:ServiceConfig {  basePath: \"/mock\" } service mock on backendEP {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function mockResource(http:Caller caller, http:Request req) {  var result = caller->respond(\"Mock Resource is Invoked.\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    Failover  Ballerina users can configure multiple HTTP clients in a given failover group. If one of the HTTP clients (dependencies) fails, Ballerina automatically fails over to another endpoint.    import ballerina/http; import ballerina/log; import ballerina/runtime;    listener http:Listener backendEP = new (8080);    Create an endpoint with port 8080 for the mock backend services.   http:FailoverClient foBackendEP = new ({  timeoutInMillis: 5000,  failoverCodes: [501, 502, 503],  intervalInMillis: 5000,    Define the failover client endpoint to call the backend services.   targets: [  {url: \"http://nonexistentEP/mock1\"},  {url: \"http://localhost:8080/echo\"},  {url: \"http://localhost:8080/mock\"}  ] });    Define a set of HTTP Clients that are targeted for failover.   @http:ServiceConfig {  basePath: \"/fo\" } service failoverDemoService on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\", \"POST\"],  path: \"/\"  }    Create a REST resource within the API.   resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = foBackendEP->get(\"/\", <@untainted>request);    Parameters include a reference to the caller and an object with the  request data.   if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload(<string>backendResponse.detail()?.message);  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   @http:ServiceConfig {  basePath: \"/echo\" } service echo on backendEP {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function echoResource(http:Caller caller, http:Request req) {    Define the sample service to mock connection timeouts and service outages.   runtime:sleep(30000);    Delay the response for 30000 milliseconds to mimic network level  delays.   var result = caller->respond(\"echo Resource is invoked\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    @http:ServiceConfig {  basePath: \"/mock\" } service mock on backendEP {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function mockResource(http:Caller caller, http:Request req) {  var result = caller->respond(\"Mock Resource is Invoked.\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    Define the sample service to mock a healthy service.   # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_failover.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the Failover Service, use following curl command. $ curl -v http://localhost:9090/fo # The `FailoverClient` endpoint is configured with three target services.The first two targets are configured to mimic # failure backends. If one target service goes down, the failover client automatically calls the other targets. # Once you invoke the Failover demo service, the Failover client fails over the request to the configured # target endpoints. In this example, the third target is configured to give a successful response and the following # response is given when the failover demo service is invoked. # Server response: * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /fo HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:29:37 +0530 < server: ballerina/1.0.0-beta < content-length: 25 < * Connection #0 to host localhost left intact Mock Resource is Invoked. # Invoke the Failover Service again using the curl command. $ curl -v http://localhost:9090/fo # At this point, Ballerina failover client already knows that leading endpoints (in this case the first two targets) # failed in the last invocation and it got the successful response from the third target. So the failover client # resumes the failover from the last successful target. In this case it is the third target and the client will get # the immediate response for subsequent calls. # Server response: * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /fo HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:29:41 +0530 < server: ballerina/1.0.0-beta < content-length: 25 < * Connection #0 to host localhost left intact Mock Resource is Invoked."},{"page":"/learn/by-example/http-filters.html","name":"HTTP Interceptors/Filters","summary":"HTTP Listener supports intercepting request in the request path.\n Its possible to define a filter with custom logic, engage to a HTTP Listener.\n The request will go through the filter logic before its dispatched to the\n actual resource in the target service.Header name to be set to the request in ...","content":"/  /  / HTTP Interceptors/Filters  import ballerina/http; import ballerina/log; final string filter_name_header = \"X-requestHeader\"; final string filter_name_header_value = \"RequestFilter\"; public type RequestFilter object {  *http:RequestFilter;  public function filterRequest(http:Caller caller, http:Request request,  http:FilterContext context) returns boolean {  request.setHeader(filter_name_header, filter_name_header_value);  return true;  } }; RequestFilter requestFilter = new; public type ResponseFilter object {  *http:ResponseFilter;  public function filterResponse(http:Response response, http:FilterContext context) returns boolean {  response.setHeader(\"X-responseHeader\", \"ResponseFilter\");  return true;  } }; ResponseFilter responseFilter = new; listener http:Listener echoListener = new http:Listener(9090,  config = {filters: [requestFilter, responseFilter]});@http:ServiceConfig {  basePath: \"/hello\" } service echo on echoListener {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\"  }  resource function echo(http:Caller caller, http:Request req) {  http:Response res = new;  res.setHeader(filter_name_header, req.getHeader(filter_name_header));  res.setPayload(\"Hello, World!\");  var result = caller->respond(<@untainted>res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    HTTP Interceptors/Filters  HTTP Listener supports intercepting request in the request path.  Its possible to define a filter with custom logic, engage to a HTTP Listener.  The request will go through the filter logic before its dispatched to the  actual resource in the target service.    import ballerina/http; import ballerina/log;    final string filter_name_header = \"X-requestHeader\";    Header name to be set to the request in the filter.   final string filter_name_header_value = \"RequestFilter\";    Header value to be set to the request in the filter.   public type RequestFilter object {  *http:RequestFilter;    The Request filter implementation. It intercepts the request and adds a new  header to request before it is dispatched to the HTTP resource.   public function filterRequest(http:Caller caller, http:Request request,  http:FilterContext context) returns boolean {    Intercepts the request.   request.setHeader(filter_name_header, filter_name_header_value);    Set a header to the request inside the filter.   return true;  } };    Return true on success.   RequestFilter requestFilter = new;    Create a new RequestFilter.   public type ResponseFilter object {  *http:ResponseFilter;    The response filter implementation. It intercepts the response in response  path and adds a new header to response.   public function filterResponse(http:Response response, http:FilterContext context) returns boolean {    Intercepts the response.   response.setHeader(\"X-responseHeader\", \"ResponseFilter\");    Set a header to the response inside the filter.   return true;  } };    Return true on success.   ResponseFilter responseFilter = new;    Create a new ResponseFilter.   listener http:Listener echoListener = new http:Listener(9090,  config = {filters: [requestFilter, responseFilter]});    Create an HTTP listener and assign the filters as a config parameter.   @http:ServiceConfig {  basePath: \"/hello\" } service echo on echoListener {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\"  }  resource function echo(http:Caller caller, http:Request req) {    http:Response res = new;    Create a new http response.   res.setHeader(filter_name_header, req.getHeader(filter_name_header));  res.setPayload(\"Hello, World!\");  var result = caller->respond(<@untainted>res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Set the filter_name_header from the request to the response.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_filters.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To build a compiled program file, can use the # \"ballerina build\" command followed by # the service module. $ ballerina build http_filters.bal    $ curl -v http://localhost:9090/hello/sayHello * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /hello/sayHello HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.61.0 > Accept: */* > < HTTP/1.1 200 OK < X-requestHeader: RequestFilter < content-type: text/plain < X-responseHeader: ResponseFilter < content-length: 13 < server: ballerina/1.0.0-beta < date: Wed, 21 Aug 2019 13:28:12 +0530 < * Connection #0 to host localhost left intact Hello, World!    Invoke the service using “curl”."},{"page":"/learn/by-example/http-load-balancer.html","name":"Load Balancing","summary":"An HTTP load balancing endpoint is used when the request load needs to be load balanced across a given\n set of target endpoints.Create an endpoint with port 8080 for the mock backend services.Define the load balance client endpoint to call the backend services.Define the set of HTTP clients that need ...","content":"/  /  / Load Balancing  import ballerina/http; import ballerina/log; listener http:Listener backendEP = new (8080); http:LoadBalanceClient lbBackendEP = new ({  targets: [  {url: \"http://localhost:8080/mock1\"},  {url: \"http://localhost:8080/mock2\"},  {url: \"http://localhost:8080/mock3\"}  ],  timeoutInMillis: 5000 }); @http:ServiceConfig {  basePath: \"/lb\" } service loadBalancerDemoService on new http:Listener(9090) {  @http:ResourceConfig {  path: \"/\"  }  resource function roundRobin(http:Caller caller, http:Request req) {  json requestPayload = {\"name\": \"Ballerina\"};  var response = lbBackendEP->post(\"/\", requestPayload);  if (response is http:Response) {  var responseToCaller = caller->respond(response);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response outResponse = new;  outResponse.statusCode = 500;  outResponse.setPayload(<string>response.detail()?.message);  var responseToCaller = caller->respond(outResponse);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } } @http:ServiceConfig {  basePath: \"/mock1\" } service mock1 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock1Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock1 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }@http:ServiceConfig {  basePath: \"/mock2\" } service mock2 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock2Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock2 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }@http:ServiceConfig {  basePath: \"/mock3\" } service mock3 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock3Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock3 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } } function handleRespondResult(http:ListenerError? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    Load Balancing  An HTTP load balancing endpoint is used when the request load needs to be load balanced across a given  set of target endpoints.    import ballerina/http; import ballerina/log;    listener http:Listener backendEP = new (8080);    Create an endpoint with port 8080 for the mock backend services.   http:LoadBalanceClient lbBackendEP = new ({    Define the load balance client endpoint to call the backend services.   targets: [  {url: \"http://localhost:8080/mock1\"},  {url: \"http://localhost:8080/mock2\"},  {url: \"http://localhost:8080/mock3\"}  ],  timeoutInMillis: 5000 });    Define the set of HTTP clients that need to be load balanced.   @http:ServiceConfig {  basePath: \"/lb\" } service loadBalancerDemoService on new http:Listener(9090) {    Create an HTTP service bound to the endpoint (loadBalancerEP).   @http:ResourceConfig {  path: \"/\"  }  resource function roundRobin(http:Caller caller, http:Request req) {  json requestPayload = {\"name\": \"Ballerina\"};  var response = lbBackendEP->post(\"/\", requestPayload);    Create a REST resource within the API.   if (response is http:Response) {  var responseToCaller = caller->respond(response);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response outResponse = new;  outResponse.statusCode = 500;  outResponse.setPayload(<string>response.detail()?.message);  var responseToCaller = caller->respond(outResponse);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If a response is returned, the normal process runs. If the service  does not get the expected response, the error-handling logic is  executed.   @http:ServiceConfig {  basePath: \"/mock1\" } service mock1 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock1Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock1 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }    Define the mock backend services, which are called by the load balancer.   @http:ServiceConfig {  basePath: \"/mock2\" } service mock2 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock2Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock2 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }    @http:ServiceConfig {  basePath: \"/mock3\" } service mock3 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock3Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock3 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }    function handleRespondResult(http:ListenerError? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    Function to handle respond results   # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_load_balancer.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the Load Balancer Demo Service, use following cURL command. $ curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:36:57 +0530 < server: ballerina/1.0.0-beta < content-length: 27 < * Connection #0 to host localhost left intact Mock1 resource was invoked.    # Repeat the same cURL command to invoke the Load Balance Demo Service again. # The request will be load balanced to the second mock service. $ curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:36:58 +0530 < server: ballerina/1.0.0-beta < content-length: 27 < * Connection #0 to host localhost left intact Mock2 resource was invoked.    # Invoke the Load Balancer Demo Service one more time using the same cURL command. # The request will be load balanced to the third mock service. $ curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:36:59 +0530 < server: ballerina/1.0.0-beta < content-length: 27 < * Connection #0 to host localhost left intact Mock3 resource was invoked.    # Invoke the Load Balancer Demo Service using the same cURL command for the last time. # The request will be load balanced to the first mock service again. $ curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:37:00 +0530 < server: ballerina/1.0.0-beta < content-length: 27 < * Connection #0 to host localhost left intact Mock1 resource was invoked."},{"page":"/learn/by-example/http-redirects.html","name":"Redirects","summary":"This example demonstrates an HTTP redirect.\n To follow redirects when calling an external HTTP server using the Ballerina HTTP client connector, set followRedirect\n to true.Creates an HTTP client to interact with a remote endpoint.Sends a GET request to the specified endpoint.Retrieves the text payload from the response.Sends a redirect response ...","content":"/  /  / Redirects  import ballerina/http; import ballerina/log; http:Client clientEndpoint = new (\"http://localhost:9092\", {  followRedirects: {enabled: true, maxCount: 5}  } );service hello on new http:Listener(9090) { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function myResource(http:Caller caller, http:Request req) {  var returnResult = clientEndpoint->get(\"/redirect1\");  if (returnResult is http:Response) {  var payload = returnResult.getTextPayload();  if (payload is string) {  var result = caller->respond(\"Response received : \" + <@untained>payload);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } else {  var result = caller->respond(\"Error in payload : \" + <@untained>payload.detail()?.message.toString());  if (result is error) {  log:printError(\"Error in responding\", result);  }  }  } else {  var result = caller->respond(\"Error in connection : \" + returnResult.detail()?.message.toString());  if (result is error) {  log:printError(\"Error in responding\", result);  }  }  } }@http:ServiceConfig {  basePath: \"/redirect1\" } service redirect1 on new http:Listener(9092) { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function redirect1(http:Caller caller, http:Request req) {  http:Response res = new;  error? result = caller->redirect(res,  http:REDIRECT_TEMPORARY_REDIRECT_307,  [\"http://localhost:9093/redirect2\"]);  if (result is error) {  log:printError(\"Error in sending redirect response to caller\",  err = result);  }  } }@http:ServiceConfig {  basePath: \"/redirect2\" } service redirect2 on new http:Listener(9093) { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function redirect2(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Redirects  This example demonstrates an HTTP redirect.  To follow redirects when calling an external HTTP server using the Ballerina HTTP client connector, set followRedirect  to true.    import ballerina/http; import ballerina/log;    http:Client clientEndpoint = new (\"http://localhost:9092\", {  followRedirects: {enabled: true, maxCount: 5}  } );    Creates an HTTP client to interact with a remote endpoint.   service hello on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function myResource(http:Caller caller, http:Request req) {    var returnResult = clientEndpoint->get(\"/redirect1\");  if (returnResult is http:Response) {    Sends a GET request to the specified endpoint.   var payload = returnResult.getTextPayload();  if (payload is string) {  var result = caller->respond(\"Response received : \" + <@untained>payload);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } else {  var result = caller->respond(\"Error in payload : \" + <@untained>payload.detail()?.message.toString());  if (result is error) {  log:printError(\"Error in responding\", result);  }  }  } else {  var result = caller->respond(\"Error in connection : \" + returnResult.detail()?.message.toString());  if (result is error) {  log:printError(\"Error in responding\", result);  }  }  } }    Retrieves the text payload from the response.   @http:ServiceConfig {  basePath: \"/redirect1\" } service redirect1 on new http:Listener(9092) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function redirect1(http:Caller caller, http:Request req) {  http:Response res = new;    error? result = caller->redirect(res,  http:REDIRECT_TEMPORARY_REDIRECT_307,  [\"http://localhost:9093/redirect2\"]);  if (result is error) {  log:printError(\"Error in sending redirect response to caller\",  err = result);  }  } }    Sends a redirect response with a location.   @http:ServiceConfig {  basePath: \"/redirect2\" } service redirect2 on new http:Listener(9093) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function redirect2(http:Caller caller, http:Request req) {    var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Sends a response to the caller.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run http_redirects.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 [ballerina/http] started HTTP/WS listener 0.0.0.0:9093"},{"page":"/learn/by-example/http-retry.html","name":"Retry","summary":"The HTTP retry client tries sending over the same request to the backend service when there is a network level failure.Define the endpoint to the call the mockHelloService.Retry configuration options.Initial retry interval in milliseconds.Number of retry attempts before giving up.Multiplier of the retry interval to exponentially increase the\n retry interval.Upper ...","content":"/  /  / Retry  import ballerina/http; import ballerina/log; import ballerina/runtime; http:Client backendClientEP = new (\"http://localhost:8080\", {  retryConfig: {  intervalInMillis: 3000,  count: 3,  backOffFactor: 2.0,  maxWaitIntervalInMillis: 20000  },  timeoutInMillis: 2000  } );@http:ServiceConfig {  basePath: \"/retry\" } service retryDemoService on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errCause = <string>backendResponse.detail()?.message;  response.setPayload(errCause);  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }int counter = 0; @http:ServiceConfig {  basePath: \"/hello\" } service mockHelloService on new http:Listener(8080) { @http:ResourceConfig {  methods: [\"GET\", \"POST\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  counter = counter + 1;  if (counter % 4 != 0) {  log:printInfo(  \"Request received from the client to delayed service.\");  runtime:sleep(5000);  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  } else {  log:printInfo(  \"Request received from the client to healthy service.\");  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  }  } }function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    Retry  The HTTP retry client tries sending over the same request to the backend service when there is a network level failure.    import ballerina/http; import ballerina/log; import ballerina/runtime;    http:Client backendClientEP = new (\"http://localhost:8080\", {    Define the endpoint to the call the mockHelloService.   retryConfig: {    Retry configuration options.   intervalInMillis: 3000,    Initial retry interval in milliseconds.   count: 3,    Number of retry attempts before giving up.   backOffFactor: 2.0,    Multiplier of the retry interval to exponentially increase the  retry interval.   maxWaitIntervalInMillis: 20000  },  timeoutInMillis: 2000  } );    Upper limit of the retry interval in milliseconds. If  intervalInMillis into backOffFactor value exceeded  maxWaitIntervalInMillis interval value.  maxWaitIntervalInMillis will be considered as the retry  interval.   @http:ServiceConfig {  basePath: \"/retry\" } service retryDemoService on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }    Create a REST resource within the API.   resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);    Parameters include a reference to the caller and an object of the  request data.   if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errCause = <string>backendResponse.detail()?.message;  response.setPayload(errCause);  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   int counter = 0;    @http:ServiceConfig {  basePath: \"/hello\" } service mockHelloService on new http:Listener(8080) {    This sample service is used to mock connection timeouts and service outages.  The service outage is mocked by stopping/starting this service.  This should run separately from the retryDemoService service.   @http:ResourceConfig {  methods: [\"GET\", \"POST\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  counter = counter + 1;  if (counter % 4 != 0) {  log:printInfo(  \"Request received from the client to delayed service.\");    runtime:sleep(5000);  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  } else {  log:printInfo(  \"Request received from the client to healthy service.\");  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  }  } }    Delay the response by 5000 milliseconds to  mimic network level delays.   function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_retry.bal.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 2019-09-04 15:47:25,980 INFO [] - Request received from the client to delayed service. 2019-09-04 15:47:30,998 INFO [] - Request received from the client to delayed service. 2019-09-04 15:47:31,012 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed 2019-09-04 15:47:36,004 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed 2019-09-04 15:47:39,005 INFO [] - Request received from the client to delayed service. 2019-09-04 15:47:44,007 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed 2019-09-04 15:47:53,016 INFO [] - Request received from the client to healthy service.    # If the request that was sent to the `retryDemoService` fails due to an error, the client tries sending the request again. $ curl -v http://localhost:9090/retry * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /retry HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:47:53 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!"},{"page":"/learn/by-example/http-timeout.html","name":"Timeout","summary":"The Timeout is used to gracefully handle network timeouts, which occur when using the HTTP Client.Timeout configuration.Create an HTTP service bound to the listener endpoint.Create a REST resource within the API.The parameters include a reference to the caller\n endpoint and an object of the request data.If backendResponse is an http:Response, ...","content":"/  /  / Timeout  import ballerina/http; import ballerina/log; import ballerina/runtime;http:Client backendClientEP = new (\"http://localhost:8080\", {  timeoutInMillis: 10000}); @http:ServiceConfig {  basePath: \"/timeout\" } service timeoutService on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errorMessage = <string>backendResponse.detail()?.message;  string expectedMessage = \"Idle timeout triggered before \" +  \"initiating inbound response\";  if (errorMessage == expectedMessage) {  response.setPayload(  \"Request timed out. Please try again in sometime.\"  );  } else {  response.setPayload(errorMessage);  }  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } } @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  runtime:sleep(15000); var result = caller->respond(\"Hello World!!!\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }# To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. ballerina run http_timeout.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2019-09-04 16:21:39,541 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed    Timeout  The Timeout is used to gracefully handle network timeouts, which occur when using the HTTP Client.    import ballerina/http; import ballerina/log; import ballerina/runtime;    http:Client backendClientEP = new (\"http://localhost:8080\", {    timeoutInMillis: 10000    Timeout configuration.   });    @http:ServiceConfig {  basePath: \"/timeout\" } service timeoutService on new http:Listener(9090) {    Create an HTTP service bound to the listener endpoint.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }    Create a REST resource within the API.   resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);    The parameters include a reference to the caller  endpoint and an object of the request data.   if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errorMessage = <string>backendResponse.detail()?.message;  string expectedMessage = \"Idle timeout triggered before \" +  \"initiating inbound response\";  if (errorMessage == expectedMessage) {  response.setPayload(  \"Request timed out. Please try again in sometime.\"  );  } else {  response.setPayload(errorMessage);  }  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    This sample service is used to mock connection timeouts.   runtime:sleep(15000);    Delay the response by 15000 milliseconds to  mimic the network level delays.   var result = caller->respond(\"Hello World!!!\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. ballerina run http_timeout.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2019-09-04 16:21:39,541 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed    $ curl -v http://localhost:9090/timeout * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /timeout HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 48 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 16:21:34 +0530 < * Connection #0 to host localhost left intact Request timed out. Please try again in sometime.    Invoke the service using “curl”."},{"page":"/learn/by-example/http-streaming.html","name":"HTTP Streaming","summary":"Ballerina supports HTTP input and output streaming capability through io:ReadableByteChannel.Creates an endpoint for the client.Sets the file as request payload.Sends the request to the client with the file content.Writes the incoming stream to a file. First get the destination\nchannel by providing the file name, the content should be\nwritten to.Sets the ...","content":"/  /  / HTTP Streaming  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime; http:Client clientEndpoint = new (\"http://localhost:9090\");@http:ServiceConfig {  basePath: \"/stream\" } service HTTPStreamingService on new http:Listener(9090) { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/fileupload\"  }  resource function handleOutputStream(http:Caller caller,  http:Request clientRequest) {  http:Request request = new;  request.setFileAsPayload(\"./files/BallerinaLang.pdf\",  contentType = mime:APPLICATION_PDF);  var clientResponse = clientEndpoint->post(\"/stream/receiver\", request); http:Response res = new;  if (clientResponse is http:Response) {  var payload = clientResponse.getTextPayload();  if (payload is string) {  res.setPayload(<@untainted>payload);  } else {  setError(res, payload);  }  } else {  log:printError(\"Error occurred while sending data to the client \",  err = clientResponse);  setError(res, clientResponse);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error while while sending response to the caller\",  err = result);  }  } @http:ResourceConfig {  methods: [\"POST\"],  path: \"/receiver\"  }  resource function handleInputStream(http:Caller caller,  http:Request clientRequest) {  http:Response res = new;  var payload = clientRequest.getByteChannel();  if (payload is io:ReadableByteChannel) {  var destinationChannel =  io:openWritableFile(\"./files/ReceivedFile.pdf\");  if (destinationChannel is io:WritableByteChannel) {  var result = copy(payload, destinationChannel);  if (result is error) {  log:printError(\"error occurred while performing copy \",  err = result);  }  close(payload);  close(destinationChannel);  }  res.setPayload(\"File Received!\");  } else {  setError(res, payload);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error occurred while sending response\",  err = result);  }  } } function setError(http:Response res, error err) {  res.statusCode = 500;  res.setPayload(<@untainted string>err.detail()?.message); } function copy(io:ReadableByteChannel src,  io:WritableByteChannel dst) returns error? {  while (true) {  byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {  int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; } function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    HTTP Streaming  Ballerina supports HTTP input and output streaming capability through io:ReadableByteChannel.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEndpoint = new (\"http://localhost:9090\");    Creates an endpoint for the client.   @http:ServiceConfig {  basePath: \"/stream\" } service HTTPStreamingService on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/fileupload\"  }  resource function handleOutputStream(http:Caller caller,  http:Request clientRequest) {  http:Request request = new;    request.setFileAsPayload(\"./files/BallerinaLang.pdf\",  contentType = mime:APPLICATION_PDF);    Sets the file as request payload.   var clientResponse = clientEndpoint->post(\"/stream/receiver\", request);    Sends the request to the client with the file content.   http:Response res = new;  if (clientResponse is http:Response) {  var payload = clientResponse.getTextPayload();  if (payload is string) {  res.setPayload(<@untainted>payload);  } else {  setError(res, payload);  }  } else {  log:printError(\"Error occurred while sending data to the client \",  err = clientResponse);  setError(res, clientResponse);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error while while sending response to the caller\",  err = result);  }  }    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/receiver\"  }  resource function handleInputStream(http:Caller caller,  http:Request clientRequest) {  http:Response res = new;  var payload = clientRequest.getByteChannel();  if (payload is io:ReadableByteChannel) {    var destinationChannel =  io:openWritableFile(\"./files/ReceivedFile.pdf\");  if (destinationChannel is io:WritableByteChannel) {  var result = copy(payload, destinationChannel);  if (result is error) {  log:printError(\"error occurred while performing copy \",  err = result);  }  close(payload);  close(destinationChannel);  }  res.setPayload(\"File Received!\");  } else {  setError(res, payload);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error occurred while sending response\",  err = result);  }  } }    Writes the incoming stream to a file. First get the destination channel by providing the file name, the content should be written to.   function setError(http:Response res, error err) {  res.statusCode = 500;  res.setPayload(<@untainted string>err.detail()?.message); }    Sets the error to the response.   function copy(io:ReadableByteChannel src,  io:WritableByteChannel dst) returns error? {    Copies the content from the source channel to a destination channel.   while (true) {    The below example shows how to read all the content from  the source and copy it to the destination.   byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {    The operation attempts to read a maximum of 1000 bytes and returns  with the available content, which could be < 1000.   int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }    The operation writes the given content into the channel.   function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes the byte channel.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_streaming.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    #Send a request to the streaming service. $ curl -X GET http://localhost:9090/stream/fileupload File Received!"},{"page":"/learn/by-example/http-to-websocket-upgrade.html","name":"HTTP To WebSocket Upgrade","summary":"This sample demonstrates how an HTTP endpoint is updated to a WebSocket endpoint using an upgrade resource.This is an HTTP resource.This is an HTTP to WebSocket upgrade resource. This is defined using the WebSocket upgrade resource config.\n Here you have access to the http:Request and to the query and path ...","content":"/  /  / HTTP To WebSocket Upgrade  import ballerina/http; import ballerina/io; import ballerina/log;@http:ServiceConfig {  basePath: \"/hello\" } service httpService on new http:Listener(9090) {  @http:ResourceConfig {  path: \"/world\",  methods: [\"POST\"]  }  resource function httpResource(http:Caller caller, http:Request req) {  http:Response resp = new;  var payload = req.getTextPayload();  if (payload is error) {  log:printError(\"Error sending message\", payload);  resp.setPayload(\"Error in payload\");  resp.statusCode = 500;  } else {  io:println(payload);  resp.setPayload(string `HTTP POST received: ${<@untainted>payload}`);  } var err = caller->respond(resp);  if (err is error) {  log:printError(\"Error in responding\", err);  }  }  @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/ws\",  upgradeService: wsService  }  }  resource function upgrader(http:Caller caller, http:Request req) { } } service wsService = @http:WebSocketServiceConfig {subProtocols: [\"xml, json\"]  ,idleTimeoutInSeconds: 20} service { resource function onOpen(http:WebSocketCaller caller) {  io:println(\"New WebSocket connection: \" + caller.getConnectionId());  } resource function onText(http:WebSocketCaller caller, string text) {  io:println(text);  var err = caller->pushText(text);  if (err is error) {  log:printError(\"Error sending message\", err);  }  } resource function onIdleTimeout(http:WebSocketCaller caller) {  io:println(\"Idle timeout: \" + caller.getConnectionId());  } };    HTTP To WebSocket Upgrade  This sample demonstrates how an HTTP endpoint is updated to a WebSocket endpoint using an upgrade resource.    import ballerina/http; import ballerina/io; import ballerina/log;    @http:ServiceConfig {  basePath: \"/hello\" } service httpService on new http:Listener(9090) {    @http:ResourceConfig {  path: \"/world\",  methods: [\"POST\"]  }  resource function httpResource(http:Caller caller, http:Request req) {  http:Response resp = new;  var payload = req.getTextPayload();  if (payload is error) {  log:printError(\"Error sending message\", payload);  resp.setPayload(\"Error in payload\");  resp.statusCode = 500;  } else {  io:println(payload);  resp.setPayload(string `HTTP POST received: ${<@untainted>payload}`);  }    This is an HTTP resource.   var err = caller->respond(resp);  if (err is error) {  log:printError(\"Error in responding\", err);  }  }    @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/ws\",  upgradeService: wsService  }  }  resource function upgrader(http:Caller caller, http:Request req) {    This is an HTTP to WebSocket upgrade resource. This is defined using the WebSocket upgrade resource config.  Here you have access to the http:Request and to the query and path params where applicable.   } }    service wsService = @http:WebSocketServiceConfig {subProtocols: [\"xml, json\"]  ,idleTimeoutInSeconds: 20} service {    Note: When a WebSocket upgrade path is defined in HTTP resource configuration. - Without service configuration for WebSocketService default values are taken for sub protocols, idle timeout etc.  - If WebSocketServiceConfig is defined without the path, sub protocols, idle timeout etc. can be configured.  - If path is defined in the WebSocketServiceConfig it shall be ignored.  - This service can also be bound to a different Listener in which case the path configuration becomes useful.   resource function onOpen(http:WebSocketCaller caller) {  io:println(\"New WebSocket connection: \" + caller.getConnectionId());  }    resource function onText(http:WebSocketCaller caller, string text) {  io:println(text);  var err = caller->pushText(text);  if (err is error) {  log:printError(\"Error sending message\", err);  }  }    resource function onIdleTimeout(http:WebSocketCaller caller) {  io:println(\"Idle timeout: \" + caller.getConnectionId());  } };    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run http_to_websocket_upgrade.bal    # To check the sample, use the Chrome or Firefox JavaScript console and run the commands given below. <br> # Change \"xml\" to another sub protocol to observe the behavior of the WebSocket server. # This WebSocket sample is configured to have two endpoints. $ var ws = new WebSocket(\"ws://localhost:9090/hello/ws\", \"xml\", \"my-protocol\");    $ ws.onmessage = function(frame) {console.log(frame.data)}; $ ws.onclose = function(frame) {console.log(frame)};    # Send messages. $ ws.send(\"hello world\");    #Use the cURL command to call the HTTP resource. $ curl -H \"Content-Type: text/plain\" -X POST -d 'Hello World!!' 'http://localhost:9090/hello/world'"},{"page":"/learn/by-example/http-trace-logs.html","name":"Trace Logs","summary":"The HTTP trace logs can be used to monitor the HTTP traffic that goes in and out of Ballerina.Create a new http:Client.Forward incoming requests to the remote backend.Respond to the caller.Log the error in case of a failure. ...","content":"/  /  / Trace Logs  import ballerina/http; import ballerina/log;@http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Client clientEP = new (\"http://httpstat.us\");  var resp = clientEP->forward(\"/200\", req);  if (resp is http:Response) {  var result = caller->respond(resp);  if (result is error) {  log:printError(\"Failed to respond to caller\", result);  }  } else {  log:printError(\"Failed to fulfill request\", resp);  }  } }    Trace Logs  The HTTP trace logs can be used to monitor the HTTP traffic that goes in and out of Ballerina.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    http:Client clientEP = new (\"http://httpstat.us\");    Create a new http:Client.   var resp = clientEP->forward(\"/200\", req);  if (resp is http:Response) {    Forward incoming requests to the remote backend.   var result = caller->respond(resp);    Respond to the caller.   if (result is error) {  log:printError(\"Failed to respond to caller\", result);  }  } else {  log:printError(\"Failed to fulfill request\", resp);  }  } }    Log the error in case of a failure.   # Trace logs are logged at `TRACE` level. # To enable trace logs, the log level has to be set to `TRACE` using the runtime argument: <br> `--b7a.http.tracelog.console=true`. <br> # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command with this runtime argument. $ ballerina run http_trace_logs.bal --b7a.http.tracelog.console=true ballerina: HTTP trace log enabled [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 # In the logs, `http.downstream` refers to the HTTP traffic that flows between the client and Ballerina, # while `http.upstream` refers to the HTTP traffic that flows between Ballerina and the backend. [2019-09-08 13:01:12,693] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9] REGISTERED [2019-09-08 13:01:12,696] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54362] ACTIVE [2019-09-08 13:01:12,745] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54362] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 Host: localhost:9090 User-Agent: curl/7.58.0 Accept: */* [2019-09-08 13:01:12,779] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] INBOUND: EmptyLastHttpContent, 0B [2019-09-08 13:01:12,782] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] READ COMPLETE [2019-09-08 13:01:13,133] TRACE {http.tracelog.upstream} - [id: 0xd79aee99] REGISTERED [2019-09-08 13:01:13,134] TRACE {http.tracelog.upstream} - [id: 0xd79aee99] CONNECT: httpstat.us/23.99.0.12:80, null [2019-09-08 13:01:13,381] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: n/a, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] DEREGISTER [2019-09-08 13:01:13,383] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: n/a, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] ACTIVE [2019-09-08 13:01:13,383] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: n/a, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] UNREGISTERED [2019-09-08 13:01:13,384] TRACE {http.tracelog.upstream} - [id: 0xd79aee99] REGISTERED [2019-09-08 13:01:13,389] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] OUTBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /200 HTTP/1.1 Accept: */* host: httpstat.us user-agent: ballerina/1.0.0 connection: keep-alive [2019-09-08 13:01:13,394] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] OUTBOUND: EmptyLastHttpContent, 0B [2019-09-08 13:01:13,395] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] FLUSH [2019-09-08 13:01:13,653] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] INBOUND: DefaultHttpResponse(decodeResult: success, version: HTTP/1.1) HTTP/1.1 200 OK Cache-Control: private Content-Length: 6 Content-Type: text/plain; charset=utf-8 Server: Microsoft-IIS/10.0 X-AspNetMvc-Version: 5.1 Access-Control-Allow-Origin: * X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET Set-Cookie: ARRAffinity=8bb96a9f72e760ea135952440e9c62bbfe3a64e8a577005f68697bfd250722b9;Path=/;HttpOnly;Domain=httpstat.us Date: Sun, 08 Sep 2019 07:31:13 GMT [2019-09-08 13:01:13,685] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] INBOUND: DefaultLastHttpContent(data: PooledSlicedByteBuf(ridx: 0, widx: 6, cap: 6/6, unwrapped: PooledUnsafeDirectByteBuf(ridx: 409, widx: 409, cap: 1024)), decoderResult: success), 6B 200 OK [2019-09-08 13:01:13,689] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] READ COMPLETE [2019-09-08 13:01:13,697] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 6, cap: 6, components=1)) HTTP/1.1 200 OK Cache-Control: private Content-Type: text/plain; charset=utf-8 X-AspNetMvc-Version: 5.1 Access-Control-Allow-Origin: * X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET Set-Cookie: ARRAffinity=8bb96a9f72e760ea135952440e9c62bbfe3a64e8a577005f68697bfd250722b9;Path=/;HttpOnly;Domain=httpstat.us Date: Sun, 08 Sep 2019 07:31:13 GMT server: Microsoft-IIS/10.0 content-length: 6, 6B 200 OK [2019-09-08 13:01:13,698] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] FLUSH [2019-09-08 13:01:13,703] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] READ COMPLETE [2019-09-08 13:01:13,704] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] INACTIVE [2019-09-08 13:01:13,704] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] CLOSE [2019-09-08 13:01:13,708] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] UNREGISTERED    # Invoke the service. $ curl http://localhost:9090/hello 200 OK"},{"page":"/learn/by-example/https-listener.html","name":"HTTPS Listener","summary":"You can use the HTTPS Listener to connect or interact with an HTTPS client.\n Provide the Secure Socket configuration to the server to expose an HTTPS connection.An HTTP endpoint can be configured to communicate through HTTPS as well.\n To secure an endpoint using HTTPS, the endpoint needs to be configured ...","content":"/  /  / HTTPS Listener  import ballerina/config; import ballerina/http; import ballerina/log; http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }; listener http:Listener helloWorldEP = new (9095, config = helloWorldEPConfig);@http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }    HTTPS Listener  You can use the HTTPS Listener to connect or interact with an HTTPS client.  Provide the Secure Socket configuration to the server to expose an HTTPS connection.    import ballerina/config; import ballerina/http; import ballerina/log;    http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };    An HTTP endpoint can be configured to communicate through HTTPS as well.  To secure an endpoint using HTTPS, the endpoint needs to be configured with  a keystore, a certificate, and a private key for the endpoint.   listener http:Listener helloWorldEP = new (9095, config = helloWorldEPConfig);    Create a listener endpoint.   @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }    Send the response back to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command along with the Ballerina home path as a config. $ ballerina run https_listener.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9095    # To invoke the service, execute the below cURL command with the `-k` option. $ curl -k https://localhost:9095/hello Hello World!"},{"page":"/learn/by-example/if-else.html","name":"If/Else","summary":"An if statement provides a way to perform conditional execution.This is a basic if statement.This is an if-else scenario.This is an if-else-if-else scenario. ...","content":"/  /  / If/Else  import ballerina/io;public function main() {  int a = 10;  int b = 0;  if (a == 10) {  io:println(\"a == 10\");  }  if (a < b) {  io:println(\"a < b\");  } else {  io:println(\"a >= b\");  }  if (b < 0) {  io:println(\"b < 0\");  } else if (b > 0) {  io:println(\"b > 0\");  } else {  io:println(\"b == 0\");  } }    If/Else  An if statement provides a way to perform conditional execution.    import ballerina/io;    public function main() {  int a = 10;  int b = 0;    if (a == 10) {  io:println(\"a == 10\");  }    This is a basic if statement.   if (a < b) {  io:println(\"a < b\");  } else {  io:println(\"a >= b\");  }    This is an if-else scenario.   if (b < 0) {  io:println(\"b < 0\");  } else if (b > 0) {  io:println(\"b > 0\");  } else {  io:println(\"b == 0\");  } }    This is an if-else-if-else scenario.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run if_else.bal a == 10 a >= b b == 0"},{"page":"/learn/by-example/immutable-values.html","name":"Immutable Values","summary":"Ballerina allows creating immutable or read-only clones of values.The .cloneReadOnly() method can be called on a value of type anydata to create a clone of the value,\n which is immutable. No changes are done to the original value.\n Calling .cloneReadOnly() on structures would deeply clone the elements and mark them ...","content":"/  /  / Immutable Values  import ballerina/io;public function main() {  map<string|int> m1 = {stringVal: \"str\", intVal: 1};  map<string|int> m2 = m1.cloneReadOnly();  io:println(\"m1 === m2: \", m1 === m2);  io:println(\"m1 is immutable: \", m1.isReadOnly());  io:println(\"m2 is immutable: \", m2.isReadOnly());  error? updateResult = trap addEntryToMap(m2, \"intValTwo\", 10);  if (updateResult is error) {  io:println(\"Error occurred on update: \",  <string>updateResult.detail()?.message);  }  map<string|int> m3 = m2.cloneReadOnly();  io:println(\"m2 === m3: \", m2 === m3);  map<string|int> m5 = {valueType: \"map\", constraint: \"string\"};  var frozenVal = m5.cloneReadOnly();  if (frozenVal is map<string>) {  io:println(\"frozenVal is map<string>\");  } } function addEntryToMap(map<string|int> m, string key, string|int value) {  m[key] = value; }    Immutable Values  Ballerina allows creating immutable or read-only clones of values.  The .cloneReadOnly() method can be called on a value of type anydata to create a clone of the value,  which is immutable. No changes are done to the original value.  Calling .cloneReadOnly() on structures would deeply clone the elements and mark them as immutable.  Moreover, if the value is already an immutable value, .cloneReadOnly() returns the value itself (no cloning is  done).  The .isReadOnly() method could be used on anydata values to check if they are immutable.  Attempts to modify an immutable/read-only value would cause panicking.    import ballerina/io;    public function main() {    map<string|int> m1 = {stringVal: \"str\", intVal: 1};    Create an anydata-typed map with two entries.   map<string|int> m2 = m1.cloneReadOnly();    Call .cloneReadOnly() on the map m1 and assign the returned value to another variable.   io:println(\"m1 === m2: \", m1 === m2);    Reference equality checks for m1 and m2 should evaluate to false due to a clone being created  since m1 is not an immutable value.   io:println(\"m1 is immutable: \", m1.isReadOnly());    Check if m1 is immutable. This evaluates to false since no changes are done to  the original value.   io:println(\"m2 is immutable: \", m2.isReadOnly());    Check if m2 is immutable. This evaluates to true since the returned clone is  marked as immutable.   error? updateResult = trap addEntryToMap(m2, \"intValTwo\", 10);  if (updateResult is error) {    Attempt to add an entry to the map and trap the panic if it results in a panic.   io:println(\"Error occurred on update: \",  <string>updateResult.detail()?.message);  }    An error should occur since m2 is frozen.   map<string|int> m3 = m2.cloneReadOnly();    Now call .cloneReadOnly() on the immutable value m2.   io:println(\"m2 === m3: \", m2 === m3);    Reference equality checks for m2 and m3 should evaluate to true due to no clones being created  since m2 is already an immutable value.   map<string|int> m5 = {valueType: \"map\", constraint: \"string\"};    An is check for a frozen value becomes an is like check.  In other words, storage type is not considered.  Define a map of the constraint type string or int, but with  values of the type string only.   var frozenVal = m5.cloneReadOnly();    Make the map immutable. The resultant value would only  contain values of the type string and no values can now be  added to the map.   if (frozenVal is map<string>) {  io:println(\"frozenVal is map<string>\");  } }    Checking if the frozen value is of the type map<string> thus  evaluates to true.   function addEntryToMap(map<string|int> m, string key, string|int value) {  m[key] = value; }    Function to add an entry to a map.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run immutable_values.bal m1 === m2: false m1 is immutable: false m2 is immutable: true Error occurred on update: Invalid map insertion: modification not allowed on readonly value m2 === m3: true frozenVal is map<string>"},{"page":"/learn/by-example/","name":"Ballerina","summary":"Ballerina by Example enables you to have complete coverage over the language, while emphasizing incremental learning. This is a series of commented example programs. ...","content":"/  / Ballerina by Example  TABLE OF CONTENTS  Ballerina by Example enables you to have complete coverage over the language, while emphasizing incremental learning. This is a series of commented example programs."},{"page":"/learn/by-example/invoke-java-methods.html","name":"Invoke Java Methods","summary":"The Method annotation in ballerina/java module allows you to link a Java method (static or instance) with a\n Ballerina function with an external function body.Let’s create a Ballerina function to call the static method randomUUID in java.util.UUID class.\n Here the name field is optional if the Ballerina function name is ...","content":"/  /  / Invoke Java Methods  import ballerina/io; import ballerina/java; function createRandomUUID() returns handle = @java:Method {  name: \"randomUUID\",  class: \"java.util.UUID\" } external; function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external; function offer(handle receiver, handle e) returns boolean = @java:Method {  class: \"java.util.ArrayDeque\" } external; function poll(handle receiver) returns handle = @java:Method {  class: \"java.util.ArrayDeque\" } external;public function main() {  var uuid = createRandomUUID();  var arrayDeque = newArrayDeque();  _ = offer(arrayDeque, java:fromString(\"John\"));  _ = offer(arrayDeque, java:fromString(\"Jane\"));  _ = offer(arrayDeque, java:fromString(\"Peter\")); var nextInLineHandle = poll(arrayDeque);  string? nextInLine = java:toString(nextInLineHandle);  io:println(nextInLine); }    Invoke Java Methods  The Method annotation in ballerina/java module allows you to link a Java method (static or instance) with a  Ballerina function with an external function body.    import ballerina/io; import ballerina/java;    function createRandomUUID() returns handle = @java:Method {  name: \"randomUUID\",  class: \"java.util.UUID\" } external;    Let’s create a Ballerina function to call the static method randomUUID in java.util.UUID class.  Here the name field is optional if the Ballerina function name is equal to the Java counterpart.  This method returns a handle value referring to a java.util.UUID instance.   function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;    The class java.util.ArrayDeque is a resizable array that allows you to add or remove an element from both sides.  Here newArrayDeque function is linked with the default constructor of the java.util.ArrayDeque class.   function offer(handle receiver, handle e) returns boolean = @java:Method {  class: \"java.util.ArrayDeque\" } external;    The offer Ballerina function is linked with the instance method offer in java.util.ArrayDeque class.  This function inserts the element e at the end of the queue referred by the parameter receiver.   function poll(handle receiver) returns handle = @java:Method {  class: \"java.util.ArrayDeque\" } external;    The poll Ballerina function is linked with the instance method poll in java.util.ArrayDeque class.  This function removes the head element of the queue referred by the parameter receiver.   public function main() {    var uuid = createRandomUUID();    Create a random UUID instance by invoking the createRandomUUID Ballerina function.  This function demonstrates how you can invoke Java static function in Ballerina.   var arrayDeque = newArrayDeque();    Create a new java.util.ArrayDeque instance.   _ = offer(arrayDeque, java:fromString(\"John\"));  _ = offer(arrayDeque, java:fromString(\"Jane\"));  _ = offer(arrayDeque, java:fromString(\"Peter\"));    Ballerina strings are different from Java strings. The fromString function in ballerina/java module converts  a Ballerina string value to a Java String representation. Java String is a reference type; hence,  this method returns a handle value referring to the created to Java string.   var nextInLineHandle = poll(arrayDeque);    string? nextInLine = java:toString(nextInLineHandle);  io:println(nextInLine); }    The toString function in ballerina/java module creates a Ballerina string  representation of the Java reference value.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run invoke-java-methods.bal John"},{"page":"/learn/by-example/java-arrays.html","name":"Java Arrays","summary":"Java arrays are represented by the handle type in Ballerina. They can be manipulated using the\n getArrayElement, setArrayElement and getArrayLength methods provided by the ballerina/java module.Convert Ballerina strings to Java strings before passing to Java methods.Invoke an external method, implemented in Java.Access an array element, pass the handle that refers ...","content":"/  /  / Java Arrays  import ballerina/io; import ballerina/java; import ballerina/java.arrays as jarrays;public function splitString(handle receiver, handle regex) returns handle = @java:Method {  name: \"split\",  class: \"java/lang/String\" } external;public function main() {  handle helloString = java:fromString(\"Hello world\");  handle regex = java:fromString(\" \");  handle words = splitString(helloString, regex); int numWords = jarrays:getLength(words);  io:println(numWords);  handle secondWord = jarrays:get(words, 1);  io:println(secondWord); }    Java Arrays  Java arrays are represented by the handle type in Ballerina. They can be manipulated using the  getArrayElement, setArrayElement and getArrayLength methods provided by the ballerina/java module.    import ballerina/io; import ballerina/java; import ballerina/java.arrays as jarrays;    public function splitString(handle receiver, handle regex) returns handle = @java:Method {  name: \"split\",  class: \"java/lang/String\" } external;    public function main() {    handle helloString = java:fromString(\"Hello world\");  handle regex = java:fromString(\" \");    Convert Ballerina strings to Java strings before passing to Java methods.   handle words = splitString(helloString, regex);    Invoke an external method, implemented in Java.   int numWords = jarrays:getLength(words);  io:println(numWords);    handle secondWord = jarrays:get(words, 1);  io:println(secondWord); }    Access an array element, pass the handle that refers to the Java array instance as the first argument.   # To run this sample, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run java_arrays.bal 2 world"},{"page":"/learn/by-example/iterable-objects.html","name":"Iterable Objects","summary":"An object can be made iterable as a sequence of values of type T by providing a method named __iterator which\n returns a value that is a subtype of Iterator<T>. We refer to this type as Iterable<T>. Any subtype\n of abstract object {public next() returns record {| T value; |}?;}, ...","content":"/  /  / Iterable Objects  import ballerina/io; type ArrayIterator object {  private int[] integers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34];  private int cursor = -1;  public function next() returns record {|int value;|}? {  self.cursor += 1;  if (self.cursor < self.integers.length()) {  record {|int value;|} nextVal = {value: self.integers[self.cursor]};  return nextVal;  }  return ();  } }; type IteratorGenerator object {  public function __iterator() returns abstract object {  public function next() returns record {|int value;|}?;} {  return new ArrayIterator();  } };public function main() {  IteratorGenerator itrGen = new;  int i = 0;  foreach var item in itrGen {  i += 1;  io:println(\"Element \", i, \": \", item);  } }    Iterable Objects  An object can be made iterable as a sequence of values of type T by providing a method named __iterator which  returns a value that is a subtype of Iterator<T>. We refer to this type as Iterable<T>. Any subtype  of abstract object {public next() returns record {| T value; |}?;}, is called Iterator. An iterable object can be  iterated over using a foreach loop. In this example, IteratorGenerator is a subtype of Iterable<int> and  ArrayIterator is a subtype of Iterator<int>.    import ballerina/io;    type ArrayIterator object {  private int[] integers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34];  private int cursor = -1;    An object that is a subtype of Iterator<int>.   public function next() returns record {|int value;|}? {  self.cursor += 1;  if (self.cursor < self.integers.length()) {  record {|int value;|} nextVal = {value: self.integers[self.cursor]};  return nextVal;  }  return ();  } };    next method which generates the sequence of values of type int.   type IteratorGenerator object {    An object that is a subtype of Iterable<int>.   public function __iterator() returns abstract object {  public function next() returns record {|int value;|}?;} {  return new ArrayIterator();  } };    The __iterator() method should return a new Iterator<T>.   public function main() {  IteratorGenerator itrGen = new;  int i = 0;  foreach var item in itrGen {  i += 1;  io:println(\"Element \", i, \": \", item);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run iterable_objects.bal Element 1: 0 Element 2: 1 Element 3: 1 Element 4: 2 Element 5: 3 Element 6: 5 Element 7: 8 Element 8: 13 Element 9: 21 Element 10: 34"},{"page":"/learn/by-example/java-varargs.html","name":"Java Varargs","summary":"Let’s look at how to invoke Java varargs functions (both static and instance) in Ballerina.\n If there are overloaded Java methods and you want to remove the ambiguity, the paramTypes field can be used\n to specify the element class type and dimension.Define a Ballerina function with an external function body ...","content":"/  /  / Java Varargs  import ballerina/io; import ballerina/java; public function asList(int... values) returns handle = @java:Method {  name: \"asList\",  class: \"java.util.Arrays\" } external;public function main() {  var answer = 42;  var javaList = asList(1, 2, answer);  io:println(javaList); }    Java Varargs  Let’s look at how to invoke Java varargs functions (both static and instance) in Ballerina.  If there are overloaded Java methods and you want to remove the ambiguity, the paramTypes field can be used  to specify the element class type and dimension.    import ballerina/io; import ballerina/java;    public function asList(int... values) returns handle = @java:Method {  name: \"asList\",  class: \"java.util.Arrays\" } external;    Define a Ballerina function with an external function body whose implementation is provided by a Java method.  When a vararg is used in the Ballerina function signature, corresponding values are wrapped in  a Java array before the invocation.   public function main() {  var answer = 42;    var javaList = asList(1, 2, answer);  io:println(javaList); }    If a method is non-static, the receiver instance has to be provided as the first parameter.   # To run this sample, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run java_varargs.bal [1, 2, 42]"},{"page":"/learn/by-example/java-exceptions.html","name":"Java Exceptions","summary":"In idiomatic Ballerina code, errors should be communicated via explicit return values in functions.\n Java error handling is different from Ballerina. Java constructors and methods throw both\n checked and unchecked exceptions. In Java interoperability design, if a Java method throws an\n unchecked exception then the corresponding Ballerina function invocation panics.\n ...","content":"/  /  / Java Exceptions  import ballerina/io; import ballerina/java; function loadClass(handle className) returns handle|error = @java:Method {  name: \"forName\",  class: \"java.lang.Class\" } external; function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external; function offer(handle receiver, handle e) returns boolean = @java:Method {  class: \"java.util.ArrayDeque\" } external;public function main() {  var classOrError = loadClass(java:fromString(\"a.b.c.z.SomeClass\"));  if classOrError is error {  io:println(classOrError);  }  var arrayDeque = newArrayDeque();  boolean|error e = trap offer(arrayDeque, java:createNull());  if e is error {  io:println(e);  } }    Java Exceptions  In idiomatic Ballerina code, errors should be communicated via explicit return values in functions.  Java error handling is different from Ballerina. Java constructors and methods throw both  checked and unchecked exceptions. In Java interoperability design, if a Java method throws an  unchecked exception then the corresponding Ballerina function invocation panics.  A panic indicates abnormal completions and usually implies that something unexpected has occurred.  If a Java method throws a checked exception, then the corresponding Ballerina function  should have the error type in its return signature.  Let’s look at how to handle Java exceptions in Ballerina.    import ballerina/io; import ballerina/java;    function loadClass(handle className) returns handle|error = @java:Method {  name: \"forName\",  class: \"java.lang.Class\" } external;    Let’s create a Ballerina function to load Java classes by linking with the forName method of  the java.lang.Class. It throws a checked exception java.lang.ClassNotFoundException.  Therefore the loadClass ballerina function should have the error type as part of its return signature.   function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;    The class java.util.ArrayDeque is a resizable array that allows you to add or remove an element from both sides.  Here newArrayDeque function is linked with the default constructor of the java.util.ArrayDeque class.   function offer(handle receiver, handle e) returns boolean = @java:Method {  class: \"java.util.ArrayDeque\" } external;    The offer method in the ArrayDeque class throws a java.lang.NullPointerException if the element is null.   public function main() {    var classOrError = loadClass(java:fromString(\"a.b.c.z.SomeClass\"));  if classOrError is error {  io:println(classOrError);  }    The loadClass function returns union of handle or error.   var arrayDeque = newArrayDeque();  boolean|error e = trap offer(arrayDeque, java:createNull());  if e is error {  io:println(e);  } }    Here we are sending a null element to offer function. The createNull function in ballerina/java  module creates a handle value that refers to Java null.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run java-exceptions.bal error java.lang.ClassNotFoundException message=a.b.c.z.SomeClass error java.lang.NullPointerException"},{"page":"/learn/by-example/jdbc-client-call-procedures.html","name":"JDBC Client Call Procedures","summary":"This example demonstrates how to execute stored procedures using JDBC Client.\n This sample uses MySQL DB. Before running the sample, copy the\n MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB\n connection properties as required.Client for MySQL database. This client can be used with any JDBC\n supported database ...","content":"/  /  / JDBC Client Call Procedures  import ballerina/io; import ballerinax/java.jdbc; jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} }); type Student record {  int id;  int age;  string name; };public function main() {  io:println(\"The update operation - Creating table and procedures:\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");  ret = testDB->update(\"CREATE PROCEDURE INSERTDATA(IN pAge INT, \" +  \"IN pName VARCHAR(255)) \" +  \"BEGIN \" +  \"INSERT INTO student(age, name) VALUES (pAge, pName); \" +  \"END\");  handleUpdate(ret, \"Stored procedure with IN param creation\");  ret = testDB->update(\"CREATE PROCEDURE GETCOUNT (INOUT pID INT, \" +  \"OUT pCount INT) \" +  \"BEGIN \" +  \"SELECT id INTO pID FROM student WHERE age = pID; \" +  \"SELECT COUNT(*) INTO pCount FROM student \" +  \"WHERE age = 20; \" +  \"END\");  handleUpdate(ret, \"Stored procedure with INOUT/OUT param creation\"); ret = testDB->update(\"CREATE PROCEDURE GETSTUDENTS() \" +  \"BEGIN SELECT * FROM student; END\");  handleUpdate(ret, \"Stored procedure with result set return\");  io:println(\"\\nThe call operation - With IN params\");  var retCall = testDB->call(\"{CALL INSERTDATA(?,?)}\", (), 20, \"George\");  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation with IN params successful\");  }  io:println(\"\\nThe call operation - With INOUT/OUT params\");  jdbc:Parameter pId = {  sqlType: jdbc:TYPE_INTEGER,  value: 20,  direction: jdbc:DIRECTION_INOUT  };  jdbc:Parameter pCount = {  sqlType: jdbc:TYPE_INTEGER,  direction: jdbc:DIRECTION_OUT  };  retCall = testDB->call(\"{CALL GETCOUNT(?,?)}\", (), pId, pCount);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation with INOUT and OUT params successful\");  io:println(\"Student ID of the student with age of 20: \", pId.value);  io:println(\"Student count with age of 20: \", pCount.value);  }  retCall = testDB->call(\"{CALL GETSTUDENTS()}\", [Student]);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message); } else if retCall is table<record {}>[] {  io:println(\"Data in students table:\");  foreach var row in retCall[0] {  io:println(row);  }  } else {  io:println(\"Call operation is not returning data\");  }  io:println(\"\\nThe update operation - Drop the tables and procedures\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); ret = testDB->update(\"DROP PROCEDURE INSERTDATA\");  handleUpdate(ret, \"Drop stored procedure INSERTDATA\"); ret = testDB->update(\"DROP PROCEDURE GETCOUNT\");  handleUpdate(ret, \"Drop stored procedure GETCOUNT\"); ret = testDB->update(\"DROP PROCEDURE GETSTUDENTS\");  handleUpdate(ret, \"Drop stored procedure GETSTUDENTS\"); } function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    JDBC Client Call Procedures  This example demonstrates how to execute stored procedures using JDBC Client.  This sample uses MySQL DB. Before running the sample, copy the  MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB  connection properties as required.    import ballerina/io; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });    Client for MySQL database. This client can be used with any JDBC  supported database by providing the corresponding JDBC URL.   type Student record {  int id;  int age;  string name; };    This is the type created to represent a data row.   public function main() {    io:println(\"The update operation - Creating table and procedures:\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");    Create a table using the update remote function.   ret = testDB->update(\"CREATE PROCEDURE INSERTDATA(IN pAge INT, \" +  \"IN pName VARCHAR(255)) \" +  \"BEGIN \" +  \"INSERT INTO student(age, name) VALUES (pAge, pName); \" +  \"END\");  handleUpdate(ret, \"Stored procedure with IN param creation\");    Create the stored procedure with IN parameters.   ret = testDB->update(\"CREATE PROCEDURE GETCOUNT (INOUT pID INT, \" +  \"OUT pCount INT) \" +  \"BEGIN \" +  \"SELECT id INTO pID FROM student WHERE age = pID; \" +  \"SELECT COUNT(*) INTO pCount FROM student \" +  \"WHERE age = 20; \" +  \"END\");  handleUpdate(ret, \"Stored procedure with INOUT/OUT param creation\");    Create the stored procedure with INOUT and OUT parameters.   ret = testDB->update(\"CREATE PROCEDURE GETSTUDENTS() \" +  \"BEGIN SELECT * FROM student; END\");  handleUpdate(ret, \"Stored procedure with result set return\");    io:println(\"\\nThe call operation - With IN params\");    The remote function call is used to invoke a stored procedure.  Here the stored procedure with IN parameters is invoked.   var retCall = testDB->call(\"{CALL INSERTDATA(?,?)}\", (), 20, \"George\");  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation with IN params successful\");  }    Invoke the stored procedure with IN type parameters.   io:println(\"\\nThe call operation - With INOUT/OUT params\");    Here stored procedure with OUT and INOUT parameters is invoked.   jdbc:Parameter pId = {  sqlType: jdbc:TYPE_INTEGER,  value: 20,  direction: jdbc:DIRECTION_INOUT  };  jdbc:Parameter pCount = {  sqlType: jdbc:TYPE_INTEGER,  direction: jdbc:DIRECTION_OUT  };    Define the parameters for INOUT arguments.   retCall = testDB->call(\"{CALL GETCOUNT(?,?)}\", (), pId, pCount);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation with INOUT and OUT params successful\");  io:println(\"Student ID of the student with age of 20: \", pId.value);  io:println(\"Student count with age of 20: \", pCount.value);  }    Invoke the stored procedure.   retCall = testDB->call(\"{CALL GETSTUDENTS()}\", [Student]);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);    Invoke the stored procedure which returns data.   } else if retCall is table<record {}>[] {  io:println(\"Data in students table:\");  foreach var row in retCall[0] {  io:println(row);  }  } else {  io:println(\"Call operation is not returning data\");  }    io:println(\"\\nThe update operation - Drop the tables and procedures\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\");    Drop the table and procedures.   ret = testDB->update(\"DROP PROCEDURE INSERTDATA\");  handleUpdate(ret, \"Drop stored procedure INSERTDATA\");    ret = testDB->update(\"DROP PROCEDURE GETCOUNT\");  handleUpdate(ret, \"Drop stored procedure GETCOUNT\");    ret = testDB->update(\"DROP PROCEDURE GETSTUDENTS\");  handleUpdate(ret, \"Drop stored procedure GETSTUDENTS\"); }    function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   # At the command line, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command. $ ballerina run jdbc_client_call_procedures.bal The update operation - Creating table and procedures: Create student table status: 0 Stored procedure with IN param creation status: 0 Stored procedure with INOUT/OUT param creation status: 0 Stored procedure with result set return status: 0    The call operation - With IN params Call operation with IN params successful    The call operation - With INOUT/OUT params Call operation with INOUT and OUT params successful Student ID of the student with age of 20: 1 Student count with age of 20: 1 Data in students table: id=1 age=20 name=George    The update operation - Drop the tables and procedures Drop table student status: 0 Drop stored procedure INSERTDATA status: 0 Drop stored procedure GETCOUNT status: 0 Drop stored procedure GETSTUDENTS status: 0"},{"page":"/learn/by-example/jdbc-client-batch-update.html","name":"JDBC Client Batch Update","summary":"This example demonstrates how to execute batch update using JDBC Client.\n This sample uses MySQL DB. Before running the sample, copy the\n MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB\n connection properties as required.Client for the MySQL database. This client can be used with any JDBC\n supported ...","content":"/  /  / JDBC Client Batch Update  import ballerina/io; import ballerinax/java.jdbc; jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} }); type Student record {  int id;  int age;  string name; };type myBatchType int|string;public function main() {  io:println(\"The update operation - Creating a table:\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");  json jsonMsg = [{  \"firstname\": \"Peter\",  \"age\": 10  }, {  \"firstname\": \"John\",  \"age\": 15  }, {  \"firstname\": \"James\",  \"age\": 12  }];  myBatchType[][] dataBatch = [];  if (jsonMsg is json[]) {  foreach (var studentData in jsonMsg) {  string name = <string>studentData.firstname;  int age = <int>studentData.age;  myBatchType[] dataRow = [age, name];  dataBatch.push(dataRow);  }  }  jdbc:BatchUpdateResult retBatch = testDB->batchUpdate(\"INSERT INTO student \" +  \"(age,name) VALUES (?,?)\", false, ...dataBatch);  error? e = retBatch.returnedError;  if (e is error) {  io:println(\"Batch update operation failed:\", <string>e.detail()?.message);  } else {  io:println(\"Batch 1 update counts: \", retBatch.updatedRowCount[0]);  io:println(\"Batch 2 update counts: \", retBatch.updatedRowCount[1]);  anydata[]? generatedKeys = retBatch.generatedKeys[\"GENERATED_KEY\"];  if (generatedKeys is int[]) {  int key1 = generatedKeys[0];  int key2 = generatedKeys[1];  int key3 = generatedKeys[2];  io:println(\"Generated keys are: \", key1, \", \", key2, \" and \", key3);  }  }  checkData();  io:println(\"\\nThe update operation - Drop the student table\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); } function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } } function checkData() {  var dtReturned = testDB->select(\"SELECT * FROM student\", Student);  if (dtReturned is table<record{}>) {  io:println(\"Data in students table:\");  foreach var row in dtReturned {  io:println(row.toString());  }  } else {  io:println(\"Select data from student table failed: \",  <string>dtReturned.detail()?.message);  } }    JDBC Client Batch Update  This example demonstrates how to execute batch update using JDBC Client.  This sample uses MySQL DB. Before running the sample, copy the  MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB  connection properties as required.    import ballerina/io; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });    Client for the MySQL database. This client can be used with any JDBC  supported database by providing the corresponding JDBC URL.   type Student record {  int id;  int age;  string name; };    This is the type created to represent a data row.   type myBatchType int|string;    public function main() {    io:println(\"The update operation - Creating a table:\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");    Create a table using the update remote function.   json jsonMsg = [{  \"firstname\": \"Peter\",  \"age\": 10  }, {  \"firstname\": \"John\",  \"age\": 15  }, {  \"firstname\": \"James\",  \"age\": 12  }];    This json input is used as the input data.   myBatchType[][] dataBatch = [];  if (jsonMsg is json[]) {  foreach (var studentData in jsonMsg) {  string name = <string>studentData.firstname;  int age = <int>studentData.age;  myBatchType[] dataRow = [age, name];  dataBatch.push(dataRow);  }  }    Prepare the data batch by iterating the json array.   jdbc:BatchUpdateResult retBatch = testDB->batchUpdate(\"INSERT INTO student \" +  \"(age,name) VALUES (?,?)\", false, ...dataBatch);  error? e = retBatch.returnedError;  if (e is error) {  io:println(\"Batch update operation failed:\", <string>e.detail()?.message);  } else {    A batch of data can be inserted using the batchUpdate remote function.   io:println(\"Batch 1 update counts: \", retBatch.updatedRowCount[0]);  io:println(\"Batch 2 update counts: \", retBatch.updatedRowCount[1]);  anydata[]? generatedKeys = retBatch.generatedKeys[\"GENERATED_KEY\"];  if (generatedKeys is int[]) {  int key1 = generatedKeys[0];  int key2 = generatedKeys[1];  int key3 = generatedKeys[2];  io:println(\"Generated keys are: \", key1, \", \", key2, \" and \", key3);  }  }    The number of inserted rows for each insert in the batch is returned as  an array.   checkData();    Check the data in the database.   io:println(\"\\nThe update operation - Drop the student table\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); }    Delete the tables from the database.   function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   function checkData() {  var dtReturned = testDB->select(\"SELECT * FROM student\", Student);  if (dtReturned is table<record{}>) {    Select data from the table and print.   io:println(\"Data in students table:\");  foreach var row in dtReturned {  io:println(row.toString());  }  } else {  io:println(\"Select data from student table failed: \",  <string>dtReturned.detail()?.message);  } }    Iterating data.   # At the command line, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command. $ ballerina run jdbc_client_batch_update.bal The update operation - Creating a table: Create student table status: 0 Batch 1 update counts: 1 Batch 2 update counts: 1 Generated keys are: 1, 2 and 3 Data in students table: id=1 age=10 name=Peter id=2 age=15 name=John id=3 age=12 name=James    The update operation - Drop the student table Drop table student status: 0"},{"page":"/learn/by-example/jdbc-client-crud-operations.html","name":"JDBC Client CRUD Operations","summary":"This example demonstrates how to execute data definition statements, insert/update/delete data\n and select data using JDBC Client.\n This sample uses MySQL DB. Before running the sample, copy the\n MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB connection\n properties as required.JDBC Client for MySQL database. This client can ...","content":"/  /  / JDBC Client CRUD Operations  import ballerina/io; import ballerina/jsonutils; import ballerina/time; import ballerinax/java.jdbc; jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} }); type Student record {  int id;  int age;  string name;  time:Time insertedTime; };public function main() {  io:println(\"The update operation - Creating a table\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), insertedTime TIMESTAMP DEFAULT \" +  \"CURRENT_TIMESTAMP, PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");  io:println(\"\\nThe update operation - Inserting data to a table\");  ret = testDB->update(\"INSERT INTO student(age, name) values \" +  \"(23, 'john')\");  handleUpdate(ret, \"Insert to student table with no parameters\");  int age = 24;  string name = \"Anne\";  ret = testDB->update(\"INSERT INTO student(age, name) values (?, ?)\",  age, name);  handleUpdate(ret, \"Insert to student table with variable parameters\");  jdbc:Parameter p1 = {sqlType: jdbc:TYPE_INTEGER, value: 25};  jdbc:Parameter p2 = {sqlType: jdbc:TYPE_VARCHAR, value: \"James\"};  jdbc:Parameter p3 = {  sqlType: jdbc:TYPE_TIMESTAMP,  value: time:currentTime()  };  ret = testDB->update(\"INSERT INTO student(age, name, insertedTime) \" +  \"values (?, ?, ?)\", p1, p2, p3);  handleUpdate(ret, \"Insert to student table with jdbc:parameter values\");  io:println(\"\\nThe Update operation - Update data in a table\");  ret = testDB->update(\"UPDATE student SET name = 'jane' WHERE age = ?\", 23);  handleUpdate(ret, \"Update a row in student table\");  io:println(\"\\nThe Update operation - Delete data from table\");  ret = testDB->update(\"DELETE FROM student WHERE age = ?\", 24);  handleUpdate(ret, \"Delete a row from student table\");  io:println(\"\\nThe Update operation - Inserting data\");  var retWithKey = testDB->update(\"INSERT INTO student \" +  \"(age, name) values (?, ?)\", 31, \"Kate\");  if (retWithKey is jdbc:UpdateResult) {  io:println(\"Inserted row count: \", retWithKey.updatedRowCount);  io:println(\"Generated key: \",  <int>retWithKey.generatedKeys[\"GENERATED_KEY\"]);  } else {  io:println(\"Insert failed: \", <string>retWithKey.detail()?.message);  }  io:println(\"\\nThe select operation - Select data from a table\");  var selectRet = testDB->select(\"SELECT * FROM student where age < ?\",  Student, 35);  if (selectRet is table<record{}>) {  json jsonConversionRet = jsonutils:fromTable(selectRet);  io:println(\"JSON: \", jsonConversionRet.toJsonString());  } else {  io:println(\"Select data from student table failed: \",  <string>selectRet.detail()?.message);  }  io:println(\"\\nThe update operation - Drop the student table\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); } function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    JDBC Client CRUD Operations  This example demonstrates how to execute data definition statements, insert/update/delete data  and select data using JDBC Client.  This sample uses MySQL DB. Before running the sample, copy the  MySQL JDBC driver to the BALLERINA_HOME/bre/lib folder and change the DB connection  properties as required.    import ballerina/io; import ballerina/jsonutils; import ballerina/time; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });    JDBC Client for MySQL database. This client can be used with any JDBC  supported database by providing the corresponding JDBC URL.   type Student record {  int id;  int age;  string name;  time:Time insertedTime; };    This is the type created to represent a data row.   public function main() {    io:println(\"The update operation - Creating a table\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), insertedTime TIMESTAMP DEFAULT \" +  \"CURRENT_TIMESTAMP, PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");    Create a table using the update remote function. If the DDL  statement execution is successful, the update remote function  returns 0.   io:println(\"\\nThe update operation - Inserting data to a table\");  ret = testDB->update(\"INSERT INTO student(age, name) values \" +  \"(23, 'john')\");  handleUpdate(ret, \"Insert to student table with no parameters\");    Insert data to the table using the update remote function. If the DML  statement execution is successful, the update remote function returns  the updated row count. The query parameters are given in the query  statement itself.   int age = 24;  string name = \"Anne\";  ret = testDB->update(\"INSERT INTO student(age, name) values (?, ?)\",  age, name);  handleUpdate(ret, \"Insert to student table with variable parameters\");    The query parameters are given as variables for the update remote  function. Only int, float, decimal, boolean, string and  byte[] values are supported as direct variables any remote function  of the java.jdbc module.   jdbc:Parameter p1 = {sqlType: jdbc:TYPE_INTEGER, value: 25};  jdbc:Parameter p2 = {sqlType: jdbc:TYPE_VARCHAR, value: \"James\"};  jdbc:Parameter p3 = {  sqlType: jdbc:TYPE_TIMESTAMP,  value: time:currentTime()  };  ret = testDB->update(\"INSERT INTO student(age, name, insertedTime) \" +  \"values (?, ?, ?)\", p1, p2, p3);  handleUpdate(ret, \"Insert to student table with jdbc:parameter values\");    The query parameters can be given as arguments of the type  jdbc:Parameter for the any remote function. This is useful if  we want to set the SQL type explicitly or for the parameter types  other than int, float, decimal, boolean, string or  byte[] (e.g. time). Default direction is IN.   io:println(\"\\nThe Update operation - Update data in a table\");  ret = testDB->update(\"UPDATE student SET name = 'jane' WHERE age = ?\", 23);  handleUpdate(ret, \"Update a row in student table\");    Update data in the table using the update remote function.   io:println(\"\\nThe Update operation - Delete data from table\");  ret = testDB->update(\"DELETE FROM student WHERE age = ?\", 24);  handleUpdate(ret, \"Delete a row from student table\");    Delete data in a table using the update remote function.   io:println(\"\\nThe Update operation - Inserting data\");  var retWithKey = testDB->update(\"INSERT INTO student \" +  \"(age, name) values (?, ?)\", 31, \"Kate\");  if (retWithKey is jdbc:UpdateResult) {  io:println(\"Inserted row count: \", retWithKey.updatedRowCount);  io:println(\"Generated key: \",  <int>retWithKey.generatedKeys[\"GENERATED_KEY\"]);  } else {  io:println(\"Insert failed: \", <string>retWithKey.detail()?.message);  }    The column values generated during the update can be retrieved using the  update remote function. If the table has several auto-generated  columns other than the auto-incremented key, those column names  should be given as an array. The values of the auto-incremented  column and the auto-generated columns are returned as a string array.  Similar to the update remote function, the inserted row count is also  returned.   io:println(\"\\nThe select operation - Select data from a table\");  var selectRet = testDB->select(\"SELECT * FROM student where age < ?\",  Student, 35);  if (selectRet is table<record{}>) {    Select data using the select remote function. The select remote  function returns a table.   json jsonConversionRet = jsonutils:fromTable(selectRet);  io:println(\"JSON: \", jsonConversionRet.toJsonString());  } else {  io:println(\"Select data from student table failed: \",  <string>selectRet.detail()?.message);  }    table can be converted to either json or xml. The actual  conversion happens on-demand. When a service client makes a request,  the result is streamed to the service instead of building the full  result in the server and returning it. This allows unlimited payload  sizes in the result and the response is instantaneous to the client.   io:println(\"\\nThe update operation - Drop the student table\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); }    Drop the table and procedures.   function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   # At the command line, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command. $ ballerina run jdbc_client_crud_operations.bal The update operation - Creating a table Create student table status: 0    The update operation - Inserting data to a table Insert to student table with no parameters status: 1 Insert to student table with variable parameters status: 1 Insert to student table with jdbc:parameter values status: 1    The Update operation - Update data in a table Update a row in student table status: 1    The Update operation - Delete data from table Delete a row from student table status: 1    The Update operation - Inserting data Inserted row count: 1 Generated key: 4    The select operation - Select data from a table JSON: [{\"id\":1, \"age\":23, \"name\":\"jane\", \"insertedTime\":\"2019-12-10 17:07:35.0\"}, {\"id\":3, \"age\":25, \"name\":\"James\", \"insertedTime\":\"2019-12-10 17:07:36.0\"}, {\"id\":4, \"age\":31, \"name\":\"Kate\", \"insertedTime\":\"2019-12-10 17:07:35.0\"}]    The update operation - Drop the student table Drop table student status: 0"},{"page":"/learn/by-example/jdbc2-complex-type-queries.html","name":"JDBC Query with Complex Types","summary":"This example demonstrates how to use the JDBC client with complex data types\n such as arrays, binary, blobs, clob, and date/time fields. Note that the\n relevant database  driver JAR should be placed in the\n BALLERINA_HOME/bre/lib folder. However, this sample is based on an H2\n database and the H2 database ...","content":"/  /  / JDBC Query with Complex Types  import ballerina/io; import ballerina/java.jdbc; import ballerina/sql; import ballerina/time;type BinaryType record {|  int row_id;  byte[] blob_type;  string clob_type;  byte[] binary_type; |};type ArrayType record {|  int row_id;  int[] int_array;  int[] long_array;  decimal[] float_array;  float[] double_array;  boolean[] boolean_array;  string[] string_array; |};type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Time timestamp_type;  string datetime_type; |};function queryBinaryType(jdbc:Client jdbcClient) {  io:println(\"------ Query Binary Type -------\");  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from BINARY_TYPES\"); io:println(\"Result 1:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  resultStream = jdbcClient->query(\"Select * from BINARY_TYPES\", BinaryType);  stream<BinaryType, sql:Error> binaryResultStream  = <stream<BinaryType, sql:Error>>resultStream; io:println(\"Result 2:\");  e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }function queryArrayType(jdbc:Client jdbcClient) {  io:println(\"------ Query Array Type -------\");  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from ARRAY_TYPES\"); io:println(\"Result 1:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  resultStream = jdbcClient->query(\"Select * from ARRAY_TYPES\", ArrayType);  stream<ArrayType, sql:Error> arrayResultStream =  <stream<ArrayType, sql:Error>>resultStream; io:println(\"Result 2:\");  e = arrayResultStream.forEach(function(ArrayType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }function queryDateTimeType(jdbc:Client jdbcClient) {  io:println(\"------ Query Date Time Type -------\");  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from DATE_TIME_TYPES\"); io:println(\"Result 1:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  resultStream = jdbcClient->query(\"Select * from DATE_TIME_TYPES\",  DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream; io:println(\"Result 2:\");  e = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); } function initializeTable(jdbc:Client jdbcClient) returns sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS BINARY_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE BINARY_TYPES (row_id \" +  \"INTEGER NOT NULL, blob_type BLOB(1024), clob_type CLOB(1024),\" +  \"binary_type BINARY(27), PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"INSERT INTO BINARY_TYPES (row_id,\" +  \"blob_type, clob_type, binary_type) VALUES (1, \" +  \"X'77736F322062616C6C6572696E6120626C6F6220746573742E', CONVERT\" +  \"('very long text', CLOB),\" +  \"X'77736F322062616C6C6572696E612062696E61727920746573742E')\"); result = check jdbcClient->execute(\"DROP TABLE IF EXISTS ARRAY_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE ARRAY_TYPES (row_id \" +  \"INTEGER NOT NULL, int_array ARRAY, long_array ARRAY,float_array \" +  \"ARRAY, double_array ARRAY, boolean_array ARRAY, string_array ARRAY,\" +  \"PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"INSERT INTO ARRAY_TYPES (row_id, \" +  \"int_array, long_array, float_array, double_array, boolean_array, \" +  \"string_array) VALUES (1, (1, 2, 3), (100000000, 200000000, \" +  \"300000000), (245.23, 5559.49, 8796.123), (245.23, 5559.49, \" +  \"8796.123), (TRUE, FALSE, TRUE), ('Hello', 'Ballerina'))\"); result = check jdbcClient->execute(\"DROP TABLE IF EXISTS DATE_TIME_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE DATE_TIME_TYPES(row_id \" +  \" INTEGER NOT NULL, date_type DATE, time_type TIME, timestamp_type \" +  \"timestamp, datetime_type datetime, PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"Insert into DATE_TIME_TYPES (row_id,\" +  \" date_type, time_type, timestamp_type, datetime_type) values (1,\" +  \"'2017-05-23','14:15:23','2017-01-25 16:33:55','2017-01-25 16:33:55')\"); }public function main() {  jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/DATA_TYPES\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  sql:Error? err = initializeTable(jdbcClient);  if (err is sql:Error) {  io:println(\"Sample data table initialization failed: \", err);  } else {  queryBinaryType(jdbcClient);  queryArrayType(jdbcClient);  queryDateTimeType(jdbcClient);  io:println(\"Sample executed successfully!\");  }  sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed: \", jdbcClient);  } }    JDBC Query with Complex Types  This example demonstrates how to use the JDBC client with complex data types  such as arrays, binary, blobs, clob, and date/time fields. Note that the  relevant database driver JAR should be placed in the  BALLERINA_HOME/bre/lib folder. However, this sample is based on an H2  database and the H2 database driver JAR is included by default in the  Ballerina distribution. Therefore, it is not required to copy the driver JAR  for the H2 database.    import ballerina/io; import ballerina/java.jdbc; import ballerina/sql; import ballerina/time;    type BinaryType record {|  int row_id;  byte[] blob_type;  string clob_type;  byte[] binary_type; |};    type ArrayType record {|  int row_id;  int[] int_array;  int[] long_array;  decimal[] float_array;  float[] double_array;  boolean[] boolean_array;  string[] string_array; |};    type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Time timestamp_type;  string datetime_type; |};    function queryBinaryType(jdbc:Client jdbcClient) {  io:println(\"------ Query Binary Type -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from BINARY_TYPES\");    Select the rows with binary data types.  The name and type of the attributes within the record from the  resultStream will be automatically identified based on the column  name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = jdbcClient->query(\"Select * from BINARY_TYPES\", BinaryType);  stream<BinaryType, sql:Error> binaryResultStream  = <stream<BinaryType, sql:Error>>resultStream;    Since the rowType is provided as a BinaryType, the resultStream will  have BinaryType records.   io:println(\"Result 2:\");    e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the binaryResultStream.   function queryArrayType(jdbc:Client jdbcClient) {  io:println(\"------ Query Array Type -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from ARRAY_TYPES\");    Select the rows with array data types.  The name and type of the attributes within the record from the resultStream will be automatically identified based on the column  name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = jdbcClient->query(\"Select * from ARRAY_TYPES\", ArrayType);  stream<ArrayType, sql:Error> arrayResultStream =  <stream<ArrayType, sql:Error>>resultStream;    Since the rowType is provided as an ArrayType, the resultStream will  have ArrayType records.   io:println(\"Result 2:\");    e = arrayResultStream.forEach(function(ArrayType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the arrayResultStream.   function queryDateTimeType(jdbc:Client jdbcClient) {  io:println(\"------ Query Date Time Type -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from DATE_TIME_TYPES\");    Select the rows with date/time data types.  The name and type of the attributes within the record from  the resultStream will be automatically identified based on the  column name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = jdbcClient->query(\"Select * from DATE_TIME_TYPES\",  DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream;    Since the rowType is provided as a DateTimeType, the resultStream  will have DateTimeType records. The Date, Time, DateTime, and  Timestamp fields of the database table can be mapped to time:Time,  string, and int types in Ballerina.   io:println(\"Result 2:\");    e = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the dateResultStream.   function initializeTable(jdbc:Client jdbcClient) returns sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS BINARY_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE BINARY_TYPES (row_id \" +  \"INTEGER NOT NULL, blob_type BLOB(1024), clob_type CLOB(1024),\" +  \"binary_type BINARY(27), PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"INSERT INTO BINARY_TYPES (row_id,\" +  \"blob_type, clob_type, binary_type) VALUES (1, \" +  \"X'77736F322062616C6C6572696E6120626C6F6220746573742E', CONVERT\" +  \"('very long text', CLOB),\" +  \"X'77736F322062616C6C6572696E612062696E61727920746573742E')\");    Initialize the database table with sample data.   result = check jdbcClient->execute(\"DROP TABLE IF EXISTS ARRAY_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE ARRAY_TYPES (row_id \" +  \"INTEGER NOT NULL, int_array ARRAY, long_array ARRAY,float_array \" +  \"ARRAY, double_array ARRAY, boolean_array ARRAY, string_array ARRAY,\" +  \"PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"INSERT INTO ARRAY_TYPES (row_id, \" +  \"int_array, long_array, float_array, double_array, boolean_array, \" +  \"string_array) VALUES (1, (1, 2, 3), (100000000, 200000000, \" +  \"300000000), (245.23, 5559.49, 8796.123), (245.23, 5559.49, \" +  \"8796.123), (TRUE, FALSE, TRUE), ('Hello', 'Ballerina'))\");    result = check jdbcClient->execute(\"DROP TABLE IF EXISTS DATE_TIME_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE DATE_TIME_TYPES(row_id \" +  \" INTEGER NOT NULL, date_type DATE, time_type TIME, timestamp_type \" +  \"timestamp, datetime_type datetime, PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"Insert into DATE_TIME_TYPES (row_id,\" +  \" date_type, time_type, timestamp_type, datetime_type) values (1,\" +  \"'2017-05-23','14:15:23','2017-01-25 16:33:55','2017-01-25 16:33:55')\"); }    public function main() {    jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/DATA_TYPES\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  sql:Error? err = initializeTable(jdbcClient);  if (err is sql:Error) {  io:println(\"Sample data table initialization failed: \", err);  } else {    Initialize the JDBC client.   queryBinaryType(jdbcClient);  queryArrayType(jdbcClient);  queryDateTimeType(jdbcClient);  io:println(\"Sample executed successfully!\");  }    Execute the complex data type queries.   sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed: \", jdbcClient);  } }    Close the JDBC client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run jdbc2_complex_type_queries.bal    ------ Query Binary Type ------- Result 1: ROW_ID=1 BLOB_TYPE=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 108 111 98 32 116 101 115 116 46 CLOB_TYPE=very long text BINARY_TYPE=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 105 110 97 114 121 32 116 101 115 116 46 Result 2: row_id=1 blob_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 108 111 98 32 116 101 115 116 46 clob_type=very long text binary_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 105 110 97 114 121 32 116 101 115 116 46 ------ ********* ------- ------ Query Array Type ------- Result 1: ROW_ID=1 INT_ARRAY=1 2 3 LONG_ARRAY=100000000 200000000 300000000 FLOAT_ARRAY=245.23 5559.49 8796.123 DOUBLE_ARRAY=245.23 5559.49 8796.123 BOOLEAN_ARRAY=true false true STRING_ARRAY=Hello Ballerina Result 2: row_id=1 int_array=1 2 3 long_array=100000000 200000000 300000000 float_array=245.23 5559.49 8796.123 double_array=245.23 5559.49 8796.123 boolean_array=true false true string_array=Hello Ballerina ------ ********* ------- ------ Query Date Time Type ------- Result 1: ROW_ID=1 DATE_TYPE=2017-05-23+05:30 TIME_TYPE=19:45:23.000+05:30 TIMESTAMP_TYPE=2017-01-25T22:03:55.000+05:30 DATETIME_TYPE=2017-01-25T22:03:55.000+05:30 Result 2: row_id=1 date_type=2017-05-23+05:30 time_type=51323000 timestamp_type=time=1485362035000 zone=id=UTC offset=0 datetime_type=2017-01-25T22:03:55.000+05:30 ------ ********* ------- Sample executed successfully!"},{"page":"/learn/by-example/jdbc-streaming-big-dataset.html","name":"Streaming a Big Dataset","summary":"Ballerina inherently supports streaming large datasets. For example,\n retrieving a large amount of data, converting it to a preferred data format\n (e.g., JSON, XML) and sending it across the network on HTTP, does not require loading\n the entire dataset to memory at once. Data is fetched on demand from the ...","content":"/  /  / Streaming a Big Dataset  import ballerina/http; import ballerina/jsonutils; import ballerina/log; import ballerinax/java.jdbc; jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} }); service dataService on new http:Listener(9090) { resource function getData(http:Caller caller, http:Request req) {  http:Response res = new;  var selectRet = testDB->select(\"SELECT * FROM Data\", ());  if (selectRet is table<record {}>) {  json jsonConversionRet = jsonutils:fromTable(selectRet);  res.setPayload(<@untainted>jsonConversionRet);  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  res.setPayload({\"Error\": \"Error occured while retrieving data \" +  \"from the database\"  });  }  var respondRet = caller->respond(res);  if (respondRet is error) {  log:printError(\"Sending response failed\", respondRet);  }  } }import ballerina/io; import ballerinax/java.jdbc;public function main() {  jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false}  });  var ret = testDB->update(\"CREATE TABLE Data (id INT, field1 \" +  \"VARCHAR(1024), field2 VARCHAR(1024));\");  handleUpdate(ret, \"Create Data table\");  ret = testDB->update(\"CREATE PROCEDURE PopulateData(IN row_count INT) \" +  \"BEGIN \" +  \"DECLARE count INT; \" +  \"DECLARE strDataEntry VARCHAR(1024); \" +  \"SET count = 1; \" +  \"SET strDataEntry = ''; \" +  \"WHILE count <= 1024 DO \" +  \"SET strDataEntry = CONCAT(strDataEntry, 'x'); \" +  \"SET count = count + 1; \" +  \"END WHILE; \" +  \"SET count = 1; \" +  \"WHILE count <= row_count DO \" +  \"INSERT INTO Data VALUES (count, strDataEntry, strDataEntry); \" +  \"SET count = count + 1; \" +  \"END WHILE; \" +  \"SELECT strDataEntry; \" +  \"END\");  handleUpdate(ret, \"Stored procedure with IN param creation\");  var retCall = testDB->call(\"CALL PopulateData(?)\", (), 100000);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation is successful\");  } } function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Streaming a Big Dataset  Ballerina inherently supports streaming large datasets. For example,  retrieving a large amount of data, converting it to a preferred data format  (e.g., JSON, XML) and sending it across the network on HTTP, does not require loading  the entire dataset to memory at once. Data is fetched on demand from the database  and incrementally converted to JSON/XML and sent to the client.  This example demonstrates streaming a large amount of data through an HTTP service.  Please run data_setup.bal file to setup a database with sufficient amount of data.  It creates a sample database with a table that contains an id field,  and two text fields each having 1KB of data. Here, the row_count parameter of the  PopulateData stored procedure is set to 100000, which would add up to around 200MB  of textual data. You can increase the value of row_count parameter to increase the  amount of data.    import ballerina/http; import ballerina/jsonutils; import ballerina/log; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });    JDBC Client for MySQL database. This client can be used with any JDBC  supported database by providing the corresponding JDBC URL.   service dataService on new http:Listener(9090) {    Create an HTTP service and bind it to a listener on port 9090.   resource function getData(http:Caller caller, http:Request req) {  http:Response res = new;    var selectRet = testDB->select(\"SELECT * FROM Data\", ());  if (selectRet is table<record {}>) {    Invoke select remote function on the MySQL database client  and obtain a large amount of data.   json jsonConversionRet = jsonutils:fromTable(selectRet);    Convert the obtained data to json. Note that this conversion  does not load all the data into memory.  The table can be converted to xml in a similar manner.   res.setPayload(<@untainted>jsonConversionRet);  } else {    Set the json payload to the response. This is streamed  to the client once the service is invoked.   res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  res.setPayload({\"Error\": \"Error occured while retrieving data \" +  \"from the database\"  });  }    Set a payload indicating an error in case the data retrieval  fails.   var respondRet = caller->respond(res);  if (respondRet is error) {  log:printError(\"Sending response failed\", respondRet);  }  } }    Respond to the client.   # At the command line, navigate to the directory that contains the # `.bal` files and run the `ballerina run` command. $ ballerina run data_setup.bal $ ballerina run big_data_service.bal    $ curl http://localhost:9090/dataService/getData > /tmp/response-data.txt  % Total % Received % Xferd Average Speed Time Time Time Current  Dload Upload Total Spent Left Speed 100 199M 0 199M 0 0 90.0M 0 --:--:-- 0:00:02 --:--:-- 90.0M    import ballerina/io; import ballerinax/java.jdbc;    public function main() {  jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false}  });    var ret = testDB->update(\"CREATE TABLE Data (id INT, field1 \" +  \"VARCHAR(1024), field2 VARCHAR(1024));\");  handleUpdate(ret, \"Create Data table\");    Create a table for data insertion.   ret = testDB->update(\"CREATE PROCEDURE PopulateData(IN row_count INT) \" +  \"BEGIN \" +  \"DECLARE count INT; \" +  \"DECLARE strDataEntry VARCHAR(1024); \" +  \"SET count = 1; \" +  \"SET strDataEntry = ''; \" +  \"WHILE count <= 1024 DO \" +  \"SET strDataEntry = CONCAT(strDataEntry, 'x'); \" +  \"SET count = count + 1; \" +  \"END WHILE; \" +  \"SET count = 1; \" +  \"WHILE count <= row_count DO \" +  \"INSERT INTO Data VALUES (count, strDataEntry, strDataEntry); \" +  \"SET count = count + 1; \" +  \"END WHILE; \" +  \"SELECT strDataEntry; \" +  \"END\");  handleUpdate(ret, \"Stored procedure with IN param creation\");    Create the stored procedure with row_count IN parameter.   var retCall = testDB->call(\"CALL PopulateData(?)\", (), 100000);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation is successful\");  } }    Call stored procedure. This inserts around 200MB of textual data.  You can increment the row_count to increase the amount of data.   function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function."},{"page":"/learn/by-example/jdbc2-execute-operation.html","name":"JDBC DDL and DML Operations","summary":"This example demonstrates how to use the JDBC client with DDL and\n DML operations. Note that the relevant database driver JAR\n should be placed in the BALLERINA_HOME/bre/lib folder. However, this sample\n is based on an H2 database and the H2 database driver JAR is included by\n default into the Ballerina ...","content":"/  /  / JDBC DDL and DML Operations  import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;function initializeTable(jdbc:Client jdbcClient) returns int|string|sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS Customers\");  if (result is sql:ExecuteResult) {  io:println(\"Drop table executed. \", result);  }  result = check jdbcClient->execute(\"CREATE TABLE IF NOT EXISTS Customers\" +  \"(customerId INTEGER NOT NULL IDENTITY, firstName VARCHAR(300), \" +  \"lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE, \" +  \"country VARCHAR(300), PRIMARY KEY (customerId))\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName, \" +  \"lastName,registrationID,creditLimit,country)\" +  \"VALUES ('Peter', 'Stuart', 1, 5000.75, 'USA')\"); if (result is sql:ExecuteResult) {  io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId);  return result.lastInsertId;  } }function updateRecord(jdbc:Client jdbcClient, int generatedId) {  sql:ExecuteResult|sql:Error? result =  jdbcClient->execute(\"Update Customers set creditLimit = 15000.5 \" +  \"where customerId = \" + generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Updated Row count: \", result?.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occurred: \", result);  } else {  io:println(\"Empty result\");  } }function deleteRecord(jdbc:Client jdbcClient, int generatedId) {  sql:ExecuteResult|sql:Error? result =  jdbcClient->execute(\"Delete from Customers where customerId = \" +  generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Deleted Row count: \", result.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }public function main() {  jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/customers\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  int|string|sql:Error? initResult = initializeTable(jdbcClient);  if (initResult is int) {  updateRecord(jdbcClient, initResult);  deleteRecord(jdbcClient, initResult);  io:println(\"Sample executed successfully!\");  } else if (initResult is sql:Error) {  io:println(\"Customer table initialization failed: \", initResult);  }  sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed!!\");  io:println(jdbcClient);  } }    JDBC DDL and DML Operations  This example demonstrates how to use the JDBC client with DDL and  DML operations. Note that the relevant database driver JAR  should be placed in the BALLERINA_HOME/bre/lib folder. However, this sample  is based on an H2 database and the H2 database driver JAR is included by  default into the Ballerina distribution. Therefore, it is not required to  copy the driver JAR for H2 databases.    import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;    function initializeTable(jdbc:Client jdbcClient) returns int|string|sql:Error? {    sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS Customers\");  if (result is sql:ExecuteResult) {  io:println(\"Drop table executed. \", result);  }    Execute dropping the table. The sql:ExecuteResult is returned upon  successful execution. An error will be returned in case of a failure.   result = check jdbcClient->execute(\"CREATE TABLE IF NOT EXISTS Customers\" +  \"(customerId INTEGER NOT NULL IDENTITY, firstName VARCHAR(300), \" +  \"lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE, \" +  \"country VARCHAR(300), PRIMARY KEY (customerId))\");    Similarly, to drop a table, the create table query is executed.  Here, the customerId is an auto-generated column.   result = check jdbcClient->execute(\"INSERT INTO Customers (firstName, \" +  \"lastName,registrationID,creditLimit,country)\" +  \"VALUES ('Peter', 'Stuart', 1, 5000.75, 'USA')\");    Insert sample data into the table. The result will have  affectedRowCount and lastInsertedId with the auto-generated ID of  the last row.   if (result is sql:ExecuteResult) {  io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId);  return result.lastInsertId;  } }    function updateRecord(jdbc:Client jdbcClient, int generatedId) {    sql:ExecuteResult|sql:Error? result =  jdbcClient->execute(\"Update Customers set creditLimit = 15000.5 \" +  \"where customerId = \" + generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Updated Row count: \", result?.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occurred: \", result);  } else {  io:println(\"Empty result\");  } }    Update the record with the auto-generated ID.   function deleteRecord(jdbc:Client jdbcClient, int generatedId) {    sql:ExecuteResult|sql:Error? result =  jdbcClient->execute(\"Delete from Customers where customerId = \" +  generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Deleted Row count: \", result.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }    Delete the record with the auto-generated ID.   public function main() {    jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/customers\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {    Initialize the JDBC client.   int|string|sql:Error? initResult = initializeTable(jdbcClient);  if (initResult is int) {    Initialize a table and insert sample data.   updateRecord(jdbcClient, initResult);    Update a record.   deleteRecord(jdbcClient, initResult);  io:println(\"Sample executed successfully!\");  } else if (initResult is sql:Error) {  io:println(\"Customer table initialization failed: \", initResult);  }    Delete a record.   sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed!!\");  io:println(jdbcClient);  } }    Close the JDBC client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run jdbc2_execute_operation.bal    Drop table executed. affectedRowCount=0 lastInsertId= Rows affected: 1 Generated Customer ID: 1 Updated Row count: 1 Deleted Row count: 1 Sample executed successfully!"},{"page":"/learn/by-example/jdbc2-init-options.html","name":"JDBC Client Initialization","summary":"This example demonstrates how to initialize the JDBC client with different\n initialization options. Note that, the relevant database driver JAR\n should be placed in the BALLERINA_HOME/bre/lib folder. However, this sample\n is based on an H2 database and the H2 database driver JAR is included by\n default in the Ballerina distribution. ...","content":"/  /  / JDBC Client Initialization  import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;function initializeClients() returns sql:Error? {  jdbc:Client jdbcClient1 = check new (\"jdbc:h2:file:./target/sample1\");  io:println(\"Simple JDBC client created.\");  jdbc:Client jdbcClient2 = check new (\"jdbc:h2:file:./target/sample2\",  \"rootUser\", \"rootPass\");  io:println(\"JDBC client with user/password created.\");  jdbc:Options h2Options = {  datasourceName: \"org.h2.jdbcx.JdbcDataSource\",  properties: {\"loginTimeout\": \"2000\"}  };  jdbc:Client jdbcClient3 = check new (\"jdbc:h2:file:./target/sample3\",  \"rootUser\", \"rootPass\", h2Options);  io:println(\"JDBC client with database options created.\");  sql:ConnectionPool connPool = {  maxOpenConnections: 5,  maxConnectionLifeTimeInSeconds: 2000.0,  minIdleConnections: 5  };  jdbc:Client jdbcClient4 = check new (\"jdbc:h2:file:./target/sample4\",  \"rootUser\", \"rootPass\", h2Options, connPool);  io:println(\"JDBC client with connection pool created.\");  jdbc:Client jdbcClient5 = check new (url = \"jdbc:h2:file:./target/sample5\",  user = \"rootUser\", password = \"rootPass\", options = h2Options,  connectionPool = connPool);  jdbc:Client jdbcClient6 = check new (url = \"jdbc:h2:file:./target/sample6\",  connectionPool = connPool);  io:println(\"JDBC client with optional params created.\");  check jdbcClient1.close();  check jdbcClient2.close();  check jdbcClient3.close();  check jdbcClient4.close();  check jdbcClient5.close();  check jdbcClient6.close(); } public function main() {  sql:Error? err = initializeClients();  if (err is sql:Error) {  io:println(\"Error occured, initialization failed!\", err);  } else {  io:println(\"Sample executed successfully!\");  } }    JDBC Client Initialization  This example demonstrates how to initialize the JDBC client with different  initialization options. Note that, the relevant database driver JAR  should be placed in the BALLERINA_HOME/bre/lib folder. However, this sample  is based on an H2 database and the H2 database driver JAR is included by  default in the Ballerina distribution. Therefore, it is not required to copy  the driver JAR for H2 databases.    import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;    function initializeClients() returns sql:Error? {    jdbc:Client jdbcClient1 = check new (\"jdbc:h2:file:./target/sample1\");  io:println(\"Simple JDBC client created.\");    This is a simple JDBC Client for an H2 database with the mandatory  field - JDBC URL. This client can be used with any database  by providing the corresponding JDBC URL and placing the relevant database  driver JAR.   jdbc:Client jdbcClient2 = check new (\"jdbc:h2:file:./target/sample2\",  \"rootUser\", \"rootPass\");  io:println(\"JDBC client with user/password created.\");    Initialize the JDBC client along by providing the username and password.   jdbc:Options h2Options = {  datasourceName: \"org.h2.jdbcx.JdbcDataSource\",  properties: {\"loginTimeout\": \"2000\"}  };  jdbc:Client jdbcClient3 = check new (\"jdbc:h2:file:./target/sample3\",  \"rootUser\", \"rootPass\", h2Options);  io:println(\"JDBC client with database options created.\");    Initialize the JDBC client by providing additional  database properties. The database properties can differ based  on the specific JDBC datasource implementation of the database.   sql:ConnectionPool connPool = {    Connection pool is used to share and use the connections  to the database efficiently. In the above samples, the global  connection pool is created and shared  among all the database clients since the connectionPool property  is not set.   maxOpenConnections: 5,    Default max number of open connections in the connection pool is 15.   maxConnectionLifeTimeInSeconds: 2000.0,    Default max life time of a connection in the connection pool is  1800 seconds (30 minutes).   minIdleConnections: 5  };    Default minimum number of idle connections is 15.   jdbc:Client jdbcClient4 = check new (\"jdbc:h2:file:./target/sample4\",  \"rootUser\", \"rootPass\", h2Options, connPool);  io:println(\"JDBC client with connection pool created.\");    Initialize the JDBC client with the specific connection pool.   jdbc:Client jdbcClient5 = check new (url = \"jdbc:h2:file:./target/sample5\",  user = \"rootUser\", password = \"rootPass\", options = h2Options,  connectionPool = connPool);    Other than the JDBC URL, all other properties are optional.  Hence, named attributes can be used specifically to assign  the attributes.   jdbc:Client jdbcClient6 = check new (url = \"jdbc:h2:file:./target/sample6\",  connectionPool = connPool);  io:println(\"JDBC client with optional params created.\");    Initialize JDBC Client only with the URL and connection pool.   check jdbcClient1.close();  check jdbcClient2.close();  check jdbcClient3.close();  check jdbcClient4.close();  check jdbcClient5.close();  check jdbcClient6.close(); }    Close the clients to release the resource  and destroy the connection pool.   public function main() {  sql:Error? err = initializeClients();  if (err is sql:Error) {  io:println(\"Error occured, initialization failed!\", err);  } else {  io:println(\"Sample executed successfully!\");  } }    Initialize JDBC clients with different options.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run jdbc2_init_options.bal    Simple JDBC client created. JDBC client with user/password created. JDBC client with database options created. JDBC client with connection pool created. JDBC client with optional params created. Sample executed successfully!"},{"page":"/learn/by-example/jdbc2-query-operation.html","name":"JDBC Select Query Operations","summary":"This example demonstrates how to use the JDBC client select query operations\n with the stream return type. Note that the relevant database driver JAR\n should be placed in the BALLERINA_HOME/bre/lib folder. However, this sample\n is based on an H2 database and the H2 database driver JAR is included by\n default ...","content":"/  /  / JDBC Select Query Operations  import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;function simpleQuery(jdbc:Client jdbcClient) {  io:println(\"------ Start Simple Query -------\");  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from Customers\");  error? e = resultStream.forEach(function(record {} result) {  io:println(\"Full Customer details: \", result);  io:println(\"Customer first name: \", result[\"FIRSTNAME\"]);  io:println(\"Customer last name: \", result[\"LASTNAME\"]);  });  if (e is error) {  io:println(\"ForEach operation on the stream failed!\");  io:println(e);  }  e = resultStream.close();  io:println(\"------ End Simple Query -------\"); }function countRows(jdbc:Client jdbcClient) {  io:println(\"------ Start Count Total Rows -------\");  stream<record{}, error> resultStream =  jdbcClient->query(\"Select count(*) as total from Customers\");  record {|record {} value;|}|error? result = resultStream.next();  if (result is record {|record {} value;|}) {  io:println(\"Total rows in customer table : \", result.value[\"TOTAL\"]);  } else if (result is error) {  io:println(\"Next operation on the stream failed. \", result);  } else {  io:println(\"Customer table is empty\");  }  error? e = resultStream.close();  io:println(\"------ End Count Total Rows -------\"); } type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};function typedQuery(jdbc:Client jdbcClient) {  io:println(\"------ Start Query With Type Description -------\");  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from Customers\", Customer);  stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream;  error? e = customerStream.forEach(function(Customer customer) {  io:println(customer);  });  if (e is error) {  io:println(e);  }  e = resultStream.close();  io:println(\"------ End Query With Type Description -------\"); } function initializeTable(jdbc:Client jdbcClient) returns sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS Customers\");  result = check jdbcClient->execute(\"CREATE TABLE IF NOT EXISTS Customers(\" +  \"customerId INTEGER NOT NULL IDENTITY, firstName VARCHAR(300),\" +  \"lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE,\" +  \"country VARCHAR(300), PRIMARY KEY (customerId))\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName,\" +  \"lastName,registrationID,creditLimit,country) VALUES ('Peter', \" +  \"'Stuart', 1, 5000.75, 'USA')\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName, \" +  \"lastName,registrationID,creditLimit,country) VALUES ('Dan', 'Brown',\" +  \"2, 10000, 'UK')\"); }public function main() {  jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/customers\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  sql:Error? err = initializeTable(jdbcClient);  if (err is sql:Error) {  io:println(\"Customer table initialization failed!\", err);  } else {  simpleQuery(jdbcClient);  countRows(jdbcClient);  typedQuery(jdbcClient);  io:println(\"Queried the database successfully!\");  }  sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed!!\");  io:println(jdbcClient);  } }    JDBC Select Query Operations  This example demonstrates how to use the JDBC client select query operations  with the stream return type. Note that the relevant database driver JAR  should be placed in the BALLERINA_HOME/bre/lib folder. However, this sample  is based on an H2 database and the H2 database driver JAR is included by  default in the Ballerina distribution. Therefore, it is not required to copy  the driver JAR for H2 databases.    import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;    function simpleQuery(jdbc:Client jdbcClient) {  io:println(\"------ Start Simple Query -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from Customers\");    Select the rows in the database table via the query remote operation.  The result is returned as a stream and the elements of the stream can  be either a record or an error.   error? e = resultStream.forEach(function(record {} result) {  io:println(\"Full Customer details: \", result);  io:println(\"Customer first name: \", result[\"FIRSTNAME\"]);  io:println(\"Customer last name: \", result[\"LASTNAME\"]);  });    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   if (e is error) {  io:println(\"ForEach operation on the stream failed!\");  io:println(e);  }    Check and handle the error during the SQL query  or iteration of the result stream.   e = resultStream.close();  io:println(\"------ End Simple Query -------\"); }    In general cases, the stream will be closed automatically  when the stream is fully consumed or any error is encountered.  However, in case if the stream is not fully consumed, the stream  should be closed specifically.   function countRows(jdbc:Client jdbcClient) {  io:println(\"------ Start Count Total Rows -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select count(*) as total from Customers\");    The result of the count operation is provided as a record stream.   record {|record {} value;|}|error? result = resultStream.next();    Since the above count query will return only a single row,  the next() operation is sufficient to retrieve the data.   if (result is record {|record {} value;|}) {  io:println(\"Total rows in customer table : \", result.value[\"TOTAL\"]);  } else if (result is error) {  io:println(\"Next operation on the stream failed. \", result);  } else {  io:println(\"Customer table is empty\");  }    Check the result and retrieve the value for total.   error? e = resultStream.close();  io:println(\"------ End Count Total Rows -------\"); }    Close the stream.   type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};    Define a record to load the query result schema as shown below in the  ‘typedQuery’ function. In this example, all columns of the customer table  will be loaded. Therefore, the Customer record will be created with all  the columns. The column name of the result and the defined field name of  the record will be matched case insensitively.   function typedQuery(jdbc:Client jdbcClient) {  io:println(\"------ Start Query With Type Description -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from Customers\", Customer);    The result is returned as a Customer record stream and the elements  of the stream can be either a Customer record or an error.   stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream;    Cast the generic record type to the Customer stream type.   error? e = customerStream.forEach(function(Customer customer) {  io:println(customer);  });  if (e is error) {  io:println(e);  }    Iterate the customer stream.   e = resultStream.close();  io:println(\"------ End Query With Type Description -------\"); }    Close the stream.   function initializeTable(jdbc:Client jdbcClient) returns sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS Customers\");  result = check jdbcClient->execute(\"CREATE TABLE IF NOT EXISTS Customers(\" +  \"customerId INTEGER NOT NULL IDENTITY, firstName VARCHAR(300),\" +  \"lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE,\" +  \"country VARCHAR(300), PRIMARY KEY (customerId))\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName,\" +  \"lastName,registrationID,creditLimit,country) VALUES ('Peter', \" +  \"'Stuart', 1, 5000.75, 'USA')\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName, \" +  \"lastName,registrationID,creditLimit,country) VALUES ('Dan', 'Brown',\" +  \"2, 10000, 'UK')\"); }    Initialize the database table with sample data.   public function main() {    jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/customers\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  sql:Error? err = initializeTable(jdbcClient);  if (err is sql:Error) {  io:println(\"Customer table initialization failed!\", err);  } else {    Initialize the JDBC client.   simpleQuery(jdbcClient);  countRows(jdbcClient);  typedQuery(jdbcClient);  io:println(\"Queried the database successfully!\");  }    Execute the select queries in different options.   sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed!!\");  io:println(jdbcClient);  } }    Close the JDBC client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run jdbc2_query_operation.bal    ------ Start Simple Query ------- Full Customer details: CUSTOMERID=1 FIRSTNAME=Peter LASTNAME=Stuart REGISTRATIONID=1 CREDITLIMIT=5000.75 COUNTRY=USA Customer first name: Peter Customer last name: Stuart Full Customer details: CUSTOMERID=2 FIRSTNAME=Dan LASTNAME=Brown REGISTRATIONID=2 CREDITLIMIT=10000.0 COUNTRY=UK Customer first name: Dan Customer last name: Brown ------ End Simple Query ------- ------ Start Count Total Rows ------- Total rows in customer table : 2 ------ End Count Total Rows ------- ------ Start Query With Type Description ------- customerId=1 firstName=Peter lastName=Stuart registrationId=1 creditLimit=5000.75 country=USA customerId=2 firstName=Dan lastName=Brown registrationId=2 creditLimit=10000.0 country=UK ------ End Query With Type Description ------- Queried the database successfully!"},{"page":"/learn/by-example/json-access.html","name":"JSON Access","summary":"Ballerina defines certain types as lax types for which static typing rules are less strict.\n For example, field access (.) and optional field access (?.), which are generally allowed on\n records and objects for fields that are defined in the type descriptors, are also additionally\n allowed on lax types. For ...","content":"/  /  / JSON Access  import ballerina/io;public function main() {  json j1 = {  fname: \"Mary\",  lname: \"Jane\",  address: {  line: \"20 Palm Grove\",  city: \"Colombo 03\",  country: \"Sri Lanka\"  }  };  json|error r1 = j1.fname;  io:println(r1);  json|error r2 = j1.address.city;  io:println(r2);  json|error r3 = j1.age.year;  io:println(r3);  json|error r4 = j1?.age?.year;  io:println(r4);  json j2 = null;  json|error r5 = j2?.name;  io:println(r5); }    JSON Access  Ballerina defines certain types as lax types for which static typing rules are less strict.  For example, field access (.) and optional field access (?.), which are generally allowed on  records and objects for fields that are defined in the type descriptors, are also additionally  allowed on lax types. For such operations, some of the type checking is moved from compile time to runtime.  json is defined to be a lax type along with any map<T> where T is a lax type.    import ballerina/io;    public function main() {    json j1 = {  fname: \"Mary\",  lname: \"Jane\",  address: {  line: \"20 Palm Grove\",  city: \"Colombo 03\",  country: \"Sri Lanka\"  }  };    Define a variable of type json that holds a mapping value.   json|error r1 = j1.fname;    Field access is allowed on the json-typed variable. However, the return  type would be a union of json and error. An error will be returned  either if the value on which the access is done is not a mapping or if  it is a mapping, but it does not contain the particular key.   io:println(r1);    r1 is of type json since j1 is a mapping and contains the field fname.   json|error r2 = j1.address.city;    Similarly, chained field access is also allowed for json. If an error  is encountered at any point during the evaluation, evaluation stops at  that point and the result would be an error.   io:println(r2);    r2 is of type json since j1 is a mapping with the field address, which in  turn is a mapping with the field city, which will be the resultant value.   json|error r3 = j1.age.year;    Attempting to access a non-existent field would result in an error.   io:println(r3);    r3 is of type error since j1 does not have a field with the key age.   json|error r4 = j1?.age?.year;    Similarly, optional field access is also allowed on lax types.  The main difference between field and optional field access for lax types  is that when a key is not found in a mapping, while the former returns  an error, the latter returns null (()) instead.  Similar to how errors are lifted with field access, () is lifted  for optional field access allowing chained access.   io:println(r4);    r4 is () since j1 does not have a field with the key age.   json j2 = null;  json|error r5 = j2?.name;    Moreover, when optional field access occurs on null (()), the result would  also be (), whereas for field access it would have been an error.   io:println(r5); }    r5 is () since j2 is ().   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run json_access.bal Mary Colombo 03 error {ballerina/lang.map}KeyNotFound message=Key 'age' not found in JSON mapping"},{"page":"/learn/by-example/json-arrays.html","name":"JSON Arrays","summary":"JSON array literals are written exactly the same way as Ballerina arrays.\n JSON array values must be of the JSON types: string, number, object, array, boolean, or null.JSON Arrays are arrays with JSON values as members.\n The same could be written as\n json[] j1 = [1, false, null, \"foo\", { ...","content":"/  /  / JSON Arrays  import ballerina/io;public function main() {  json j1 = [1, false, null, \"foo\", {first: \"John\", last: \"Pala\"}];  io:println(j1.toJsonString());  json[] j2 = <json[]>j1;  json j3 = j2[4];  io:println(j3.toJsonString());  j2[4] = 8.00;  io:println(j1.toJsonString());  map<json> p = {  fname: \"John\",  lname: \"Stallone\",  family: [  {fname: \"Peter\", lname: \"Stallone\"},  {fname: \"Emma\", lname: \"Stallone\"},  {fname: \"Jena\", lname: \"Stallone\"},  {fname: \"Paul\", lname: \"Stallone\"}  ]  }; json[] family = <json[]>p[\"family\"];  map<json> member2 = <map<json>>family[2];  member2[\"fname\"] = \"Alisha\";  io:println(p.toJsonString());  int l = family.length();  io:println(\"length of the array: \", l);  int i = 0;  while (i < l) {  io:println(family[i].toJsonString());  i = i + 1;  } }    JSON Arrays  JSON array literals are written exactly the same way as Ballerina arrays.  JSON array values must be of the JSON types: string, number, object, array, boolean, or null.    import ballerina/io;    public function main() {    json j1 = [1, false, null, \"foo\", {first: \"John\", last: \"Pala\"}];  io:println(j1.toJsonString());    JSON Arrays are arrays with JSON values as members.  The same could be written as  json[] j1 = [1, false, null, \"foo\", { first: \"John\", last: \"Pala];   json[] j2 = <json[]>j1;  json j3 = j2[4];  io:println(j3.toJsonString());    JSON array elements can be accessed by index.  The json value j1 first needs to be cast to a json[] to use member access.  Alternatively, j1 could have been defined as a json[].   j2[4] = 8.00;  io:println(j1.toJsonString());    Similarly, member access could be used with json[]-typed variables to add or  change members in a json array.   map<json> p = {  fname: \"John\",  lname: \"Stallone\",  family: [  {fname: \"Peter\", lname: \"Stallone\"},  {fname: \"Emma\", lname: \"Stallone\"},  {fname: \"Jena\", lname: \"Stallone\"},  {fname: \"Paul\", lname: \"Stallone\"}  ]  };    JSON array in an object literal.   json[] family = <json[]>p[\"family\"];  map<json> member2 = <map<json>>family[2];  member2[\"fname\"] = \"Alisha\";  io:println(p.toJsonString());    int l = family.length();  io:println(\"length of the array: \", l);    Get the length of the JSON array.   int i = 0;  while (i < l) {  io:println(family[i].toJsonString());  i = i + 1;  } }    Loop through the array.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run json_arrays.bal [1, false, null, \"foo\", {\"first\":\"John\", \"last\":\"Pala\"}] {\"first\":\"John\", \"last\":\"Pala\"} [1, false, null, \"foo\", 8.0] {\"fname\":\"John\", \"lname\":\"Stallone\", \"family\":[{\"fname\":\"Peter\", \"lname\":\"Stallone\"}, {\"fname\":\"Emma\", \"lname\":\"Stallone\"}, {\"fname\":\"Alisha\", \"lname\":\"Stallone\"}, {\"fname\":\"Paul\", \"lname\":\"Stallone\"}]} length of the array: 4 {\"fname\":\"Peter\", \"lname\":\"Stallone\"} {\"fname\":\"Emma\", \"lname\":\"Stallone\"} {\"fname\":\"Alisha\", \"lname\":\"Stallone\"} {\"fname\":\"Paul\", \"lname\":\"Stallone\"}"},{"page":"/learn/by-example/json-io.html","name":"JSON I/O","summary":"This sample demonstrates how to read JSON content from a file and write JSON content\n to a file using the character channel, readJson(), and writeJson() of the I/O API.Closes a readable channel.Closes a writable channel.Writes the provided json to the specified path.Creates a writable byte channel from the given path.Derives ...","content":"/  /  / JSON I/O  import ballerina/io; import ballerina/log; function closeRc(io:ReadableCharacterChannel rc) {  var result = rc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } } function closeWc(io:WritableCharacterChannel wc) {  var result = wc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } } function write(json content, string path) returns @tainted error? {  io:WritableByteChannel wbc = check io:openWritableFile(path);  io:WritableCharacterChannel wch = new (wbc, \"UTF8\");  var result = wch.writeJson(content);  closeWc(wch);  return result; } function read(string path) returns @tainted json|error {  io:ReadableByteChannel rbc = check io:openReadableFile(path);  io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");  var result = rch.readJson();  closeRc(rch);  return result; }public function main() {  string filePath = \"./files/sample.json\";  json j1 = {  \"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };  io:println(\"Preparing to write json file\");  var wResult = write(j1, filePath);  if (wResult is error) {  log:printError(\"Error occurred while writing json: \", wResult);  } else {  io:println(\"Preparing to read the content written\");  var rResult = read(filePath);  if (rResult is error) {  log:printError(\"Error occurred while reading json: \",  err = rResult);  } else {  io:println(rResult.toJsonString());  }  } }    JSON I/O  This sample demonstrates how to read JSON content from a file and write JSON content  to a file using the character channel, readJson(), and writeJson() of the I/O API.    import ballerina/io; import ballerina/log;    function closeRc(io:ReadableCharacterChannel rc) {  var result = rc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    Closes a readable channel.   function closeWc(io:WritableCharacterChannel wc) {  var result = wc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    Closes a writable channel.   function write(json content, string path) returns @tainted error? {    Writes the provided json to the specified path.   io:WritableByteChannel wbc = check io:openWritableFile(path);    Creates a writable byte channel from the given path.   io:WritableCharacterChannel wch = new (wbc, \"UTF8\");  var result = wch.writeJson(content);  closeWc(wch);  return result; }    Derives the character channel from the byte channel.   function read(string path) returns @tainted json|error {    Reads a json value from the specified path.   io:ReadableByteChannel rbc = check io:openReadableFile(path);    Creates a readable byte channel from the given path.   io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");  var result = rch.readJson();  closeRc(rch);  return result; }    Derives the character channel from the byte channel.   public function main() {  string filePath = \"./files/sample.json\";    json j1 = {  \"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };  io:println(\"Preparing to write json file\");    Creates thejson content from the string.   var wResult = write(j1, filePath);  if (wResult is error) {  log:printError(\"Error occurred while writing json: \", wResult);  } else {  io:println(\"Preparing to read the content written\");    Writes the json content.   var rResult = read(filePath);  if (rResult is error) {  log:printError(\"Error occurred while reading json: \",  err = rResult);  } else {  io:println(rResult.toJsonString());  }  } }    Reads the json content.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run json_io.bal Preparing to write json file Preparing to read the content written {\"Store\":{\"@id\":\"AST\", \"name\":\"Anne\", \"address\":{\"street\":\"Main\", \"city\":\"94\"}, \"codes\":[\"4\", \"8\"]}}"},{"page":"/learn/by-example/json-objects.html","name":"JSON Objects","summary":"JSON objects are represented as maps of JSON in Ballerina.\n JSON object members could be of any JSON type: string, number, object, array, boolean, or null.Create a JSON object. A JSON object in Ballerina is equivalent to a map<json>.\n Thus, the same can be written as\n map<json> j = { ...","content":"/  /  / JSON Objects  import ballerina/io;public function main() {  json j = {name: \"apple\", color: \"red\", price: 100};  io:println(j.toJsonString());  io:println(\"j is map<json>: \", j is map<json>);  json empty = {}; int age = 30;  json p = {fname: \"John\", lname: \"Stallone\", \"age\": age};  io:println(p.toJsonString());  map<json> mp = <map<json>>p;  mp[\"age\"] = 31;  io:println(p.toJsonString());  map<json> p2 = {  fname: \"Peter\",  lname: \"Stallone\",  address: {  line: \"20 Palm Grove\",  city: \"Colombo 03\",  country: \"Sri Lanka\"  }  };  io:println(p2.toJsonString());  json lastName = p2[\"lname\"];  io:println(lastName); }    JSON Objects  JSON objects are represented as maps of JSON in Ballerina.  JSON object members could be of any JSON type: string, number, object, array, boolean, or null.    import ballerina/io;    public function main() {    json j = {name: \"apple\", color: \"red\", price: 100};  io:println(j.toJsonString());    Create a JSON object. A JSON object in Ballerina is equivalent to a map<json>.  Thus, the same can be written as  map<json> j = { name: \"apple\", color: \"red\", price: j2 };   io:println(\"j is map<json>: \", j is map<json>);    Since a JSON object is a map<json>, this type test evaluates to true.   json empty = {};    Create an empty JSON object. This is equivalent to an empty map<json>.   int age = 30;    json p = {fname: \"John\", lname: \"Stallone\", \"age\": age};  io:println(p.toJsonString());    Create a JSON object. Keys can be defined with or without quotes.  Values can be any json expression.   map<json> mp = <map<json>>p;  mp[\"age\"] = 31;  io:println(p.toJsonString());    You can add or change JSON object values using member access (i.e., the [expr] operator).  In order to change fields of an object value, it needs to be accessed  as a map<json>. This is done by casting p to map<json>.  Alternatively, p could have been defined as a map<json>.   map<json> p2 = {  fname: \"Peter\",  lname: \"Stallone\",  address: {  line: \"20 Palm Grove\",  city: \"Colombo 03\",  country: \"Sri Lanka\"  }  };  io:println(p2.toJsonString());    Create a nested JSON object.  This could also be defined as a json variable instead of map<json>.   json lastName = p2[\"lname\"];  io:println(lastName); }    Member access expressions with string keys can be used to access fields of a  mapping of json.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run json_objects.bal {\"name\":\"apple\", \"color\":\"red\", \"price\":100} j is map<json>: true {\"fname\":\"John\", \"lname\":\"Stallone\", \"age\":30} {\"fname\":\"John\", \"lname\":\"Stallone\", \"age\":31} {\"fname\":\"Peter\", \"lname\":\"Stallone\", \"address\":{\"line\":\"20 Palm Grove\", \"city\":\"Colombo 03\", \"country\":\"Sri Lanka\"}} Stallone"},{"page":"/learn/by-example/json-csv.html","name":"JSON to CSV Transform","summary":"This sample demonstrates how a json array can be transformed to CSV.Convert a map<json> value to an array of Strings.\n Return the result as a tuple, which contains the headers and fields.Writes json content to CSV.We ignore the result as this would mean a nil returnThe sample json, which will ...","content":"/  /  / JSON to CSV Transform  import ballerina/io; import ballerina/log; function getFields(map<json> rec) returns [string[], string[]] {  string[] fields = [];  foreach var recordField in rec {  fields[fields.length()] = recordField.toString();  }  return [rec.keys(), fields]; } function writeCsv(json[] content, string path) returns @tainted error? {  io:WritableCSVChannel csvch = check io:openWritableCsvFile(path);  int recIndex = 0;  int recLen = content.length();  while (recIndex < recLen) {  [string[], string[]] result = getFields(<map<json>>content[recIndex]);  var [headers, fields] = result;  if (recIndex == 0) {  check csvch.write(headers);  }  check csvch.write(fields);  recIndex = recIndex + 1;  } }public function main() {  json sample = {  \"employees\": {  \"employee\": [  {  \"id\": \"1\",  \"firstName\": \"Tom\",  \"lastName\": \"Cruise\",  \"photo\": \"https://ballerina-team/profile/3737.jpg\"  },  {  \"id\": \"2\",  \"firstName\": \"Maria\",  \"lastName\": \"Sharapova\",  \"photo\": \"https://ballerina-team/profile/5676.jpg\"  },  {  \"id\": \"3\",  \"firstName\": \"James\",  \"lastName\": \"Bond\",  \"photo\": \"https://ballerina-team/profile/6776.jpg\"  }  ]  }  };  string path = \"./files/sample.csv\";  var result = writeCsv(<json[]>sample.employees.employee, path);  if (result is error) {  log:printError(\"Error occurred while writing csv record :\",  err = result);  } else {  io:println(\"json record successfully transformed to a csv, file could\" +  \" be found in \" + path);  } }    JSON to CSV Transform  This sample demonstrates how a json array can be transformed to CSV.    import ballerina/io; import ballerina/log;    function getFields(map<json> rec) returns [string[], string[]] {  string[] fields = [];  foreach var recordField in rec {  fields[fields.length()] = recordField.toString();  }  return [rec.keys(), fields]; }    Convert a map<json> value to an array of Strings.  Return the result as a tuple, which contains the headers and fields.   function writeCsv(json[] content, string path) returns @tainted error? {  io:WritableCSVChannel csvch = check io:openWritableCsvFile(path);  int recIndex = 0;  int recLen = content.length();  while (recIndex < recLen) {  [string[], string[]] result = getFields(<map<json>>content[recIndex]);  var [headers, fields] = result;  if (recIndex == 0) {    Writes json content to CSV.   check csvch.write(headers);  }  check csvch.write(fields);  recIndex = recIndex + 1;  } }    We ignore the result as this would mean a nil return   public function main() {    json sample = {  \"employees\": {  \"employee\": [  {  \"id\": \"1\",  \"firstName\": \"Tom\",  \"lastName\": \"Cruise\",  \"photo\": \"https://ballerina-team/profile/3737.jpg\"  },  {  \"id\": \"2\",  \"firstName\": \"Maria\",  \"lastName\": \"Sharapova\",  \"photo\": \"https://ballerina-team/profile/5676.jpg\"  },  {  \"id\": \"3\",  \"firstName\": \"James\",  \"lastName\": \"Bond\",  \"photo\": \"https://ballerina-team/profile/6776.jpg\"  }  ]  }  };    The sample json, which will be written.   string path = \"./files/sample.csv\";    Writes JSON into a CSV.   var result = writeCsv(<json[]>sample.employees.employee, path);  if (result is error) {  log:printError(\"Error occurred while writing csv record :\",  err = result);  } else {  io:println(\"json record successfully transformed to a csv, file could\" +  \" be found in \" + path);  } }    Specifies the JSON array, which should be transformed into CSV.  Also, provides the location the CSV should be written.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run json_csv.bal json record successfully transformed to a csv, file could be found in ./files/sample.csv"},{"page":"/learn/by-example/json-record-map-conversion.html","name":"JSON/Record/Map Conversion","summary":"Ballerina records, maps, and JSON objects are used to hold records.\n Records are collections of fields and each field value is accessed by a key.\n Converting from one type to another is very useful in certain situations.This is a Ballerina record definition.This example shows how you can convert a record ...","content":"/  /  / JSON/Record/Map Conversion  import ballerina/io; type Person record {  string fname;  string lname;  int age; };type Movie record {  string title;  string year;  string released;  Person writer; };public function main() {  Movie theRevenant = {  title: \"The Revenant\",  year: \"2015\",  released: \"08 Jan 2016\",  writer: {  fname: \"Michael\",  lname: \"Punke\",  age: 30  }  };  json|error j = json.constructFrom(theRevenant);  if (j is json) {  io:println(j.toJsonString());  io:println(j.writer.lname);  }  map<anydata>|error movieMap = map<anydata>.constructFrom(theRevenant);  if (movieMap is map<anydata>) {  Person|error writer = Person.constructFrom(movieMap[\"writer\"]);  if (writer is Person) {  io:println(writer.age);  }  }  json inceptionJ = {  title: \"Inception\",  year: \"2010\",  released: \"16 Jul 2010\",  writer: {  fname: \"Christopher\",  lname: \"Nolan\",  age: 30  }  };  Movie|error inception = Movie.constructFrom(inceptionJ);  if (inception is Movie) {  io:println(inception);  } }    JSON/Record/Map Conversion  Ballerina records, maps, and JSON objects are used to hold records.  Records are collections of fields and each field value is accessed by a key.  Converting from one type to another is very useful in certain situations.    import ballerina/io;    type Person record {  string fname;  string lname;  int age; };    This is a Ballerina record definition.   type Movie record {  string title;  string year;  string released;  Person writer; };    public function main() {  Movie theRevenant = {  title: \"The Revenant\",  year: \"2015\",  released: \"08 Jan 2016\",  writer: {  fname: \"Michael\",  lname: \"Punke\",  age: 30  }  };    json|error j = json.constructFrom(theRevenant);  if (j is json) {  io:println(j.toJsonString());  io:println(j.writer.lname);  }    This example shows how you can convert a record to a JSON object.  This conversion could return an error because it may not be possible  to convert some data types that are defined in the record to JSON.   map<anydata>|error movieMap = map<anydata>.constructFrom(theRevenant);  if (movieMap is map<anydata>) {  Person|error writer = Person.constructFrom(movieMap[\"writer\"]);  if (writer is Person) {  io:println(writer.age);  }  }    Similarly, you can convert a record to a map.   json inceptionJ = {  title: \"Inception\",  year: \"2010\",  released: \"16 Jul 2010\",  writer: {  fname: \"Christopher\",  lname: \"Nolan\",  age: 30  }  };  Movie|error inception = Movie.constructFrom(inceptionJ);  if (inception is Movie) {  io:println(inception);  } }    This example shows how you can convert a JSON object to a record.  This conversion could return an error because the field names and  types are unknown until they are evaluated at runtime.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run json_record_map_conversion.bal {\"title\":\"The Revenant\", \"year\":\"2015\", \"released\":\"08 Jan 2016\", \"writer\":{\"fname\":\"Michael\", \"lname\":\"Punke\", \"age\":30}} Punke 30 title=Inception year=2010 released=16 Jul 2010 writer=fname=Christopher lname=Nolan age=30"},{"page":"/learn/by-example/jwt-issue-validate.html","name":"JWT Issue/Validate","summary":"This example demonstrates how to issue and validate a JWT.Defines the keystore.Defines the JWT keystore configurations.Defines the JWT header and sets the values.Defines the JWT payload and sets the values.Issues a JWT based on the provided header, payload and config.Defines the truststore.Defines the JWT validator configurations.Validates the created JWT. ...","content":"/  /  / JWT Issue/Validate  import ballerina/config; import ballerina/crypto; import ballerina/io; import ballerina/jwt; import ballerina/time;public function main() {  crypto:KeyStore keyStore = {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  };  jwt:JwtKeyStoreConfig keyStoreConfig = {  keyStore: keyStore,  keyAlias: \"ballerina\",  keyPassword: \"ballerina\"  };  jwt:JwtHeader header = {};  header.alg = jwt:RS256;  header.typ = \"JWT\";  jwt:JwtPayload payload = {};  payload.sub = \"John\";  payload.iss = \"wso2\";  payload.jti = \"100078234ba23\";  payload.aud = [\"ballerina\", \"ballerinaSamples\"];  payload.exp = time:currentTime().time/1000 + 600;  string|jwt:Error jwt = jwt:issueJwt(header, payload, keyStoreConfig);  if (jwt is string) {  io:println(\"Issued JWT: \", jwt);  } else {  io:println(\"An error occurred while issuing the JWT: \",  jwt.detail()?.message);  }  crypto:TrustStore trustStore = {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  };  jwt:JwtValidatorConfig validatorConfig = {  issuer: \"wso2\",  audience: \"ballerina\",  clockSkewInSeconds: 60,  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: trustStore  }  };  jwt:JwtPayload|jwt:Error result = jwt:validateJwt(<string>jwt, validatorConfig);  if (result is jwt:JwtPayload) {  io:println(\"Validated JWT Payload: \", result);  } else {  io:println(\"An error occurred while validating the JWT: \",  result.detail()?.message);  } }    JWT Issue/Validate  This example demonstrates how to issue and validate a JWT.    import ballerina/config; import ballerina/crypto; import ballerina/io; import ballerina/jwt; import ballerina/time;    public function main() {    crypto:KeyStore keyStore = {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  };    Defines the keystore.   jwt:JwtKeyStoreConfig keyStoreConfig = {  keyStore: keyStore,  keyAlias: \"ballerina\",  keyPassword: \"ballerina\"  };    Defines the JWT keystore configurations.   jwt:JwtHeader header = {};  header.alg = jwt:RS256;  header.typ = \"JWT\";    Defines the JWT header and sets the values.   jwt:JwtPayload payload = {};  payload.sub = \"John\";  payload.iss = \"wso2\";  payload.jti = \"100078234ba23\";  payload.aud = [\"ballerina\", \"ballerinaSamples\"];  payload.exp = time:currentTime().time/1000 + 600;    Defines the JWT payload and sets the values.   string|jwt:Error jwt = jwt:issueJwt(header, payload, keyStoreConfig);  if (jwt is string) {  io:println(\"Issued JWT: \", jwt);  } else {  io:println(\"An error occurred while issuing the JWT: \",  jwt.detail()?.message);  }    Issues a JWT based on the provided header, payload and config.   crypto:TrustStore trustStore = {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  };    Defines the truststore.   jwt:JwtValidatorConfig validatorConfig = {  issuer: \"wso2\",  audience: \"ballerina\",  clockSkewInSeconds: 60,  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: trustStore  }  };    Defines the JWT validator configurations.   jwt:JwtPayload|jwt:Error result = jwt:validateJwt(<string>jwt, validatorConfig);  if (result is jwt:JwtPayload) {  io:println(\"Validated JWT Payload: \", result);  } else {  io:println(\"An error occurred while validating the JWT: \",  result.detail()?.message);  } }    Validates the created JWT.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run jwt_issue_validate.bal --b7a.home=<ballerina_home_path> Issued JWT: eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QifQ.eyJzdWIiOiJKb2huIiwgImlzcyI6IndzbzIiLCAiZXhwIjoxNTg2NDM3MzgwLCAianRpIjoiMTAwMDc4MjM0YmEyMyIsICJhdWQiOlsiYmFsbGVyaW5hIiwgImJhbGxlcmluYVNhbXBsZXMiXX0.H67rsDKLmZJacI1NKMlYl6cCROS-rsLfW3Z2INvvDyHrntNau0P8FFoIc98D_c7UPe_L1_uV3no0nWweoWvzqQB8wfvduB6wKNxb1KGprIUF0ilxveQN1Vzab2Mvd7SJCJ19tf6OcKort38C7ES0am5vsm0495OyaNVDAq3ixFP8WRacQW53b0ELc25QCYJJBLhjFBdXLpnx1boSjgS2vhTrg8bY8zlkoV3pJULfHmjS3JX0a_FBqqeB1yQqbIp1RxGrWzGg4nA6kPjGC1GwYvxjcCVQjY5PWWsd9GAeCnnvmFE_Xy6Xenq5lfL2RWWO4H3yF8x_8hcLS9XidERGWQ Validated JWT Payload: iss=wso2 sub=John aud=ballerina ballerinaSamples jti=100078234ba23 exp=1586437380 customClaims="},{"page":"/learn/by-example/json-to-xml-conversion.html","name":"JSON to XML Conversion","summary":"JSON to XML conversions can be done using the xmlutils:fromJSON() function.\n This function takes a xmlutils:JsonOptions record as an argument.\n The JsonOptions record has two fields: the attributePrefix and the arrayEntryTag.\n The attributePrefix is a prefix that is used to identify the XML attributes.\n The default value of the attributePrefix ...","content":"/  /  / JSON to XML Conversion  import ballerina/io; import ballerina/xmlutils;public function main() {  json j1 = {  \"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };  var x1 = xmlutils:fromJSON(j1);  io:println(x1); json j2 = {  \"Store\": {  \"#id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };  var x2 = xmlutils:fromJSON(j2, {attributePrefix: \"#\", arrayEntryTag: \"wrapper\"});  io:println(x2); }    JSON to XML Conversion  JSON to XML conversions can be done using the xmlutils:fromJSON() function.  This function takes a xmlutils:JsonOptions record as an argument.  The JsonOptions record has two fields: the attributePrefix and the arrayEntryTag.  The attributePrefix is a prefix that is used to identify the XML attributes.  The default value of the attributePrefix option is @.  The arrayEntryTag is the name of the tag that is to be added to each entry of  the JSON array. The default value of the arrayEntryTag option is root.    import ballerina/io; import ballerina/xmlutils;    public function main() {    json j1 = {  \"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };    Creates a JSON object.   var x1 = xmlutils:fromJSON(j1);  io:println(x1);    Converts the JSON object to XML using the default attributePrefix  and the default arrayEntryTag.   json j2 = {  \"Store\": {  \"#id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };    var x2 = xmlutils:fromJSON(j2, {attributePrefix: \"#\", arrayEntryTag: \"wrapper\"});  io:println(x2); }    Converts the JSON object to XML using a custom attributePrefix (i.e., the # character)  and the custom arrayEntryTag (i.e., wrapper).   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run json_to_xml_conversion.bal <Store id=\"AST\"><name>Anne</name><address><street>Main</street><city>94</city></address><codes><root>4</root><root>8</root></codes></Store> <Store id=\"AST\"><name>Anne</name><address><street>Main</street><city>94</city></address><codes><wrapper>4</wrapper><wrapper>8</wrapper></codes></Store>"},{"page":"/learn/by-example/json.html","name":"JSON","summary":"JSON is a textual format for representing a collection of values:\n a simple value (string, number, “true”, “false”, “null”), an array of values, or an object.\n Ballerina has a single type named json that can represent any JSON value.\n Thus, json is a built-in union type in Ballerina that can ...","content":"/  /  / JSON  import ballerina/io;public function main() {  json j1 = \"Apple\";  io:println(j1);  json j2 = 5.36;  io:println(j2);  json j3 = true;  io:println(j3);  json j4 = false;  io:println(j4);  json j5 = null;  json j6 = {name: \"apple\", color: \"red\", price: j2};  io:println(j6);  io:println(j6.toJsonString());  json j7 = [1, false, null, \"foo\", {first: \"John\", last: \"Pala\"}];  io:println(j7.toJsonString());  json j8 = checkpanic j5.mergeJson(j7);  io:println(j8.toJsonString());  json j9 = {name: \"Anne\", age: null, marks: {math: 90, language: 95}};  json j10 = {name: (), age: 20, marks: {physics: 85}};  json j11 = checkpanic j9.mergeJson(j10);  io:println(j11.toJsonString());  io:println(j9 === j11);  json|error j12 = j2.mergeJson(j3);  io:println(j12);  string s = j6.toJsonString();  json j13 = checkpanic s.fromJsonString();  io:println(j13.toJsonString());  io:println(j6 == j13); }    JSON  JSON is a textual format for representing a collection of values:  a simple value (string, number, “true”, “false”, “null”), an array of values, or an object.  Ballerina has a single type named json that can represent any JSON value.  Thus, json is a built-in union type in Ballerina that can contain values of the types  nil (as the null value), boolean, int, float, decimal, string, json[], and map<json>.    import ballerina/io;    public function main() {    json j1 = \"Apple\";  io:println(j1);    Create a JSON string value.   json j2 = 5.36;  io:println(j2);    Create a JSON number value.   json j3 = true;  io:println(j3);    Create a JSON true value.   json j4 = false;  io:println(j4);    Create a JSON false value.   json j5 = null;    Create a JSON null value.   json j6 = {name: \"apple\", color: \"red\", price: j2};  io:println(j6);    Creates a JSON Object. This is equivalent to a map<json>.   io:println(j6.toJsonString());    The .toJsonString() defined for json values returns a string that  represents the value in JSON format.   json j7 = [1, false, null, \"foo\", {first: \"John\", last: \"Pala\"}];  io:println(j7.toJsonString());    Create a JSON Array. This is equivalent to a json[].   json j8 = checkpanic j5.mergeJson(j7);  io:println(j8.toJsonString());    The .mergeJson() method can be used to merge two json values.  If either of the two values is null, the result of .mergeJson() is  the other value.   json j9 = {name: \"Anne\", age: null, marks: {math: 90, language: 95}};  json j10 = {name: (), age: 20, marks: {physics: 85}};  json j11 = checkpanic j9.mergeJson(j10);  io:println(j11.toJsonString());    .mergeJson() can also be used to merge two JSON objects.  Where both json values are mappings, for each entry in the second,  if an entry is not present in the first by the same key, the entry  is added to the first mapping. If there is already a field by the same  key in the first mapping, .mergeJson() is called recursively.   io:println(j9 === j11);    Reference equality checks between j9 and j11 evaluate to true since  the j9 itself is updated and returned if the merge is successful.   json|error j12 = j2.mergeJson(j3);  io:println(j12);    .mergeJson() returns an error if the values cannot be merged.  For example, attempting to merge a mapping value with a non-mapping value  or two non-mapping values where neither is null.   string s = j6.toJsonString();  json j13 = checkpanic s.fromJsonString();  io:println(j13.toJsonString());    The .fromJsonString() defined on string values attempts parsing the  string expected to be in the JSON format and returns the represented JSON value  if successful. This method returns an error if the string cannot be parsed.   io:println(j6 == j13); }    The value would be equal to the original value from which the string  was created.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run json.bal Apple 5.36 true false name=apple color=red price=5.36 {\"name\":\"apple\", \"color\":\"red\", \"price\":5.36} [1, false, null, \"foo\", {\"first\":\"John\", \"last\":\"Pala\"}] [1, false, null, \"foo\", {\"first\":\"John\", \"last\":\"Pala\"}] {\"name\":\"Anne\", \"age\":20, \"marks\":{\"math\":90, \"language\":95, \"physics\":85}} true error {ballerina/lang.value}MergeJsonError message=Cannot merge JSON values of types 'float' and 'boolean' {\"name\":\"apple\", \"color\":\"red\", \"price\":5.36} true"},{"page":"/learn/by-example/kafka_message_consumer_group_service.html","name":"Consumer Groups","summary":"Here, is an example of a kafka consumer used as a listener to listen to a\n given topic/topics. The listener uses a group of concurrent consumers within\n the service. This consumer uses the builtin string deserializer for the\n values.The bootstrapServers is the list of remote server endpoints of the\n Kafka ...","content":"/  /  / Consumer Groups  import ballerina/kafka; import ballerina/log;kafka:ConsumerConfiguration consumerConfigs = {  bootstrapServers: \"localhost:9092\",  concurrentConsumers: 2,  groupId: \"group-id\",  topics: [\"test-kafka-topic\"],  pollingIntervalInMillis: 1000,  valueDeserializerType: kafka:DES_STRING };listener kafka:Consumer consumer = new (consumerConfigs);service kafkaService on consumer {  resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {  foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }  } }function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  anydata message = kafkaRecord.value;  if (message is string) {  log:printInfo(\"Topic: \" + kafkaRecord.topic + \" Partition: \" +  kafkaRecord.partition.toString() + \" Received Message: \" + message);  } else {  log:printError(\"Error occurred while retrieving message data;\" +  \"Unexpected type\");  } }    Consumer Groups  Here, is an example of a kafka consumer used as a listener to listen to a  given topic/topics. The listener uses a group of concurrent consumers within  the service. This consumer uses the builtin string deserializer for the  values.    import ballerina/kafka; import ballerina/log;    kafka:ConsumerConfiguration consumerConfigs = {    bootstrapServers: \"localhost:9092\",    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   concurrentConsumers: 2,  groupId: \"group-id\",    Using two concurrent consumers to work as a group.   topics: [\"test-kafka-topic\"],  pollingIntervalInMillis: 1000,    Subscribes to the topic test-kafka-topic.   valueDeserializerType: kafka:DES_STRING };    Uses the default string deserializer to deserialize the Kafka value.   listener kafka:Consumer consumer = new (consumerConfigs);    service kafkaService on consumer {    resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {    This resource executes when a message or a set of messages are published  to the subscribed topic/topics.   foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }  } }    The set of Kafka records dispatched to the service are processed one  by one.   function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  anydata message = kafkaRecord.value;  if (message is string) {    log:printInfo(\"Topic: \" + kafkaRecord.topic + \" Partition: \" +  kafkaRecord.partition.toString() + \" Received Message: \" + message);  } else {  log:printError(\"Error occurred while retrieving message data;\" +  \"Unexpected type\");  } }    Prints the retrieved Kafka record.   # For this example to work properly, an active Kafka broker should be present. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run kafka_message_consumer_group_service.bal    # If the listener started successfully, the following lines will be printed in # the Console. [ballerina/kafka] kafka servers: localhost:9092 [ballerina/kafka] subscribed topics: test-kafka-topic [ballerina/kafka] started kafka listener"},{"page":"/learn/by-example/kafka_message_producer.html","name":"Producer","summary":"This is an example on how to send messages to a Kafka topic using a\n kafka:Producer object. The producer is configured to send string\n values and int keys.The bootstrapServers is the list of remote server endpoints of the\n Kafka brokers.Uses the builtin string serializer for the values.Uses the builtin int ...","content":"/  /  / Producer  import ballerina/io; import ballerina/kafka;kafka:ProducerConfiguration producerConfiguration = {  bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,  valueSerializerType: kafka:SER_STRING,  keySerializerType: kafka:SER_INT };kafka:Producer kafkaProducer = new (producerConfiguration);public function main() {  string message = \"Hello World, Ballerina\";  var sendResult = kafkaProducer->send(message, \"test-kafka-topic\", key = 1);  if (sendResult is error) {  io:println(\"Error occurred while sending data: \" + sendResult.toString());  } else {  io:println(\"Message sent successfully.\");  }  var flushResult = kafkaProducer->flushRecords();  if (flushResult is error) {  io:println(\"Error occurred while flishing the data: \" + flushResult.toString());  } else {  io:println(\"Records were flushed successfully.\");  } }    Producer  This is an example on how to send messages to a Kafka topic using a  kafka:Producer object. The producer is configured to send string  values and int keys.    import ballerina/io; import ballerina/kafka;    kafka:ProducerConfiguration producerConfiguration = {    bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   valueSerializerType: kafka:SER_STRING,    Uses the builtin string serializer for the values.   keySerializerType: kafka:SER_INT };    Uses the builtin int serializer for the keys.   kafka:Producer kafkaProducer = new (producerConfiguration);    public function main() {  string message = \"Hello World, Ballerina\";  var sendResult = kafkaProducer->send(message, \"test-kafka-topic\", key = 1);  if (sendResult is error) {  io:println(\"Error occurred while sending data: \" + sendResult.toString());  } else {  io:println(\"Message sent successfully.\");  }  var flushResult = kafkaProducer->flushRecords();  if (flushResult is error) {  io:println(\"Error occurred while flishing the data: \" + flushResult.toString());  } else {  io:println(\"Records were flushed successfully.\");  } }    # For this example to work properly, an active Kafka broker should be present. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run kafka_message_producer_simple.bal    # If the producer successfully sent the message, the following will be printed # in the Console. Message sent successfully. Records were flushed successfully."},{"page":"/learn/by-example/kafka_message_consumer_service.html","name":"Consumer Service","summary":"Here, is an example in which we create a Kafka consumer used as a listener\n to a service with manual offset commits.\n This consumer uses the builtin int deserializer for the keys and the\n builtin string deserializer for the values.The bootstrapServers is the list of remote server endpoints of the\n ...","content":"/  /  / Consumer Service  import ballerina/kafka; import ballerina/log;kafka:ConsumerConfiguration consumerConfigs = {  bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",  topics: [\"test-kafka-topic\"],  pollingIntervalInMillis: 1000,  keyDeserializerType: kafka:DES_INT,  valueDeserializerType: kafka:DES_STRING,  autoCommit: false };listener kafka:Consumer consumer = new (consumerConfigs);service kafkaService on consumer {  resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {  foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }  var commitResult = kafkaConsumer->commit();  if (commitResult is error) {  log:printError(\"Error occurred while committing the \" +  \"offsets for the consumer \", commitResult);  }  } }function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  anydata value = kafkaRecord.value;  anydata key = kafkaRecord.key;  if (value is string) {  if (key is int) {  log:printInfo(\"Topic: \" + kafkaRecord.topic);  log:printInfo(\"Partition: \" + kafkaRecord.partition.toString());  log:printInfo(\"Key: \" + key.toString());  log:printInfo(\"Value: \" + value);  } else {  log:printError(\"Invalid key type received\");  }  } else {  log:printError(\"Invalid value type received\");  } }    Consumer Service  Here, is an example in which we create a Kafka consumer used as a listener  to a service with manual offset commits.  This consumer uses the builtin int deserializer for the keys and the  builtin string deserializer for the values.    import ballerina/kafka; import ballerina/log;    kafka:ConsumerConfiguration consumerConfigs = {    bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   topics: [\"test-kafka-topic\"],  pollingIntervalInMillis: 1000,    Subscribes to the topic test-kafka-topic.   keyDeserializerType: kafka:DES_INT,    Uses the default int deserializer for the keys.   valueDeserializerType: kafka:DES_STRING,    Uses the default string deserializer for the values.   autoCommit: false };    Set autoCommit to false, so that the records should be committed  manually.   listener kafka:Consumer consumer = new (consumerConfigs);    service kafkaService on consumer {    resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {    This resource will be executed when a message is published to the  subscribed topic/topics.   foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }    The set of Kafka records dispatched to the service are processed one  by one.   var commitResult = kafkaConsumer->commit();  if (commitResult is error) {  log:printError(\"Error occurred while committing the \" +  \"offsets for the consumer \", commitResult);  }  } }    Commit offsets for returned records by marking them as consumed.   function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  anydata value = kafkaRecord.value;  anydata key = kafkaRecord.key;    if (value is string) {    The value should be a string, since the string deserializer is used  for the value.   if (key is int) {    The key should be an int, since the int deserializer is used for  the key.   log:printInfo(\"Topic: \" + kafkaRecord.topic);  log:printInfo(\"Partition: \" + kafkaRecord.partition.toString());  log:printInfo(\"Key: \" + key.toString());  log:printInfo(\"Value: \" + value);  } else {  log:printError(\"Invalid key type received\");  }  } else {  log:printError(\"Invalid value type received\");  } }    Prints the received Kafka record.   # For this example to work properly, an active Kafka broker should be present. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run kafka_message_consumer_service.bal    # If the listener started successfully, the following lines will be printed in # the Console. [ballerina/kafka] kafka servers: localhost:9092 [ballerina/kafka] subscribed topics: test-kafka-topic [ballerina/kafka] started kafka listener"},{"page":"/learn/by-example/kafka_message_consumer_simple.html","name":"Consumer Client","summary":"This is an example on how to use a kafka:Consumer as a simple record\n consumer. The records from a subscribed topic can be retrieved using the\n poll() function.\n This consumer uses the builtin byte array deserializer for both the key and\n the value, which is the default deserializer in the ...","content":"/  /  / Consumer Client  import ballerina/io; import ballerina/kafka; import ballerina/lang.'string; import ballerina/log;kafka:ConsumerConfiguration consumerConfiguration = {  bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",  offsetReset: \"earliest\",  topics: [\"test-kafka-topic\"] };kafka:Consumer consumer = new (consumerConfiguration);public function main() {  var results = consumer->poll(1000);  if (results is error) {  log:printError(\"Error occurred while polling \", results);  }  kafka:ConsumerRecord[] records = <kafka:ConsumerRecord[]>results;  foreach var kafkaRecord in records {  anydata serializedMessage = kafkaRecord.value;  if (serializedMessage is byte[]) {  string|error message = 'string:fromBytes(serializedMessage);  if (message is string) {  io:println(\"Topic: \", kafkaRecord.topic, \" Received Message: \",  message);  } else {  log:printError(\"Error occurred while converting message data\",  message);  }  } else {  log:printError(\"Error occurred while retrieving message data;\" +  \"Unexpected type\");  }  } }    Consumer Client  This is an example on how to use a kafka:Consumer as a simple record  consumer. The records from a subscribed topic can be retrieved using the  poll() function.  This consumer uses the builtin byte array deserializer for both the key and  the value, which is the default deserializer in the kafka:Consumer.    import ballerina/io; import ballerina/kafka; import ballerina/lang.'string; import ballerina/log;    kafka:ConsumerConfiguration consumerConfiguration = {    bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",  offsetReset: \"earliest\",    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   topics: [\"test-kafka-topic\"] };    Subscribes to the topic test-kafka-topic.   kafka:Consumer consumer = new (consumerConfiguration);    public function main() {    var results = consumer->poll(1000);  if (results is error) {  log:printError(\"Error occurred while polling \", results);  }  kafka:ConsumerRecord[] records = <kafka:ConsumerRecord[]>results;  foreach var kafkaRecord in records {  anydata serializedMessage = kafkaRecord.value;  if (serializedMessage is byte[]) {    Poll the consumer for messages.   string|error message = 'string:fromBytes(serializedMessage);  if (message is string) {    Converts byte[] to string.   io:println(\"Topic: \", kafkaRecord.topic, \" Received Message: \",  message);  } else {  log:printError(\"Error occurred while converting message data\",  message);  }  } else {  log:printError(\"Error occurred while retrieving message data;\" +  \"Unexpected type\");  }  } }    Prints the retrieved Kafka record.   # For this example to work properly, an active Kafka broker should be present. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run kafka_message_consumer_simple.bal    # Then it will print the following lines in the Console, and the # received messages if there's any. [ballerina/kafka] kafka servers: localhost:9092 [ballerina/kafka] subscribed topics: test-kafka-topic"},{"page":"/learn/by-example/kafka_message_producer_transactional.html","name":"Transactional Producer","summary":"This example shows you how to do transactional message producing by sending messages\n to kafka brokers atomically using the kafka:Producer object.The bootstrapServers is the list of remote server endpoints of the\n Kafka brokers.The enableIdempotence should set to true to make a producer\n transactional.A transactionalId must be provided to make a ...","content":"/  /  / Transactional Producer  import ballerina/io; import ballerina/kafka;kafka:ProducerConfiguration producerConfigs = {  bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,  enableIdempotence: true,  transactionalId: \"test-transactional-id\" };kafka:Producer kafkaProducer = new (producerConfigs);public function main() {  string message = \"Hello World Transaction Message\";  byte[] serializedMessage = message.toBytes();  kafkaAdvancedTransactionalProduce(serializedMessage); }function kafkaAdvancedTransactionalProduce(byte[] message) {  transaction {  var sendResult = kafkaProducer->send(message, \"test-kafka-topic\",  partition = 0);  if (sendResult is error) {  io:println(\"Kafka producer failed to send first message\",  sendResult.toString());  }  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  } }    Transactional Producer  This example shows you how to do transactional message producing by sending messages  to kafka brokers atomically using the kafka:Producer object.    import ballerina/io; import ballerina/kafka;    kafka:ProducerConfiguration producerConfigs = {    bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   enableIdempotence: true,    The enableIdempotence should set to true to make a producer  transactional.   transactionalId: \"test-transactional-id\" };    A transactionalId must be provided to make a producer transactional.   kafka:Producer kafkaProducer = new (producerConfigs);    public function main() {  string message = \"Hello World Transaction Message\";  byte[] serializedMessage = message.toBytes();    kafkaAdvancedTransactionalProduce(serializedMessage); }    Here, we create a producer config with optional parameters.  transactional.id - enable transactional message production.   function kafkaAdvancedTransactionalProduce(byte[] message) {  transaction {  var sendResult = kafkaProducer->send(message, \"test-kafka-topic\",  partition = 0);  if (sendResult is error) {  io:println(\"Kafka producer failed to send first message\",  sendResult.toString());  }  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  } }    # For this example to work properly, an active Kafka broker should be present. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run --experimental kafka_message_producer_transactional.bal    # If the producer successfully sent the message, the following will be printed # in the Console. 2020-03-26 13:57:29,129 INFO [ballerina/transactions] - Created transaction: 6cfac3a7-a8a2-4220-944e-dfbd6d27910f 2020-03-26 13:57:29,184 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 6cfac3a7-a8a2-4220-944e-dfbd6d27910f:$anon$.$0 Transaction committed"},{"page":"/learn/by-example/length.html","name":"Length","summary":"Ballerina provides a .length() method for strings, arrays, tuples, maps, records, and xml,\n which returns the length/size of the given value.Create an integer array with several integer elements.Print the length of the created integer array. The length is\n retrieved using the .length() method.Create a JSON array with several JSON elements.Print ...","content":"/  /  / Length  import ballerina/io;public function main() {  int[] intArray = [1, 2, 3];  int length;  length = intArray.length();  io:println(\"Integer array size: \", length);  json[] jsonArray = [  {\"name\": \"John\", \"age\": 31},  {\"name\": \"Neal\", \"age\": 22}  ];  length = jsonArray.length();  io:println(\"JSON array size: \", length);  map<int> strMap = {};  strMap[\"A\"] = 1;  strMap[\"B\"] = 2;  strMap[\"C\"] = 3;  length = strMap.length();  io:println(\"Map size: \", length);  string myStr = \"My name is Peter Parker\";  length = myStr.length();  io:println(\"String size: \", length);  xml x1 = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  length = (x1/<*>).length();  io:println(\"XML child elements size: \", length);  [int, string] tupleVar = [10, \"John\"];  length = tupleVar.length();  io:println(\"Tuple size: \", length);  Student stu = {id: 1, fname: \"John\", lname: \"Doe\", age: 17};  length = stu.length();  io:println(\"Field size in `Student` record: \", length); }type Student record {|  int id;  string fname;  string lname;  int age;  string...; |};    Length  Ballerina provides a .length() method for strings, arrays, tuples, maps, records, and xml,  which returns the length/size of the given value.    import ballerina/io;    public function main() {    int[] intArray = [1, 2, 3];  int length;    Create an integer array with several integer elements.   length = intArray.length();  io:println(\"Integer array size: \", length);    Print the length of the created integer array. The length is  retrieved using the .length() method.   json[] jsonArray = [  {\"name\": \"John\", \"age\": 31},  {\"name\": \"Neal\", \"age\": 22}  ];    Create a JSON array with several JSON elements.   length = jsonArray.length();  io:println(\"JSON array size: \", length);    Print the length of the created JSON array.   map<int> strMap = {};  strMap[\"A\"] = 1;  strMap[\"B\"] = 2;  strMap[\"C\"] = 3;    Create an int-constrained map.   length = strMap.length();  io:println(\"Map size: \", length);    Print the length of the created map.   string myStr = \"My name is Peter Parker\";  Define a string.   length = myStr.length();  io:println(\"String size: \", length);    Print the length of the string.   xml x1 = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;    Create an XML element.   length = (x1/<*>).length();  io:println(\"XML child elements size: \", length);    Print the number of content items in the XML element.   [int, string] tupleVar = [10, \"John\"];    Define a tuple with two members.   length = tupleVar.length();  io:println(\"Tuple size: \", length);    Print the size of the tuple (i.e., the number of members in the tuple).   Student stu = {id: 1, fname: \"John\", lname: \"Doe\", age: 17};    Create a record of the Student type.   length = stu.length();  io:println(\"Field size in `Student` record: \", length); }    Print the number of fields in the created Student record.   type Student record {|  int id;  string fname;  string lname;  int age;  string...; |};    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run length.bal Integer array size: 3 JSON array size: 2 Map size: 3 String size: 23 XML child elements size: 2 Tuple size: 2 Field size in `Student` record: 4"},{"page":"/learn/by-example/knative-deployment.html","name":"Knative Deployment","summary":"Ballerina supports generating Knative Serivces artifacts based on annotations.\nArtifacts will be generated by adding the @knative:Service annotation to the HTTP service.\nFor more information, see .Add the @knative:Service to a Ballerina service to generate a Knative Service artifact and push the Docker image to Docker Hub.Enable pushing the Docker image.Set the ...","content":"/  /  / Knative Deployment  import ballerina/http; import ballerina/knative; import ballerina/log; @knative:Service {  push: true,  name: \"hello-world-knative\",  username: \"$env{DOCKER_USERNAME}\",  password: \"$env{DOCKER_PASSWORD}\",  registry: \"index.docker.io/$env{DOCKER_USERNAME}\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on new http:Listener(8080) {  resource function sayHello(http:Caller outboundEP, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello, World from service helloWorld ! \\n\");  var responseResult = outboundEP->respond(response);  if (responseResult is error) {  log:printError(\"error responding back to client.\", responseResult);  }  } }    Knative Deployment  Ballerina supports generating Knative Serivces artifacts based on annotations. Artifacts will be generated by adding the @knative:Service annotation to the HTTP service. For more information, see .    import ballerina/http; import ballerina/knative; import ballerina/log;    @knative:Service {    Add the @knative:Service to a Ballerina service to generate a Knative Service artifact and push the Docker image to Docker Hub.   push: true,    Enable pushing the Docker image.   name: \"hello-world-knative\",    Set the name of the Docker image.   username: \"$env{DOCKER_USERNAME}\",    Sets the username credential to push the Docker image using the DOCKER_USERNAME environment variable.   password: \"$env{DOCKER_PASSWORD}\",    Sets the password credential to push the Docker image using the DOCKER_PASSWORD environment variable.   registry: \"index.docker.io/$env{DOCKER_USERNAME}\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on new http:Listener(8080) {  resource function sayHello(http:Caller outboundEP, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello, World from service helloWorld ! \\n\");  var responseResult = outboundEP->respond(response);  if (responseResult is error) {  log:printError(\"error responding back to client.\", responseResult);  }  } }    Setting the registry URL.   # Build the Ballerina program. $ ballerina build knative_deployment.bal Compiling source \tknative_deployment.bal    Generating executables \tknative_deployment.jar    Generating Knative artifacts...    @knative:Service - complete 1/1 \t@knative:Docker - complete 3/3    Run the following command to deploy the Knative artifacts: \tkubectl apply -f ./kubernetes    Run the following command to install the application using Helm: \thelm install --name hello-world-knative ./kubernetes/hello-world-knative    # Verify if the Docker image is generated. $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE knative_deployment latest 85933f1c05b0 3 minutes ago 133MB    # Apply the Knative artifacts. $ kubectl apply -f ./kubernetes/ service.serving.knative.dev/hello-world-knative created    # Wait for the `hello-world-knative` route to be ready. $ watch -n 1 kubectl get pod,revision,route NAME READY STATUS RESTARTS AGE pod/hello-world-knative-dd6nk-deployment-5694769c7d-nzvts 2/2 Running 0 12s    NAME CONFIG NAME K8S SERVICE NAME GENERATION READY REASON revision.serving.knative.dev/hello-world-knative-dd6nk hello-world-knative hello-world-knative-dd6nk 1 True    NAME URL READY REASON route.serving.knative.dev/hello-world-knative http://hello-world-knative.default.example.com True    # Add DNS mapping for the `hello-world-knative` route's URL. $ sudo vim /etc/hosts 127.0.0.1 hello-world-knative.default.example.com    # Access the service. $ curl -kv http://hello-world-knative.default.example.com/helloWorld/sayHello Hello, World from service helloWorld !"},{"page":"/learn/by-example/kubernetes-deployment.html","name":"Kubernetes Deployment","summary":"Ballerina supports generating Kubernetes artifacts based on annotations.\nA single Ballerina module is mapped to a single Kubernetes deployment.\nMinikube or Docker for Mac/Windows should be configured and\nKubernetes should be enabled to run the example.\nThis example deploys an HTTPS service, which retrieves values from a config file to Kubernetes.\nBefore running the sample, ...","content":"/  /  / Kubernetes Deployment  import ballerina/config; import ballerina/http; import ballerina/log; import ballerina/kubernetes; @kubernetes:Service {  serviceType: \"NodePort\" } @kubernetes:Ingress {  hostname: \"abc.com\" } listener http:Listener helloWorldEP = new(9090, config = {  secureSocket: {  keyStore: {  path: \"./security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: \"./security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); @kubernetes:ConfigMap {  conf: \"./ballerina.conf\" } @kubernetes:Deployment {  livenessProbe: true,  image: \"kubernetes:v.1.0\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/config/{user}\"  }  resource function getConfig(http:Caller outboundEP, http:Request request, string user) {  string userId = getConfigValue(user, \"userid\");  string groups = getConfigValue(user, \"groups\");  json payload = {  userId: userId,  groups: groups  };  var responseResult = outboundEP->respond(payload);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }function getConfigValue(string instanceId, string property) returns (string) {  string key = <@untainted string> (instanceId + \".\" + property);  return config:getAsString(key, \"Invalid User\"); }# Create a `ballerina.conf` file with the following content in the same directory, which contains the kubernetes_deployment.bal file. [john] userid=\"john@ballerina.com\" groups=\"apim,esb\" [jane] userid=\"jane3@ballerina.com\" groups=\"esb\"    Kubernetes Deployment  Ballerina supports generating Kubernetes artifacts based on annotations. A single Ballerina module is mapped to a single Kubernetes deployment. Minikube or Docker for Mac/Windows should be configured and Kubernetes should be enabled to run the example. This example deploys an HTTPS service, which retrieves values from a config file to Kubernetes. Before running the sample, create a directory named security inside current working directory from where the ballerina build command will be issued. Then copy the ballerinaKeystore.p12 and ballerinaTruststore.p12 files located in to the security folder. For more information, see .    import ballerina/config; import ballerina/http; import ballerina/log; import ballerina/kubernetes;    @kubernetes:Service {    Add the @kubernetes:Service to a listener endpoint to expose the endpoint as a Kubernetes Service.   serviceType: \"NodePort\" }    Service type is NodePort.   @kubernetes:Ingress {    Add the @kubernetes:Ingress to a listener endpoint to expose the endpoint as a Kubernetes Ingress.   hostname: \"abc.com\" } listener http:Listener helloWorldEP = new(9090, config = {    Hostname of the service is abc.com.   secureSocket: {  keyStore: {  path: \"./security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: \"./security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    Ballerina automatically creates Kubernetes secrets for the keystore and truststore when the @kubernetes:Service annotation is added to the endpoint.   @kubernetes:ConfigMap {    Add the @kubernetes:ConfigMap annotation to a Ballerina service to mount configs to the container.   conf: \"./ballerina.conf\" }    Path to the ballerina.conf file. If a releative path is provided, the path should be releative to where the ballerina build command is executed.   @kubernetes:Deployment {    Add the @kubernetes:Deployment annotation to a Ballerna service to generate Kuberenetes Deployment for a Ballerina module.   livenessProbe: true,    Enable Kubernetes liveness probe to this service.   image: \"kubernetes:v.1.0\"    Generate a Docker image with the name kubernetes:v1.0.   } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/config/{user}\"  }  resource function getConfig(http:Caller outboundEP, http:Request request, string user) {  string userId = getConfigValue(user, \"userid\");  string groups = getConfigValue(user, \"groups\");  json payload = {  userId: userId,  groups: groups  };  var responseResult = outboundEP->respond(payload);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    If you are using minikube, uncomment and change the following values accordingly. //dockerHost:“tcp://:2376”, //dockerCertPath:”/.minikube/certs”   function getConfigValue(string instanceId, string property) returns (string) {  string key = <@untainted string> (instanceId + \".\" + property);  return config:getAsString(key, \"Invalid User\"); }    # Create a `ballerina.conf` file with the following content in the same directory, which contains the kubernetes_deployment.bal file. [john] userid=\"john@ballerina.com\" groups=\"apim,esb\" [jane] userid=\"jane3@ballerina.com\" groups=\"esb\"    # Build the ballerina program $ ballerina build kubernetes_deployment.bal Compiling source \tkubernetes_deployment.bal Generating executables \tkubernetes_deployment.jar    Generating artifacts...    @kubernetes:Service - complete 1/1 \t@kubernetes:Ingress - complete 1/1 \t@kubernetes:ConfigMap - complete 1/1 \t@kubernetes:Deployment - complete 1/1 \t@kubernetes:Docker - complete 2/2 @kubernetes:Helm - complete 1/1    Run the following command to deploy the Kubernetes artifacts: kubectl apply -f ./kubernetes    Run the following command to install the application using Helm: helm install --name kubernetes-deployment-deployment ./kubernetes/kubernetes-deployment-deployment    # Verify the Docker image is generated $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE kubernetes v1.0 6c0a26a62545 2 seconds ago 127MB    # Apply the Kubernetes artifacts. $ kubectl apply -f ./kubernetes/ service/helloworldep-svc created ingress.extensions/helloworldep-ingress created secret/helloworldep-secure-socket created configmap/helloworld-ballerina-conf-config-map created deployment.extensions/kubernetes-deployment-deployment created    # Verify if the service, pods, & config-maps are deployed $ kubectl get pods NAME READY STATUS RESTARTS AGE kubernetes-deployment-5858fd78d4-lnz8n 1/1 Running 0 20s    $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE helloworldep-svc NodePort 10.109.125.193 <none> 9090:32417/TCP 1m    $ kubectl get cm NAME DATA AGE helloworld-ballerina-conf-config-map 1 5m    # Access the service # Change the port <32417> to Nodeport of the service. $ curl https://localhost:<32417>/helloWorld/config/jane -k {userId: jane3@ballerina.com, groups: esb}    $ curl https://localhost:<32417>/helloWorld/config/john -k {userId: john@ballerina.com, groups: apim,esb}    # If you are using minikube, IP address should be changed according to the output of the `minikube ip` command. $ minikube ip 192.168.99.100    $ curl https://192.168.99.100:<32417>/helloWorld/config/jane -k {userId: jane3@ballerina.com, groups: esb}"},{"page":"/learn/by-example/let-expression.html","name":"Let Expression","summary":"A let expression binds variables and then evaluates an expression with those variables in-scope.This is a simple let expression, which involves only a single\n variable declaration.Declare multiple variables in a let expression.The scope of a variable declared in a let expression is from\n the point of declaration to the end ...","content":"/  /  / Let Expression  import ballerina/io;public function main() {  int a = let int b = 1 in b * 2;  io:println(\"a: \", a);  string greeting = let string hello = \"Hello \",  string ballerina = \"Ballerina!\"  in hello + ballerina;  io:println(\"greeting: \", greeting);  int three = let int one = getInt(), int two = one + one in one + two;  io:println(\"three: \", three);  int length = let var num = 10, var txt = \"four\" in num + txt.length();  io:println(\"length: \", length); [int, int] v1 = [10, 20];  int tupleBindingResult = let [int, int] [d1, d2] = v1,  int d3 = d1 + d2  in d3 * 2;  io:println(\"tuple binding result: \", tupleBindingResult); int age = let Person {  name: firstName,  age: personAge,  ...otherDetails  } = getPerson()  in personAge;  io:println(\"age: \", age); var fatal = let var error(reason, ...params) = getSampleError()  in params[\"fatal\"];  io:println(\"fatal: \", fatal); }public function getInt() returns int => 1;type Person record {  string name;  int age;  string country; };function getPerson() returns Person => {  name: \"John\",  age: 31,  country: \"USA\",  \"occupation\": \"Lawyer\" };function getSampleError() returns error {  return error(\"SampleError\", message = \"Detail message\", fatal = true); }    Let Expression  A let expression binds variables and then evaluates an expression with those variables in-scope.    import ballerina/io;    public function main() {    int a = let int b = 1 in b * 2;  io:println(\"a: \", a);    This is a simple let expression, which involves only a single  variable declaration.   string greeting = let string hello = \"Hello \",  string ballerina = \"Ballerina!\"  in hello + ballerina;  io:println(\"greeting: \", greeting);    Declare multiple variables in a let expression.   int three = let int one = getInt(), int two = one + one in one + two;  io:println(\"three: \", three);    The scope of a variable declared in a let expression is from  the point of declaration to the end of the let expression.   int length = let var num = 10, var txt = \"four\" in num + txt.length();  io:println(\"length: \", length);    Declare variables using the keyword var in a let expression.   [int, int] v1 = [10, 20];    int tupleBindingResult = let [int, int] [d1, d2] = v1,  int d3 = d1 + d2  in d3 * 2;  io:println(\"tuple binding result: \", tupleBindingResult);    Let variable declarations can include binding patterns.   int age = let Person {  name: firstName,  age: personAge,  ...otherDetails  } = getPerson()  in personAge;  io:println(\"age: \", age);    var fatal = let var error(reason, ...params) = getSampleError()  in params[\"fatal\"];  io:println(\"fatal: \", fatal); }    public function getInt() returns int => 1;    type Person record {  string name;  int age;  string country; };    function getPerson() returns Person => {  name: \"John\",  age: 31,  country: \"USA\",  \"occupation\": \"Lawyer\" };    function getSampleError() returns error {  return error(\"SampleError\", message = \"Detail message\", fatal = true); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run let_expression.bal a: 2 greeting: Hello Ballerina! three: 3 length: 14 tuple binding result: 60 age: 31 fatal: true"},{"page":"/learn/by-example/local-transactions-with-participants.html","name":"Local Transactions with participants","summary":"A Ballerina transaction is a series of data manipulation statements\n that must either fully complete or fully fail, thereby, leaving the\n system in a consistent state. This example demonstrates the usage of\n transactions with local participants. If the participant panics even when it\n is trapped and if the initiator completes, ...","content":"/  /  / Local Transactions with participants  import ballerina/io; import ballerina/transactions;public function main() {  transaction {  var res = trap localTransactionParticipant();  if (res is error) {  io:println(\"Local participant panicked.\");  }  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  } } @transactions:Participant {  oncommit: participantOnCommit } function localTransactionParticipant() {  io:println(\"Invoke local participant function.\");  error er = error(\"Simulated Failure\");  panic er; }function participantOnCommit(string transactionId) {  io:println(\"Local participant committed function handler...\"); }    Local Transactions with participants  A Ballerina transaction is a series of data manipulation statements  that must either fully complete or fully fail, thereby, leaving the  system in a consistent state. This example demonstrates the usage of  transactions with local participants. If the participant panics even when it  is trapped and if the initiator completes, the transaction is considered as a failure.  Ballerina transactions are at the experimental stage.  Hence, use the –experimental flag to enable them.    import ballerina/io;    import ballerina/transactions;    Import the ballerina/transactions module to use the  @transactions:Participant annotation.   public function main() {    transaction {    The transaction block initiates the transaction. Thus, it is called the initiator.   var res = trap localTransactionParticipant();  if (res is error) {    Invokes the local participant.   io:println(\"Local participant panicked.\");  }  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  } }    The local participant gets panicked.   @transactions:Participant {  oncommit: participantOnCommit } function localTransactionParticipant() {  io:println(\"Invoke local participant function.\");  error er = error(\"Simulated Failure\");  panic er; }    The @transactions:Participant annotation from the  transactions module is used to indicate the function as a local participant.   function participantOnCommit(string transactionId) {  io:println(\"Local participant committed function handler...\"); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command with the --experimental option. $ ballerina run --experimental local_transactions_with_participants.bal    2020-03-18 11:57:09,328 INFO [ballerina/transactions] - Created transaction: bf592603-4639-4c16-9daf-605b8e131470 2020-03-18 11:57:09,343 INFO [ballerina/transactions] - Registered local participant: 5ca42804-876c-4a69-9b34-8bc537c8d87a:$anon$.$1 for transaction:bf592603-4639-4c16-9daf-605b8e131470 2020-03-18 11:57:09,344 INFO [ballerina/transactions] - participant registered: bf592603-4639-4c16-9daf-605b8e131470 Invoke local participant function. Local participant panicked. 2020-03-18 11:57:09,350 INFO [ballerina/transactions] - Running 2-phase commit for transaction: bf592603-4639-4c16-9daf-605b8e131470:$anon$.$0 2020-03-18 11:57:09,350 INFO [ballerina/transactions] - Local prepare failed, aborting.. Retrying transaction 2020-03-18 11:57:09,359 INFO [ballerina/transactions] - Created transaction: 371da573-8e4f-436e-99b3-adc2b9e911a4 2020-03-18 11:57:09,360 INFO [ballerina/transactions] - Registered local participant: 5ca42804-876c-4a69-9b34-8bc537c8d87a:$anon$.$1 for transaction:371da573-8e4f-436e-99b3-adc2b9e911a4 2020-03-18 11:57:09,361 INFO [ballerina/transactions] - participant registered: 371da573-8e4f-436e-99b3-adc2b9e911a4 Invoke local participant function. Local participant panicked. 2020-03-18 11:57:09,362 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 371da573-8e4f-436e-99b3-adc2b9e911a4:$anon$.$0 2020-03-18 11:57:09,364 INFO [ballerina/transactions] - Local prepare failed, aborting.. Retrying transaction 2020-03-18 11:57:09,366 INFO [ballerina/transactions] - Created transaction: 9a792401-17fd-4486-bb8e-2fb0a79a04a8 2020-03-18 11:57:09,366 INFO [ballerina/transactions] - Registered local participant: 5ca42804-876c-4a69-9b34-8bc537c8d87a:$anon$.$1 for transaction:9a792401-17fd-4486-bb8e-2fb0a79a04a8 2020-03-18 11:57:09,367 INFO [ballerina/transactions] - participant registered: 9a792401-17fd-4486-bb8e-2fb0a79a04a8 Invoke local participant function. Local participant panicked. 2020-03-18 11:57:09,367 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 9a792401-17fd-4486-bb8e-2fb0a79a04a8:$anon$.$0 2020-03-18 11:57:09,368 INFO [ballerina/transactions] - Local prepare failed, aborting.. Transaction aborted [ballerina/http] started HTTP/WS listener 172.17.0.1:35909 [ballerina/http] stopped HTTP/WS listener 172.17.0.1:35909"},{"page":"/learn/by-example/local-transactions.html","name":"Local Transactions","summary":"A Ballerina transaction is a series of data manipulation statements\n that must either fully complete or fully fail, thereby, leaving the\n system in a consistent state. This sample uses an H2 database, which is\n created when running the sample. Prior to running this sample,\n the DB connection properties need to ...","content":"/  /  / Local Transactions  import ballerina/io; import ballerinax/java.jdbc; jdbc:Client testDB = new ({  url: \"jdbc:h2:file:./local-transactions/testdb\",  username: \"test\",  password: \"test\" });public function main() {  var ret = testDB->update(\"CREATE TABLE CUSTOMER (ID INTEGER, NAME \" +  \"VARCHAR(30))\");  handleUpdate(ret, \"Create CUSTOMER table\");  ret = testDB->update(\"CREATE TABLE SALARY (ID INTEGER, MON_SALARY FLOAT)\");  handleUpdate(ret, \"Create SALARY table\");  transaction with retries = 4 {  ret = testDB->update(\"INSERT INTO CUSTOMER(ID,NAME) \" +  \"VALUES (1, 'Anne')\");  ret = testDB->update(\"INSERT INTO SALARY (ID, MON_SALARY) \" +  \"VALUES (1, 2500)\");  if (ret is jdbc:UpdateResult) {  io:println(\"Inserted count: \", ret.updatedRowCount);  if (ret.updatedRowCount == 0) {  abort;  }  } else {  retry;  }  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  }  ret = testDB->update(\"DROP TABLE CUSTOMER\");  handleUpdate(ret, \"Drop table CUSTOMER\"); ret = testDB->update(\"DROP TABLE SALARY\");  handleUpdate(ret, \"Drop table SALARY\"); } function handleUpdate(jdbc:UpdateResult|error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message + \" status: \", returned.updatedRowCount);  } else {  io:println(message + \" failed: \", <string>returned.detail()?.message);  } }# Before running this sample, change the H2 DB connection properties as required.    Local Transactions  A Ballerina transaction is a series of data manipulation statements  that must either fully complete or fully fail, thereby, leaving the  system in a consistent state. This sample uses an H2 database, which is  created when running the sample. Prior to running this sample,  the DB connection properties need to be changed as required.  Ballerina transactions are at the experimental stage,  Thus, use the –experimental flag to enable them.    import ballerina/io; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:h2:file:./local-transactions/testdb\",  username: \"test\",  password: \"test\" });    JDBC Client for H2 database.   public function main() {    var ret = testDB->update(\"CREATE TABLE CUSTOMER (ID INTEGER, NAME \" +  \"VARCHAR(30))\");  handleUpdate(ret, \"Create CUSTOMER table\");    Create the tables that are required for the transaction.   ret = testDB->update(\"CREATE TABLE SALARY (ID INTEGER, MON_SALARY FLOAT)\");  handleUpdate(ret, \"Create SALARY table\");    Populate table with data.   transaction with retries = 4 {    This is a transaction block. If you do not explicitly abort or  retry a returned error, the transaction will be automatically  retried until the retry count is reached and aborted.  The retry count that is given via retries is the number of times the  transaction is retried before it being aborted and the default value is 3.   ret = testDB->update(\"INSERT INTO CUSTOMER(ID,NAME) \" +  \"VALUES (1, 'Anne')\");    Any transacted action within the transaction block may return  errors such as backend DB errors, connection pool errors etc.  The user can decide whether to abort or retry based on the  returned error.  This is the first remote function participant of the transaction.   ret = testDB->update(\"INSERT INTO SALARY (ID, MON_SALARY) \" +  \"VALUES (1, 2500)\");  if (ret is jdbc:UpdateResult) {  io:println(\"Inserted count: \", ret.updatedRowCount);    This is the second remote function participant of the transaction.   if (ret.updatedRowCount == 0) {  abort;  }  } else {    If the transaction is forced to abort, it will roll back the transaction  and exit the transaction block without retrying.   retry;  }    If the transaction is forced to retry, it will roll back the transaction,  go to the onretry block, and retry from the beginning until the defined  retry count is reached.   } onretry {    The end curly bracket marks the end of the transaction and the transaction will  be committed or rolled back at this point.   io:println(\"Retrying transaction\");  } committed {    The onretry block will be executed whenever the transaction is retried until it  reaches the retry count. A transaction could be retried if it fails due to an  exception or throw statement or from an explicit retry statement.   io:println(\"Transaction committed\");  } aborted {    Any action that needs to be performed after the transaction is  committed should be added here.   io:println(\"Transaction aborted\");  }    If the transaction is aborted, any action that needs to perform after  the abortion should be added here.   ret = testDB->update(\"DROP TABLE CUSTOMER\");  handleUpdate(ret, \"Drop table CUSTOMER\");    Drop the tables.   ret = testDB->update(\"DROP TABLE SALARY\");  handleUpdate(ret, \"Drop table SALARY\"); }    function handleUpdate(jdbc:UpdateResult|error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message + \" status: \", returned.updatedRowCount);  } else {  io:println(message + \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   # Before running this sample, change the H2 DB connection properties as required.    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run --experimental local_transactions.bal [ballerina/http] started HTTP/WS listener 172.17.0.1:49479 Create CUSTOMER table status: 0 Create SALARY table status: 0 2020-03-18 12:36:26,983 INFO [ballerina/transactions] - Created transaction: 17130bbc-28e0-414d-b0a0-e20efccdacec Inserted count: 1 2020-03-18 12:36:26,999 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 17130bbc-28e0-414d-b0a0-e20efccdacec:$anon$.$0 Transaction committed Drop table CUSTOMER status: 0 Drop table SALARY status: 0 [ballerina/http] started HTTP/WS listener 192.168.1.3:63458 [ballerina/http] stopped HTTP/WS listener 192.168.1.3:63458"},{"page":"/learn/by-example/locks.html","name":"Lock","summary":"Ballerina locks are used for concurrency management. The encapsulating block of statements will acquire\n the locks for each global or service level variable reference that is used within the block or for any\n field access of an object or a record. When there is nested field access (e.g., a record ...","content":"/  /  / Lock  import ballerina/io; int counter = 0;public function main() {  process();  io:println(\"final counter value - \", counter);  io:println(\"final count field value - \", counterObj.count); }type Counter object {  int count = 0; public function update() {  foreach var i in 1 ... 1000 {  lock {  self.count = self.count + 1;  }  }  } }; Counter counterObj = new;function process() {  worker w1 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {  counter = counter + 1;  }  }  }  worker w2 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {  counter = counter + 1;  }  }  }  worker w3 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {  counter = counter + 1;  }  }  }  worker w4 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {  counter = counter + 1;  }  }  }  var result = wait {w1, w2, w3, w4}; }    Lock  Ballerina locks are used for concurrency management. The encapsulating block of statements will acquire  the locks for each global or service level variable reference that is used within the block or for any  field access of an object or a record. When there is nested field access (e.g., a record within a record),  all the field accesses of the records will be locked.  Locks in Ballerina are currently an experimental feature.  Thus, use the –experimental flag to enable them.    import ballerina/io;    int counter = 0;    The counter variable will be shared among multiple workers.   public function main() {  process();  io:println(\"final counter value - \", counter);  io:println(\"final count field value - \", counterObj.count); }    type Counter object {  int count = 0;    public function update() {  foreach var i in 1 ... 1000 {  lock {    self.count = self.count + 1;  }  }  } };    Locks the count field variable and increments the count.  The count field of the same object instance will be locked.   Counter counterObj = new;    The counterObj object instance will be shared among multiple workers.   function process() {  worker w1 {  counterObj.update();    foreach var i in 1 ... 1000 {  lock {    Locks the shared counter variable and increments the counter.   counter = counter + 1;  }  }  }  worker w2 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {    Locks the shared counter variable and increments the counter.   counter = counter + 1;  }  }  }  worker w3 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {    Locks the shared counter variable and increments the counter.   counter = counter + 1;  }  }  }  worker w4 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {    Locks the shared counter variable and increments the counter.   counter = counter + 1;  }  }  }    Locks the shared counter variable and increments the counter.   var result = wait {w1, w2, w3, w4}; }    Waits for all workers to complete.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run locks.bal final counter value - 4000 final count field value - 4000"},{"page":"/learn/by-example/log-api.html","name":"Log","summary":"The ballerina/log module contains the Ballerina-log-handling functions including ‘DEBUG’, ‘ERROR’, ‘INFO’, ‘TRACE’,\n‘WARN’, ‘OFF’, and ‘ALL’.The Ballerina log API provides functions to log at five levels, which are\n DEBUG, ERROR, INFO, TRACE, and WARN. By default, all log\n messages are logged to the console at the INFO level. In addition to\n ...","content":"/  /  / Log  import ballerina/io; import ballerina/log;public function main() {  error e = error(\"error occurred\");  log:printDebug(\"debug log\");  log:printError(\"error log\");  log:printError(\"error log with cause\", e);  log:printInfo(\"info log\");  log:printTrace(\"trace log\");  log:printWarn(\"warn log\");  Fruit apple = new (\"Apple\");  Fruit orange = new (\"Orange\"); log:printDebug(\"Name of the fruit is Strawberry.\");  log:printDebug(io:sprintf(\"Names of the fruits are %s, %s.\", apple.getName(), orange.getName()));  log:printDebug(function() returns string {  return io:sprintf(\"Name of the fruit is is %s\", apple.getName());  }); }public type Fruit object {  string name;  public function __init(string name) {  self.name = name;  }  function getName() returns string {  return self.name;  } };    Log  The ballerina/log module contains the Ballerina-log-handling functions including ‘DEBUG’, ‘ERROR’, ‘INFO’, ‘TRACE’, ‘WARN’, ‘OFF’, and ‘ALL’.    import ballerina/io; import ballerina/log;    public function main() {  error e = error(\"error occurred\");    log:printDebug(\"debug log\");  log:printError(\"error log\");  log:printError(\"error log with cause\", e);  log:printInfo(\"info log\");  log:printTrace(\"trace log\");  log:printWarn(\"warn log\");    The Ballerina log API provides functions to log at five levels, which are  DEBUG, ERROR, INFO, TRACE, and WARN. By default, all log  messages are logged to the console at the INFO level. In addition to  these log levels, there are 2 additional levels named OFF and ALL.  OFF turns off logging and ALL enables all the log levels. The log  level can be configured via a Ballerina configuration file or CLI  parameters.   To set the log level of the API, use the following CLI parameter: --b7a.log.level=[LOG_LEVEL]  To configure using a configuration file, place the entry given below in  the file:   [b7a.log]  level=\"[LOG_LEVEL]\"    Fruit apple = new (\"Apple\");  Fruit orange = new (\"Orange\");    Each module can also be assigned its own log level. To assign a  log level to a module, provide the following configuration  <MODULE_NAME>.loglevel.  E.g., --foo.loglevel=DEBUG   log:printDebug(\"Name of the fruit is Strawberry.\");  log:printDebug(io:sprintf(\"Names of the fruits are %s, %s.\", apple.getName(), orange.getName()));    log:printDebug(function() returns string {  return io:sprintf(\"Name of the fruit is is %s\", apple.getName());  }); }    Logic constructing log messages with expensive operations can alternatively be passed as a function  pointer implementation. The function will be executed if and only if that particular log level is enabled.   public type Fruit object {  string name;  public function __init(string name) {  self.name = name;  }  function getName() returns string {  return self.name;  } };    # As shown in the output, only the `INFO` and higher level logs are logged by default. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run log_api.bal 2019-08-09 11:47:07,334 ERROR [ballerina/log] - error log 2019-08-09 11:47:07,340 ERROR [ballerina/log] - error log with cause : error error occurred 2019-08-09 11:47:07,341 INFO [ballerina/log] - info log 2019-08-09 11:47:07,342 WARN [ballerina/log] - warn log    # If the log level is set to `TRACE`, logs of all log levels are logged. $ ballerina run log_api.bal --b7a.log.level=TRACE 2019-08-09 11:48:04,411 DEBUG [ballerina/log] - debug log 2019-08-09 11:48:04,415 ERROR [ballerina/log] - error log 2019-08-09 11:48:04,416 ERROR [ballerina/log] - error log with cause : error error occurred 2019-08-09 11:48:04,416 INFO [ballerina/log] - info log 2019-08-09 11:48:04,417 TRACE [ballerina/log] - trace log 2019-08-09 11:48:04,421 WARN [ballerina/log] - warn log 2019-08-09 12:17:35,946 DEBUG [ballerina/log] - Name of the fruit is Strawberry. 2019-08-09 12:17:35,947 DEBUG [ballerina/log] - Names of the fruits are Apple, Orange. 2019-08-09 12:17:35,947 DEBUG [ballerina/log] - Name of the fruit is is Apple."},{"page":"/learn/by-example/math-functions.html","name":"Math","summary":"The Ballerina Math API contains methods to perform various numerical operations.This returns the absolute value of a float value.This returns the absolute value of an int value.This returns the arc cosine of a value.This returns the arc sine of a value.This returns the arc tangent of a value.This returns the ...","content":"/  /  / Math  import ballerina/io; import ballerina/math;public function main() { io:println(\"Value of PI : \", math:PI);  io:println(\"Value of E : \", math:E);  float absoluteFloatValue = math:absFloat(-152.2544);  io:println(\"Absolute value of -152.2544 : \", absoluteFloatValue);  int absoluteIntValue = math:absInt(-152);  io:println(\"Absolute value of -152 : \", absoluteIntValue);  float acosValue = math:acos(0.027415567780803774);  io:println(\"Arc cosine of 0.027415567780803774 : \", acosValue);  float arcSineValue = math:asin(0.027415567780803774);  io:println(\"Arc sine of 0.027415567780803774 : \", arcSineValue);  float arcTangent = math:atan(0.027415567780803774);  io:println(\"Arc tangent of 0.027415567780803774 : \", arcTangent);  float cubeRoot = math:cbrt(-27.0);  io:println(\"Cube root of -27.0 : \", cubeRoot); }    Math  The Ballerina Math API contains methods to perform various numerical operations.    import ballerina/io; import ballerina/math;    public function main() {    io:println(\"Value of PI : \", math:PI);  io:println(\"Value of E : \", math:E);    float absoluteFloatValue = math:absFloat(-152.2544);  io:println(\"Absolute value of -152.2544 : \", absoluteFloatValue);    This returns the absolute value of a float value.   int absoluteIntValue = math:absInt(-152);  io:println(\"Absolute value of -152 : \", absoluteIntValue);    This returns the absolute value of an int value.   float acosValue = math:acos(0.027415567780803774);  io:println(\"Arc cosine of 0.027415567780803774 : \", acosValue);    This returns the arc cosine of a value.   float arcSineValue = math:asin(0.027415567780803774);  io:println(\"Arc sine of 0.027415567780803774 : \", arcSineValue);    This returns the arc sine of a value.   float arcTangent = math:atan(0.027415567780803774);  io:println(\"Arc tangent of 0.027415567780803774 : \", arcTangent);    This returns the arc tangent of a value.   float cubeRoot = math:cbrt(-27.0);  io:println(\"Cube root of -27.0 : \", cubeRoot);    This returns the cube root of a float value.   }    There are over 40 methods in the ballerina math API that can be used to perform numeric operations. You can find them in the ballerina/math module.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run math_functions.bal Value of PI : 3.141592653589793 Value of E : 2.718281828459045 Absolute value of -152.2544 : 152.2544 Absolute value of -152 : 152 Arc cosine of 0.027415567780803774 : 1.5433773235341761 Arc sine of 0.027415567780803774 : 0.02741900326072046 Arc tangent of 0.027415567780803774 : 0.0274087022410345 Cube root of -27.0 : -3.0"},{"page":"/learn/by-example/match.html","name":"Match","summary":"A match statement is a value-switching construct that allows selective code execution based on\n matching the value of the expression that is being matched against the pattern.The value of the counter variable is matched against the given value match patterns.The value match can also be used with binary OR expression.The ...","content":"/  /  / Match  import ballerina/io;public function main() { int[5] intArray = [0, 1, 2, 3, 4]; foreach var counter in intArray {  match counter {  0 => {  io:println(\"value is: 0\");  }  1 => {  io:println(\"value is: 1\");  }  2 => {  io:println(\"value is: 2\");  }  3 => {  io:println(\"value is: 3\");  }  4 => {  io:println(\"value is: 4\");  }  5 => {  io:println(\"value is: 5\");  }  }  } string[] animals = [\"Cat\", \"Canine\", \"Mouse\", \"Horse\"]; foreach string animal in animals {  match animal {  \"Mouse\" => {  io:println(\"Mouse\");  }  \"Dog\"|\"Canine\" => {  io:println(\"Dog\");  }  \"Cat\"|\"Feline\" => {  io:println(\"Cat\");  }  _ => {  io:println(\"Match All\");  }  }  } }    Match  A match statement is a value-switching construct that allows selective code execution based on  matching the value of the expression that is being matched against the pattern.    import ballerina/io;    public function main() {    int[5] intArray = [0, 1, 2, 3, 4];    foreach var counter in intArray {    match counter {  0 => {  io:println(\"value is: 0\");  }  1 => {  io:println(\"value is: 1\");  }  2 => {  io:println(\"value is: 2\");  }  3 => {  io:println(\"value is: 3\");  }  4 => {  io:println(\"value is: 4\");  }  5 => {  io:println(\"value is: 5\");  }  }  }    The value of the counter variable is matched against the given value match patterns.   string[] animals = [\"Cat\", \"Canine\", \"Mouse\", \"Horse\"];    foreach string animal in animals {    match animal {  \"Mouse\" => {  io:println(\"Mouse\");  }  \"Dog\"|\"Canine\" => {  io:println(\"Dog\");  }  \"Cat\"|\"Feline\" => {  io:println(\"Cat\");  }    The value match can also be used with binary OR expression.   _ => {  io:println(\"Match All\");  }  }  } }    The pattern _ can be used as the final static value match pattern, which will be matched against all values.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run match.bal value is: 0 value is: 1 value is: 2 value is: 3 value is: 4 Cat Dog Mouse Match All"},{"page":"/learn/by-example/maps.html","name":"Maps","summary":"The map type in Ballerina defines a mutable mapping from keys (that are strings) to values of the type specified as\n the map’s constraint type.Declare a map constrained by the type string.You can also declare and initialize a map with a mapping constructor\n expression.A field can be specified as a ...","content":"/  /  / Maps  import ballerina/io;public function main() {  map<string> m; string city = \"Colombo\";  string country = \"Sri Lanka\";  string codeLiteral = \"code\";  map<string> addrMap = {  line1: \"No. 20\",  line2: \"Palm Grove\",  city: \"Colombo 03\",  country,  [codeLiteral]: \"00300\"  };  io:println(addrMap);  string? countryValue = addrMap[\"country\"]; if (countryValue is string) {  io:println(countryValue);  } else {  io:println(\"key 'country' not found\");  }  string line2Value = addrMap.get(\"line2\");  io:println(line2Value);  boolean hasPostalCode = addrMap.hasKey(\"postalCode\");  io:println(hasPostalCode);  addrMap[\"postalCode\"] = \"00300\";  io:println(addrMap);  io:println(addrMap.keys());  io:println(addrMap.length());  string removedElement = addrMap.remove(\"code\");  io:println(addrMap);  addrMap.forEach(function (string value) {  io:println(value);  }); map<int> marks = {sam: 50, jon: 60};  map<int> modifiedMarks = marks.entries().map(function ([string, int] pair)  returns int {  var [name, score] = pair;  io:println(io:sprintf(\"%s scored: %d\", name, score));  return score + 10;  }  );  io:println(modifiedMarks);  map<int> allMarks = {jane: 100, ...modifiedMarks, amy: 75};  io:println(allMarks); }    Maps  The map type in Ballerina defines a mutable mapping from keys (that are strings) to values of the type specified as  the map’s constraint type.    import ballerina/io;    public function main() {    map<string> m;    Declare a map constrained by the type string.   string city = \"Colombo\";  string country = \"Sri Lanka\";  string codeLiteral = \"code\";    map<string> addrMap = {    You can also declare and initialize a map with a mapping constructor  expression.   line1: \"No. 20\",  line2: \"Palm Grove\",    A field can be specified as a key-value pair.   city: \"Colombo 03\",    The value in a key-value pair can be any expression, which evaluates  to a value of a type that belongs to the constraint type of the map.   country,    A field can also be just a variable reference, which would result  in the variable name being the field name and the variable itself  being the value expression.  This is equivalent to saying country: country.   [codeLiteral]: \"00300\"  };  io:println(addrMap);    The key in a key-value pair can also be a computed key.  A computed key is defined by specifying the key expression within  brackets. The key expression must belong to type string.  For a computed key, the key expression is evaluated at runtime and  the resulting value is used as the key.   string? countryValue = addrMap[\"country\"];    Member access can be used to retrieve a value from a map.  Member access returns the value if a field exists in the map with the  specified key. Else, it returns () if a field does not exist with the specified key.  Thus, the type of a member access expression for a map is the union of  the constraint type and the nil type.   if (countryValue is string) {  io:println(countryValue);  } else {  io:println(\"key 'country' not found\");  }    string line2Value = addrMap.get(\"line2\");  io:println(line2Value);    Retrieve a value using the .get() method.  If the map has a field with the specified key, .get() returns the value.  Else, it panics if the map does not have a field with the specified key.  Thus, the return type of .get() when invoked on a map is the map’s constraint type.   boolean hasPostalCode = addrMap.hasKey(\"postalCode\");  io:println(hasPostalCode);    The .hasKey() function checks if a map contains the specified key.   addrMap[\"postalCode\"] = \"00300\";  io:println(addrMap);    Member access expressions can be used on the left hand side of an assignment  to add fields to a map or update an already-existing field in the map.   io:println(addrMap.keys());    The .keys() method returns the keys of the map as an array.   io:println(addrMap.length());    Print the number of fields in the map.   string removedElement = addrMap.remove(\"code\");  io:println(addrMap);    Fields can be removed using the .remove() method.   addrMap.forEach(function (string value) {  io:println(value);  });    Maps support functional iteration.   map<int> marks = {sam: 50, jon: 60};    map<int> modifiedMarks = marks.entries().map(function ([string, int] pair)  returns int {  var [name, score] = pair;  io:println(io:sprintf(\"%s scored: %d\", name, score));  return score + 10;  }  );  io:println(modifiedMarks);    Calling the .entries() method on a map will return the key-value pairs as  an array of tuples.   map<int> allMarks = {jane: 100, ...modifiedMarks, amy: 75};  io:println(allMarks); }    A mapping constructor expression can also include a spread field  referring to another mapping value. When a spread field is specified,  all the fields of the relevant mapping value are added to the new  mapping value being created.  A spread field is used with modifiedMarks to include all the entries  in modifiedMarks when creating allMarks.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run maps.bal line1=No. 20 line2=Palm Grove city=Colombo 03 country=Sri Lanka code=00300 Sri Lanka Palm Grove false line1=No. 20 line2=Palm Grove city=Colombo 03 country=Sri Lanka code=00300 postalCode=00300 line1 line2 city country code postalCode 6 line1=No. 20 line2=Palm Grove city=Colombo 03 country=Sri Lanka postalCode=00300 No. 20 Palm Grove Colombo 03 Sri Lanka 00300 sam scored: 50 jon scored: 60 sam=60 jon=70 jane=100 sam=60 jon=70 amy=75"},{"page":"/learn/by-example/modules.html","name":"Modules","summary":"Ballerina program files have the .bal extension and the file names do not have semantics.\n These source files can be grouped into modules. The code within a module can refer to any module-level symbol (name) declared\n in the same module. Module names can only contain alphanumerics, underscores, and periods and ...","content":"/  /  / Modules  import ballerina/math; import ballerina/io as console;public function main() {  float piValue = math:PI;  console:println(piValue); }    Modules  Ballerina program files have the .bal extension and the file names do not have semantics.  These source files can be grouped into modules. The code within a module can refer to any module-level symbol (name) declared  in the same module. Module names can only contain alphanumerics, underscores, and periods and the maximum length is 256 characters.  By default, the last element of the module name becomes an alias that is used to refer to the symbols of the imported module.  If the module name has periods, then the word after the last period becomes the alias.    import ballerina/math;    This example imports a module. You can only refer to the public symbols of  an imported module.   import ballerina/io as console;    Declare an explicit alias.   public function main() {    float piValue = math:PI;    Refer symbols of another module.  math:PI is a qualified identifier. Note the usage of the module alias.   console:println(piValue); }    Use the explicit alias console to invoke a function defined in the ballerina/io module.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run modules.bal 3.141592653589793"},{"page":"/learn/by-example/mutual-ssl.html","name":"Mutual SSL","summary":"Ballerina supports mutual SSL, which is a certificate-based authentication process where two parties (client and\nserver) authenticate each other by verifying the digital certificates. It ensures that both parties are assured of\neach other’s identity.Create an HTTP listener configuration, which will configure a listener to\n accept new connections that are secured via ...","content":"/  /  / Mutual SSL  import ballerina/config; import ballerina/http; import ballerina/log; http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  },  protocol: {  name: \"TLS\",  versions: [\"TLSv1.2\", \"TLSv1.1\"]  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"],  sslVerifyClient: \"require\"  } }; listener http:Listener helloWorldEP = new (9095, helloWorldEPConfig);@http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Successful\");  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }import ballerina/config; import ballerina/http; import ballerina/log; http:ClientConfiguration clientEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  },  protocol: {  name: \"TLS\"  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  } };public function main() {  http:Client clientEP = new(\"https://localhost:9095\", clientEPConfig);  var resp = clientEP->get(\"/hello\");  if (resp is http:Response) {  var payload = resp.getTextPayload();  if (payload is string) {  log:printInfo(payload);  } else {  log:printError(<string>payload.detail()[\"message\"]);  }  } else {  log:printError(<string>resp.detail()[\"message\"]);  } }    Mutual SSL  Ballerina supports mutual SSL, which is a certificate-based authentication process where two parties (client and server) authenticate each other by verifying the digital certificates. It ensures that both parties are assured of each other’s identity.    import ballerina/config; import ballerina/http; import ballerina/log;    http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  },    Create an HTTP listener configuration, which will configure a listener to  accept new connections that are secured via mutual SSL.   protocol: {  name: \"TLS\",  versions: [\"TLSv1.2\", \"TLSv1.1\"]  },    Enable the preferred SSL protocol and its versions.   ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"],    Configure the preferred ciphers.   sslVerifyClient: \"require\"  } };    Enable mutual SSL.   listener http:Listener helloWorldEP = new (9095, helloWorldEPConfig);    Create a listener endpoint.   @http:ServiceConfig {  basePath: \"/hello\" }    service helloWorld on helloWorldEP {    Bind the service to the listener endpoint that you declared earlier.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    var result = caller->respond(\"Successful\");  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Send the response to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command along with the Ballerina home path as a config. $ ballerina run mutual_ssl_service.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9095    import ballerina/config; import ballerina/http; import ballerina/log;    http:ClientConfiguration clientEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  },  protocol: {  name: \"TLS\"  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  } };    Create a client configuration to be passed to the client endpoint.  Configure the keyStoreFile, keyStorePassword, trustStoreFile, and  thetrustStorePassword, which are required to enable mutual SSL.   public function main() {    http:Client clientEP = new(\"https://localhost:9095\", clientEPConfig);    Create an HTTP client to interact with the created listener endpoint.   var resp = clientEP->get(\"/hello\");  if (resp is http:Response) {    Send a GET request to the listener.   var payload = resp.getTextPayload();  if (payload is string) {    If the request is successful, retrieve the text payload from the  response.   log:printInfo(payload);  } else {    Log the retrieved text payload.   log:printError(<string>payload.detail()[\"message\"]);  }  } else {    If an error occurs while retrieving the text payload, log  the error.   log:printError(<string>resp.detail()[\"message\"]);  } }    If an error occurs while getting the response, log the error.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command along with the Ballerina home path as a config. $ ballerina run ssl_client.bal --b7a.home=<ballerina_home_path> INFO [] - Successful"},{"page":"/learn/by-example/mysql-complex-type-queries.html","name":"MySQL Query with Complex Types","summary":"This example demonstrates how to use the MySQL client with complex data types\n such as binary, blobs, and date/time fields. Note that the MySQL database\n driver JAR should be placed in the BALLERINA_HOME/bre/lib directory. The\n MySQL connector uses some database properties from MySQL version 8.0.x\n onwards. Therefore, it is recommended ...","content":"/  /  / MySQL Query with Complex Types  import ballerina/io; import ballerina/mysql; import ballerina/sql; import ballerina/time; string dbUser = \"root\"; string dbPassword = \"Test@123\"; type BinaryType record {|  int row_id;  byte[] blob_type;  byte[] binary_type; |};type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Time timestamp_type;  string datetime_type; |};function queryBinaryType(mysql:Client mysqlClient) {  io:println(\"------ Query Binary Type -------\");  stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from BINARY_TYPES\"); io:println(\"Result 1:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  resultStream = mysqlClient->query(\"Select * from BINARY_TYPES\", BinaryType);  stream<BinaryType, sql:Error> binaryResultStream =  <stream<BinaryType, sql:Error>>resultStream; io:println(\"Result 2:\");  e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }function queryDateTimeType(mysql:Client mysqlClient) {  io:println(\"------ Query Date Time Type -------\");  stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from DATE_TIME_TYPES\"); io:println(\"Result 1:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  resultStream = mysqlClient->query(\"Select * from DATE_TIME_TYPES\",  DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream; io:println(\"Result 2:\");  e = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); } function initializeTable() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result = check  mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS MYSQL_BBE\"); result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \" +  \"MYSQL_BBE.BINARY_TYPES\");  result = check mysqlClient->execute(\"CREATE TABLE MYSQL_BBE.BINARY_TYPES\"+  \"(row_id INTEGER NOT NULL, blob_type BLOB(1024), binary_type \"+  \"BINARY (27), PRIMARY KEY (row_id))\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.BINARY_TYPES \"+  \"(row_id, blob_type, binary_type) VALUES (1, \"+  \"X'77736F322062616C6C6572696E6120626C6F6220746573742E',\" +  \"X'77736F322062616C6C6572696E612062696E61727920746573742E')\"); result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \" +  \"MYSQL_BBE.DATE_TIME_TYPES\");  result = check mysqlClient->execute(\"CREATE TABLE \"+  \"MYSQL_BBE.DATE_TIME_TYPES(row_id INTEGER NOT NULL,\" +  \"date_type DATE, time_type TIME, timestamp_type timestamp, \"+  \"datetime_type datetime, PRIMARY KEY (row_id))\");  result = check mysqlClient->execute(\"Insert into \" +  \"MYSQL_BBE.DATE_TIME_TYPES (row_id, date_type, time_type, \"+  \"timestamp_type, datetime_type) values (1,'2017-05-23','14:15:23',\"+  \"'2017-01-25 16:33:55','2017-01-25 16:33:55')\"); check mysqlClient.close(); }public function main() {  sql:Error? err = initializeTable();  if (err is sql:Error) {  io:println(\"Sample data initialization failed!\", err);  } else {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = \"MYSQL_BBE\");  if (mysqlClient is mysql:Client) {  queryBinaryType(mysqlClient);  queryDateTimeType(mysqlClient);  io:println(\"Sample executed successfully!\");  sql:Error? e = mysqlClient.close();  } else {  io:println(\"MySQL Client initialization for querying data\" +  \"failed!!\", mysqlClient);  }  } }    MySQL Query with Complex Types  This example demonstrates how to use the MySQL client with complex data types  such as binary, blobs, and date/time fields. Note that the MySQL database  driver JAR should be placed in the BALLERINA_HOME/bre/lib directory. The  MySQL connector uses some database properties from MySQL version 8.0.x  onwards. Therefore, it is recommended to use a MySQL driver version greater  than 8.0.x.    import ballerina/io; import ballerina/mysql; import ballerina/sql; import ballerina/time;    string dbUser = \"root\"; string dbPassword = \"Test@123\";    Username and password of the MySQL database. This is used in below examples  when initializing the MySQL connector. You need to change these based on  your setup if you are trying locally.   type BinaryType record {|  int row_id;  byte[] blob_type;  byte[] binary_type; |};    Define the record types to be used in the below examples.   type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Time timestamp_type;  string datetime_type; |};    function queryBinaryType(mysql:Client mysqlClient) {  io:println(\"------ Query Binary Type -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from BINARY_TYPES\");    Select the rows with binary data types.  The name and type of the attributes within the record from the  resultStream will be automatically identified based on the column  name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = mysqlClient->query(\"Select * from BINARY_TYPES\", BinaryType);  stream<BinaryType, sql:Error> binaryResultStream =  <stream<BinaryType, sql:Error>>resultStream;    Since the rowType is provided as a BinaryType, the resultStream will  have BinaryType records.   io:println(\"Result 2:\");    e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the binaryResultStream.   function queryDateTimeType(mysql:Client mysqlClient) {  io:println(\"------ Query Date Time Type -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from DATE_TIME_TYPES\");    Select the rows with date/time data types.  The name and type of the attributes within the record from the  resultStream will be automatically identified based on the column  name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = mysqlClient->query(\"Select * from DATE_TIME_TYPES\",  DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream;    Since the rowType is provided as a DateTimeType, the resultStream  will have DateTimeType records. The Date, Time, DateTime, and  Timestamp fields of the database table can be mapped to time:Time,  string and int types in Ballerina.   io:println(\"Result 2:\");    e = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the dateResultStream.   function initializeTable() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result = check  mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS MYSQL_BBE\");    Initialize the database table with sample data.   result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \" +  \"MYSQL_BBE.BINARY_TYPES\");  result = check mysqlClient->execute(\"CREATE TABLE MYSQL_BBE.BINARY_TYPES\"+  \"(row_id INTEGER NOT NULL, blob_type BLOB(1024), binary_type \"+  \"BINARY (27), PRIMARY KEY (row_id))\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.BINARY_TYPES \"+  \"(row_id, blob_type, binary_type) VALUES (1, \"+  \"X'77736F322062616C6C6572696E6120626C6F6220746573742E',\" +  \"X'77736F322062616C6C6572696E612062696E61727920746573742E')\");    result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \" +  \"MYSQL_BBE.DATE_TIME_TYPES\");  result = check mysqlClient->execute(\"CREATE TABLE \"+  \"MYSQL_BBE.DATE_TIME_TYPES(row_id INTEGER NOT NULL,\" +  \"date_type DATE, time_type TIME, timestamp_type timestamp, \"+  \"datetime_type datetime, PRIMARY KEY (row_id))\");  result = check mysqlClient->execute(\"Insert into \" +  \"MYSQL_BBE.DATE_TIME_TYPES (row_id, date_type, time_type, \"+  \"timestamp_type, datetime_type) values (1,'2017-05-23','14:15:23',\"+  \"'2017-01-25 16:33:55','2017-01-25 16:33:55')\");    check mysqlClient.close(); }    public function main() {    sql:Error? err = initializeTable();  if (err is sql:Error) {  io:println(\"Sample data initialization failed!\", err);  } else {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = \"MYSQL_BBE\");  if (mysqlClient is mysql:Client) {    Initialize the MySQL client.   queryBinaryType(mysqlClient);  queryDateTimeType(mysqlClient);  io:println(\"Sample executed successfully!\");    Execute the complex data type queries.   sql:Error? e = mysqlClient.close();  } else {  io:println(\"MySQL Client initialization for querying data\" +  \"failed!!\", mysqlClient);  }  } }    Close the MySQL client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run mysql-complex-type-queries.bal    ------ Query Binary Type ------- Result 1: row_id=1 blob_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 108 111 98 32 116 101 115 116 46 binary_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 105 110 97 114 121 32 116 101 115 116 46 Result 2: row_id=1 blob_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 108 111 98 32 116 101 115 116 46 binary_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 105 110 97 114 121 32 116 101 115 116 46 ------ ********* ------- ------ Query Date Time Type ------- Result 1: row_id=1 date_type=2017-05-23+05:30 time_type=19:45:23.000+05:30 timestamp_type=2017-01-25T22:03:55.000+05:30 datetime_type=2017-01-25T22:03:55.000+05:30 Result 2: row_id=1 date_type=2017-05-23+05:30 time_type=51323000 timestamp_type=time=1485362035000 zone=id=UTC offset=0 datetime_type=2017-01-25T22:03:55.000+05:30 ------ ********* ------- Sample executed successfully!"},{"page":"/learn/by-example/mysql-init-options.html","name":"MySQL Client Initialization","summary":"This example demonstrates how to initialize the MySQL client with different\n initialization options. Note that, the MySQL database driver JAR should be\n placed in the BALLERINA_HOME/bre/lib directory. The MySQL connector uses\n database properties from MySQL version 8.0.x onwards. Therefore, it is\n recommended to use a MySQL driver version greater than ...","content":"/  /  / MySQL Client Initialization  import ballerina/io; import ballerina/mysql; import ballerina/sql; string dbUser = \"root\"; string dbPassword = \"Test@123\";function initializeClients() returns sql:Error? {  mysql:Client|sql:Error mysqlClient1 = new ();  if (mysqlClient1 is sql:Error) {  io:println(\"Error when initializing the MySQL client without any \" +  \"params. \", mysqlClient1);  } else {  io:println(\"Simple MySQL client created successfully\");  check mysqlClient1.close();  }  mysql:Client mysqlClient2 = check new (\"localhost\", dbUser, dbPassword);  io:println(\"MySQL client with user and password created.\");  mysql:Client mysqlClient3 = check new (user = dbUser,  password = dbPassword);  io:println(\"MySQL client with user and password created \" +  \"with default host.\");  mysql:Client mysqlClient4 = check new (\"localhost\", dbUser, dbPassword,  \"information_schema\", 3306);  io:println(\"MySQL client with host, user, password, database and \" +  \"port created.\");  mysql:Options mysqlOptions = {  ssl: {  mode: mysql:SSL_PREFERRED  },  connectTimeoutInSeconds: 10  };  mysql:Client mysqlClient5 = check new (user = dbUser, password = dbPassword,  options = mysqlOptions);  io:println(\"MySQL client with database options created.\");  sql:ConnectionPool connPool = {  maxOpenConnections: 5,  maxConnectionLifeTimeInSeconds: 2000.0,  minIdleConnections: 5  };  mysql:Client mysqlClient6 = check new (user = dbUser, password = dbPassword,  options = mysqlOptions, connectionPool = connPool);  io:println(\"MySQL client with connection pool created.\");  mysql:Client mysqlClient7 = check new (\"localhost\", dbUser, dbPassword,  \"information_schema\", 3306, mysqlOptions, connPool);  mysql:Client mysqlClient8 = check new (host = \"localhost\",  user = dbUser, password = dbPassword, database =  \"information_schema\", port = 3306, options = mysqlOptions,  connectionPool = connPool);  check mysqlClient2.close();  check mysqlClient3.close();  check mysqlClient4.close();  check mysqlClient5.close();  check mysqlClient6.close();  check mysqlClient7.close();  check mysqlClient8.close(); } public function main() {  sql:Error? err = initializeClients();  if (err is sql:Error) {  io:println(\"Error occured, initialization failed! \", err);  } else {  io:println(\"Sample executed successfully!\");  } }    MySQL Client Initialization  This example demonstrates how to initialize the MySQL client with different  initialization options. Note that, the MySQL database driver JAR should be  placed in the BALLERINA_HOME/bre/lib directory. The MySQL connector uses  database properties from MySQL version 8.0.x onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.x    import ballerina/io; import ballerina/mysql; import ballerina/sql;    string dbUser = \"root\"; string dbPassword = \"Test@123\";    Username and password of the MySQL database. This is used in the below  examples when initializing the MySQL connector. You need to change these  based on your setup to try locally.   function initializeClients() returns sql:Error? {    mysql:Client|sql:Error mysqlClient1 = new ();  if (mysqlClient1 is sql:Error) {  io:println(\"Error when initializing the MySQL client without any \" +  \"params. \", mysqlClient1);  } else {  io:println(\"Simple MySQL client created successfully\");  check mysqlClient1.close();  }    Initialize the MySQL Client without any parameters. In that case,  all parameters will be using the default values:localhost for host,  3306 for port, and () for user, password, and database.   mysql:Client mysqlClient2 = check new (\"localhost\", dbUser, dbPassword);  io:println(\"MySQL client with user and password created.\");    Initialize the MySQL client by providing the username and password.   mysql:Client mysqlClient3 = check new (user = dbUser,  password = dbPassword);  io:println(\"MySQL client with user and password created \" +  \"with default host.\");    Initialize the MySQL client by providing the username, password,  and default host.   mysql:Client mysqlClient4 = check new (\"localhost\", dbUser, dbPassword,  \"information_schema\", 3306);  io:println(\"MySQL client with host, user, password, database and \" +  \"port created.\");    Initialize the MySQL client by providing the host, username,  password, database, and port.   mysql:Options mysqlOptions = {    Initialize the MySQL client by providing additional  MySQL database properties.   ssl: {    SSL is enabled by default and the default mode is  sql:SSL_PREFERRED. SSL will be disabled, if ssl is assigned to  ().   mode: mysql:SSL_PREFERRED  },  connectTimeoutInSeconds: 10  };    Possible options for mode are sql:SSL_PREFERRED,  sql:SSL_REQUIRED, sql:SSL_VERIFY_CERT, and  sql:SSL_VERIFY_IDENTITY. For details on each mode, go to  the MySQL reference ().   mysql:Client mysqlClient5 = check new (user = dbUser, password = dbPassword,  options = mysqlOptions);  io:println(\"MySQL client with database options created.\");    Initialize the MySQL client with MySQL database options.   sql:ConnectionPool connPool = {    Connection pool is used to share and use the database connections  efficiently. In the above samples, the global connection pool is  created and shared among all the database clients since the  connectionPool property is not set.   maxOpenConnections: 5,    Default max number of open connections in the connection pool is 15.   maxConnectionLifeTimeInSeconds: 2000.0,    Default max life time of a connection in the connection pool is  1800 seconds (30 minutes).   minIdleConnections: 5  };    Default minimum number of idle connections is 15.   mysql:Client mysqlClient6 = check new (user = dbUser, password = dbPassword,  options = mysqlOptions, connectionPool = connPool);  io:println(\"MySQL client with connection pool created.\");    Initialize the MySQL client with the specific connection pool.   mysql:Client mysqlClient7 = check new (\"localhost\", dbUser, dbPassword,  \"information_schema\", 3306, mysqlOptions, connPool);    Initialize the MySQL client with all the parameters.   mysql:Client mysqlClient8 = check new (host = \"localhost\",  user = dbUser, password = dbPassword, database =  \"information_schema\", port = 3306, options = mysqlOptions,  connectionPool = connPool);    All properties are optional.  Hence, named attributes can be used specifically to assign  the attributes.   check mysqlClient2.close();  check mysqlClient3.close();  check mysqlClient4.close();  check mysqlClient5.close();  check mysqlClient6.close();  check mysqlClient7.close();  check mysqlClient8.close(); }    Close the clients to release the resource  and destroy the connection pool.   public function main() {  sql:Error? err = initializeClients();  if (err is sql:Error) {  io:println(\"Error occured, initialization failed! \", err);  } else {  io:println(\"Sample executed successfully!\");  } }    Initialize MySQL clients with different options.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run mysql_init_options.bal    Error when initializing the MySQL client without any params. error {ballerina/sql}ApplicationError message=error in sql connector configuration: Failed to initialize pool: Access denied for user ''@'localhost' (using password: NO) Caused by :Access denied for user ''@'localhost' (using password: NO) MySQL client with user and password created. MySQL client with user and password created with default host. MySQL client with host, user, password, database and port created. MySQL client with database options created. MySQL client with connection pool created. Sample executed successfully!"},{"page":"/learn/by-example/mysql-execute-operation.html","name":"MySQL DDL and DML Operations","summary":"This example demonstrates how to use the JDBC client with the DDL and  DML\n operations. Note that the MySQL database driver JAR should be placed in\n theBALLERINA_HOME/bre/lib directory. The MySQL connector uses database\n properties from MySQL version 8.0.x onwards. Therefore, it is\n recommended to use a MySQL driver version ...","content":"/  /  / MySQL DDL and DML Operations  import ballerina/io; import ballerina/mysql; import ballerina/sql; string dbUser = \"root\"; string dbPassword = \"Test@123\"; string dbName = \"MYSQL_BBE_EXEC\";function initializeDatabase() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result =  check mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS \" + dbName);  io:println(\"Database created. \");  check mysqlClient.close(); }function initializeTable(mysql:Client mysqlClient)  returns int|string|sql:Error? {  sql:ExecuteResult? result =  check mysqlClient->execute(\"DROP TABLE IF EXISTS Customers\");  if (result is sql:ExecuteResult) {  io:println(\"Drop table executed. \", result);  }  result = check mysqlClient->execute(\"CREATE TABLE IF NOT EXISTS Customers\" +  \"(customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300)\" +  \",lastName VARCHAR(300), registrationID INTEGER,\" +  \"creditLimit DOUBLE, country VARCHAR(300), PRIMARY KEY (customerId))\");  result = check mysqlClient->execute(\"INSERT INTO Customers (firstName,\" +  \"lastName,registrationID,creditLimit, country) VALUES ('Peter', \" +  \"'Stuart', 1, 5000.75, 'USA')\");  int|string? generatedId = (); if (result is sql:ExecuteResult) {  io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId);  generatedId = result.lastInsertId;  }  return generatedId; }function updateRecord(mysql:Client mysqlClient, int generatedId) {  string query = string ` ${generatedId}`;  sql:ExecuteResult|sql:Error? result =  mysqlClient->execute(\"Update Customers set creditLimit = 15000.5 \"+  \"where customerId =\" + generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Updated Row count: \", result?.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }function deleteRecord(mysql:Client mysqlClient, int generatedId) {  sql:ExecuteResult|sql:Error? result =  mysqlClient->execute(\"Delete from Customers where customerId = \"+  generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Deleted Row count: \", result.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }public function main() {  sql:Error? err = initializeDatabase();  if (err is ()) {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = dbName);  if (mysqlClient is mysql:Client) {  int|string|sql:Error? initResult = initializeTable(mysqlClient);  if (initResult is int) {  updateRecord(mysqlClient, initResult);  deleteRecord(mysqlClient, initResult);  io:println(\"Sample executed successfully!\");  } else if (initResult is sql:Error) {  io:println(\"Customer table initialization failed!\", initResult);  }  sql:Error? e = mysqlClient.close();  } else {  io:println(\"Table initialization failed!!\", mysqlClient);  }  } else {  io:println(\"Database initialization failed!!\", err);  } }    MySQL DDL and DML Operations  This example demonstrates how to use the JDBC client with the DDL and DML  operations. Note that the MySQL database driver JAR should be placed in  theBALLERINA_HOME/bre/lib directory. The MySQL connector uses database  properties from MySQL version 8.0.x onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.x.    import ballerina/io; import ballerina/mysql; import ballerina/sql;    string dbUser = \"root\"; string dbPassword = \"Test@123\"; string dbName = \"MYSQL_BBE_EXEC\";    Username and password of the MySQL database. This is used in the below  examples when initializing the MySQL connector. You need to change these  based on your setup if you try locally.   function initializeDatabase() returns sql:Error? {    mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);    Initialize the client without any database to create the database.   sql:ExecuteResult? result =  check mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS \" + dbName);  io:println(\"Database created. \");    Create database if it does not exist. If any error occurred,  the error will be returned.   check mysqlClient.close(); }    Close the MySQL client.   function initializeTable(mysql:Client mysqlClient)  returns int|string|sql:Error? {    sql:ExecuteResult? result =  check mysqlClient->execute(\"DROP TABLE IF EXISTS Customers\");  if (result is sql:ExecuteResult) {  io:println(\"Drop table executed. \", result);  }    Execute dropping the table. The sql:ExecuteResult is returned upon  successful execution. An error will be returned in case of a failure.   result = check mysqlClient->execute(\"CREATE TABLE IF NOT EXISTS Customers\" +  \"(customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300)\" +  \",lastName VARCHAR(300), registrationID INTEGER,\" +  \"creditLimit DOUBLE, country VARCHAR(300), PRIMARY KEY (customerId))\");    Similarly, to drop a table, the create table query is executed.  Here, the customerId is an auto-generated column.   result = check mysqlClient->execute(\"INSERT INTO Customers (firstName,\" +  \"lastName,registrationID,creditLimit, country) VALUES ('Peter', \" +  \"'Stuart', 1, 5000.75, 'USA')\");  int|string? generatedId = ();    Insert sample data into the table. The result will have  affectedRowCount and lastInsertedId with the auto-generated ID of  the last row.   if (result is sql:ExecuteResult) {  io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId);  generatedId = result.lastInsertId;  }  return generatedId; }    function updateRecord(mysql:Client mysqlClient, int generatedId) {    string query = string ` ${generatedId}`;  sql:ExecuteResult|sql:Error? result =  mysqlClient->execute(\"Update Customers set creditLimit = 15000.5 \"+  \"where customerId =\" + generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Updated Row count: \", result?.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }    Update the record with the auto-generated ID.   function deleteRecord(mysql:Client mysqlClient, int generatedId) {    sql:ExecuteResult|sql:Error? result =  mysqlClient->execute(\"Delete from Customers where customerId = \"+  generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Deleted Row count: \", result.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }    Delete the record with the auto-generated ID.   public function main() {    sql:Error? err = initializeDatabase();  if (err is ()) {    Initialize the database.   mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = dbName);  if (mysqlClient is mysql:Client) {    Initialize the MySQL client to be used for the rest of the DDL  and DML operations.   int|string|sql:Error? initResult = initializeTable(mysqlClient);  if (initResult is int) {    Initialize a table and insert data.   updateRecord(mysqlClient, initResult);    Update a record.   deleteRecord(mysqlClient, initResult);  io:println(\"Sample executed successfully!\");  } else if (initResult is sql:Error) {  io:println(\"Customer table initialization failed!\", initResult);  }    Delete a record.   sql:Error? e = mysqlClient.close();  } else {  io:println(\"Table initialization failed!!\", mysqlClient);  }  } else {  io:println(\"Database initialization failed!!\", err);  } }    Close the MySQL client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run mysql_execute_operation.bal    Database created. Drop table executed. affectedRowCount=0 lastInsertId= Rows affected: 1 Generated Customer ID: 1 Updated Row count: 1 Deleted Row count: 1 Sample executed successfully!"},{"page":"/learn/by-example/nats-basic-client.html","name":"Basic Publisher and Subscriber","summary":"The NATS client is used either to produce a message to a subject or consume a message from a subject.\n In order to execute this example, it is required that a NATS server is up and running on its default host, port, and cluster.\n For instructions on installing the NATS ...","content":"/  /  / Basic Publisher and Subscriber  import ballerina/io; import ballerina/log; import ballerina/nats; const string ESCAPE = \"!q\"; public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");  nats:Connection connection = new ();  nats:Producer producer = new (connection);  while (message != ESCAPE) {  message = io:readln(\"Message : \");  nats:Error? result = producer->publish(subject, <@untainted>message);  if (result is nats:Error) {  io:println(\"Error occurred while producing the message.\");  } else {  io:println(\"Message published successfully.\");  }  }  nats:Error? result = producer.close();  if (result is nats:Error) {  log:printError(\"Error occurred while closing the logical connection\",  result);  } result = connection.close();  if (result is nats:Error) {  log:printError(\"Error occurred while closing the connection\", result);  } }import ballerina/log; import ballerina/nats; nats:Connection connection = new; listener nats:Listener subscription = new (connection); @nats:SubscriptionConfig {  subject: \"demo\" } service demo on subscription { resource function onMessage(nats:Message msg, string data) {  log:printInfo(\"Received message : \" + data);  } resource function onError(nats:Message msg, nats:Error err) {  log:printError(\"Error occurred in data binding\", err);  } }    Basic Publisher and Subscriber  The NATS client is used either to produce a message to a subject or consume a message from a subject.  In order to execute this example, it is required that a NATS server is up and running on its default host, port, and cluster.  For instructions on installing the NATS server,  go to .    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection connection = new ();  nats:Producer producer = new (connection);  while (message != ESCAPE) {  message = io:readln(\"Message : \");    Initializes a producer.   nats:Error? result = producer->publish(subject, <@untainted>message);  if (result is nats:Error) {  io:println(\"Error occurred while producing the message.\");  } else {  io:println(\"Message published successfully.\");  }  }    Produces a message to the specified subject.   nats:Error? result = producer.close();  if (result is nats:Error) {  log:printError(\"Error occurred while closing the logical connection\",  result);  }    Closes the publisher connection.   result = connection.close();  if (result is nats:Error) {  log:printError(\"Error occurred while closing the connection\", result);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Subject : demo Message : Hello Ballerina! GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/log; import ballerina/nats;    nats:Connection connection = new;    Initializes a connection.   listener nats:Listener subscription = new (connection);    Initializes the NATS listener.   @nats:SubscriptionConfig {  subject: \"demo\" } service demo on subscription {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   resource function onMessage(nats:Message msg, string data) {    log:printInfo(\"Received message : \" + data);  }    Prints the incoming message in the console.   resource function onError(nats:Message msg, nats:Error err) {  log:printError(\"Error occurred in data binding\", err);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run subscriber.bal Received message : Hello Ballerina!"},{"page":"/learn/by-example/mysql-query-operation.html","name":"MySQL Select Query Operations","summary":"This example demonstrates how to use the JDBC client select query operations\n with the stream return type. Note that the MySQL database driver JAR should\n be placed in the BALLERINA_HOME/bre/lib directory. The MySQL connector uses\n database properties from MySQL version 8.0.x onwards. Therefore, it is\n recommended to use a MySQL ...","content":"/  /  / MySQL Select Query Operations  import ballerina/io; import ballerina/mysql; import ballerina/sql; string dbUser = \"root\"; string dbPassword = \"Test@123\";function simpleQuery(mysql:Client mysqlClient) {  io:println(\"------ Start Simple Query -------\");  stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from Customers\");  error? e = resultStream.forEach(function(record {} result) {  io:println(\"Customer full details: \", result);  io:println(\"Customer first name: \", result[\"FirstName\"]);  io:println(\"Customer last name: \", result[\"LastName\"]);  });  if (e is error) {  io:println(\"ForEach operation on the stream failed!\", e);  }  e = resultStream.close();  io:println(\"------ End Simple Query -------\"); }function countRows(mysql:Client mysqlClient) {  io:println(\"------ Start Count Total Rows -------\");  stream<record{}, error> resultStream =  mysqlClient->query(\"Select count(*) as Total from Customers\");  record {|record {} value;|}|error? result = resultStream.next();  if (result is record {|record {} value;|}) {  io:println(\"Total rows in customer table : \", result.value[\"Total\"]);  } else if (result is error) {  io:println(\"Next operation on the stream failed!\", result);  } else {  io:println(\"Customer table is empty\");  }  error? e = resultStream.close();  io:println(\"------ End Count Total Rows -------\"); } type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};function typedQuery(mysql:Client mysqlClient) {  io:println(\"------ Start Query With Type Description -------\");  stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from Customers\", Customer);  stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream;  error? e = customerStream.forEach(function(Customer customer) {  io:println(customer);  });  if (e is error) {  io:println(e);  }  e = resultStream.close(); io:println(\"------ End Query With Type Description -------\"); } function initializeTable() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result =  check mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS MYSQL_BBE\");  result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \"+  \"MYSQL_BBE.Customers\");  result = check mysqlClient->execute(\"CREATE TABLE IF NOT EXISTS \" +  \"MYSQL_BBE.Customers(customerId INTEGER \" +  \"NOT NULL AUTO_INCREMENT, FirstName VARCHAR(300), LastName \" +  \"VARCHAR(300), RegistrationID INTEGER,\" +  \"CreditLimit DOUBLE, Country VARCHAR(300), PRIMARY KEY (CustomerId))\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.Customers \"+  \"(FirstName,LastName,RegistrationID,\" +  \"CreditLimit,Country) VALUES ('Peter', 'Stuart', 1, 5000.75, 'USA')\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.Customers \"+  \"(FirstName,LastName,RegistrationID,\" +  \"CreditLimit,Country) VALUES ('Dan', 'Brown', 2, 10000, 'UK')\");  check mysqlClient.close(); }public function main() {  sql:Error? err = initializeTable();  if (err is sql:Error) {  io:println(\"Sample data initialization failed!\");  io:println(err);  } else {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = \"MYSQL_BBE\");  if (mysqlClient is mysql:Client) {  simpleQuery(mysqlClient);  countRows(mysqlClient);  typedQuery(mysqlClient);  io:println(\"Queried the database successfully!\");  sql:Error? e = mysqlClient.close();  } else {  io:println(\"MySQL Client initialization for \" +  \"querying data failed!\", mysqlClient);  }  } }    MySQL Select Query Operations  This example demonstrates how to use the JDBC client select query operations  with the stream return type. Note that the MySQL database driver JAR should  be placed in the BALLERINA_HOME/bre/lib directory. The MySQL connector uses  database properties from MySQL version 8.0.x onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.x.    import ballerina/io; import ballerina/mysql; import ballerina/sql;    string dbUser = \"root\"; string dbPassword = \"Test@123\";    Username and password of the MySQL database. This is used in the below  examples when initializing the MySQL connector. You need to change these  based on your setup to try locally.   function simpleQuery(mysql:Client mysqlClient) {  io:println(\"------ Start Simple Query -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from Customers\");    Select the rows in the database table via the query remote operation.  The result is returned as a stream and the elements of the stream can  be either a record or an error.   error? e = resultStream.forEach(function(record {} result) {  io:println(\"Customer full details: \", result);  io:println(\"Customer first name: \", result[\"FirstName\"]);  io:println(\"Customer last name: \", result[\"LastName\"]);  });    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   if (e is error) {  io:println(\"ForEach operation on the stream failed!\", e);  }    Check and handle the error during the SQL query  or iteration of the result stream.   e = resultStream.close();  io:println(\"------ End Simple Query -------\"); }    In general cases, the stream will be closed automatically  when the stream is fully consumed or any error is encountered.  However, in case if the stream is not fully consumed, the stream should be  closed specifically.   function countRows(mysql:Client mysqlClient) {  io:println(\"------ Start Count Total Rows -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select count(*) as Total from Customers\");    The result of the count operation is provided as a record stream.   record {|record {} value;|}|error? result = resultStream.next();    Since the above count query will return only a single row, the  next() operation is sufficient to retrieve the data.   if (result is record {|record {} value;|}) {  io:println(\"Total rows in customer table : \", result.value[\"Total\"]);  } else if (result is error) {  io:println(\"Next operation on the stream failed!\", result);  } else {  io:println(\"Customer table is empty\");  }    Check the result and retrieve the value for total.   error? e = resultStream.close();  io:println(\"------ End Count Total Rows -------\"); }    Close the stream.   type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};    Define a record to load the query result schema as shown in the ‘typedQuery’ function. In this example, all columns of the customer table will be loaded. Therefore, a Customer record will be created with all the columns. The name of the result column and the defined field name of the record will be matched case insensitively.   function typedQuery(mysql:Client mysqlClient) {  io:println(\"------ Start Query With Type Description -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from Customers\", Customer);    The result is returned as a Customer record stream and the elements  of the stream can be either a Customer record or an error.   stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream;    Cast the generic record type to the Customer stream type.   error? e = customerStream.forEach(function(Customer customer) {  io:println(customer);  });  if (e is error) {  io:println(e);  }    Iterate the customer stream.   e = resultStream.close();    Close the stream.   io:println(\"------ End Query With Type Description -------\"); }    function initializeTable() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result =  check mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS MYSQL_BBE\");  result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \"+  \"MYSQL_BBE.Customers\");  result = check mysqlClient->execute(\"CREATE TABLE IF NOT EXISTS \" +  \"MYSQL_BBE.Customers(customerId INTEGER \" +  \"NOT NULL AUTO_INCREMENT, FirstName VARCHAR(300), LastName \" +  \"VARCHAR(300), RegistrationID INTEGER,\" +  \"CreditLimit DOUBLE, Country VARCHAR(300), PRIMARY KEY (CustomerId))\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.Customers \"+  \"(FirstName,LastName,RegistrationID,\" +  \"CreditLimit,Country) VALUES ('Peter', 'Stuart', 1, 5000.75, 'USA')\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.Customers \"+  \"(FirstName,LastName,RegistrationID,\" +  \"CreditLimit,Country) VALUES ('Dan', 'Brown', 2, 10000, 'UK')\");  check mysqlClient.close(); }    Initialize the database table with sample data.   public function main() {    sql:Error? err = initializeTable();  if (err is sql:Error) {  io:println(\"Sample data initialization failed!\");  io:println(err);  } else {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = \"MYSQL_BBE\");  if (mysqlClient is mysql:Client) {    Initialize the MySQL client.   simpleQuery(mysqlClient);  countRows(mysqlClient);  typedQuery(mysqlClient);  io:println(\"Queried the database successfully!\");    Execute the select queries in different options.   sql:Error? e = mysqlClient.close();  } else {  io:println(\"MySQL Client initialization for \" +  \"querying data failed!\", mysqlClient);  }  } }    Close the MySQL client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run mysql_query_operation.bal    ------ Start Simple Query ------- Customer full details: customerId=1 FirstName=Peter LastName=Stuart RegistrationID=1 CreditLimit=5000.75 Country=USA Customer first name: Peter Customer last name: Stuart Customer full details: customerId=2 FirstName=Dan LastName=Brown RegistrationID=2 CreditLimit=10000.0 Country=UK Customer first name: Dan Customer last name: Brown ------ End Simple Query ------- ------ Start Count Total Rows ------- Total rows in customer table : 2 ------ End Count Total Rows ------- ------ Start Query With Type Description ------- customerId=1 firstName=Peter lastName=Stuart registrationId=1 creditLimit=5000.75 country=USA customerId=2 firstName=Dan lastName=Brown registrationId=2 creditLimit=10000.0 country=UK ------ End Query With Type Description ------- Queried the database successfully!"},{"page":"/learn/by-example/nats-streaming-client.html","name":"Basic Streaming Publisher and Subscriber","summary":"This sample demonstrates the basic usage of the NATS Streaming client\n to publish data to a subject and consume data from that subject.\n In order to run this sample, a NATS Streaming server should be\n running on the corresponding port used in the sample.Represents the escape character.Produces a message to ...","content":"/  /  / Basic Streaming Publisher and Subscriber  import ballerina/io; import ballerina/log; import ballerina/nats; const string ESCAPE = \"!q\"; public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \"); nats:Connection conn = new; nats:StreamingProducer publisher = new (conn); while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats; nats:Connection conn = new; listener nats:StreamingListener lis = new (conn); @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received: \" + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Basic Streaming Publisher and Subscriber  This sample demonstrates the basic usage of the NATS Streaming client  to publish data to a subject and consume data from that subject.  In order to run this sample, a NATS Streaming server should be  running on the corresponding port used in the sample.    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn);    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Subject : demo Message : Hello Ballerina! GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn);    Initializes the NATS Streaming listener.   @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received: \" + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run subscriber.bal Received message : Hello Ballerina!"},{"page":"/learn/by-example/nats-streaming-durable-subscriptions.html","name":"Durable Subscriptions","summary":"This sample demonstrates creating a durable subscription\n in the NATS Streaming server. Regular subscriptions remember\n their position while the client is connected. If the client\n disconnects, the position is lost. Durable subscriptions\n remember their position even if the client is disconnected.Represents the escape character.Produces a message to a subject in ...","content":"/  /  / Durable Subscriptions  import ballerina/io; import ballerina/log; import ballerina/nats; const string ESCAPE = \"!q\"; public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \"); nats:Connection conn = new; nats:StreamingProducer publisher = new (conn); while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats; nats:Connection conn = new; listener nats:StreamingListener lis = new (conn, clientId = \"c0\"); @nats:StreamingSubscriptionConfig {  subject: \"demo\",  durableName: \"sample-name\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received: \" + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Durable Subscriptions  This sample demonstrates creating a durable subscription  in the NATS Streaming server. Regular subscriptions remember  their position while the client is connected. If the client  disconnects, the position is lost. Durable subscriptions  remember their position even if the client is disconnected.    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn);    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Subject : demo Message : First Message GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn, clientId = \"c0\");    Initializes the NATS Streaming listener.   @nats:StreamingSubscriptionConfig {  subject: \"demo\",  durableName: \"sample-name\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received: \" + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run subscriber.bal Received message : First Message    # Stop the subscriber and publish some messages while it is stopped. # Run the subscriber again. # All messages which had been published while the subscriber # wasn't running should be received.    $ ballerina run subscriber.bal Received message : Second Message"},{"page":"/learn/by-example/nats-streaming-consumer-with-data-binding.html","name":"Streaming Publisher and Subscriber With Data Binding","summary":"This sample demonstrates the usage of NATS subscriber\n services to bind the data in the incoming message to\n a user-provided compatible type.Represents the escape character.Produces a message to a subject in the NATS sever.Produces a message to the specified subject.Closes the connection.Creates a NATS connection.Initializes the NATS Streaming listener.Binds the ...","content":"/  /  / Streaming Publisher and Subscriber With Data Binding  import ballerina/io; import ballerina/log; import ballerina/nats; const string ESCAPE = \"!q\"; public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \"); nats:Connection conn = new; nats:StreamingProducer publisher = new (conn, \"p0\", \"test-cluster\"); while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }import ballerina/log; import ballerina/nats; nats:Connection conn = new; listener nats:StreamingListener lis = new (conn); @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message, json data) {  string|error val = data.toJsonString();  if (val is string) {  log:printInfo(\"Message Received: \" + val);  } else {  log:printError(\"Error occurred during json to string conversion\",  err = val);  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Streaming Publisher and Subscriber With Data Binding  This sample demonstrates the usage of NATS subscriber  services to bind the data in the incoming message to  a user-provided compatible type.    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn, \"p0\", \"test-cluster\");    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Subject : demo [ballerina/nats] Connection established with server nats://localhost:4222 Message : \"{ Hello : World }\" GUID PXbFl6Mlx6cewaL8oXwnn1 received for the produced message.    import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn);    Initializes the NATS Streaming listener.   @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message, json data) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   string|error val = data.toJsonString();  if (val is string) {    Converts JSON data to string.   log:printInfo(\"Message Received: \" + val);  } else {  log:printError(\"Error occurred during json to string conversion\",  err = val);  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run subscriber.bal Message Received: { Hello : World }"},{"page":"/learn/by-example/nats-streaming-queue-group.html","name":"Queue Groups","summary":"This sample demonstrates leveraging the NATS built-in load balancing\n feature called “distributed queues”. All subscribers with the\n same queue name form the queue group.  As messages on the registered\n subject are published, one member of the group is chosen randomly\n to receive the message. Although queue groups have multiple ...","content":"/  /  / Queue Groups  import ballerina/io; import ballerina/log; import ballerina/nats; const string ESCAPE = \"!q\"; public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \"); nats:Connection conn = new; nats:StreamingProducer publisher = new (conn); while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats; nats:Connection conn = new; listener nats:StreamingListener lis = new (conn); @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service firstQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to first queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } } @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service secondQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to second queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } } @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service thridQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to third queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Queue Groups  This sample demonstrates leveraging the NATS built-in load balancing  feature called “distributed queues”. All subscribers with the  same queue name form the queue group. As messages on the registered  subject are published, one member of the group is chosen randomly  to receive the message. Although queue groups have multiple subscribers,  each message is consumed by only one.    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn);    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Subject : demo Message : First Message GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn);    Initializes the NATS Streaming listeners.   @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service firstQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Belongs to the queue group named “sample-queue-group”   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to first queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service secondQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Belongs to the queue group named “sample-queue-group”   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to second queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service thridQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Belongs to the queue group named “sample-queue-group”   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to third queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. # `queue-group.bal` contains three services belonging to the same # queue group. # When several messages are published, it can be noticed that # each message is received by only one queue group member. $ ballerina run queue-group.bal Message Received to third queue group member: First Message Message Received to second queue group member: Second Message Message Received to first queue group member: Third Message"},{"page":"/learn/by-example/nats-streaming-start-position.html","name":"Historical Message Replay","summary":"This sample demonstrates leveraging the historical\n message replay feature of Streaming NATS.\n New subscriptions may specify a starting position in the stream of\n messages stored for the channel of the subscribed subject.\n Message delivery may begin at:\n 1. The earliest message stored for this subject\n 2. The most recently stored ...","content":"/  /  / Historical Message Replay  import ballerina/io; import ballerina/log; import ballerina/nats; const string ESCAPE = \"!q\"; public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \"); nats:Connection conn = new; nats:StreamingProducer publisher = new (conn); while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats; nats:Connection conn = new; listener nats:StreamingListener lis = new (conn); @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service receiveNewOnly on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveNewOnly: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } } @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: nats:FIRST } service receiveFromBegining on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromBegining: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } } @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: nats:LAST_RECEIVED } service receiveFromLastReceived on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromLastReceived: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }[nats:SEQUENCE_NUMBER, int] sequenceNo = [nats:SEQUENCE_NUMBER, 3]; @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: sequenceNo } service receiveFromGivenIndex on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromGivenIndex: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }[nats:TIME_DELTA_START, int] timeDelta = [nats:TIME_DELTA_START, 5]; @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: timeDelta } service receiveSinceTimeDelta on lis {  resource function onMessage(nats:StreamingMessage message) {  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveSinceTimeDelta: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  } resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }# To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. # When you start the subscriber after publishing several messages, # You'll notice that, # 1. `receiveSinceTimeDelta` service receives the messages if # the messages were sent within a historical offset of 5 seconds # from the current server date/time # 2. `receiveFromGivenIndex` service receives services messages # starting from the third message published. # 3. `receiveFromLastReceived` service receives messages starting # from the last published message. # 4. `receiveFromBeginning` service receives all messages ever # published # 5. `receiveNewOnly` service receives only the messages, which are # published after the subscriber starts.    Historical Message Replay  This sample demonstrates leveraging the historical  message replay feature of Streaming NATS.  New subscriptions may specify a starting position in the stream of  messages stored for the channel of the subscribed subject.  Message delivery may begin at:  1. The earliest message stored for this subject  2. The most recently stored message for this subject  prior to the start of the current subscription.  3. A historical offset from the current server date/time  (e.g., the last 30 seconds).  4. A specific message sequence number    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn);    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Subject : demo [ballerina/nats] Connection established with server nats://localhost:4222 Message : First Message GUID UBMEgrERHdxZRqUBP05PtD received for the produced message. Message : Second Message GUID UBMEgrERHdxZRqUBP05Puz received for the produced message. Message : Third Message GUID UBMEgrERHdxZRqUBP05Pwl received for the produced message. Message : Forth Message GUID UBMEgrERHdxZRqUBP05PyX received for the produced message.    import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn);    Initializes the NATS Streaming listener.   @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service receiveNewOnly on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  By default, only new messages are received.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveNewOnly: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: nats:FIRST } service receiveFromBegining on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives all messages from the beginning.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromBegining: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: nats:LAST_RECEIVED } service receiveFromLastReceived on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages starting from the last received message.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromLastReceived: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    [nats:SEQUENCE_NUMBER, int] sequenceNo = [nats:SEQUENCE_NUMBER, 3];    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: sequenceNo } service receiveFromGivenIndex on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages starting from the provided sequence number.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromGivenIndex: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    [nats:TIME_DELTA_START, int] timeDelta = [nats:TIME_DELTA_START, 5];    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: timeDelta } service receiveSinceTimeDelta on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages since the provided historical time delta.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveSinceTimeDelta: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. # When you start the subscriber after publishing several messages, # You'll notice that, # 1. `receiveSinceTimeDelta` service receives the messages if # the messages were sent within a historical offset of 5 seconds # from the current server date/time # 2. `receiveFromGivenIndex` service receives services messages # starting from the third message published. # 3. `receiveFromLastReceived` service receives messages starting # from the last published message. # 4. `receiveFromBeginning` service receives all messages ever # published # 5. `receiveNewOnly` service receives only the messages, which are # published after the subscriber starts.    $ ballerina run subscriber.bal    [ballerina/nats] Connection established with server nats://localhost:4222 Message Received to service receiveSinceTimeDelta: Third Message Message Received to service receiveFromGivenIndex: Third Message Message Received to service receiveFromLastReceived: Third Message Message Received to service receiveFromBeginning: First Message Message Received to service receiveFromBeginning: Second Message Message Received to service receiveFromBeginning: Third Message Message Received to service receiveFromGivenIndex: Forth Message Message Received to service receiveFromLastReceived: Forth Message Message Received to service receiveNewOnly: Forth Message Message Received to service receiveSinceTimeDelta: Forth Message Message Received to service receiveFromBeginning: Forth Message"},{"page":"/learn/by-example/object-assignability.html","name":"Object Assignability","summary":"An object is assignable to another object type if they are structurally equivalent. There are rules that need to\n be satisfied for objects to be structurally equivalent. The following are the general equivalency rules\n that are applicable for objects.Both objects should have the same access modifier (i.e., either both should ...","content":"/  /  / Object Assignability  import ballerina/io; public type Person object {  public int age = 0;  public string name = \"\"; public function getName() returns string {  return self.name;  } }; public type Employee object {  public int age;  public string name;  public string address; public function __init(int age, string name, string address) {  self.age = age;  self.name = name;  self.address = address;  } public function getName() returns string {  return self.name + \" Doe\";  } public function getAge() returns int {  return self.age;  } };public function main() {  Person p1 = new Employee(50, \"John\", \"street1\"); io:println(p1.getName()); }    Object Assignability  An object is assignable to another object type if they are structurally equivalent. There are rules that need to  be satisfied for objects to be structurally equivalent. The following are the general equivalency rules  that are applicable for objects.  Both objects should have the same access modifier (i.e., either both should be public or both should be private).  If both objects are private, they should be in the same package.  The right hand side (RHS) object type should at least have all the fields as well as the methods of the left hand side (LHS) type.  If the objects are public object types, all the fields and methods must be public as well.  The field types of the RHS object should be assignable to the field types of the LHS object.  The method signatures of the RHS object type should match the method signatures of the LHS object type.  The parameters and return types of the RHS object type should also be the same types or subtypes of  the corresponding parameters and return types of the LHS object type.    import ballerina/io;    public type Person object {  public int age = 0;  public string name = \"\";    Defines an object called Person with public fields and a method.   public function getName() returns string {  return self.name;  } };    public type Employee object {  public int age;  public string name;  public string address;    Defines an object called Employee with public fields, methods, and the initializer.   public function __init(int age, string name, string address) {  self.age = age;  self.name = name;  self.address = address;  }    public function getName() returns string {  return self.name + \" Doe\";  }    public function getAge() returns int {  return self.age;  } };    public function main() {    Person p1 = new Employee(50, \"John\", \"street1\");    Creates an object of the type Employee and assigns that to a variable of the type Person.   io:println(p1.getName()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run object_assignability.bal John Doe"},{"page":"/learn/by-example/object-initializer.html","name":"Object Initializer","summary":"In Ballerina, objects can have a method named __init(), which is used to initialize the object when creating a\n new object. This method can have parameters as in any other method. However, the return type of the __init() method\n should be a subtype of error|(), which includes (). If an ...","content":"/  /  / Object Initializer  import ballerina/io; type Person object { public string name;  private int age; function __init(string name, int age) returns error? {  self.name = name;  self.age = check validateAge(age);  } };function validateAge(int age) returns int|error {  if (age > 0 && age < 100) {  return age;  } error invalidAge = error(\"The age should be between 0-100\");  return invalidAge; }public function main() {  Person|error p1 = new(\"John\", 25);  if (p1 is Person) {  io:println(p1.name);  } else {  io:println(p1.reason());  }  Person|error p2 = new(\"Sam\", -20);  if (p2 is Person) {  io:println(p2.name);  } else {  io:println(p2.reason());  } }    Object Initializer  In Ballerina, objects can have a method named __init(), which is used to initialize the object when creating a  new object. This method can have parameters as in any other method. However, the return type of the __init() method  should be a subtype of error|(), which includes (). If an explicit definition for the __init() method  is not specified, there will be an implicit __init() method, which does not accept any parameters and returns ().    import ballerina/io;    type Person object {    Defines an object called Person. Each object has its own __init() method, which gets  invoked when creating the objects. You can place the logic for initializing the fields of the  object within the body of the __init() method.   public string name;  private int age;    function __init(string name, int age) returns error? {  self.name = name;  self.age = check validateAge(age);  } };    function validateAge(int age) returns int|error {  if (age > 0 && age < 100) {  return age;  }    error invalidAge = error(\"The age should be between 0-100\");  return invalidAge; }    public function main() {    Person|error p1 = new(\"John\", 25);  if (p1 is Person) {  io:println(p1.name);  } else {  io:println(p1.reason());  }    Since the __init() method potentially returns an error, the p1 variable should  be of the type Person|error.   Person|error p2 = new(\"Sam\", -20);  if (p2 is Person) {  io:println(p2.name);  } else {  io:println(p2.reason());  } }    p2 will be an error since the name does not conform to the expected format.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run object_initializer.bal John The age should be between 0-100"},{"page":"/learn/by-example/object-methods.html","name":"Object Methods","summary":"Objects can have functions associated with them. These associated functions are known as methods.\n Methods can be defined inside or outside the object. To define a method outside the object,\n first declare the method signature inside the object.Defines an object called Person.The object initializer.A method returning the full name value ...","content":"/  /  / Object Methods  import ballerina/io; type Person object {  public int age;  public string firstName;  public string lastName;  function __init(int age, string firstName, string lastName) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  }  function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }};public function main() {  Person p1 = new (5, \"John\", \"Doe\"); io:println(p1.getFullName()); }    Object Methods  Objects can have functions associated with them. These associated functions are known as methods.  Methods can be defined inside or outside the object. To define a method outside the object,  first declare the method signature inside the object.    import ballerina/io;    type Person object {  public int age;  public string firstName;  public string lastName;    Defines an object called Person.   function __init(int age, string firstName, string lastName) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  }    The object initializer.   function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }    A method returning the full name value of the Person object.   };    public function main() {    Person p1 = new (5, \"John\", \"Doe\");    Initializes a Person object.   io:println(p1.getFullName()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run object_methods.bal John Doe"},{"page":"/learn/by-example/object-type-reference.html","name":"Object Type Reference","summary":"Object type references provide a way to copy the members from an abstract\n object into another object. It is equivalent to specifying the members\n explicitly within the new object, thus, eliminating redundancy. An object can have\n zero or more type references and may have chained references as well.Defines an abstract ...","content":"/  /  / Object Type Reference  import ballerina/io; type Person abstract object {  public int age;  public string firstName;  public string lastName;  function getFullName() returns string;}; type Employee abstract object {  *Person;  public float salary; function getSalary() returns float; };type Owner abstract object {  public string status; };type Manager object {  *Employee;  *Owner; public string dpt;  function __init(int age, string firstName, string lastName, string status) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  self.status = status;  self.salary = 2000;  self.dpt = \"HR\";  }  function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  } function getSalary() returns float {  return self.salary;  } };public function main() {  Manager p = new Manager(5, \"John\", \"Doe\", \"Senior\");  io:println(p.age);  io:println(p.dpt);  io:println(p.getFullName());  io:println(p.getSalary()); }    Object Type Reference  Object type references provide a way to copy the members from an abstract  object into another object. It is equivalent to specifying the members  explicitly within the new object, thus, eliminating redundancy. An object can have  zero or more type references and may have chained references as well.    import ballerina/io;    type Person abstract object {  public int age;  public string firstName;  public string lastName;    Defines an abstract object called Person. It should only contain fields and the  method declarations.   function getFullName() returns string;    Method declarations can be within the object. However, the method cannot  have a body.   };    type Employee abstract object {    Defines another abstract object called Employee, which references the Person object.   *Person;  public float salary;    Add a reference to the Person object type. Only abstract objects can be referred.  All the member fields and member methods will be copied from the Person object.   function getSalary() returns float; };    type Owner abstract object {  public string status; };    type Manager object {    *Employee;    Type references can be chained by adding a reference to the Employee object, which  again has a reference to the Employee object. This will copy all the members from  the Employee object. It will be same as defining each of those members within this object.   *Owner;    It is possible to have more than one type reference as well.   public string dpt;    function __init(int age, string firstName, string lastName, string status) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  self.status = status;  self.salary = 2000;  self.dpt = \"HR\";  }    All the fields referenced through the type reference can be accessed within this object.   function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }    The member methods coming from the referenced type should be defined within the object.   function getSalary() returns float {  return self.salary;  } };    public function main() {  Manager p = new Manager(5, \"John\", \"Doe\", \"Senior\");    io:println(p.age);  io:println(p.dpt);    Accessing the fields that are coming from the referenced type.   io:println(p.getFullName());  io:println(p.getSalary()); }    Invoking the methods that are coming from the referenced type.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run object_type_reference.bal 5 HR John Doe 2000.0"},{"page":"/learn/by-example/objects.html","name":"Object","summary":"Objects are a behaviourial type. An object is a combination of public, private, and module-level visible fields along with a\n set of associated functions (called methods) that can be used to manipulate the fields. This allows you\n to define custom-behavioural data types.Defines an object called Person. It contains public, private, ...","content":"/  /  / Object  import ballerina/io; type Person object {  public string name = \"\";  public int age = 0;  public Person? parent = ();  private string email = \"default@abc.com\";  string address = \"No 20, Palm grove\"; };public function main() {  Person p1 = new;  io:println(p1.age); Person p2 = new ();  io:println(p2.age);  Person p3 = new Person();  io:println(p3.age); }    Object  Objects are a behaviourial type. An object is a combination of public, private, and module-level visible fields along with a  set of associated functions (called methods) that can be used to manipulate the fields. This allows you  to define custom-behavioural data types.    import ballerina/io;    type Person object {  public string name = \"\";  public int age = 0;    Defines an object called Person. It contains public, private, and module-level visible fields along with their types.  For fields, the default value must be specified if an explicit object initializer method is not defined.   public Person? parent = ();    If you need to have a field with its own type, you need to make that field defaultable  (i.e., able to specify a default value).  Here, the parent field is made defaultable by allowing it to have nil as a value.   private string email = \"default@abc.com\";    Private fields are only visible within the object and its functions.   string address = \"No 20, Palm grove\"; };    Protected fields (i.e., no access modifiers) are visible only within the same module.   public function main() {    Person p1 = new;  io:println(p1.age);    There are three ways to initialize a Person object.   Person p2 = new ();  io:println(p2.age);    Person p3 = new Person();  io:println(p3.age); }    This type of initialization is useful when you cannot determine the type of the object to be  created based on the context (e.g., when the left hand side is a union of object types).   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run objects.bal 0 0 0"},{"page":"/learn/by-example/openapi-to-ballerina.html","name":"OpenAPI To Ballerina","summary":"If you already have an OpenApi Specification(OAS)-3 document for your service(s),\n you can use that contract to generate a Ballerina source code.\n Currently, Ballerina supports two types of code generation.\n ‘gen-service’ generates a mock version of the Ballerina service for a provided OAS definition.\n ballerina openapi gen-service <module-name>:<service-name> <openapi-contract>\n ‘gen-client’ ...","content":"/  /  / OpenAPI To Ballerina  openapi: \"3.0.0\" info:  version: 1.0.0  title: OpenApi Petstore  license:  name: MIT servers:  - url: http://localhost:9090/petstore/v1 paths:  /pets:  get:  summary: List all pets  operationId: listPets  tags:  - pets  parameters:  - name: limit  in: query  description: How many items to return at one time (max 100)  required: false  schema:  type: integer  format: int32  responses:  '200':  description: An paged array of pets  headers:  x-next:  description: A link to the next page of responses  schema:  type: string  content:  application/json:  schema:  $ref: \"#/components/schemas/Pets\"  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\"  post:  summary: Create a pet  operationId: createPets  tags:  - pets  responses:  '201':  description: Null response  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\"  /pets/{petId}:  get:  summary: Info for a specific pet  operationId: showPetById  tags:  - pets  parameters:  - name: petId  in: path  required: true  description: The id of the pet to retrieve  schema:  type: string  responses:  '200':  description: Expected response to a valid request  content:  application/json:  schema:  $ref: \"#/components/schemas/Pets\"  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\" components:  schemas:  Pet:  required:  - id  - name  properties:  id:  type: integer  format: int64  name:  type: string  tag:  type: string  Pets:  type: array  items:  $ref: \"#/components/schemas/Pet\"  Error:  required:  - code  - message  properties:  code:  type: integer  format: int32  message:  type: string    OpenAPI To Ballerina  If you already have an OpenApi Specification(OAS)-3 document for your service(s),  you can use that contract to generate a Ballerina source code.  Currently, Ballerina supports two types of code generation.  ‘gen-service’ generates a mock version of the Ballerina service for a provided OAS definition.  ballerina openapi gen-service <module-name>:<service-name> <openapi-contract>  ‘gen-client’ generates a Ballerina client endpoint for a provided OAS definition.  ballerina openapi gen-client [<module>:]<client-name> <openapi-file> [-o=<outputFileName>]    openapi: \"3.0.0\" info:  version: 1.0.0  title: OpenApi Petstore  license:  name: MIT servers:  - url: http://localhost:9090/petstore/v1 paths:  /pets:  get:  summary: List all pets  operationId: listPets  tags:  - pets  parameters:  - name: limit  in: query  description: How many items to return at one time (max 100)  required: false  schema:  type: integer  format: int32  responses:  '200':  description: An paged array of pets  headers:  x-next:  description: A link to the next page of responses  schema:  type: string  content:  application/json:  schema:  $ref: \"#/components/schemas/Pets\"  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\"  post:  summary: Create a pet  operationId: createPets  tags:  - pets  responses:  '201':  description: Null response  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\"  /pets/{petId}:  get:  summary: Info for a specific pet  operationId: showPetById  tags:  - pets  parameters:  - name: petId  in: path  required: true  description: The id of the pet to retrieve  schema:  type: string  responses:  '200':  description: Expected response to a valid request  content:  application/json:  schema:  $ref: \"#/components/schemas/Pets\"  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\" components:  schemas:  Pet:  required:  - id  - name  properties:  id:  type: integer  format: int64  name:  type: string  tag:  type: string  Pets:  type: array  items:  $ref: \"#/components/schemas/Pet\"  Error:  required:  - code  - message  properties:  code:  type: integer  format: int32  message:  type: string    # Run the following command in a Ballerina project to generate the service from OpenAPI contract. $ ballerina openapi gen-service petStore:petService openapi_to_ballerina.yaml Note: This is an Experimental tool ship under ballerina hence this will only support limited set of functionality. Service generated successfully and the OpenApi contract is copied to petStore/resources. this location will be referenced throughout the ballerina project. Following files were created. src/ - petStore -- petservice.bal -- schema.bal    # Run the following command in a Ballerina project to generate the service client from OpenAPI contract. $ ballerina openapi gen-client petservice_client openapi_to_ballerina.yaml Note: This is an Experimental tool ship under ballerina hence this will only support limited set of functionality. Client generated successfully. Following files were created. src/ - client -- openapi_petstore.bal -- schema.bal"},{"page":"/learn/by-example/openshift-deployment.html","name":"OpenShift Deployment","summary":"Ballerina supports generating the OpenShift Route, BuildConfig, and ImageStream artifacts based on annotations.\nDocker image of the Ballerina service is built using the BuildConfig, which then can be used by the generated Kubernetes Deployment.\nA generated OpenShift Route exposes the Kubernetes Service of the Ballerina Service.\nThis example deploys an HTTP service, which ...","content":"/  /  / OpenShift Deployment  import ballerina/http; import ballerina/log; import ballerina/kubernetes; import ballerina/openshift; @kubernetes:Service {} @openshift:Route {  host: \"www.oc-example.com\" } listener http:Listener helloEP = new(9090); @kubernetes:Deployment {  namespace: \"hello-api\",  registry: \"172.30.1.1:5000\",  image: \"hello-service:v1.0\",  buildImage: false,  buildExtension: openshift:BUILD_EXTENSION_OPENSHIFT } @http:ServiceConfig {  basePath: \"/hello\" } service hello on helloEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/{user}\"  }  resource function sayHello(http:Caller caller, http:Request request, string user) {  string payload = string `Hello ${<@untainted string> user}!`;  var responseResult = caller->respond(payload);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    OpenShift Deployment  Ballerina supports generating the OpenShift Route, BuildConfig, and ImageStream artifacts based on annotations. Docker image of the Ballerina service is built using the BuildConfig, which then can be used by the generated Kubernetes Deployment. A generated OpenShift Route exposes the Kubernetes Service of the Ballerina Service. This example deploys an HTTP service, which responses “Hello” followed by a name. For more information, see .    import ballerina/http; import ballerina/log; import ballerina/kubernetes; import ballerina/openshift;    @kubernetes:Service {}    Add the @kubernetes:Service to a listener endpoint to expose the endpoint as a Kubernetes Service.   @openshift:Route {  host: \"www.oc-example.com\" } listener http:Listener helloEP = new(9090);    Add the @openshift:Route to expose the Kubernetes Service through an OpenShift Route.   @kubernetes:Deployment {    Add the @kubernetes:Deployment annotation to a Ballerina service to generate a Kuberenetes Deployment for a Ballerina module.   namespace: \"hello-api\",    OpenShift project name.   registry: \"172.30.1.1:5000\",    IP and port of the OpenShift docker registry. If you are using minishift, use the minishift openshift registry to find the Docker registry.   image: \"hello-service:v1.0\",    Generate a Docker image with the name 172.30.1.1:5000/hello-api/hello-service:v1.0.   buildImage: false,    Disable the image being built by default so that the OpenShift BuildConfig can build it.   buildExtension: openshift:BUILD_EXTENSION_OPENSHIFT } @http:ServiceConfig {  basePath: \"/hello\" } service hello on helloEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/{user}\"  }  resource function sayHello(http:Caller caller, http:Request request, string user) {  string payload = string `Hello ${<@untainted string> user}!`;  var responseResult = caller->respond(payload);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    Generate the OpenShift BuildConfig for building the Docker image.   # Build the Ballerina program. $ ballerina build openshift_deployment.bal Compiling source \topenshift_deployment.bal    Generating executables. \topenshift_deployment.jar    Generating artifacts...    @kubernetes:Service - complete 1/1 \t@kubernetes:Deployment - complete 1/1 \t@kubernetes:Docker - complete 1/1 \t@kubernetes:Helm - complete 1/1 \t@openshift:BuildConfig - complete 1/1 \t@openshift:ImageStream - complete 1/1 \t@openshift:Route - complete 1/1    Run the following command to deploy the OpenShift artifacts: \toc apply -f ./kubernetes/openshift    Run the following command to start a build: \toc start-build bc/openshift-openshift-bc-openshift-bc --from-dir=. --follow    Run the following command to deploy the Kubernetes artifacts: \tkubectl apply -f ./kubernetes    # Create a new OpenShift project $ oc new-project hello-api    # Deploy the OpenShift artifacts $ oc apply -f ./kubernetes/openshift buildconfig.build.openshift.io/openshift-openshift-bc-openshift-bc created imagestream.image.openshift.io/hello-service created route.route.openshift.io/helloep-openshift-route created    # Trigger a build to create the Docker image. $ oc start-build bc/openshift-openshift-bc-openshift-bc --from-dir=. --follow Uploading directory \".\" as binary input for the build ... .. Uploading finished build.build.openshift.io/openshift-openshift-bc-openshift-bc-1 started Receiving source from STDIN as archive ... Pulling image ballerina/jre8:v1 ... Pulled 3/4 layers, 92% complete Pulled 4/4 layers, 100% complete Extracting Step 1/10 : FROM ballerina/jre8:v1  ---> 6953736bfaaa Step 2/10 : LABEL maintainer \"dev@ballerina.io\"  ---> Running in e77dfb0dfe3c  ---> e3ae9b17b0b7 Removing intermediate container e77dfb0dfe3c Step 3/10 : RUN addgroup troupe && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina && apk add --update --no-cache bash && chown -R ballerina:troupe /usr/bin/java && rm -rf /var/cache/apk/*  ---> Running in eaa889f617e6 fetch http://dl-cdn.alpinelinux.org/alpine/v3.9/main/x86_64/APKINDEX.tar.gz fetch http://dl-cdn.alpinelinux.org/alpine/v3.9/community/x86_64/APKINDEX.tar.gz (1/5) Installing ncurses-terminfo-base (6.1_p20190105-r0) (2/5) Installing ncurses-terminfo (6.1_p20190105-r0) (3/5) Installing ncurses-libs (6.1_p20190105-r0) (4/5) Installing readline (7.0.003-r1) (5/5) Installing bash (4.4.19-r1) Executing bash-4.4.19-r1.post-install Executing busybox-1.29.3-r10.trigger OK: 93 MiB in 58 packages  ---> c49c36916288 Removing intermediate container eaa889f617e6 Step 4/10 : WORKDIR /home/ballerina  ---> a701b8eae0d9 Removing intermediate container 50703b9e9269 Step 5/10 : COPY openshift_deployment.jar /home/ballerina  ---> 991deed81242 Removing intermediate container ce1ec590569b Step 6/10 : EXPOSE 9090  ---> Running in 854b6576d5d6  ---> d00ae6c70a05 Removing intermediate container 854b6576d5d6 Step 7/10 : USER ballerina  ---> Running in c56759363d0a  ---> 2fc8a5b56b1b Removing intermediate container c56759363d0a Step 8/10 : CMD java -jar openshift_deployment.jar  ---> Running in 0c2eb5f6f61b  ---> 1cf62f598ef2 Removing intermediate container 0c2eb5f6f61b Step 9/10 : ENV \"OPENSHIFT_BUILD_NAME\" \"openshift-openshift-bc-openshift-bc-1\" \"OPENSHIFT_BUILD_NAMESPACE\" \"hello-api2\"  ---> Running in 1aeed538f9bc  ---> 35657b171b0a Removing intermediate container 1aeed538f9bc Step 10/10 : LABEL \"io.openshift.build.name\" \"openshift-openshift-bc-openshift-bc-1\" \"io.openshift.build.namespace\" \"hello-api2\"  ---> Running in a48523992d84  ---> 104517906bb2 Removing intermediate container a48523992d84 Successfully built 104517906bb2 Pushing image 172.30.1.1:5000/hello-api2/hello-service:v1.0 ... Pushed 0/6 layers, 7% complete Pushed 1/6 layers, 28% complete Pushed 2/6 layers, 50% complete Pushed 3/6 layers, 60% complete Pushed 4/6 layers, 70% complete Pushed 5/6 layers, 87% complete Pushed 6/6 layers, 100% complete Push successful    # Deploy the Kubernetes artifacts $ kubectl apply -f ./kubernetes service/helloep-svc created deployment.apps/openshift-deployment-deployment created    # Check if pods are running $ oc get pods NAME READY STATUS RESTARTS AGE openshift-deployment-deployment-865d564bc9-5rh78 1/1 Running 0 35m    # Invoke the service. If you are using minikube, go to www.oc-example.com to get the minikube IP. Use the `minikube ip` command to find the IP. $ curl --resolve www.oc-example.com:80:192.168.99.101 http://www.oc-example.com/hello/john Hello john!"},{"page":"/learn/by-example/optional-type.html","name":"Optional Type","summary":"One of the design principles of the type system of Ballerina is to eliminate null reference errors.\n Over the years, null reference errors have caused numerous system crashes, security vulnerabilities etc.\n Optional types in Ballerina allow developers to identify where the value or the function\n is of type T optionally, ...","content":"/  /  / Optional Type  import ballerina/io; function getValue(string key) returns string? {  if (key == \"string\") {  return \"hello world\";  }  return (); }public function main() {  string? s = getValue(\"string\");  if (s is string) {  io:println(\"Length of the string: \", s.length());  } else {  io:println(\"s is ()\");  }  s = ();  if (s is string) {  io:println(\"Length of the string: \", s.length());  } else {  io:println(\"s is ()\");  } }    Optional Type  One of the design principles of the type system of Ballerina is to eliminate null reference errors.  Over the years, null reference errors have caused numerous system crashes, security vulnerabilities etc.  Optional types in Ballerina allow developers to identify where the value or the function  is of type T optionally, for any T. You can syntactically represent this as T? or T|()`.    import ballerina/io;    function getValue(string key) returns string? {  if (key == \"string\") {  return \"hello world\";  }    This function (optionally) returns a string value. In this example, string? is equivalent to string|().   return (); }    In Ballerina, the nil type that is provided as () contains a single value named “nil”. This is used  to represent the absence of any other value.  The nil value is written as ().  null is syntactic sugar for “nil” that is to be used with JSON values because JSON uses null.  return (); here is the same as return;. Not having a return statement at the end is also the same as  explicitly returning ().   public function main() {    string? s = getValue(\"string\");    It is optional for getValue() to return a value of type string. Thus, the value could be either  of type string or of type () and needs to be handled explicitly.  The statement string s = getValue(\"string\"); produces a compilation error.   if (s is string) {  io:println(\"Length of the string: \", s.length());  } else {  io:println(\"s is ()\");  }    The type test can then be used to check if the value is in fact a string and then operate on it.   s = ();  if (s is string) {  io:println(\"Length of the string: \", s.length());  } else {  io:println(\"s is ()\");  } }    A value of type string or () can be assigned to s.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run optional_type.bal Length of the string: 11 s is ()"},{"page":"/learn/by-example/optional-field-access.html","name":"Optional Field Access","summary":"The optional field access operator can be used to access record fields including optional fields.\n The Optional Type example demonstrates how to eliminate null reference errors by using optional types in Ballerina.\n Further, it demonstrates how to operate on optional-typed variables.\n E.g., the + operator cannot operate on values of ...","content":"/  /  / Optional Field Access  import ballerina/io;type Address record {  string line01;  string line02;  string city;  string state;  string zipcode; }; type Person record {  string name;  int age?;  Address? addr; }; function getPerson(string name, int age) returns Person? {  if (name == \"\" || age == 0) {  return;  } else {  Person p = {  name: name,  age: age,  addr: {  line01: \"No. 61\",  line02: \"Brandon street\",  city: \"Santa Clara\",  state: \"CA\",  zipcode: \"95134\"  }  };  return p;  } }public function main() {  Person p1 = {name: \"Anne\", addr: ()};  int? age = p1?.age;  io:println(\"Age: \", age);  p1 = {name: \"Anne\", age: 24, addr: ()};  age = p1?.age;  io:println(\"Age: \", age); Person? p2 = getPerson(\"John\", 30);  io:println(p2);  string? city1 = p2?.addr?.city;  io:println(city1);  Person? p3 = getPerson(\"\", 0);  string? city2 = p3?.addr?.city;  io:println(city2);  p3 = {name: \"George\", age: 20, addr: ()};  city2 = p3?.addr?.city;  io:println(city2);  string defaultCity = \"San Jose\";  string city = city2 ?: defaultCity;  io:println(city); }    Optional Field Access  The optional field access operator can be used to access record fields including optional fields.  The Optional Type example demonstrates how to eliminate null reference errors by using optional types in Ballerina.  Further, it demonstrates how to operate on optional-typed variables.  E.g., the + operator cannot operate on values of the int? type. However, the optional field access operator can  be applied on optional record types and lax types.    import ballerina/io;    type Address record {  string line01;  string line02;  string city;  string state;  string zipcode; };    type Person record {  string name;  int age?;  Address? addr; };    According to the Person record type descriptor, the addr field could either hold an Address record or the value  nil (()). Moreover, the age field is an optional field that may or may not be specified.   function getPerson(string name, int age) returns Person? {  if (name == \"\" || age == 0) {  return;  } else {    This function optionally returns a Person value.   Person p = {  name: name,  age: age,  addr: {  line01: \"No. 61\",  line02: \"Brandon street\",  city: \"Santa Clara\",  state: \"CA\",  zipcode: \"95134\"  }  };  return p;  } }    Defines a Person record.   public function main() {    Person p1 = {name: \"Anne\", addr: ()};    Create a Person value without specifying the age field.   int? age = p1?.age;  io:println(\"Age: \", age);    The optional field age can be accessed using the optional field access operator.  The return type will be the union of the type of the field and ().  If the value is present, the value will be returned.  If not, () will be returned.  () is returned here since age is not set.   p1 = {name: \"Anne\", age: 24, addr: ()};    Create a Person value with the age field.   age = p1?.age;  io:println(\"Age: \", age);    Now, age will be the int value that is set.   Person? p2 = getPerson(\"John\", 30);  io:println(p2);    string? city1 = p2?.addr?.city;    The optional field access operator is a lifted operator in Ballerina.  Both p2 and p2.addr are optional record types.  If the type of either p2 or p2.addr is () at runtime, () would  be assigned to the city1 variable. Else, the string value of the city field  of the address field of the Person record p2 would be assigned.   io:println(city1);    The value “Santa Clara” is displayed in the console.   Person? p3 = getPerson(\"\", 0);    Invoking getPerson() as follows will result in () being assigned to p3.   string? city2 = p3?.addr?.city;  io:println(city2);    Thus, the city2 variable will contain () as the value.   p3 = {name: \"George\", age: 20, addr: ()};    Now, assign a Person record to p3 setting the address field to ().   city2 = p3?.addr?.city;  io:println(city2);    Again, the city2 variable will contain (), since the value of the address field is ().   string defaultCity = \"San Jose\";  string city = city2 ?: defaultCity;  io:println(city); }    In this example, the Elvis operator is used to eliminate nil.  If the value of the first expression is not nil, the Elvis operator returns that value.  If the value of the first expression is nil, the operator returns the value of the second expression.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run optional_field_access.bal Age: Age: 24 name=John age=30 addr=line01=No. 61 line02=Brandon street city=Santa Clara state=CA zipcode=95134 Santa Clara    San Jose"},{"page":"/learn/by-example/panic.html","name":"Panic","summary":"In Ballerina, panic indicates abnormal completion and usually implies that something unexpected has occurred\n (i.e., something that should not have occurred during the normal operation). A panic causes\n the call stack to unwind until it is trapped, or if not trapped results in the termination of the program.Ballerina discourages the ...","content":"/  /  / Panic  import ballerina/io;type Record record {  int id;  string name; };function readRecord(Record? value) {  if (value is Record) {  io:println(\"Record ID: \", value.id, \", value: \", value.name);  } else {  error err = error(\"Record is nil\");  panic err;  } }public function main() {  Record r1 = {  id: 1,  name: \"record1\"  };  readRecord(r1);  Record? r2 = ();  readRecord(r2);  Record r3 = {  id: 3,  name: \"record3\"  };  readRecord(r3); }    Panic  In Ballerina, panic indicates abnormal completion and usually implies that something unexpected has occurred  (i.e., something that should not have occurred during the normal operation). A panic causes  the call stack to unwind until it is trapped, or if not trapped results in the termination of the program.  Ballerina discourages the use of panic to handle program-related  errors such as “header not found”, “data mismatch”, etc.). However,  panic can be used in scenarios such as “Connection Closed/Timeout” and “OutOfMemory”  where the program cannot handle the error by itself.    import ballerina/io;    type Record record {  int id;  string name; };    function readRecord(Record? value) {  if (value is Record) {  io:println(\"Record ID: \", value.id, \", value: \", value.name);  } else {    error err = error(\"Record is nil\");  panic err;  } }    Panics if value is ().   public function main() {  Record r1 = {  id: 1,  name: \"record1\"  };  readRecord(r1);    Record? r2 = ();    r2 is ().   readRecord(r2);    Since r2 is (), readRecord() will panic.   Record r3 = {  id: 3,  name: \"record3\"  };  readRecord(r3); }    The following lines of code will not be executed.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run panic.bal Record ID: 1, value: record1 error: Record is nil  at panic:readRecord(panic.bal:13)  panic:main(panic.bal:28)"},{"page":"/learn/by-example/overloaded-methods-constructors.html","name":"Overloaded Methods/Constructors","summary":"Let’s look at how to specify the exact Java constructor or Java method when they are overloaded.\n If and only if the Java constructor or the method of interest is overloaded with the same number of\n parameters, then you need to specify the parameter types of the exact constructor or ...","content":"/  /  / Overloaded Methods/Constructors  import ballerina/io; import ballerina/java; function newStringBuffer(handle str) returns handle = @java:Constructor {  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.String\"] } external; function appendString(handle receiver, handle str) returns handle = @java:Method {  name: \"append\",  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.String\"] } external; function appendStringBuffer(handle receiver, handle strBuffer) returns handle = @java:Method {  name: \"append\",  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.StringBuffer\"] } external;public function main() {  var strBuffer = newStringBuffer(java:fromString(\"Ballerina is \"));  _ = appendString(strBuffer, java:fromString(\"awesome \")); var strBufferToAppend = newStringBuffer(java:fromString(\"and \"));  _ = appendString(strBufferToAppend, java:fromString(\"fun.\"));  _ = appendStringBuffer(strBuffer, strBufferToAppend); string? text = java:toString(strBuffer);  io:println(text); }    Overloaded Methods/Constructors  Let’s look at how to specify the exact Java constructor or Java method when they are overloaded.  If and only if the Java constructor or the method of interest is overloaded with the same number of  parameters, then you need to specify the parameter types of the exact constructor or the method using the  paramTypes annotation field.    import ballerina/io; import ballerina/java;    function newStringBuffer(handle str) returns handle = @java:Constructor {  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.String\"] } external;    This Ballerina function invokes the java.lang.StringBuffer constructor that takes a  java.lang.String as an argument. The java.lang.StringBuffer class has other overloaded  constructors that take a single parameter. Therefore you need to specify the parameter types here.   function appendString(handle receiver, handle str) returns handle = @java:Method {  name: \"append\",  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.String\"] } external;    The append method in java.lang.StringBuffer is overloaded many methods that take a single parameter.  In this example, let’s use two of those methods. The appendString function is linked with the Java append  method that takes a java.lang.String as an argument.   function appendStringBuffer(handle receiver, handle strBuffer) returns handle = @java:Method {  name: \"append\",  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.StringBuffer\"] } external;    This appendStringBuffer function is linked with the Java append method that takes a  java.lang.StringBuffer as an argument.   public function main() {    var strBuffer = newStringBuffer(java:fromString(\"Ballerina is \"));  _ = appendString(strBuffer, java:fromString(\"awesome \"));    Create a new java.lang.StringBuffer by passing a Java string as an argument.   var strBufferToAppend = newStringBuffer(java:fromString(\"and \"));  _ = appendString(strBufferToAppend, java:fromString(\"fun.\"));    _ = appendStringBuffer(strBuffer, strBufferToAppend);    Append an instance of a java.lang.StringBuffer to another java.lang.StringBuffer instance.   string? text = java:toString(strBuffer);  io:println(text); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run overloaded-methods-constructors.bal Ballerina is awesome and fun."},{"page":"/learn/by-example/passthrough.html","name":"Passthrough","summary":"The passthrough sample exhibits the process of an HTTP client connector. The ‘Echo Service’ is used as a sample backend.The passthrough resource allows all HTTP methods since the resource configuration does not explicitly specify\n which HTTP methods are allowed.When forward() is called on the backend client endpoint, it forwards the ...","content":"/  /  / Passthrough  import ballerina/http; import ballerina/log;http:Client clientEP = new (\"http://localhost:9092/hello\");service passthrough on new http:Listener(9090) {  @http:ResourceConfig {  path: \"/\"  }  resource function passthrough(http:Caller caller, http:Request req) {  var clientResponse = clientEP->forward(\"/\", req);  if (clientResponse is http:Response) {  var result = caller->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>clientResponse.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } } service hello on new http:Listener(9092) {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function helloResource(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Passthrough  The passthrough sample exhibits the process of an HTTP client connector. The ‘Echo Service’ is used as a sample backend.    import ballerina/http; import ballerina/log;    http:Client clientEP = new (\"http://localhost:9092/hello\");    service passthrough on new http:Listener(9090) {    @http:ResourceConfig {  path: \"/\"  }  resource function passthrough(http:Caller caller, http:Request req) {    The passthrough resource allows all HTTP methods since the resource configuration does not explicitly specify  which HTTP methods are allowed.   var clientResponse = clientEP->forward(\"/\", req);    When forward() is called on the backend client endpoint, it forwards the request that the passthrough  resource received to the backend. When forwarding, the request is made using the same HTTP method that was  used to invoke the passthrough resource. The forward() function returns the response from the backend if  there are no errors.   if (clientResponse is http:Response) {    forward() can return an HTTP response or an error.   var result = caller->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {    If the request was successful, an HTTP response is returned.  Here, the received response is forwarded to the client through the outbound endpoint.   http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>clientResponse.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    If there was an error, the 500 error response is constructed and sent back to the client.   service hello on new http:Listener(9092) {    Sample hello world service.   @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function helloResource(http:Caller caller, http:Request req) {    The helloResource only accepts requests made using the specified HTTP methods.   var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Send the response back to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run passthrough.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    $ curl http://localhost:9090/passthrough -X POST Hello World! $ curl http://localhost:9090/passthrough -X GET Hello World! $ curl http://localhost:9090/passthrough -X PUT Hello World!"},{"page":"/learn/by-example/proto-to-ballerina.html","name":"Proto To Ballerina","summary":"If you already have protocol buffer file for your service(s) you can use that to autogenerate Ballerina source code.\n Currently, Ballerina supports two types of code generation. service generation generates a mock version of the\n Ballerina service for an input proto definition.  client generation generates a Ballerina client endpoint ...","content":"/  /  / Proto To Ballerina  syntax = \"proto3\";service helloWorld {  rpc hello(HelloRequest) returns (HelloResponse);  rpc bye(ByeRequest) returns (ByeResponse); }message HelloRequest { \tstring name = 1; } message HelloResponse { \tstring message = 1; } message ByeRequest { \tstring greet = 1; } message ByeResponse { \tstring say = 1; }    Proto To Ballerina  If you already have protocol buffer file for your service(s) you can use that to autogenerate Ballerina source code.  Currently, Ballerina supports two types of code generation. service generation generates a mock version of the  Ballerina service for an input proto definition. client generation generates a Ballerina client endpoint for an  input proto definition.  The Ballerina code generator supports the following parameters:  --input The path of the .proto file. This is a mandatory parameter.  --output The file location in which the Ballerina client/service and the stub must be generated. This is an optional parameter.  If no value is specified for this parameter and proto definition doesn’t contain package value,  the Ballerina client/service and the stub files are generated inside temp directory in the current location.  This path must be a project directory.  --mode The mode (client or server) to generate code samples.  If no value is specified for this parameter, only the stub file will be generated.    syntax = \"proto3\";    service helloWorld {  rpc hello(HelloRequest) returns (HelloResponse);  rpc bye(ByeRequest) returns (ByeResponse); }    message HelloRequest { \tstring name = 1; } message HelloResponse { \tstring message = 1; } message ByeRequest { \tstring greet = 1; } message ByeResponse { \tstring say = 1; }    # Execute the below command in the Ballerina tools distribution to generate the mock service. $ ballerina grpc --input proto_to_ballerina.proto --mode service --output service    # Execute the below command in the Ballerina tools distribution to generate the client endpoint and the stub file. $ ballerina grpc --input proto_to_ballerina.proto --mode client --output client    # Execute the below command in the Ballerina tools distribution to generate the stub file. $ ballerina grpc --input proto_to_ballerina.proto"},{"page":"/learn/by-example/query-action.html","name":"Query Action","summary":"Like a query-expression, a query-action can be used with a value that is iterable with any error type.\n The result of the query-action is the termination value of the iterator.\n Thus, if the source type is infallibly iterable, the result will be () and can be ignored.\n This is a ...","content":"/  /  / Query Action  import ballerina/io;type Student record {  string firstName;  string lastName;  float score; };type FullName record {|  string firstName;  string lastName; |};public function main() {  Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2}; Student[] studentList = [s1, s2, s3]; FullName[] nameList = [];  var e = from var student in studentList  do {  FullName fullName = {firstName: student.firstName, lastName: student.lastName};  nameList.push(fullName);  }; foreach var name in nameList {  io:println(name);  } }    Query Action  Like a query-expression, a query-action can be used with a value that is iterable with any error type.  The result of the query-action is the termination value of the iterator.  Thus, if the source type is infallibly iterable, the result will be () and can be ignored.  This is a preview feature.    import ballerina/io;    type Student record {  string firstName;  string lastName;  float score; };    type FullName record {|  string firstName;  string lastName; |};    public function main() {  Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2};    Student[] studentList = [s1, s2, s3];    FullName[] nameList = [];    var e = from var student in studentList    query-action works similarly to a foreach statement. It can be used to iterate through any iterable value. The result of the query-action is the termination value of the iterable value. It can be either an error or ().   do {  FullName fullName = {firstName: student.firstName, lastName: student.lastName};  nameList.push(fullName);  };    The block inside the do clause is executed for each iteration.   foreach var name in nameList {  io:println(name);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run query_action.bal    firstName=Alex lastName=George firstName=Ranjan lastName=Fonseka firstName=John lastName=David"},{"page":"/learn/by-example/quoted-identifiers.html","name":"Quoted Identifiers","summary":"Ballerina supports quoted identifiers, making it possible to use arbitrary non-empty strings as identifiers,\n including those that are not generally allowed as identifiers (e.g., reserved keywords).\n Quoted identifiers are defined and referenced by prefixing the identifier with the ' character.Use the reserved keyword function as the name of the function.Use ...","content":"/  /  / Quoted Identifiers  import ballerina/io; function 'function(int val) returns int {  return val + 1; }public function main() {  int 'int = 1;  int i = 'function('int);  io:println(i);  int '1PlusI = 1 + i;  io:println('1PlusI); }    Quoted Identifiers  Ballerina supports quoted identifiers, making it possible to use arbitrary non-empty strings as identifiers,  including those that are not generally allowed as identifiers (e.g., reserved keywords).  Quoted identifiers are defined and referenced by prefixing the identifier with the ' character.    import ballerina/io;    function 'function(int val) returns int {  return val + 1; }    Use the reserved keyword function as the name of the function.   public function main() {    int 'int = 1;    Use the reserved keyword int as the name of the variable.   int i = 'function('int);  io:println(i);    Invoke the function named function with the variable named int.  The quoted identifier syntax is used to refer to both the function and  the variable.   int '1PlusI = 1 + i;  io:println('1PlusI); }    Define a variable where the variable name starts with a digit.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run quoted_identifiers.bal 2 3"},{"page":"/learn/by-example/query-path-matrix-param.html","name":"Query Path Matrix Param","summary":"Ballerina supports extracting values using the PathParam, QueryParam and MatrixParam parameters.The PathParam and QueryParam parameters extract values from the request URI.Get the QueryParam value for a given parameter key.Get the MatrixParams.Create a JSON payload with the extracted values.A util method to set the JSON payload to the response message.Send a ...","content":"/  /  / Query Path Matrix Param  import ballerina/http; import ballerina/log;service sample on new http:Listener(9090) { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/path/{foo}\"  }  resource function params(http:Caller caller, http:Request req,  string foo) {  var bar = req.getQueryParamValue(\"bar\");  map<any> pathMParams = req.getMatrixParams(\"/sample/path\");  var a = <string>pathMParams[\"a\"];  var b = <string>pathMParams[\"b\"];  string pathMatrixStr = string `a=${a}, b=${b}`;  map<any> fooMParams = req.getMatrixParams(\"/sample/path/\" + foo);  var x = <string>fooMParams[\"x\"];  var y = <string>fooMParams[\"y\"];  string fooMatrixStr = string `x=${x}, y=${y}`;  json matrixJson = {\"path\": pathMatrixStr, \"foo\": fooMatrixStr};  json responseJson = {  \"pathParam\": foo,  \"queryParam\": bar,  \"matrix\": matrixJson  };  http:Response res = new;  res.setJsonPayload(<@untainted>responseJson);  var result = caller->respond(res); if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    Query Path Matrix Param  Ballerina supports extracting values using the PathParam, QueryParam and MatrixParam parameters.    import ballerina/http; import ballerina/log;    service sample on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/path/{foo}\"  }    resource function params(http:Caller caller, http:Request req,  string foo) {    The PathParam and QueryParam parameters extract values from the request URI.   var bar = req.getQueryParamValue(\"bar\");    Get the QueryParam value for a given parameter key.   map<any> pathMParams = req.getMatrixParams(\"/sample/path\");  var a = <string>pathMParams[\"a\"];  var b = <string>pathMParams[\"b\"];  string pathMatrixStr = string `a=${a}, b=${b}`;  map<any> fooMParams = req.getMatrixParams(\"/sample/path/\" + foo);  var x = <string>fooMParams[\"x\"];  var y = <string>fooMParams[\"y\"];  string fooMatrixStr = string `x=${x}, y=${y}`;  json matrixJson = {\"path\": pathMatrixStr, \"foo\": fooMatrixStr};    Get the MatrixParams.   json responseJson = {  \"pathParam\": foo,  \"queryParam\": bar,  \"matrix\": matrixJson  };  http:Response res = new;    Create a JSON payload with the extracted values.   res.setJsonPayload(<@untainted>responseJson);    A util method to set the JSON payload to the response message.   var result = caller->respond(res);    Send a response to the client.   if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run query_path_matrix_param.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Run this curl command to invoke the service. $ curl \"http://localhost:9090/sample/path;a=4;b=5/value1;x=10;y=15?bar=value2\" {\"pathParam\":\"value1\", \"queryParam\":\"value2\", \"matrix\":{\"path\":\"a=4, b=5\", \"foo\":\"x=10, y=15\"}}"},{"page":"/learn/by-example/query-expression.html","name":"Query Expression","summary":"A query expression is a list comprehension, which can be used with a value that is iterable with any error type.\n It consists of four kinds of clauses: from, let, where, and select.\n The first clause must be a from clause and the last clause must be a select.\n The ...","content":"/  /  / Query Expression  import ballerina/io;type Student record {  string firstName;  string lastName;  int intakeYear;  float score; };type Report record {  string name;  string degree;  int expectedGradYear; };public function main() { Student s1 = {firstName: \"Alex\", lastName: \"George\", intakeYear: 2020, score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", intakeYear: 2020, score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", intakeYear: 2022, score: 1.2}; Student[] studentList = [s1, s2, s3];  Report[] reportList = from var student in studentList  where student.score >= 1  let string degreeName = \"Bachelor of Medicine\",  int graduationYear = calGraduationYear(student.intakeYear)  select {  name: student.firstName,  degree: degreeName,  expectedGradYear: graduationYear  }; foreach var report in reportList {  io:println(report);  } }function calGraduationYear(int year) returns int {  return year + 5; }    Query Expression  A query expression is a list comprehension, which can be used with a value that is iterable with any error type.  It consists of four kinds of clauses: from, let, where, and select.  The first clause must be a from clause and the last clause must be a select.  The result of the query expression is a list.  This is a preview feature.    import ballerina/io;    type Student record {  string firstName;  string lastName;  int intakeYear;  float score; };    type Report record {  string name;  string degree;  int expectedGradYear; };    public function main() {    Student s1 = {firstName: \"Alex\", lastName: \"George\", intakeYear: 2020, score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", intakeYear: 2020, score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", intakeYear: 2022, score: 1.2};    Student[] studentList = [s1, s2, s3];    Report[] reportList = from var student in studentList    The from clause works similarly to a foreach statement. It can be used to iterate any iterable value. The outputStudentList is the result of the query expression.   where student.score >= 1    The where clause provides a way to perform conditional execution and works similarly to an if condition. It can refer to variables bound by the from clause. When the where condition evaluates to false, the iteration skips following the clauses.   let string degreeName = \"Bachelor of Medicine\",  int graduationYear = calGraduationYear(student.intakeYear)    The let clause binds the variables.   select {  name: student.firstName,  degree: degreeName,  expectedGradYear: graduationYear  };    The select clause is evaluated for each iteration. The result of the query expression is a list(reportList) whose members are the result of the select clause.   foreach var report in reportList {  io:println(report);  } }    function calGraduationYear(int year) returns int {  return year + 5; }    # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run query_expression.bal    name=Alex degree=Bachelor of Medicine expectedGradYear=2025 name=John degree=Bachelor of Medicine expectedGradYear=2027"},{"page":"/learn/by-example/rabbitmq-consumer-with-data-binding.html","name":"Data Binding","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener.\n The messages can be accessed using the rabbitmq:Message object and also\n the second parameter of the resource function.\n string, json, xml, byte[], record, float and int are\n supported as parameter types.Creates a ballerina ...","content":"/  /  / Data Binding  import ballerina/log; import ballerina/rabbitmq; rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});listener rabbitmq:Listener channelListener = new (connection);@rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK } service dataBindingConsumer on channelListener {  resource function onMessage(rabbitmq:Message message, string stringMessage) {  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }  log:printInfo(\"The message received from data binding: \" + stringMessage);  var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  }  resource function onError(rabbitmq:Message message, error err) {  log:printError(\"Error from connector: \" + err.reason() + \" - \"  + <string>err.detail()?.message);  } }# Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_data_binding.bal' file, and issue the 'ballerina run' command as follows.    Data Binding  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener.  The messages can be accessed using the rabbitmq:Message object and also  the second parameter of the resource function.  string, json, xml, byte[], record, float and int are  supported as parameter types.    import ballerina/log; import ballerina/rabbitmq;    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows re-usability if necessary.   listener rabbitmq:Listener channelListener = new (connection);    @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK }    service dataBindingConsumer on channelListener {    Attaches the service to the listener.   resource function onMessage(rabbitmq:Message message, string stringMessage) {    Gets triggered when a message is received by the queue.   var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }    Retrieves the text content of the message.   log:printInfo(\"The message received from data binding: \" + stringMessage);    Message content can be accessed using the second parameter  of the resource function.   var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  }    Acknowledges a single message positively.   resource function onError(rabbitmq:Message message, error err) {  log:printError(\"Error from connector: \" + err.reason() + \" - \"  + <string>err.detail()?.message);  } }    Gets triggered when an error is encountered.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_data_binding.bal' file, and issue the 'ballerina run' command as follows.    $ ballerina run rabbitmq_consumer_with_data_binding.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    2019-06-13 13:15:35,611 INFO [] - The message received: Hello from Ballerina 2019-06-13 13:15:35,612 INFO [] - The message received from data binding: Hello from Ballerina"},{"page":"/learn/by-example/rabbitmq-consumer-with-client-acknowledgement.html","name":"Client Acknowledgements","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener.\n The received messages are acknowledged manually.\n By default, the ackMode is rabbitmq:AUTO_ACK, which will automatically acknowledge\n all messages once consumed.Creates a ballerina RabbitMQ connection that allows re-usability if necessary.The consumer service listens to ...","content":"/  /  / Client Acknowledgements  import ballerina/log; import ballerina/rabbitmq; rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});listener rabbitmq:Listener channelListener = new (connection); @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK } service rabbitmqConsumerAck on channelListener {  resource function onMessage(rabbitmq:Message message) {  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }  var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  } }# Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_client_acknowledgement.bal' file and issue the 'ballerina run' command as follows..    Client Acknowledgements  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener.  The received messages are acknowledged manually.  By default, the ackMode is rabbitmq:AUTO_ACK, which will automatically acknowledge  all messages once consumed.    import ballerina/log; import ballerina/rabbitmq;    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows re-usability if necessary.   listener rabbitmq:Listener channelListener = new (connection);    @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK }    The consumer service listens to the “MyQueue” queue.  ackMode is by default rabbitmq:AUTO_ACK which will automatically acknowledge  all messages once consumed.   service rabbitmqConsumerAck on channelListener {    Attaches the service to the listener.   resource function onMessage(rabbitmq:Message message) {    Gets triggered when a message is received by the queue.   var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }    Retrieves the text content of the message.   var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  } }    Positively acknowledges a single message.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_client_acknowledgement.bal' file and issue the 'ballerina run' command as follows..    $ ballerina run rabbitmq_consumer_with_client_acknowledgement.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    2019-03-29 12:11:18,194 INFO [] - The message received: Hello from Ballerina"},{"page":"/learn/by-example/rabbitmq-consumer.html","name":"Consumer","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener.\n The Ballerina RabbitMQ connection used here can be re-used to create\n multiple channels.\n Multiple services consuming messages from the same queue or from\n different queues can be attached to the same Listener.Creates a ...","content":"/  /  / Consumer  import ballerina/log; import ballerina/rabbitmq; rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});listener rabbitmq:Listener channelListener = new (connection); @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  } } service rabbitmqConsumer on channelListener {  resource function onMessage(rabbitmq:Message message) {  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }  } }# Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer.bal' file, and issue the 'ballerina run' command as follows..    Consumer  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener.  The Ballerina RabbitMQ connection used here can be re-used to create  multiple channels.  Multiple services consuming messages from the same queue or from  different queues can be attached to the same Listener.    import ballerina/log; import ballerina/rabbitmq;    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows re-usability if necessary.   listener rabbitmq:Listener channelListener = new (connection);    @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  } }    The consumer service listens to the “MyQueue” queue.  The ackMode is by default rabbitmq:AUTO_ACK where messages are acknowledged  immediately after consuming.   service rabbitmqConsumer on channelListener {    Attaches the service to the listener.   resource function onMessage(rabbitmq:Message message) {    Gets triggered when a message is received by the queue.   var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }  } }    Retrieves the text content of the message.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer.bal' file, and issue the 'ballerina run' command as follows..    $ ballerina run rabbitmq_consumer.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    2019-03-29 12:11:18,194 INFO [] - The message received: Hello from Ballerina"},{"page":"/learn/by-example/rabbitmq-producer.html","name":"Producer","summary":"In this example, messages are sent to two different queues,\n to one queue using the same channel and to the other using two different channels.Creates a ballerina RabbitMQ connection that allows re-usability if necessary.Creates multiple ballerina RabbitMQ channels.Declares the queue, MyQueue1.Declares the queue, MyQueue2.Publishing messages to an exchange using a ...","content":"/  /  / Producer  import ballerina/io; import ballerina/rabbitmq;public function main() {  rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});  rabbitmq:Channel newChannel1 = new (connection);  rabbitmq:Channel newChannel2 = new (connection);  var queueResult1 = newChannel1->queueDeclare({queueName: \"MyQueue1\"});  if (queueResult1 is error) {  io:println(\"An error occurred while creating the MyQueue1 queue.\");  }  var queueResult2 = newChannel2->queueDeclare({queueName: \"MyQueue2\"});  if (queueResult2 is error) {  io:println(\"An error occurred while creating the MyQueue2 queue.\");  }  worker w1 {  var sendResult = newChannel1->basicPublish(\"Hello from Ballerina\",  \"MyQueue1\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue1 using newChannel1.\");  }  }  worker w2 {  var sendResult = newChannel2->basicPublish(\"Hello from Ballerina\",  \"MyQueue1\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue1 using newChannel2.\");  }  }  worker w3 {  var sendResult = newChannel1->basicPublish(\"Hello from Ballerina\",  \"MyQueue2\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue2 using newChannel1.\");  }  }  _ = wait {w1, w2, w3}; }# Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_producer.bal' file, and issue the 'ballerina run' command as follows..    Producer  In this example, messages are sent to two different queues,  to one queue using the same channel and to the other using two different channels.    import ballerina/io; import ballerina/rabbitmq;    public function main() {    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows re-usability if necessary.   rabbitmq:Channel newChannel1 = new (connection);  rabbitmq:Channel newChannel2 = new (connection);    Creates multiple ballerina RabbitMQ channels.   var queueResult1 = newChannel1->queueDeclare({queueName: \"MyQueue1\"});  if (queueResult1 is error) {  io:println(\"An error occurred while creating the MyQueue1 queue.\");  }    Declares the queue, MyQueue1.   var queueResult2 = newChannel2->queueDeclare({queueName: \"MyQueue2\"});  if (queueResult2 is error) {  io:println(\"An error occurred while creating the MyQueue2 queue.\");  }    Declares the queue, MyQueue2.   worker w1 {  var sendResult = newChannel1->basicPublish(\"Hello from Ballerina\",  \"MyQueue1\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue1 using newChannel1.\");  }  }    Publishing messages to an exchange using a routing key.  Publishes the message using newChannel1 and the routing key named MyQueue1.   worker w2 {  var sendResult = newChannel2->basicPublish(\"Hello from Ballerina\",  \"MyQueue1\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue1 using newChannel2.\");  }  }    Publishing messages to the same routing key using a different channel.  Publishes the message using newChannel2 and the same routing key named MyQueue1.   worker w3 {  var sendResult = newChannel1->basicPublish(\"Hello from Ballerina\",  \"MyQueue2\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue2 using newChannel1.\");  }  }  _ = wait {w1, w2, w3}; }    Publishing messages to different routing keys using the same channel.  Publishes the message using newChannel1 to a different routing key named MyQueue2.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_producer.bal' file, and issue the 'ballerina run' command as follows..    $ ballerina run rabbitmq_producer.bal"},{"page":"/learn/by-example/rabbitmq-consumer-with-qos-settings.html","name":"QoS Settings","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener,\n requesting specific “quality of service” settings.\n These settings (i.e., prefetchCount and prefetchSize) impose limits on the amount\n of data the server will deliver to consumers before requiring acknowledgements.\n Thus, they provide a means ...","content":"/  /  / QoS Settings  import ballerina/log; import ballerina/rabbitmq; rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});listener rabbitmq:Listener channelListener = new (connection); @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK,  prefetchCount: 10 } service QosConsumer on channelListener {  resource function onMessage(rabbitmq:Message message) {  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }  var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  } }# Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_qos_settings.bal' file and issue the 'ballerina run' command as follows..    QoS Settings  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener,  requesting specific “quality of service” settings.  These settings (i.e., prefetchCount and prefetchSize) impose limits on the amount  of data the server will deliver to consumers before requiring acknowledgements.  Thus, they provide a means of consumer-initiated flow control.  prefetchSize is the maximum amount of content (measured in octets)  that the server will deliver.  If the prefetchSize is given as 0, it will be considered unlimited.  prefetchCount is the maximum number of messages that the server will deliver.  If the prefetchCount is given as 0, it will be considered unlimited.  If the settings are specified at the listener initialization, they will be  applied for the entire connection as a global setting.  To apply the settings per consumer service, they should be specified in the  service config annotation.    import ballerina/log; import ballerina/rabbitmq;    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows reusability if necessary.   listener rabbitmq:Listener channelListener = new (connection);    @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK,  prefetchCount: 10 }    The consumer service listens to the “MyQueue” queue.  Quality of service settings(prefetchCount and prefetchSize) can be  set at the listener initialization globally or per consumer service.  These settings impose limits on the amount of data the server  will deliver to consumers before requiring acknowledgements.  Thus they provide a means of consumer-initiated flow control.   service QosConsumer on channelListener {    Attaches the service to the listener.   resource function onMessage(rabbitmq:Message message) {  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }    Gets triggered when a message is received by the queue.   var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  } }    The consumer will continue to receive messages from the server  once a total of 10(prefetchCount) messages are being acknowledged.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_qos_settings.bal' file and issue the 'ballerina run' command as follows..    $ ballerina run rabbitmq_consumer_with_qos_settings.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    2019-03-29 12:11:18,194 INFO [] - The message received: Hello from Ballerina"},{"page":"/learn/by-example/range-expressions.html","name":"Range Expressions","summary":"Range expressions result in iterable objects that allow iterating over a sequence of integers in increasing order.\n Range expressions are mainly expected to be used in foreach statements but could be used anywhere.A range expression x ... y can be used to iterate integers\n from x to y including x ...","content":"/  /  / Range Expressions  import ballerina/io;public function main() {  io:println(\"foreach for 25 ... 28\");  foreach int i in 25 ... 28 {  io:println(i);  }  io:println(\"\\nforeach for 25 ..< 28\");  foreach int i in 25 ..< 28 {  io:println(i);  }  abstract object {  public function __iterator() returns  abstract object {  public function next() returns record {|int value;|}?;  };  } iterableObj = 25 ..< 28; abstract object {  public function next() returns (record {|int value;|}?);  } iterator = iterableObj.__iterator(); io:println(\"\\niterable object for 25 ..< 28\");  while (true) {  record {|int value;|}? r = iterator.next();  if (r is record {|int value;|}) {  io:println(r.value);  } else {  break;  }  } }    Range Expressions  Range expressions result in iterable objects that allow iterating over a sequence of integers in increasing order.  Range expressions are mainly expected to be used in foreach statements but could be used anywhere.    import ballerina/io;    public function main() {    io:println(\"foreach for 25 ... 28\");  foreach int i in 25 ... 28 {  io:println(i);  }    A range expression x ... y can be used to iterate integers  from x to y including x and y in ascending order.   io:println(\"\\nforeach for 25 ..< 28\");  foreach int i in 25 ..< 28 {  io:println(i);  }    A range expression x ..< y can be used to iterate integers  from x to y including x but excluding y in ascending order.   abstract object {  public function __iterator() returns  abstract object {  public function next() returns record {|int value;|}?;  };  } iterableObj = 25 ..< 28;    The result of a range expression can also be used by assigning it to  an object belonging to the abstract object type Iterable<int>.   abstract object {  public function next() returns (record {|int value;|}?);  } iterator = iterableObj.__iterator();    io:println(\"\\niterable object for 25 ..< 28\");  while (true) {  record {|int value;|}? r = iterator.next();  if (r is record {|int value;|}) {  io:println(r.value);  } else {    break;  }  } }    r is () implying the end of the iteration.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run range_expressions.bal foreach for 25 ... 28 25 26 27 28    foreach for 25 ..< 28 25 26 27    iterable object for 25 ..< 28 25 26 27"},{"page":"/learn/by-example/record-destructure-binding-pattern.html","name":"Record Destructure Binding Pattern","summary":"Record destructure binding patterns are used to destructure and assign the values of each field in the destructed record to variable references.\n The record destructuring binding patterns will be used to refer to existing variables as a record, destructure\n the given value on the right hand side, and assign the ...","content":"/  /  / Record Destructure Binding Pattern  import ballerina/io;type Person record {  string name;  int age;  string country; };type Country record {  string name;  Capital capital; };type Capital record {|  string name; |};public function main() { string firstName;  int personAge;  map<anydata|error> otherDetails = {};  {name: firstName, age: personAge, ...otherDetails} = getPerson();  io:println(\"Name: \", firstName);  io:println(\"Age: \", personAge);  io:println(\"Other Details: \", otherDetails); string name;  int age;  {name, age} = getPerson();  io:println(\"Name: \", name);  io:println(\"Age: \", age); string countryName;  string capitalName;  {name: countryName, capital: {name: capitalName}} = getCountry();  io:println(\"Country Name: \", countryName);  io:println(\"Capital Name: \", capitalName); }function getPerson() returns Person {  Person person = {  name: \"Peter\",  age: 28,  country: \"Sri Lanka\",  \"occupation\": \"Software Engineer\"  };  return person; }function getCountry() returns Country {  Capital capital = {name: \"Colombo\"};  Country country = {name: \"Sri Lanka\", capital: capital};  return country; }    Record Destructure Binding Pattern  Record destructure binding patterns are used to destructure and assign the values of each field in the destructed record to variable references.  The record destructuring binding patterns will be used to refer to existing variables as a record, destructure  the given value on the right hand side, and assign the values to each individual variable of the record during the runtime.    import ballerina/io;    type Person record {  string name;  int age;  string country; };    type Country record {  string name;  Capital capital; };    type Capital record {|  string name; |};    public function main() {    string firstName;  int personAge;  map<anydata|error> otherDetails = {};    {name: firstName, age: personAge, ...otherDetails} = getPerson();  io:println(\"Name: \", firstName);  io:println(\"Age: \", personAge);  io:println(\"Other Details: \", otherDetails);    This record destructure binding pattern will destructure a record of the type Person and assign the values  to three variable references as follows:  The value of the field name in the Person record will be assigned to the variable firstName.  The value of the field age in the Person record will be assigned to the variable personAge.  ...otherDetails is a rest parameter. Since Person is an open record, the remaining field values that have  not been matched in the record binding pattern will be assigned as a map<anydata|error> to the variable  otherDetails.   string name;  int age;    {name, age} = getPerson();  io:println(\"Name: \", name);  io:println(\"Age: \", age);    If no variable name is given for a field, the value of the field will be assigned to a variable reference of the  same name as the field.  i.e., {name, age} is same as {name: name, age: age}.  Since a rest parameter is not given, all remaining fields are ignored.   string countryName;  string capitalName;    {name: countryName, capital: {name: capitalName}} = getCountry();  io:println(\"Country Name: \", countryName);  io:println(\"Capital Name: \", capitalName); }    Binding patterns are recursive in nature. capital, which is a field of type Capital in Country can also be  destructured as follows:   function getPerson() returns Person {  Person person = {  name: \"Peter\",  age: 28,  country: \"Sri Lanka\",  \"occupation\": \"Software Engineer\"  };  return person; }    function getCountry() returns Country {  Capital capital = {name: \"Colombo\"};  Country country = {name: \"Sri Lanka\", capital: capital};  return country; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run record_destructure_binding_pattern.bal Name: Peter Age: 28 Other Details: country=Sri Lanka occupation=Software Engineer Name: Peter Age: 28 Country Name: Sri Lanka Capital Name: Colombo"},{"page":"/learn/by-example/record-match-statement.html","name":"Record Match","summary":"The match statement in Ballerina will support value-based match patterns only. There are static and structured\n based match patterns that can be used with the match clauses. Structured match patterns will take structured\n binding patterns for matching. Record binding pattern is one of the structured binding patterns that can be ...","content":"/  /  / Record Match  import ballerina/io;type RecordOne record {  string var1; };type RecordTwo record {|  string var1;  int var2; |};type RecordThree record {  string var1;  RecordTwo var2; };public function main() {  RecordOne rec1 = {var1: \"Hello\", \"var2\": 150};  RecordOne rec2 = {var1: \"Hello\", \"var2\": true};  RecordOne rec3 = {var1: \"Hello\", \"var2\": 150, \"var3\": true};  RecordOne rec4 = {var1: \"Hello\"}; basicMatch(rec1);  basicMatch(rec2);  basicMatch(rec3);  basicMatch(rec4); RecordTwo tRec1 = {var1: \"Ballerina\", var2: 500};  RecordThree tRec2 = {var1: \"Language\", var2: tRec1}; matchWithTypeGuard(tRec1);  matchWithTypeGuard(tRec2);  matchWithTypeGuard(true); } function basicMatch(any a) {  match a {  var {var1, var2, var3} => {  io:println(\"Matched with three vars : \", var1, \", \", var2, \", \", var3);  }  var {var1, var2} => {  io:println(\"Matched with two vars : \", var1, \", \", var2);  }  var {var1} => {  io:println(\"Matched with single var : \", var1);  }  } } function matchWithTypeGuard(any matchExpr) {  match matchExpr {  var {var1, var2} if var2 is string => {  io:println(\"Matched with string typeguard\");  }  var {var1, var2} if (var1 is int && var2 is int) => {  io:println(\"Matched with int and int typeguard : \", var1);  }  var {var1, var2} if (var1 is string && var2 is int) => {  io:println(\"Matched with string and int typeguard : \", var1);  }  var {var1, var2} if (var1 is int && var2 is RecordTwo) => {  io:println(\"Matched with int and RecordTwo typeguard : \", var1);  }  var {var1, var2} if (var1 is string && var2 is RecordTwo) => {  io:println(\"Matched with string and RecordTwo typeguard : \", var2.var1);  }  var x => {  io:println(\"Matched with Default\");  }  } }    Record Match  The match statement in Ballerina will support value-based match patterns only. There are static and structured  based match patterns that can be used with the match clauses. Structured match patterns will take structured  binding patterns for matching. Record binding pattern is one of the structured binding patterns that can be used  with the match. The value will be checked for “isLike” relationship with the pattern to match at runtime.  The match pattern clauses can also have additional type guard conditions as strong match conditions.    import ballerina/io;    type RecordOne record {  string var1; };    type RecordTwo record {|  string var1;  int var2; |};    type RecordThree record {  string var1;  RecordTwo var2; };    public function main() {  RecordOne rec1 = {var1: \"Hello\", \"var2\": 150};  RecordOne rec2 = {var1: \"Hello\", \"var2\": true};  RecordOne rec3 = {var1: \"Hello\", \"var2\": 150, \"var3\": true};  RecordOne rec4 = {var1: \"Hello\"};    basicMatch(rec1);  basicMatch(rec2);  basicMatch(rec3);  basicMatch(rec4);    RecordTwo tRec1 = {var1: \"Ballerina\", var2: 500};  RecordThree tRec2 = {var1: \"Language\", var2: tRec1};    matchWithTypeGuard(tRec1);  matchWithTypeGuard(tRec2);  matchWithTypeGuard(true); }    function basicMatch(any a) {  match a {    This method uses structured record match patterns with different fields. The given match expression will  be checked for “isLike” relationship and will be matched at runtime.   var {var1, var2, var3} => {  io:println(\"Matched with three vars : \", var1, \", \", var2, \", \", var3);  }    This pattern checks for a mapping value with three fields var1, var2 and var3 and types will  be any in the pattern block.   var {var1, var2} => {  io:println(\"Matched with two vars : \", var1, \", \", var2);  }    This pattern checks for a mapping value with two fields var1, var2 and types will be any in  the pattern block.   var {var1} => {  io:println(\"Matched with single var : \", var1);  }  } }    This pattern checks for a mapping value with single field var1 and type will be any in the pattern block.   function matchWithTypeGuard(any matchExpr) {    This method uses structured record match patterns with different fields  along with type guards. The expression used with match will be evaluated to  check if it “is like” any of the match patterns. For a successful match, an additional  check will also be performed against the specified type guard.   match matchExpr {    All the patterns except the last one will check for a mapping value with two fields var1 and var2  with a given type guard.   var {var1, var2} if var2 is string => {  io:println(\"Matched with string typeguard\");  }    This pattern will only match if var2 is of the type string.   var {var1, var2} if (var1 is int && var2 is int) => {  io:println(\"Matched with int and int typeguard : \", var1);  }    This pattern will only match if var1 is of the type int and var2 is of the type int.   var {var1, var2} if (var1 is string && var2 is int) => {  io:println(\"Matched with string and int typeguard : \", var1);  }    This pattern will only match if var1 is of the type string and var2 is of the type int.   var {var1, var2} if (var1 is int && var2 is RecordTwo) => {  io:println(\"Matched with int and RecordTwo typeguard : \", var1);  }    This pattern will only match if var1 is of the type int and var2 is of the type RecordTwo.   var {var1, var2} if (var1 is string && var2 is RecordTwo) => {  io:println(\"Matched with string and RecordTwo typeguard : \", var2.var1);  }    This pattern will only match if var1 is of the type string and var2 is of the type RecordTwo.   var x => {  io:println(\"Matched with Default\");  }  } }    A pattern with a single identifier can be used as the last match pattern and all values will  be matched to this.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run record_match_statement.bal Matched with two vars : Hello, 150 Matched with two vars : Hello, true Matched with three vars : Hello, 150, true Matched with single var : Hello Matched with string and int typeguard : Ballerina Matched with string and RecordTwo typeguard : Ballerina Matched with Default"},{"page":"/learn/by-example/record-io.html","name":"Record I/O","summary":"This example demonstrates how to read and write records using I/O APIs.This function returns a ReadableTextRecordChannel from a given file location.\n The encoding is a character representation (i.e., UTF-8 ASCCI) of the\n content in the file. The rs parameter defines a record separator\n (e.g., a new line) and the fs ...","content":"/  /  / Record I/O  import ballerina/io; import ballerina/log; function getReadableRecordChannel(string filePath, string encoding,  string rs, string fs)  returns @tainted io:ReadableTextRecordChannel|error {  io:ReadableByteChannel byteChannel = check io:openReadableFile(filePath);  io:ReadableCharacterChannel characterChannel = new (byteChannel, encoding);  io:ReadableTextRecordChannel delimitedRecordChannel = new (characterChannel,  rs = rs,  fs = fs);  return delimitedRecordChannel; } function getWritableRecordChannel(string filePath, string encoding, string rs,  string fs)  returns @tainted io:WritableTextRecordChannel|error {  io:WritableByteChannel byteChannel = check io:openWritableFile(filePath);  io:WritableCharacterChannel characterChannel = new (byteChannel, encoding);  io:WritableTextRecordChannel delimitedRecordChannel = new(characterChannel,  rs = rs,  fs = fs);  return delimitedRecordChannel; } function process(io:ReadableTextRecordChannel srcRecordChannel,  io:WritableTextRecordChannel dstRecordChannel)  returns @tainted error? {  while (srcRecordChannel.hasNext()) {  string[] records = check srcRecordChannel.getNext();  var result = check dstRecordChannel.write(records);  }  return; } function closeRc(io:ReadableTextRecordChannel rc) {  var closeResult = rc.close();  if (closeResult is error) {  log:printError(\"Error occurred while closing the channel: \", closeResult);  } } function closeWc(io:WritableTextRecordChannel wc) {  var closeResult = wc.close();  if (closeResult is error) {  log:printError(\"Error occurred while closing the channel: \", closeResult);  } } public function main() {  string srcFileName = \"./files/sample.csv\";  string dstFileName = \"./files/sampleResponse.txt\";  io:ReadableTextRecordChannel srcRecordChannel;  var readableChannel = getReadableRecordChannel(srcFileName,  \"UTF-8\", \"\\\\r?\\\\n\", \",\");  if (readableChannel is error) {  log:printError(\"An error occurred while creating readable record channel. \",  readableChannel);  return;  } else {  srcRecordChannel = readableChannel;  }  io:WritableTextRecordChannel dstRecordChannel;  var writableChannel = getWritableRecordChannel(dstFileName,  \"UTF-8\", \"\\r\\n\", \"|\");  if (writableChannel is error) {  log:printError(\"An error occurred while creating writable record channel. \",  writableChannel);  return;  } else {  dstRecordChannel = writableChannel;  } io:println(\"Start processing the CSV file from \" + srcFileName +  \" to the text file in \" + dstFileName);  var result = process(srcRecordChannel, dstRecordChannel);  if (result is error) {  log:printError(\"An error occurred while processing the records: \", result);  } else {  io:println(\"Processing completed. The processed file is located in \",  dstFileName);  }  closeRc(srcRecordChannel);  closeWc(dstRecordChannel); }    Record I/O  This example demonstrates how to read and write records using I/O APIs.    import ballerina/io; import ballerina/log;    function getReadableRecordChannel(string filePath, string encoding,  string rs, string fs)  returns @tainted io:ReadableTextRecordChannel|error {  io:ReadableByteChannel byteChannel = check io:openReadableFile(filePath);    This function returns a ReadableTextRecordChannel from a given file location.  The encoding is a character representation (i.e., UTF-8 ASCCI) of the  content in the file. The rs parameter defines a record separator  (e.g., a new line) and the fs parameter is a field separator  (e.g., a comma).   io:ReadableCharacterChannel characterChannel = new (byteChannel, encoding);    Creates a readable character channel  from the readable byte channel to read the content as text.   io:ReadableTextRecordChannel delimitedRecordChannel = new (characterChannel,  rs = rs,  fs = fs);  return delimitedRecordChannel; }    Converts the readable character channel to a readable record channel  to read the content as records.   function getWritableRecordChannel(string filePath, string encoding, string rs,  string fs)  returns @tainted io:WritableTextRecordChannel|error {  io:WritableByteChannel byteChannel = check io:openWritableFile(filePath);    This function returns a WritableTextRecordChannel from a given file location.  The encoding is a character representation (i.e., UTF-8 ASCCI) of the  content in the file. The rs parameter defines a record separator  (e.g., a new line) and the fs parameter is a field separator  (e.g., a comma).   io:WritableCharacterChannel characterChannel = new (byteChannel, encoding);    Creates a writable character channel  from the writable byte channel to read the content as text.   io:WritableTextRecordChannel delimitedRecordChannel = new(characterChannel,  rs = rs,  fs = fs);  return delimitedRecordChannel; }    Converts the writable character channel to a writable record channel  to read the content as records.   function process(io:ReadableTextRecordChannel srcRecordChannel,  io:WritableTextRecordChannel dstRecordChannel)  returns @tainted error? {    This function processes the .CSV file and  writes the content back as text with the | delimiter.   while (srcRecordChannel.hasNext()) {    Reads all the records from the provided file until there are  no more records.   string[] records = check srcRecordChannel.getNext();    Reads the records.   var result = check dstRecordChannel.write(records);  }  return; }    Writes the records.   function closeRc(io:ReadableTextRecordChannel rc) {  var closeResult = rc.close();  if (closeResult is error) {  log:printError(\"Error occurred while closing the channel: \", closeResult);  } }    Closes the readable text record channel.   function closeWc(io:WritableTextRecordChannel wc) {  var closeResult = wc.close();  if (closeResult is error) {  log:printError(\"Error occurred while closing the channel: \", closeResult);  } }    Closes the writable channel.   public function main() {  string srcFileName = \"./files/sample.csv\";  string dstFileName = \"./files/sampleResponse.txt\";    Specifies the location of the .CSV file and the text file.   io:ReadableTextRecordChannel srcRecordChannel;  var readableChannel = getReadableRecordChannel(srcFileName,  \"UTF-8\", \"\\\\r?\\\\n\", \",\");  if (readableChannel is error) {  log:printError(\"An error occurred while creating readable record channel. \",  readableChannel);  return;  } else {  srcRecordChannel = readableChannel;  }    The record separator of the .CSV file is a  new line and the field separator is a comma (,).   io:WritableTextRecordChannel dstRecordChannel;  var writableChannel = getWritableRecordChannel(dstFileName,  \"UTF-8\", \"\\r\\n\", \"|\");  if (writableChannel is error) {  log:printError(\"An error occurred while creating writable record channel. \",  writableChannel);  return;  } else {  dstRecordChannel = writableChannel;  }    The record separator of the text file is a new line and the field separator is a pipe (|).   io:println(\"Start processing the CSV file from \" + srcFileName +  \" to the text file in \" + dstFileName);  var result = process(srcRecordChannel, dstRecordChannel);  if (result is error) {  log:printError(\"An error occurred while processing the records: \", result);  } else {  io:println(\"Processing completed. The processed file is located in \",  dstFileName);  }    closeRc(srcRecordChannel);  closeWc(dstRecordChannel); }    Closes the channels.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run record_io.bal Start processing the CSV file from ./files/sample.csv to the text file in ./files/sampleResponse.txt Processing completed. The processed file is located in ./files/sampleResponse.txt"},{"page":"/learn/by-example/record-optional-fields.html","name":"Optional Fields","summary":"Fields of a record can be marked as optional. These fields can be omitted when creating a record.\n Such fields can be accessed via optional field access (e.g., p?.name) or member access (e.g., p[“name”])\n which will both return () if the field is not present in the record.This is a ...","content":"/  /  / Optional Fields  import ballerina/io;type Gender \"male\"|\"female\";type Person record {  string fname;  string lname = \"\"; Gender gender;  int age?; };public function main() {  Person john = {fname: \"John\", gender: \"male\"};  io:println(\"Person with the non-defaultable required field set: \", john);  int? age = john?.age;  io:println(\"Age before setting: \", age);  john.age = 25;  age = john?.age;  io:println(\"Age after setting: \", age);  Person jane = {fname: \"Jane\", lname: \"Doe\", gender: \"female\"};  io:println(\"Person with values assigned to required fields: \", jane); }    Optional Fields  Fields of a record can be marked as optional. These fields can be omitted when creating a record.  Such fields can be accessed via optional field access (e.g., p?.name) or member access (e.g., p[“name”])  which will both return () if the field is not present in the record.    import ballerina/io;    type Gender \"male\"|\"female\";    type Person record {    string fname;    This is a required field without an explicit default value.  The compiler will not assign default values. Therefore, a value should be specified  for this field when creating the record.   string lname = \"\";    This is a required field with an explicit default value specified.   Gender gender;    int age?; };    Adding ? following the identifier marks the field as an optional field.   public function main() {    Person john = {fname: \"John\", gender: \"male\"};    The required fields fname and gender are not given default values in the record type descriptor.  Therefore, values must be specified for fname and gender when creating the record.   io:println(\"Person with the non-defaultable required field set: \", john);    The age field is not present in the record since it is an optional field.   int? age = john?.age;  io:println(\"Age before setting: \", age);    Optional fields of the record can be accessed using the ?. operator.  This returns the value if the field is present in the record. Returns () if not.  Since the age field is not set, optional field access returns () here.   john.age = 25;    Now set a value for the age field. Field access can be used to set the value since  age is a field defined in the type descriptor for Person.   age = john?.age;  io:println(\"Age after setting: \", age);    Since the age field is set, optional field access returns the int-typed value.   Person jane = {fname: \"Jane\", lname: \"Doe\", gender: \"female\"};    Create a Person-typed value specifying a value for the defaultable field lname.   io:println(\"Person with values assigned to required fields: \", jane); }    Field values provided when creating a record takes highest precedence.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run record_optional_fields.bal Person with the non-defaultable required field set: fname=John lname= gender=male Age before setting: Age after setting: 25 Person with values assigned to required fields: fname=Jane lname=Doe gender=female"},{"page":"/learn/by-example/record-type-reference.html","name":"Record Type Reference","summary":"Record type referencing provides a convenient way to copy the fields defined in a record type descriptor\n to another record type descriptor. It is equivalent to explicitly defining those fields in the new type descriptor.\n If the record being type-referenced has fields with explicitly-assigned default values, those values would also ...","content":"/  /  / Record Type Reference  import ballerina/io;type Person record {|  string name;  int age = 25; |};type Employee record {|  *Person;  string company?;  string designation; |};type Manager record {  Employee[] team?;  *Employee; };public function main() {  Employee john = {name: \"John Doe\", designation: \"Software Engineer\"};  Employee jane = {name: \"Jane Doe\", designation: \"UX Engineer\"};  io:println(john);  io:println(jane); Manager mgr = {name: \"Mark\", age: 35, designation: \"Engineering Manager\"};  mgr.team = [john, jane];  mgr.company = \"XYZ Inc.\"; io:println(mgr); }    Record Type Reference  Record type referencing provides a convenient way to copy the fields defined in a record type descriptor  to another record type descriptor. It is equivalent to explicitly defining those fields in the new type descriptor.  If the record being type-referenced has fields with explicitly-assigned default values, those values would also be  copied. A record type descriptor can have multiple type references as well as chained-type references.  Type referencing applies to both open and closed records. In open records, the rest field is not considered for  type referencing in open records.    import ballerina/io;    type Person record {|  string name;  int age = 25; |};    type Employee record {|    *Person;  string company?;  string designation; |};    References the Person record.   type Manager record {  Employee[] team?;    *Employee; };    References the Employee record. Since Employee references Person,  Manager will have the fields of Person and the additional fields  in Employee.   public function main() {    Employee john = {name: \"John Doe\", designation: \"Software Engineer\"};  Employee jane = {name: \"Jane Doe\", designation: \"UX Engineer\"};    Employee has all the fields of Person.   io:println(john);  io:println(jane);    Type referencing copies the fields including their properties  (e.g., type, default value, optional status). As it can be seen  by printing an Employee record, the optional field company  is not included in the record.   Manager mgr = {name: \"Mark\", age: 35, designation: \"Engineering Manager\"};  mgr.team = [john, jane];  mgr.company = \"XYZ Inc.\";    io:println(mgr); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run record_type_reference.bal designation=Software Engineer name=John Doe age=25 designation=UX Engineer name=Jane Doe age=25 team=designation=Software Engineer name=John Doe age=25 designation=UX Engineer name=Jane Doe age=25 company=XYZ Inc. designation=Engineering Manager name=Mark age=35"},{"page":"/learn/by-example/record-typed-binding-pattern.html","name":"Record-Typed Binding Pattern","summary":"Record typed binding patterns are used in declaring and defining new variables by destructuring fields in a record variable.\n The record type binding pattern statement must have an assignment expression on the right hand side.This record type binding pattern will destructure a record of the type Person and create three ...","content":"/  /  / Record-Typed Binding Pattern  import ballerina/io;type Person record {  string name;  int age;  string country; };type Country record {  string name;  Capital capital; };type Capital record {|  string name; |};public function main() {  Person {name: firstName, age: personAge, ...otherDetails} = getPerson();  io:println(\"Name: \", firstName);  io:println(\"Age: \", personAge);  io:println(\"Other Details: \", otherDetails);  Person {name, age} = getPerson();  io:println(\"Name: \", name);  io:println(\"Age: \", age);  var {name: vFirstName, age: vPersonAge, ...vOtherDetails} = getPerson();  io:println(\"Name: \", vFirstName);  io:println(\"Age: \", vPersonAge);  io:println(\"Other Details: \", vOtherDetails);  var {name: countryName, capital: {name: capitalName}} = getCountry();  io:println(\"Country Name: \", countryName);  io:println(\"Capital Name: \", capitalName); }function getPerson() returns Person {  Person person = {  name: \"Peter\",  age: 28,  country: \"Sri Lanka\",  \"occupation\": \"Software Engineer\"  };  return person; }function getCountry() returns Country {  Capital capital = {name: \"Colombo\"};  Country country = {name: \"Sri Lanka\", capital: capital};  return country; }    Record-Typed Binding Pattern  Record typed binding patterns are used in declaring and defining new variables by destructuring fields in a record variable.  The record type binding pattern statement must have an assignment expression on the right hand side.    import ballerina/io;    type Person record {  string name;  int age;  string country; };    type Country record {  string name;  Capital capital; };    type Capital record {|  string name; |};    public function main() {    Person {name: firstName, age: personAge, ...otherDetails} = getPerson();  io:println(\"Name: \", firstName);  io:println(\"Age: \", personAge);  io:println(\"Other Details: \", otherDetails);    This record type binding pattern will destructure a record of the type Person and create three variables as follows:  The value of the field name in the Person record will be set to a new string variable firstName.  The value of the field age in the Person record will be set to a new int variable personAge.  ...otherDetails is a rest parameter. Since Person is an open record, a new map<anydata|error> variable  otherDetails will be created (with the remaining fields that have not been matched) in the record binding pattern.   Person {name, age} = getPerson();  io:println(\"Name: \", name);  io:println(\"Age: \", age);    If a variable name is not given for a field, a variable will be created with the same name as the field.  i.e, Person {name, age} is same as Person {name: name, age: age}.  Since a rest parameter is not given, all remaining fields are ignored.   var {name: vFirstName, age: vPersonAge, ...vOtherDetails} = getPerson();    Record type binding patterns can be used with var to infer the type from the right hand side.  Since the types of the new variables are based on the type of the type binding pattern, using var will  infer the types from the right hand side.   io:println(\"Name: \", vFirstName);    The type of vFirstName is inferred as string.   io:println(\"Age: \", vPersonAge);    The type of vPersonAge is inferred as int.   io:println(\"Other Details: \", vOtherDetails);    The type of vOtherDetails will be map<anydata|error>.   var {name: countryName, capital: {name: capitalName}} = getCountry();  io:println(\"Country Name: \", countryName);  io:println(\"Capital Name: \", capitalName); }    Binding patterns are recursive in nature. capital, which is a field of the type Capital in Country can also be  destructured as follows:   function getPerson() returns Person {  Person person = {  name: \"Peter\",  age: 28,  country: \"Sri Lanka\",  \"occupation\": \"Software Engineer\"  };  return person; }    function getCountry() returns Country {  Capital capital = {name: \"Colombo\"};  Country country = {name: \"Sri Lanka\", capital: capital};  return country; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run record_type_binding_pattern.bal Name: Peter Age: 28 Other Details: country=Sri Lanka occupation=Software Engineer Name: Peter Age: 28 Name: Peter Age: 28 Other Details: country=Sri Lanka occupation=Software Engineer Country Name: Sri Lanka Capital Name: Colombo"},{"page":"/learn/by-example/records.html","name":"Record","summary":"In Ballerina, records are a mapping type. However, the keys (fields) are named and their types define the\n types of values that are allowed for the fields. If the set of fields is fixed, the record is called a “closed record”.\n If the set of fields is not fixed, the ...","content":"/  /  / Record  import ballerina/io; type Student record {  string name;  int age;  Grades grades; }; type Address record {|  string city;  string country; |}; type Grades record {|  int maths;  int physics;  int chemistry;  int...; |};public function main() { int age = 17;  Student john = {  name: \"John Doe\",  age,  grades: {  maths: 80,  physics: 75,  chemistry: 65  }  };  io:println(john);  io:println(john.name);  io:println(john[\"name\"]);  io:println(john.grades.maths); Student peter = {  name: \"Peter\",  age: 19,  grades: {  maths: 40,  physics: 35,  chemistry: 35  }  };  peter.age = 16; io:println(peter);  io:println(john);  Address address = {city: \"Colombo\", country: \"Sri Lanka\"};  peter[\"address\"] = address;  io:println(peter);  Grades grades = {maths: 80, physics: 75, chemistry: 65, \"english\": 90};  io:println(grades);  int? english = grades[\"english\"];  io:println(english);  Student anne = {  name: \"Anne\",  age: 18,  grades: {  maths: 70,  physics: 80,  chemistry: 55  },  ...address  };  io:println(anne);  var rec = {name: \"Amy\", age: 18, ...address};  io:println(rec);  io:println(rec.name); }    Record  In Ballerina, records are a mapping type. However, the keys (fields) are named and their types define the  types of values that are allowed for the fields. If the set of fields is fixed, the record is called a “closed record”.  If the set of fields is not fixed, the record is called an “open record”.    import ballerina/io;    type Student record {  string name;  int age;  Grades grades; };    Define an open record type named Student. The { and } delimiters indicate that in addition to the defined fields,  this record type allows additional fields with anydata values.  The descriptor record { } is equivalent to record {| anydata...; |}.   type Address record {|  string city;  string country; |};    Define a closed record type named Address. The {| and |} delimiters indicate that this record type  allows mapping values, which contain only the described fields.   type Grades record {|  int maths;  int physics;  int chemistry;    Define an open record type named Grades. Although it is defined using the {| and |} delimiters, it has  an int rest field as well. Therefore, this is an open record type.   int...; |};    This is a rest field of the typeint. All additional fields should be of the type or a subtype of the rest field.   public function main() {    int age = 17;    Student john = {    This creates a Student record. Since all the fields are required and none of the fields  have explicit default values assigned to them, values must be specified for all the fields  when creating the record.   name: \"John Doe\",    A field can be specified as a key-value pair.   age,  grades: {  maths: 80,  physics: 75,  chemistry: 65  }  };  io:println(john);    A variable reference can also be used to define a field.  The name of the variable will be used as the key while  the variable reference itself will be used as the value  expression.  This is equivalent to age: age.   io:println(john.name);    This is an example of field-based access of record fields. The return type of this expression is the  type of the field. Field access is only allowed for required fields in a record.   io:println(john[\"name\"]);    This is an example of member access of record fields. Where the type of the field is T, the type of  this expression is T if the field is a required field or has a default value. If the field is an optional  field or a rest field, the type of this expression is T?.  If it is a closed record, accessing an undefined key will result in a compilation error.   io:println(john.grades.maths);    This fetches a field of a nested record.   Student peter = {  name: \"Peter\",  age: 19,  grades: {  maths: 40,  physics: 35,  chemistry: 35  }  };    peter.age = 16;    This modifies the value of the age field.  Field access is allowed with assignment only for fields defined in the record type descriptor.   io:println(peter);  io:println(john);    Address address = {city: \"Colombo\", country: \"Sri Lanka\"};  peter[\"address\"] = address;  io:println(peter);    Member access can be used to assign to fields that are not defined in the record type descriptor.  An attempt to add additional fields to a closed record results in compile errors.   Grades grades = {maths: 80, physics: 75, chemistry: 65, \"english\": 90};  io:println(grades);    Create a Grades record adding additional fields for the int-typed rest field.  The english field is not specified in the record, but is allowed since Grades is an  open record with an int-typed rest field.  Keys for such field should either be string literals or expressions (i.e., they  cannot be identifiers).   int? english = grades[\"english\"];  io:println(english);    Similarly, only member access can be used to access the fields that are possibly  added for the rest field. An int value is returned if the field is present in the  record, else () is returned.   Student anne = {  name: \"Anne\",  age: 18,  grades: {  maths: 70,  physics: 80,  chemistry: 55  },  ...address  };  io:println(anne);    A mapping constructor expression used when creating a record value  can also include a spread field referring to another mapping value.  When a spread field is specified, all the fields of the relevant  mapping value are added to the new record value being created.  A spread field is used with the address to include the individual address  entries in address when creating anne.   var rec = {name: \"Amy\", age: 18, ...address};  io:println(rec);    Using a mapping constructor expression with var (i.e., no contextually-expected  type) results in a mapping value where the inferred type is a record type based  on the fields specified in the mapping constructor expression.   io:println(rec.name); }    The record type inferred for rec is  record {| string name; int age; string city; string country; |}.  Thus, field access can be used to access the fields.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run records.bal name=John Doe age=17 grades=maths=80 physics=75 chemistry=65 John Doe John Doe 80 name=Peter age=16 grades=maths=40 physics=35 chemistry=35 name=John Doe age=17 grades=maths=80 physics=75 chemistry=65 name=Peter age=16 grades=maths=40 physics=35 chemistry=35 address=city=Colombo country=Sri Lanka maths=80 physics=75 chemistry=65 english=90 90 name=Anne age=18 grades=maths=70 physics=80 chemistry=55 city=Colombo country=Sri Lanka name=Amy age=18 city=Colombo country=Sri Lanka Amy"},{"page":"/learn/by-example/response-with-multiparts.html","name":"Response With Multiparts","summary":"Ballerina supports encoding and decoding multipart content in HTTP responses along with the nested parts.\n When you request multiparts from an HTTP inbound response, you get an array of the parts of the body (an array of\n entities). If the received parts contain nested parts, you can loop through the ...","content":"/  /  / Response With Multiparts  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime; http:Client clientEP = new (\"http://localhost:9092\"); listener http:Listener multipartEP = new (9090);@http:ServiceConfig {  basePath: \"/multiparts\" } service multipartResponseEncoder on new http:Listener(9092) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/encode_out_response\"  }  resource function multipartSender(http:Caller caller,  http:Request request) {  mime:Entity parentPart = new;  mime:Entity childPart1 = new;  childPart1.setJson({\"name\": \"wso2\"});  mime:Entity childPart2 = new;  childPart2.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:TEXT_XML);  mime:Entity[] childParts = [childPart1, childPart2];  parentPart.setBodyParts(childParts,  contentType = mime:MULTIPART_MIXED);  mime:Entity[] immediatePartsToResponse = [parentPart];  http:Response outResponse = new;  outResponse.setBodyParts(immediatePartsToResponse,  contentType = mime:MULTIPART_FORM_DATA);  var result = caller->respond(outResponse);  if (result is error) {  log:printError(\"Error in responding \", result);  }  } } @http:ServiceConfig {  basePath: \"/multiparts\" } service multipartResponseDecoder on multipartEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/decode_in_response\"  }  resource function multipartReceiver(http:Caller caller,  http:Request request) {  http:Response inResponse = new;  var returnResult = clientEP->get(\"/multiparts/encode_out_response\");  http:Response res = new;  if (returnResult is http:Response) {  var parentParts = returnResult.getBodyParts();  if (parentParts is mime:Entity[]) {  foreach var parentPart in parentParts {  handleNestedParts(parentPart);  }  res.setPayload(\"Body Parts Received!\");  }  } else {  res.statusCode = 500;  res.setPayload(\"Connection error\");  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding \", result);  }  } } function handleNestedParts(mime:Entity parentPart) {  string contentTypeOfParent = parentPart.getContentType();  if (contentTypeOfParent.startsWith(\"multipart/\")) {  var childParts = parentPart.getBodyParts();  if (childParts is mime:Entity[]) {  log:printInfo(\"Nested Parts Detected!\");  foreach var childPart in childParts {  handleContent(childPart);  }  } else {  log:printError(\"Error retrieving child parts! \" +  <string> childParts.detail().message);  }  } } function handleContent(mime:Entity bodyPart) {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {  var payload = bodyPart.getXml();  if (payload is xml) {  string strValue = io:sprintf(\"%s\", payload);  log:printInfo(\"XML data: \" + strValue);  } else {  log:printError(\"Error in parsing XML data\", payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"JSON data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing JSON data\", payload);  }  } else if (mime:TEXT_PLAIN == baseType) {  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", payload);  }  } else if (mime:APPLICATION_PDF == baseType) {  var payload = bodyPart.getByteChannel();  if (payload is io:ReadableByteChannel) {  io:WritableByteChannel destinationChannel =  <@untainted io:WritableByteChannel>io:openWritableFile(\"ReceivedFile.pdf\");  var result = copy(payload, destinationChannel);  if (result is error) {  log:printError(\"error occurred while performing copy \", result);  }  close(payload);  close(destinationChannel);  } else {  log:printError(\"Error in parsing byte channel :\", payload);  }  } } function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } } function copy(io:ReadableByteChannel src, io:WritableByteChannel dst)  returns error? {  while (true) {  byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {  int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; } function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Response With Multiparts  Ballerina supports encoding and decoding multipart content in HTTP responses along with the nested parts.  When you request multiparts from an HTTP inbound response, you get an array of the parts of the body (an array of  entities). If the received parts contain nested parts, you can loop through the parent parts and get the child parts.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEP = new (\"http://localhost:9092\");    Creates an endpoint for the client.   listener http:Listener multipartEP = new (9090);    Creates a listener for the service.   @http:ServiceConfig {  basePath: \"/multiparts\" } service multipartResponseEncoder on new http:Listener(9092) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/encode_out_response\"  }  resource function multipartSender(http:Caller caller,  http:Request request) {    mime:Entity parentPart = new;    Creates an enclosing entity to hold the child parts.   mime:Entity childPart1 = new;  childPart1.setJson({\"name\": \"wso2\"});    Creates a child part with the JSON content.   mime:Entity childPart2 = new;    Creates another child part with a file.   childPart2.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:TEXT_XML);    This file path is relative to where the Ballerina is running. If your file is located outside, please give the absolute file path instead.   mime:Entity[] childParts = [childPart1, childPart2];    Creates an array to hold the child parts.   parentPart.setBodyParts(childParts,  contentType = mime:MULTIPART_MIXED);    Sets the child parts to the parent part.   mime:Entity[] immediatePartsToResponse = [parentPart];  http:Response outResponse = new;  outResponse.setBodyParts(immediatePartsToResponse,  contentType = mime:MULTIPART_FORM_DATA);  var result = caller->respond(outResponse);  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }    Creates an array to hold the parent part and set it to the response.   @http:ServiceConfig {  basePath: \"/multiparts\" } service multipartResponseDecoder on multipartEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/decode_in_response\"  }    Binds the listener to the service.   resource function multipartReceiver(http:Caller caller,  http:Request request) {  http:Response inResponse = new;  var returnResult = clientEP->get(\"/multiparts/encode_out_response\");  http:Response res = new;  if (returnResult is http:Response) {    This resource accepts multipart responses.   var parentParts = returnResult.getBodyParts();  if (parentParts is mime:Entity[]) {    Extracts the body parts from the response.   foreach var parentPart in parentParts {  handleNestedParts(parentPart);  }  res.setPayload(\"Body Parts Received!\");  }  } else {  res.statusCode = 500;  res.setPayload(\"Connection error\");  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }    Loops through body parts.   function handleNestedParts(mime:Entity parentPart) {  string contentTypeOfParent = parentPart.getContentType();  if (contentTypeOfParent.startsWith(\"multipart/\")) {  var childParts = parentPart.getBodyParts();  if (childParts is mime:Entity[]) {  log:printInfo(\"Nested Parts Detected!\");  foreach var childPart in childParts {  handleContent(childPart);  }  } else {  log:printError(\"Error retrieving child parts! \" +  <string> childParts.detail().message);  }  } }    Gets the child parts that are nested within the parent.   function handleContent(mime:Entity bodyPart) {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {    The content logic that handles the body parts vary based on your requirement.   var payload = bodyPart.getXml();  if (payload is xml) {  string strValue = io:sprintf(\"%s\", payload);  log:printInfo(\"XML data: \" + strValue);  } else {  log:printError(\"Error in parsing XML data\", payload);  }  } else if (mime:APPLICATION_JSON == baseType) {    Extracts xml data from the body part.   var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"JSON data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing JSON data\", payload);  }  } else if (mime:TEXT_PLAIN == baseType) {    Extracts json data from the body part.   var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", payload);  }  } else if (mime:APPLICATION_PDF == baseType) {    Extracts text data from the body part.   var payload = bodyPart.getByteChannel();  if (payload is io:ReadableByteChannel) {  io:WritableByteChannel destinationChannel =  <@untainted io:WritableByteChannel>io:openWritableFile(\"ReceivedFile.pdf\");  var result = copy(payload, destinationChannel);  if (result is error) {  log:printError(\"error occurred while performing copy \", result);  }  close(payload);  close(destinationChannel);  } else {  log:printError(\"Error in parsing byte channel :\", payload);  }  } }    Extracts byte channel from the body part and save it as a file.   function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }    Gets the base type from a given content type.   function copy(io:ReadableByteChannel src, io:WritableByteChannel dst)  returns error? {  while (true) {    Copies the content from the source channel to the destination channel.   byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {    Operation attempts to read a maximum of 1000 bytes.   int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }    Writes the given content into the channel.   function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes the byte channel.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run response_with_multiparts.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 2018-11-30 08:43:53,163 INFO [ballerina/log] - Nested Parts Detected! 2018-11-30 08:43:53,177 INFO [ballerina/log] - JSON data: {\"name\":\"wso2\"} 2018-11-30 08:43:53,240 INFO [ballerina/log] - XML data: <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang>    #To encode the outbound response with multiparts. $ curl -X GET http://localhost:9092/multiparts/encode_out_response --5afd3d91ee639af3 content-type: multipart/mixed;boundary=de5520ef3bc703d7    --de5520ef3bc703d7 content-type: application/json    {\"name\":\"wso2\"} --de5520ef3bc703d7 content-type: text/xml    <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang> --de5520ef3bc703d7--    --5afd3d91ee639af3--    #To decode the inbound response with multiparts. $ curl -X GET http://localhost:9090/multiparts/decode_in_response Body Parts Received!"},{"page":"/learn/by-example/request-with-multiparts.html","name":"Request With Multiparts","summary":"Ballerina supports encoding and decoding multipart content in http requests along with nested parts.\n When you request multiparts from the HTTP inbound request, you get an array of body parts (an array of entities).\n You can loop through this array and handle the received body parts according to your requirement.Binds ...","content":"/  /  / Request With Multiparts  import ballerina/http; import ballerina/log; import ballerina/mime;http:Client clientEP = new (\"http://localhost:9090\");@http:ServiceConfig {  basePath: \"/multiparts\" } service multipartDemoService on new http:Listener(9090) { @http:ResourceConfig {  methods: [\"POST\"],  path: \"/decode\"  }  resource function multipartReceiver(http:Caller caller, http:Request  request) {  http:Response response = new;  var bodyParts = request.getBodyParts();  if (bodyParts is mime:Entity[]) {  foreach var part in bodyParts {  handleContent(part);  }  response.setPayload(<@untainted>bodyParts);  } else {  log:printError(<string>bodyParts.reason());  response.setPayload(\"Error in decoding multiparts!\");  response.statusCode = 500;  }  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } @http:ResourceConfig {  methods: [\"GET\"],  path: \"/encode\"  }  resource function multipartSender(http:Caller caller, http:Request req) {  mime:Entity jsonBodyPart = new;  jsonBodyPart.setContentDisposition(  getContentDispositionForFormData(\"json part\"));  jsonBodyPart.setJson({\"name\": \"wso2\"});  mime:Entity xmlFilePart = new;  xmlFilePart.setContentDisposition(  getContentDispositionForFormData(\"xml file part\"));  xmlFilePart.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:APPLICATION_XML);  mime:Entity[] bodyParts = [jsonBodyPart, xmlFilePart];  http:Request request = new;  request.setBodyParts(bodyParts, contentType = mime:MULTIPART_FORM_DATA);  var returnResponse = clientEP->post(\"/multiparts/decode\", request);  if (returnResponse is http:Response) {  var result = caller->respond(returnResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response response = new;  response.setPayload(\"Error occurred while sending multipart \" +  \"request!\");  response.statusCode = 500;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } } function handleContent(mime:Entity bodyPart) {  var mediaType = mime:getMediaType(bodyPart.getContentType());  if (mediaType is mime:MediaType) {  string baseType = mediaType.getBaseType();  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {  var payload = bodyPart.getXml();  if (payload is xml) {  log:printInfo(payload.toString());  } else {  log:printError(<string>payload.detail().message);  }  } else if (mime:APPLICATION_JSON == baseType) {  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(payload.toJsonString());  } else {  log:printError(<string>payload.detail().message);  }  } else if (mime:TEXT_PLAIN == baseType) {  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(payload);  } else {  log:printError(<string>payload.detail().message);  }  }  } }function getContentDispositionForFormData(string partName)  returns (mime:ContentDisposition) {  mime:ContentDisposition contentDisposition = new;  contentDisposition.name = partName;  contentDisposition.disposition = \"form-data\";  return contentDisposition; }    Request With Multiparts  Ballerina supports encoding and decoding multipart content in http requests along with nested parts.  When you request multiparts from the HTTP inbound request, you get an array of body parts (an array of entities).  You can loop through this array and handle the received body parts according to your requirement.    import ballerina/http; import ballerina/log; import ballerina/mime;    http:Client clientEP = new (\"http://localhost:9090\");    @http:ServiceConfig {  basePath: \"/multiparts\" }    service multipartDemoService on new http:Listener(9090) {    Binds the listener to the service.   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/decode\"  }  resource function multipartReceiver(http:Caller caller, http:Request  request) {  http:Response response = new;    var bodyParts = request.getBodyParts();  if (bodyParts is mime:Entity[]) {  foreach var part in bodyParts {  handleContent(part);  }  response.setPayload(<@untainted>bodyParts);  } else {  log:printError(<string>bodyParts.reason());  response.setPayload(\"Error in decoding multiparts!\");  response.statusCode = 500;  }  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }    Extracts bodyparts from the request.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/encode\"  }  resource function multipartSender(http:Caller caller, http:Request req) {    mime:Entity jsonBodyPart = new;  jsonBodyPart.setContentDisposition(  getContentDispositionForFormData(\"json part\"));  jsonBodyPart.setJson({\"name\": \"wso2\"});    Create a json body part.   mime:Entity xmlFilePart = new;  xmlFilePart.setContentDisposition(  getContentDispositionForFormData(\"xml file part\"));    Create an xml body part as a file upload.   xmlFilePart.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:APPLICATION_XML);    This file path is relative to where the ballerina is running.  If your file is located outside, please  give the absolute file path instead.   mime:Entity[] bodyParts = [jsonBodyPart, xmlFilePart];  http:Request request = new;    Create an array to hold all the body parts.   request.setBodyParts(bodyParts, contentType = mime:MULTIPART_FORM_DATA);  var returnResponse = clientEP->post(\"/multiparts/decode\", request);  if (returnResponse is http:Response) {  var result = caller->respond(returnResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response response = new;  response.setPayload(\"Error occurred while sending multipart \" +  \"request!\");  response.statusCode = 500;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    Set the body parts to the request.  Here the content-type is set as multipart form data.  This also works with any other multipart media type.  eg:- multipart/mixed, multipart/related etc.  You need to pass the content type that suit your requirement.   function handleContent(mime:Entity bodyPart) {  var mediaType = mime:getMediaType(bodyPart.getContentType());  if (mediaType is mime:MediaType) {  string baseType = mediaType.getBaseType();  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {    The content logic that handles the body parts vary based on your requirement.   var payload = bodyPart.getXml();  if (payload is xml) {  log:printInfo(payload.toString());  } else {  log:printError(<string>payload.detail().message);  }  } else if (mime:APPLICATION_JSON == baseType) {    Extracts xml data from the body part.   var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(payload.toJsonString());  } else {  log:printError(<string>payload.detail().message);  }  } else if (mime:TEXT_PLAIN == baseType) {    Extracts json data from the body part.   var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(payload);  } else {  log:printError(<string>payload.detail().message);  }  }  } }    Extracts text data from the body part.   function getContentDispositionForFormData(string partName)  returns (mime:ContentDisposition) {  mime:ContentDisposition contentDisposition = new;  contentDisposition.name = partName;  contentDisposition.disposition = \"form-data\";  return contentDisposition; }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run request_with_multiparts.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Start multipartDemoService # The cURL command, which you need to execute to decode a multipart request $ curl -F \"part1={\\\"name\\\":\\\"ballerina\\\"};type=application/json\" http://localhost:9090/multiparts/decode -H \"Content-Type: multipart/mixed\" -H 'Expect:' --ac4875939cf6b158 content-type: application/json content-disposition: form-data;name=\"part1\" content-id: 0    {\"name\":\"ballerina\"} --ac4875939cf6b158--    # The cURL command, which you need to execute to encode the parts of the body and send a multipart request via the Ballerina service $ curl -v http://localhost:9090/multiparts/encode < HTTP/1.1 200 OK < content-type: multipart/form-data; boundary=3bbfa10811dcdee6 < date: Thu, 14 Jun 2018 15:22:21 +0530 < server: ballerina/0.982.1-SNAPSHOT < content-length: 398 < --3bbfa10811dcdee6 content-type: application/json content-disposition: form-data;name=\"json part\" content-id: 0    {\"name\":\"wso2\"} --3bbfa10811dcdee6 content-type: application/xml content-disposition: form-data;name=\"xml file part\" content-id: 1    <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang> --3bbfa10811dcdee6--"},{"page":"/learn/by-example/restrict-by-media-type.html","name":"Restrict By Media Type","summary":"You can configure resources of HTTP services to restrict the types of media they consume and produce.\n This is done through the ‘consumes’ and ‘produces’ annotation attributes of the ResourceConfig annotation, which is used with resources.The consumes and produces annotations contain MIME types as an\n array of strings. The resource ...","content":"/  /  / Restrict By Media Type  import ballerina/http; import ballerina/log;service infoService on new http:Listener(9092) {  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/\",  consumes: [\"text/json\", \"application/json\"],  produces: [\"application/xml\"]  }  resource function student(http:Caller caller, http:Request req) {  http:Response res = new;  var msg = req.getJsonPayload();  if (msg is json) {  string nameString = <string>msg.name;  xml name = xml `<name>${nameString}</name>`;  res.setXmlPayload(<@untained>name);  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>msg.detail()?.message);  } var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Restrict By Media Type  You can configure resources of HTTP services to restrict the types of media they consume and produce.  This is done through the ‘consumes’ and ‘produces’ annotation attributes of the ResourceConfig annotation, which is used with resources.    import ballerina/http; import ballerina/log;    service infoService on new http:Listener(9092) {    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/\",  consumes: [\"text/json\", \"application/json\"],  produces: [\"application/xml\"]  }  resource function student(http:Caller caller, http:Request req) {    The consumes and produces annotations contain MIME types as an  array of strings. The resource can only consume/accept text/json and  application/json media types. Therefore, the Content-Type header  of the request must be in one of these two types. The resource can produce  application/xml payloads. Therefore, you need to set the Accept header accordingly.   http:Response res = new;  var msg = req.getJsonPayload();  if (msg is json) {    Get the JSON payload from the request message.   string nameString = <string>msg.name;    Get the string value, which is relevant to the key “name”.   xml name = xml `<name>${nameString}</name>`;  res.setXmlPayload(<@untained>name);  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>msg.detail()?.message);  }    Create the XML payload and send back a response.   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run restrict_by_media_type.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    # To invoke the service, execute the following cURL request. $ curl -v http://localhost:9092/infoService -H \"Accept:application/xml\" -H \"Content-Type:application/json\" -d '{\"name\":\"Ballerina\"}' # The server response. < HTTP/1.1 200 OK < content-type: application/xml < content-length: 22 < * Connection #0 to host localhost left intact <name>Ballerina</name>    # To invoke the service using unsupported media type, execute the following cURL request. The content type of the # request is not listed under the `consumes` resource configuration. $ curl -v http://localhost:9092/infoService -H \"Accept:application/xml\" -H \"Content-Type:text/plain\" -d \"Hello ballerina\" # The server response. < HTTP/1.1 415 Unsupported Media Type < content-type: text/plain < content-length: 0 < * Connection #0 to host localhost left intact    # To invoke the service with a media type that is not acceptable, execute the following cURL request. The media type mentioned # in the Accept header is not listed under the `produces` resource configuration. $ curl -v http://localhost:9092/infoService -H \"Accept:text/html\" -H \"Content-Type:application/json\" -d '{\"name\":\"Ballerina\"}' # The server response. < HTTP/1.1 406 Not Acceptable < content-type: text/plain < content-length: 0 < * Connection #0 to host localhost left intact"},{"page":"/learn/by-example/secured-client-with-basic-auth.html","name":"Secured Client with Basic Auth","summary":"A client, which is secured with Basic authentication should be used to\n connect to a service, which is secured with Basic authentication.\n The auth:OutboundBasicAuthProvider is initialized with the username and\n password and the http:BasicAuthHandler is initialized by providing\n the created auth:OutboundBasicAuthProvider. An additional auth field is\n added to the HTTP ...","content":"/  /  / Secured Client with Basic Auth  import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log; auth:OutboundBasicAuthProvider outboundBasicAuthProvider = new ({  username: \"tom\",  password: \"1234\" }); http:BasicAuthHandler outboundBasicAuthHandler =  new (outboundBasicAuthProvider);http:Client httpEndpoint = new (\"https://localhost:9090\", {  auth: {  authHandler: outboundBasicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });public function main() {  var response = httpEndpoint->get(\"/hello/sayHello\");  if (response is http:Response) {  var result = response.getTextPayload();  log:printInfo((result is error) ? \"Failed to retrieve payload.\"  : result);  } else {  log:printError(\"Failed to call the endpoint.\", response);  } }import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log; auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new (inboundBasicAuthProvider);listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [inboundBasicAuthHandler],  scopes: [\"hello\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Client with Basic Auth  A client, which is secured with Basic authentication should be used to  connect to a service, which is secured with Basic authentication.  The auth:OutboundBasicAuthProvider is initialized with the username and  password and the http:BasicAuthHandler is initialized by providing  the created auth:OutboundBasicAuthProvider. An additional auth field is  added to the HTTP client endpoint initialization in order to secure the  simple HTTP client endpoint.  The authHandler field is defined inside the auth field with the value of  it being the reference of the created http:BearerAuthHandler.    import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;    auth:OutboundBasicAuthProvider outboundBasicAuthProvider = new ({  username: \"tom\",  password: \"1234\" });    Defines the Basic Auth client endpoint to call the backend services.  Basic Authentication is enabled by creating an  auth:OutboundBasicAuthProvider with the username and password  passed as a record.   http:BasicAuthHandler outboundBasicAuthHandler =  new (outboundBasicAuthProvider);    Creates a Basic Auth handler with the created Basic Auth provider.   http:Client httpEndpoint = new (\"https://localhost:9090\", {  auth: {  authHandler: outboundBasicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    public function main() {    var response = httpEndpoint->get(\"/hello/sayHello\");  if (response is http:Response) {  var result = response.getTextPayload();  log:printInfo((result is error) ? \"Failed to retrieve payload.\"  : result);  } else {  log:printError(\"Failed to call the endpoint.\", response);  } }    Send a GET request to the specified endpoint.   # To test the client, first start the sample service by executing the below # command by specifying the configuration file name and passing Ballerina home # path as a system property. $ ballerina run secured_service_with_basic_auth.bal --b7a.config.file=sample-users.toml --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    # Then start the client by executing the below command by passing Ballerina home # path as a system property. $ ballerina run secured_client_with_basic_auth.bal --b7a.home=<ballerina_home_path> INFO [ballerina/log] - Hello, World!!!    import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;    auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new (inboundBasicAuthProvider);    Defines the sample backend service, which is secured with Basic Auth  authentication.   listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [inboundBasicAuthHandler],  scopes: [\"hello\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }"},{"page":"/learn/by-example/secured-client-with-jwt-auth.html","name":"Secured Client with JWT Auth","summary":"A secured client, which is secured  with JWT authentication should be used\n to connect to a service, which is secured with JWT authentication.\n The jwt:OutboundJWTAuthProvider is initialized with/without passing\n the JWT issuer configurations as a record. If the JWT issuer configurations\n are passed, a new JWT will be issued ...","content":"/  /  / Secured Client with JWT Auth  import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log; jwt:OutboundJwtAuthProvider outboundJwtAuthProvider = new ({  username: \"ballerina\",  issuer: \"ballerina\",  audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],  customClaims: {\"scope\": \"hello\"},  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler outboundJwtAuthHandler = new (outboundJwtAuthProvider);http:Client httpEndpoint = new (\"https://localhost:9090\", {  auth: {  authHandler: outboundJwtAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });public function main() {  var response = httpEndpoint->get(\"/hello/sayHello\");  if (response is http:Response) {  var result = response.getTextPayload();  log:printInfo((result is error) ? \"Failed to retrieve payload.\"  : result);  } else {  log:printError(\"Failed to call the endpoint.\", response);  } }import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log; jwt:InboundJwtAuthProvider inboundJwtAuthProvider = new ({  issuer: \"ballerina\",  audience: \"ballerina.io\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler inboundJwtAuthHandler = new (inboundJwtAuthProvider); listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [inboundJwtAuthHandler],  scopes: [\"hello\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Client with JWT Auth  A secured client, which is secured with JWT authentication should be used  to connect to a service, which is secured with JWT authentication.  The jwt:OutboundJWTAuthProvider is initialized with/without passing  the JWT issuer configurations as a record. If the JWT issuer configurations  are passed, a new JWT will be issued and it will be used for the outbound  authentication. If the JWT issuer configurations are not passed,  a JWT will be searched in runtime:AuthenticationContext and it will be  used for the outbound authentication.  The http:BearerAuthHandler is initialized by providing  the created jwt:OutboundBasicAuthProvider. An additional auth field is  added to the HTTP client endpoint initialization in order to secure the  simple HTTP client endpoint.  The authHandler field is defined inside the auth field with the value  of it being the reference of the created http:BearerAuthHandler.    import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;    jwt:OutboundJwtAuthProvider outboundJwtAuthProvider = new ({  username: \"ballerina\",  issuer: \"ballerina\",  audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],  customClaims: {\"scope\": \"hello\"},  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    Defines the JWT auth client endpoint to call the backend services.  JWT authentication is enabled by creating a jwt:OutboundJWTAuthProvider  with/without passing the JWT issuer configurations as a record.  If the JWT issuer configurations are not passed, a JWT will be searched  in runtime:AuthenticationContext and it will be used for the outbound  authentication.   http:BearerAuthHandler outboundJwtAuthHandler = new (outboundJwtAuthProvider);    Create a Bearer Auth handler with the created JWT Auth provider.   http:Client httpEndpoint = new (\"https://localhost:9090\", {  auth: {  authHandler: outboundJwtAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    public function main() {    var response = httpEndpoint->get(\"/hello/sayHello\");  if (response is http:Response) {  var result = response.getTextPayload();  log:printInfo((result is error) ? \"Failed to retrieve payload.\"  : result);  } else {  log:printError(\"Failed to call the endpoint.\", response);  } }    Sends a GET request to the specified endpoint.   # To test the client, first start the sample service by executing the below # command by passing Ballerina home path as a system property. $ ballerina run secured_service_with_jwt_auth.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    # Then start the client by executing the below command by passing Ballerina home # path as a system property. $ ballerina run secured_client_with_jwt_auth.bal --b7a.home=<ballerina_home_path> INFO [ballerina/log] - Hello, World!!!    import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;    jwt:InboundJwtAuthProvider inboundJwtAuthProvider = new ({  issuer: \"ballerina\",  audience: \"ballerina.io\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler inboundJwtAuthHandler = new (inboundJwtAuthProvider); listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [inboundJwtAuthHandler],  scopes: [\"hello\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    Defines the sample backend service, which is secured with JWT Auth  authentication.   service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }"},{"page":"/learn/by-example/secured-client-with-oauth2.html","name":"Secured Client with OAuth2","summary":"A client, which is secured with OAuth2 Authentication should be used\n to connect to a service, which is secured with OAuth2 Authentication.\n The oauth2:OutboundOAuth2Provider is initialized with the relevant\n configurations passed as a record. The http:BearerAuthHandler\n is initialized by providing the created oauth2:OutboundOAuth2Provider.\n An additional auth field is added to ...","content":"/  /  / Secured Client with OAuth2  import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/oauth2; oauth2:OutboundOAuth2Provider oauth2Provider1 = new ({  tokenUrl: \"<Token URL for the authorization endpoint>\",  clientId: \"<Client ID for the client credentials grant authentication>\",  clientSecret: \"<Client secret for the client credentials grant authentication>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  } }); http:BearerAuthHandler oauth2Handler1 = new (oauth2Provider1);http:Client clientEP1 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler1  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); oauth2:OutboundOAuth2Provider oauth2Provider2 = new ({  tokenUrl: \"<Token URL for the authorization endpoint>\",  username: \"<Username for password grant authentication>\",  password: \"<Password for password grant authentication>\",  clientId: \"<Client ID for password grant authentication>\",  clientSecret: \"<Client secret for password grant authentication>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  },  refreshConfig: {  refreshUrl: \"<Refresh token URL for the refresh token server>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  }  } }); http:BearerAuthHandler oauth2Handler2 = new (oauth2Provider2);http:Client clientEP2 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler2  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); oauth2:OutboundOAuth2Provider oauth2Provider3 = new ({  accessToken: \"<Access token for the authorization endpoint>\",  refreshConfig: {  clientId: \"<Client ID for authentication with the authorization endpoint>\",  clientSecret: \"<Client secret for authentication with the authorization endpoint>\",  refreshToken: \"<Refresh token for the refresh token server>\",  refreshUrl: \"<Refresh token URL for the refresh token server>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  }  } }); http:BearerAuthHandler oauth2Handler3 = new (oauth2Provider3);http:Client clientEP3 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler3  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });public function main() {  var response1 = clientEP1->get(\"/\");  if (response1 is http:Response) {  var result = response1.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP1.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP1.\", response1);  }  var response2 = clientEP2->get(\"/\");  if (response2 is http:Response) {  var result = response2.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP2.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP2.\", response2);  }  var response3 = clientEP3->get(\"/\");  if (response3 is http:Response) {  var result = response3.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP2.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP3.\", response3);  } }    Secured Client with OAuth2  A client, which is secured with OAuth2 Authentication should be used  to connect to a service, which is secured with OAuth2 Authentication.  The oauth2:OutboundOAuth2Provider is initialized with the relevant  configurations passed as a record. The http:BearerAuthHandler  is initialized by providing the created oauth2:OutboundOAuth2Provider.  An additional auth field is added to the HTTP client endpoint  initialization in order to secure the simple HTTP client endpoint.  The authHandler field is defined inside the auth field with the  value of it being the reference of the created http:BearerAuthHandler.    import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/oauth2;    oauth2:OutboundOAuth2Provider oauth2Provider1 = new ({  tokenUrl: \"<Token URL for the authorization endpoint>\",  clientId: \"<Client ID for the client credentials grant authentication>\",  clientSecret: \"<Client secret for the client credentials grant authentication>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  } }); http:BearerAuthHandler oauth2Handler1 = new (oauth2Provider1);    Define the OAuth2 client endpoint to call the backend services.  The OAuth2 authentication with client credentials grant type is enabled by  creating an oauth2:OutboundOAuth2Provider with the relevant configurations  passed as a record.   http:Client clientEP1 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler1  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    oauth2:OutboundOAuth2Provider oauth2Provider2 = new ({  tokenUrl: \"<Token URL for the authorization endpoint>\",  username: \"<Username for password grant authentication>\",  password: \"<Password for password grant authentication>\",  clientId: \"<Client ID for password grant authentication>\",  clientSecret: \"<Client secret for password grant authentication>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  },  refreshConfig: {  refreshUrl: \"<Refresh token URL for the refresh token server>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  }  } }); http:BearerAuthHandler oauth2Handler2 = new (oauth2Provider2);    Defines the OAuth2 client endpoint to call the backend services.  The OAuth2 authentication with the password grant type is enabled by  creating an oauth2:OutboundOAuth2Provider with the relevant  configurations passed as a record. If the access token expires or  becomes invalid, then it will be automatically refreshed with the provided  refreshConfig.   http:Client clientEP2 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler2  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    oauth2:OutboundOAuth2Provider oauth2Provider3 = new ({  accessToken: \"<Access token for the authorization endpoint>\",  refreshConfig: {  clientId: \"<Client ID for authentication with the authorization endpoint>\",  clientSecret: \"<Client secret for authentication with the authorization endpoint>\",  refreshToken: \"<Refresh token for the refresh token server>\",  refreshUrl: \"<Refresh token URL for the refresh token server>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  }  } }); http:BearerAuthHandler oauth2Handler3 = new (oauth2Provider3);    Defines the OAuth2 client endpoint to call the backend services.  The OAuth2 authentication with direct token mode is enabled by creating  an oauth2:OutboundOAuth2Provider with the relevant configurations passed  as a record. If the accessToken is invalid or not provided, it will  be automatically refreshed with the provided refreshConfig.   http:Client clientEP3 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler3  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    public function main() {    var response1 = clientEP1->get(\"/\");  if (response1 is http:Response) {  var result = response1.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP1.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP1.\", response1);  }    Sends a GET request to the specified endpoint.   var response2 = clientEP2->get(\"/\");  if (response2 is http:Response) {  var result = response2.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP2.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP2.\", response2);  }    Send a GET request to the specified endpoint.   var response3 = clientEP3->get(\"/\");  if (response3 is http:Response) {  var result = response3.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP2.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP3.\", response3);  } }    Send a GET request to the specified endpoint.   # To test the client, configure the clients with required parameters and # execute the below command by passing Ballerina home path as a system property. $ ballerina run secured_client_with_oauth2.bal --b7a.home=<ballerina_home_path>    # This should log the JSON output returned by the REST endpoints."},{"page":"/learn/by-example/secured-service-with-basic-auth.html","name":"Secured Service with Basic Auth","summary":"A service can be secured using basic authentication and optionally, by\n enforcing authorization. The auth provider reads the username and password\n from a file which has a toml format. This stores usernames, passwords for\n authentication, and scopes for authorization.\n Ballerina uses the concept of scopes for authorization. A resource\n declared ...","content":"/  /  / Secured Service with Basic Auth  import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log; auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new (basicAuthProvider); listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [basicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });@http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"scope1\"]  } } service echo on ep { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\",  auth: {  scopes: [\"scope2\"]  }  }  resource function hello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Service with Basic Auth  A service can be secured using basic authentication and optionally, by  enforcing authorization. The auth provider reads the username and password  from a file which has a toml format. This stores usernames, passwords for  authentication, and scopes for authorization.  Ballerina uses the concept of scopes for authorization. A resource  declared in a service can be bound to one/more scope(s). In the config  auth provider, scopes are mapped to users.  In the authorization phase, the scopes of the resource are compared against  the scopes mapped to the user for at least one match between the two sets.  The following code block shows the contents of the file sample-users.toml,  which has the required format of usernames, passwords and scopes, including  their mapping.   [b7a.users]   [b7a.users.alice]  password=\"password1\"  scopes=\"scope1\"   [b7a.users.bob]  password=\"password2\"  scopes=\"scope2,scope3\"   There are two users defined - Alice and Bob. Each user has a password and  assigned scopes.    import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;    auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new (basicAuthProvider);    Creates a Basic Auth header handler with the relevant configurations.   listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [basicAuthHandler]  },    The endpoint used here is the http:Listener, which by default tries to  authenticate and authorize each request. The Basic Authentication handler is  set to this endpoint using the authHandlers attribute. It is optional to  override the authentication and authorization at the service level and/or  resource level.   secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    The secure hello world sample uses HTTPS.   @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"scope1\"]  } }    service echo on ep {    The Auth configuration comprises of two parts -  authentication & authorization.  Authentication can be disabled by setting the enabled: false annotation  attribute.  Authorization is based on scopes. A scope maps to one or more groups.  For a user to access a resource, the user should be in the same groups as  the scope.  To specify one or more scopes of a resource, the scopes annotation  attribute can be used.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\",  auth: {  scopes: [\"scope2\"]  }  }    resource function hello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    The authentication and authorization settings can be overridden at the  resource level.  The hello resource would inherit the enabled: true flag from the  service level, which is set automatically. The service level scope  (i.e., scope1) will be overridden by the scope defined in the resource  level (i.e., scope2).   # At the command line, navigate to the directory that contains the `.bal` file. # Ensure that the `sample-users.toml` file is populated correctly with the user # information. If required, user passwords can be encrypted using the # `ballerina encrypt` configuration encryption command. $ echo '[\"b7a.users\"] [\"b7a.users.alice\"] password=\"password1\" scopes=\"scope1\" [\"b7a.users.bob\"] password=\"password2\" scopes=\"scope2,scope3\"' > sample-users.toml    # To run the service, execute the below command by specifying the configuration # file name and passing Ballerina home path as a system property. $ ballerina run secured_service_with_basic_auth.bal --b7a.config.file=sample-users.toml --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    # Since the resource configuration has overridden the required scopes to denote # that `scope2` is required to invoke `sayHello` resource, the invocation will # fail during authorization. $ curl -k -u alice:password1 https://localhost:9090/hello/sayHello Authorization failure    # Since `bob` has `scope2`, the invocation will succeed. $ curl -k -u bob:password2 https://localhost:9090/hello/sayHello Hello, World!!!"},{"page":"/learn/by-example/secured-service-with-ldap.html","name":"Secured Service with LDAP","summary":"A service can be secured using LDAP and optionally by enforcing\n authorization. The LDAP auth provider verifies the token against the\n configured LDAP server. The result returned from the LDAP\n server is used for authentication and authorization.Defines the LDAP connection configurations.Creates an inbound LDAP authentication provider with the LDAP\n connection ...","content":"/  /  / Secured Service with LDAP  import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/ldap; ldap:LdapConnectionConfig ldapConfig = {  domainName: \"ballerina.io\",  connectionURL: \"ldap://localhost:9095\",  connectionName: \"uid=admin,ou=system\",  connectionPassword: \"secret\",  userSearchBase: \"ou=Users,dc=ballerina,dc=io\",  userEntryObjectClass: \"identityPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=person)(uid=?))\",  userNameListFilter: \"(objectClass=person)\",  groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeoutInMillis: 5000,  readTimeoutInMillis: 60000,  retryAttempts: 3 }; ldap:InboundLdapAuthProvider ldapAuthProvider = new(ldapConfig, \"ldap01\"); http:BasicAuthHandler ldapAuthHandler = new(ldapAuthProvider); listener http:Listener ep = new (9090, {  auth: {  authHandlers: [ldapAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Service with LDAP  A service can be secured using LDAP and optionally by enforcing  authorization. The LDAP auth provider verifies the token against the  configured LDAP server. The result returned from the LDAP  server is used for authentication and authorization.    import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/ldap;    ldap:LdapConnectionConfig ldapConfig = {  domainName: \"ballerina.io\",  connectionURL: \"ldap://localhost:9095\",  connectionName: \"uid=admin,ou=system\",  connectionPassword: \"secret\",  userSearchBase: \"ou=Users,dc=ballerina,dc=io\",  userEntryObjectClass: \"identityPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=person)(uid=?))\",  userNameListFilter: \"(objectClass=person)\",  groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeoutInMillis: 5000,  readTimeoutInMillis: 60000,  retryAttempts: 3 };    Defines the LDAP connection configurations.   ldap:InboundLdapAuthProvider ldapAuthProvider = new(ldapConfig, \"ldap01\");    Creates an inbound LDAP authentication provider with the LDAP  connection configurations.   http:BasicAuthHandler ldapAuthHandler = new(ldapAuthProvider);    Creates a Basic Auth handler with the created LDAP Auth provider.   listener http:Listener ep = new (9090, {  auth: {  authHandlers: [ldapAuthHandler]  },    The endpoint used here is the http:Listener. The LDAP Auth handler is  set to this endpoint using the authHandlers attribute.  It is optional to override the authentication and authorization at the  service and resource levels.   secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    The secure hello world sample uses HTTPS.   service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    # To run the service, execute the below command by passing the Ballerina home path # as a system property. $ ballerina run secured_service_with_ldap.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    $ curl -k -H \"Authorization: Basic YWxpY2U6YWJjMTIz\" \\ https://localhost:9090/hello/sayHello Hello, World!!!    Start the LDAP server and invoke the service using cURL.  It is required to provide the correct basic authentication header or  <username>:<password> with the -u parameter and the cURL command.  It will get validated against the LDAP server.   $ curl -k -u alice:abc123 https://localhost:9090/hello/sayHello Hello, World!!!"},{"page":"/learn/by-example/secured-service-with-oauth2.html","name":"Secured Service with OAuth2","summary":"A service can be secured using OAuth2 and optionally by enforcing\n authorization. The OAuth2 auth provider verifies the token against the\n configured introspection server. The result returned from the introspection\n server is used for token expiration, authorization etc.\n Ballerina uses the concept of scopes for authorization. A resource declared\n in ...","content":"/  /  / Secured Service with OAuth2  import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/oauth2; oauth2:InboundOAuth2Provider oauth2Provider = new ({  url: \"https://localhost:9095/oauth2/token/introspect\" }); http:BearerAuthHandler oauth2Handler = new (oauth2Provider); listener http:Listener ep = new (9090, {  auth: {  authHandlers: [oauth2Handler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Service with OAuth2  A service can be secured using OAuth2 and optionally by enforcing  authorization. The OAuth2 auth provider verifies the token against the  configured introspection server. The result returned from the introspection  server is used for token expiration, authorization etc.  Ballerina uses the concept of scopes for authorization. A resource declared  in a service can be bound to one/more scope(s). The scopes are included in  the introspection response and the scopes of the resource are compared  against those for at least one match between the two sets.    import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/oauth2;    oauth2:InboundOAuth2Provider oauth2Provider = new ({  url: \"https://localhost:9095/oauth2/token/introspect\" });    Creates an inbound OAuth2 authentication provider with the relevant  configurations of the introspection server.   http:BearerAuthHandler oauth2Handler = new (oauth2Provider);    Creates a Bearer Auth handler with the created OAuth2 provider.   listener http:Listener ep = new (9090, {  auth: {  authHandlers: [oauth2Handler]  },    The endpoint used here is the http:Listener. The OAuth2 handler is  set to this endpoint using the authHandlers attribute.  It is optional to override the authentication and authorization at the  service and resource levels.   secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    The secure hello world sample uses HTTPS.   service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    # To run the service, execute the below command by passing Ballerina home path # as a system property. $ ballerina run secured_service_with_oauth2.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    $ curl -k -H \"Authorization: Bearer YWRtaW46MTIz\" \\ https://localhost:9090/hello/sayHello Hello, World!!!    Start the introspection server on 9095 with the /oauth2/token/introspect  resource path and invoke the service using cURL. Note that it is required  to provide the correct bearer authentication header with the cURL command.  It will get validated against the introspection server."},{"page":"/learn/by-example/secured-service-with-jwt-auth.html","name":"Secured Service with JWT Auth","summary":"A service can be secured using JWT and optionally, by enforcing\n authorization. The JWT auth provider verifies the signature of the JWT\n token sent in the Authorization header. For this, Ballerina should trust the\n JWT issuer (the certificate of the JWT issuer must be present in the Ballerina\n certificate truststore).\n ...","content":"/  /  / Secured Service with JWT Auth  import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log; jwt:InboundJwtAuthProvider jwtAuthProvider = new ({  issuer: \"ballerina\",  audience: \"ballerina.io\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler jwtAuthHandler = new (jwtAuthProvider); listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [jwtAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });@http:ServiceConfig {  basePath: \"/hello\" } service echo on ep {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\",  auth: {  scopes: [\"hello\"],  enabled: true  }  }  resource function hello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Service with JWT Auth  A service can be secured using JWT and optionally, by enforcing  authorization. The JWT auth provider verifies the signature of the JWT  token sent in the Authorization header. For this, Ballerina should trust the  JWT issuer (the certificate of the JWT issuer must be present in the Ballerina  certificate truststore).  Ballerina uses the concept of scopes for authorization. A resource declared  in a service can be bound to one/more scope(s). The scope can be included  in the JWT using the scope attribute.  In the authorization phase, the scopes of the resource are compared against  the scopes mapped to the user for at least one match between the two sets.    import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;    jwt:InboundJwtAuthProvider jwtAuthProvider = new ({  issuer: \"ballerina\",  audience: \"ballerina.io\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    Creates an inbound JWT authentication provider with the relevant  configurations.   http:BearerAuthHandler jwtAuthHandler = new (jwtAuthProvider);    Creates a Bearer Auth handler with the created JWT Auth provider.   listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [jwtAuthHandler]  },    The endpoint used here is the http:Listener. The JWT authentication  handler is set to this endpoint using the authHandlers attribute.  It is optional to override the authentication and authorization at the  service and resource levels.   secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    The secure hello world sample uses HTTPS.   @http:ServiceConfig {  basePath: \"/hello\" }    service echo on ep {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\",  auth: {  scopes: [\"hello\"],  enabled: true  }  }    The Auth configuration comprises of two parts -  authentication & authorization.  Authentication can be disabled by setting the enabled: false flag.  Authorization is based on scopes. A scope maps to one or more groups.  For a user to access a resource, the user should be in the same groups as  the scope.  To specify one or more scope of a resource, the annotation attribute  scopes can be used.   resource function hello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    The authentication and authorization settings can be overridden at  the resource level.  The hello resource would inherit the enabled: true flag from the  service level, which is set automatically.  The scope of the resource is defined as “hello”.   # To run the service, execute the below command by passing Ballerina home path # as a system property. $ ballerina run secured_service_with_jwt_auth.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    $ curl -k -H \"Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\\ eyJzdWIiOiJiYWxsZXJpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksIm\\ lhdCI6MTUyNDU3NTAxOSwianRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQi\\ LCJhdWQiOlsiYmFsbGVyaW5hIiwiYmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdLCJzY2\\ 9wZSI6ImhlbGxvIn0.bNoqz9_DzgeKSK6ru3DnKL7NiNbY32ksXPYrh6Jp0_O3ST7WfXMs9WVk\\ x6Q2TiYukMAGrnMUFrJnrJvZwC3glAmRBrl4BYCbQ0c5mCbgM9qhhCjC1tBA50rjtLAtRW-JTR\\ pCKS0B9_EmlVKfvXPKDLIpM5hnfhOin1R3lJCPspJ2ey_Ho6fDhsKE3DZgssvgPgI9PBItnkip\\ Q3CqqXWhV-RFBkVBEGPDYXTUVGbXhdNOBSwKw5ZoVJrCUiNG5XD0K4sgN9udVTi3EMKNMnVQaq\\ 399k6RYPAy3vIhByS6QZtRjOG8X93WJw-9GLiHvcabuid80lnrs2-mAEcstgiHVw\" \\ https://localhost:9090/hello/sayHello Hello, World!!!    Invoke the service using “cURL”.  Note that it is required to provide the correct bearer authentication header  with the cURL command."},{"page":"/learn/by-example/send-and-receive-emails.html","name":"Send and Receive Emails","summary":"The Email Connector is used to send (with SMTP) and receive (with POP3 or\n IMAP4) emails using the SSL or STARTTLS protocols. This sample includes\n sending and receiving emails with default configurations over SSL using\n default ports.Creates an SMTP client with the connection parameters, host, username,\n and password. Default port ...","content":"/  /  / Send and Receive Emails  import ballerina/email; import ballerina/io;public function main() {  email:SmtpClient smtpClient = new (\"smtp.email.com\", \"sender@email.com\"  , \"pass123\");  email:Email email = {  to: [\"receiver1@email.com\", \"receiver2@email.com\"],  cc: [\"receiver3@email.com\", \"receiver4@email.com\"],  bcc: [\"receiver5@email.com\"],  subject: \"Sample Email\",  body: \"This is a sample email.\",  'from: \"author@email.com\",  sender: \"sender@email.com\",  replyTo: [\"replyTo1@email.com\", \"replyTo2@email.com\"]  };  email:Error? response = smtpClient->send(email);  if (response is email:Error) {  io:println(\"Error while sending the email: \"  + <string> response.detail()[\"message\"]);  }}import ballerina/email; import ballerina/io;public function main() {  email:PopClient|email:Error popClient = new (\"pop.email.com\",  \"reader@email.com\", \"pass456\");  if (popClient is email:PopClient) {  email:Email|email:Error? emailResponse = popClient->read();  if (emailResponse is email:Email) {  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse.body);  } else if (emailResponse is ()) {  io:println(\"There are no emails in the INBOX.\");  } else {  io:println(\"Error while getting getting response: \"  + <string> emailResponse.detail()[\"message\"]);  }  } else {  io:println(\"Error while creating client: \"  + <string> popClient.detail()[\"message\"]);  } }import ballerina/email; import ballerina/io;public function main() {  email:ImapClient|email:Error imapClient = new (\"imap.email.com\",  \"reader@email.com\", \"pass456\");  if (imapClient is email:ImapClient) {  email:Email|email:Error? emailResponse = imapClient->read();  if (emailResponse is email:Email) {  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse.body);  } else if (emailResponse is ()) {  io:println(\"There are no emails in the INBOX.\");  } else {  io:println(\"Error while getting getting response: \"  + <string> emailResponse.detail()[\"message\"]);  }  } else {  io:println(\"Error while creating client: \"  + <string> imapClient.detail()[\"message\"]);  } }    Send and Receive Emails  The Email Connector is used to send (with SMTP) and receive (with POP3 or  IMAP4) emails using the SSL or STARTTLS protocols. This sample includes  sending and receiving emails with default configurations over SSL using  default ports.    import ballerina/email; import ballerina/io;    public function main() {    email:SmtpClient smtpClient = new (\"smtp.email.com\", \"sender@email.com\"  , \"pass123\");    Creates an SMTP client with the connection parameters, host, username,  and password. Default port number 465 is used over SSL with these  configurations.   email:Email email = {    Define the email that is required to be sent.   to: [\"receiver1@email.com\", \"receiver2@email.com\"],  cc: [\"receiver3@email.com\", \"receiver4@email.com\"],  bcc: [\"receiver5@email.com\"],    “TO”, “CC” and “BCC” address lists are added as follows.  Only “TO” address list is mandatory out of these three.   subject: \"Sample Email\",    Subject of the email is added as follows. This field is mandatory.   body: \"This is a sample email.\",    Body content of the email is added as follows.  This field is mandatory.   'from: \"author@email.com\",    Email author’s address is added as follows. This field is mandatory.   sender: \"sender@email.com\",    Email sender service address is added as follows.  This field is optional. Sender is same as the 'from when the  email author himself sends the email.   replyTo: [\"replyTo1@email.com\", \"replyTo2@email.com\"]  };    List of recipients when replying to the email is added as follows.  This field is optional. These addresses are required when the emails  are to be replied to some other address(es) other than the sender or  the author.   email:Error? response = smtpClient->send(email);  if (response is email:Error) {  io:println(\"Error while sending the email: \"  + <string> response.detail()[\"message\"]);  }    Send the email with the client.   }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run send_email.bal    # Check the inbox to view the email.    import ballerina/email; import ballerina/io;    public function main() {    email:PopClient|email:Error popClient = new (\"pop.email.com\",  \"reader@email.com\", \"pass456\");  if (popClient is email:PopClient) {    Create the client with the connection parameters, host, username, and  password. An error is received in failure. Default port number 995 is  used over SSL with these configurations.   email:Email|email:Error? emailResponse = popClient->read();  if (emailResponse is email:Email) {  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse.body);    Read the first unseen email received by the POP3 server. Nil is  returned when there are no new unseen emails. In error cases an  error is returned.   } else if (emailResponse is ()) {  io:println(\"There are no emails in the INBOX.\");  } else {  io:println(\"Error while getting getting response: \"  + <string> emailResponse.detail()[\"message\"]);  }  } else {  io:println(\"Error while creating client: \"  + <string> popClient.detail()[\"message\"]);  } }    When no emails are available in the server, nil is returned.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run receive_email.bal    # Subject and the content body of the email would be printed.    import ballerina/email; import ballerina/io;    public function main() {    email:ImapClient|email:Error imapClient = new (\"imap.email.com\",  \"reader@email.com\", \"pass456\");  if (imapClient is email:ImapClient) {    Create the client with the connection parameters, host, username, and  password. An error is received in failure. Default port number 993 is  used over SSL with these configurations.   email:Email|email:Error? emailResponse = imapClient->read();  if (emailResponse is email:Email) {  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse.body);    Read the first unseen email received by the IMAP4 server. Nil is  returned when there are no new unseen emails. In error cases an  error is returned.   } else if (emailResponse is ()) {  io:println(\"There are no emails in the INBOX.\");  } else {  io:println(\"Error while getting getting response: \"  + <string> emailResponse.detail()[\"message\"]);  }  } else {  io:println(\"Error while creating client: \"  + <string> imapClient.detail()[\"message\"]);  } }    When no emails are available in the server, nil is returned.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run receive_email.bal    # Subject and the content body of the email will be printed."},{"page":"/learn/by-example/shift-expressions.html","name":"Shift Expressions","summary":"A shift expression performs a bitwise shift. Both the value to be shifted (left hand operand) and the shift amount\n (right hand operand) should have static types that are subtypes of the int type.\n All except the bottom 6 bits of the shift amount are masked out.\n All shift operations ...","content":"/  /  / Shift Expressions  import ballerina/io; import ballerina/lang.'int;public function main() {  int a = 1;  int res1 = a << 2;  io:println(\"`int` 1 << 2: \", res1); 'int:Unsigned8 b = 128;  int res2 = b << 3;  io:println(\"`int:Unsigned8` 128 << 3: \", res2);  'int:Signed16 c = -32700;  int res3 = c >> 2;  io:println(\"`int:Signed16` -32700 >> 2: \", res3);  'int:Unsigned8 d = 255;  int e = 4;  'int:Unsigned8 res4 = d >> e;  io:println(\"`int:Unsigned8` 255 >> 4: \", res4);  'int:Signed32 f = 123167;  int res5 = f >>> 3;  io:println(\"`int:Signed32` 123167 >>> 3: \", res5);  'int:Unsigned16 g = 32001;  'int:Unsigned16 res6 = g >> 2;  io:println(\"`int:Unsigned16` 32001 >>> 2: \", res6); }    Shift Expressions  A shift expression performs a bitwise shift. Both the value to be shifted (left hand operand) and the shift amount  (right hand operand) should have static types that are subtypes of the int type.  All except the bottom 6 bits of the shift amount are masked out.  All shift operations are based on the 64-bit representations of the values.    import ballerina/io; import ballerina/lang.'int;    public function main() {  int a = 1;    int res1 = a << 2;  io:println(\"`int` 1 << 2: \", res1);    << performs a left shift. The bits shifted in on the right, in place  of the bits shifted to the left, are 0.  The type of the result of a left shift is always int.   'int:Unsigned8 b = 128;  int res2 = b << 3;  io:println(\"`int:Unsigned8` 128 << 3: \", res2);    'int:Signed16 c = -32700;  int res3 = c >> 2;  io:println(\"`int:Signed16` -32700 >> 2: \", res3);    >> performs a signed right shift. The bits shifted in on the left, in place  of the bits shifted to the right, are the same as the most significant bit.  If the value to be shifted is of a signed subtype of int, the type of  the result of the signed right shift is int.   'int:Unsigned8 d = 255;  int e = 4;  'int:Unsigned8 res4 = d >> e;  io:println(\"`int:Unsigned8` 255 >> 4: \", res4);    If the value to be shifted is of an unsigned subtype of int, the type of  the result of the signed right shift is the same unsigned subtype of int.   'int:Signed32 f = 123167;  int res5 = f >>> 3;  io:println(\"`int:Signed32` 123167 >>> 3: \", res5);    >>> performs an unsigned right shift. The bits shifted in on the left, in place  of the bits shifted to the right, are 0.  If the value to be shifted is of a signed subtype of int, the type of  the result of the signed right shift is int.   'int:Unsigned16 g = 32001;  'int:Unsigned16 res6 = g >> 2;  io:println(\"`int:Unsigned16` 32001 >>> 2: \", res6); }    If the value to be shifted is of an unsigned subtype of int, the type of  the result of the signed right shift is the same unsigned subtype of int.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run shift_expressions.bal `int` 1 << 2: 4 `int:Unsigned8` 128 << 3: 1024 `int:Signed16` -32700 >> 2: -8175 `int:Unsigned8` 255 >> 4: 15 `int:Signed32` 123167 >>> 3: 15395 `int:Unsigned16` 32001 >>> 2: 8000"},{"page":"/learn/by-example/streams.html","name":"Streams","summary":"The stream type represents a sequence that may be constructed lazily\n and is used to iterate over the sequence of values of type T with error type E.\n stream<T> is short for stream<T, never>.\n A stream can be iterated over at most once.\n A stream has a next() method; a ...","content":"/  /  / Streams  import ballerina/io; type OddNumberGenerator object {  int i = 1;  public function next() returns record {|int value;|}|error? {  self.i += 2;  return {value: self.i};  } };type ResultValue record {|  int value; |};type Student record {  string firstName;  string lastName;  float score; };type StudentValue record {|  Student value; |};type FullName record {|  string firstName;  string lastName; |};type Subscription record {|  string firstName;  string lastName;  float score;  string degree; |};public function main() {  OddNumberGenerator oddGen = new;  var oddNumberStream = new stream<int, error>(oddGen); record {|int value;|}|error? oddNumber = oddNumberStream.next(); if (oddNumber is ResultValue) {  io:println(\"Retrieved odd number: \", oddNumber.value);  } io:println(\"Filter records and map them to a different type :\"); Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2}; Student[] studentList = [s1, s2, s3];  stream<Student> studentStream = studentList.toStream();  stream<Subscription> subscriptionStream = studentStream.filter(function (Student student) returns boolean {  return student.score > 1;  }).'map(function (Student student) returns Subscription {  Subscription subscription = {  firstName: student.firstName,  lastName: student.lastName,  score: student.score,  degree: \"Bachelor of Medicine\"  };  return subscription;  }); io:println(\"Calculate the average score of the subscribed students: \");  float? avg = subscriptionStream.reduce(function (float accum, Student student) returns float {  return accum + <float>student.score / studentList.length();  }, 0.0); if (avg is float) {  io:println(\"Average: \", avg);  }  stream<Student> studentStream2 = studentList.toStream(); io:println(\"Calls next method manually and get the next iteration value: \");  record {|Student value;|}|error? student = studentStream2.next();  if (student is StudentValue) {  io:println(student.value);  } io:println(\"Use foreach method to loop through the rest of the stream: \");  error? e = studentStream2.forEach(function (Student student) {  io:println(\"Student \", student.firstName, \" has a score of \", student.score);  });  if (e is error) {  io:println(\"ForEach operation on the stream failed: \", e);  } stream<Student> studentStream3 = studentList.toStream();  var iterator = studentStream3.iterator();  record {|Student value;|}|error? nextStudent = iterator.next();  if (nextStudent is StudentValue) {  io:println(nextStudent.value);  } }    Streams  The stream type represents a sequence that may be constructed lazily  and is used to iterate over the sequence of values of type T with error type E.  stream<T> is short for stream<T, never>.  A stream can be iterated over at most once.  A stream has a next() method; a stream’s iterator works by calling this method.  The stream type provides methods similar to lists such as map, foreach, filter, reduce, and iterator.  The stream type does not provide a length method. This is a preview feature.    import ballerina/io;    type OddNumberGenerator object {  int i = 1;  public function next() returns record {|int value;|}|error? {  self.i += 2;  return {value: self.i};  } };    Defines an object called OddNumberGenerator. Each object has its own next() method, which gets invoked when the stream’s next() function gets called.   type ResultValue record {|  int value; |};    type Student record {  string firstName;  string lastName;  float score; };    type StudentValue record {|  Student value; |};    type FullName record {|  string firstName;  string lastName; |};    type Subscription record {|  string firstName;  string lastName;  float score;  string degree; |};    public function main() {  OddNumberGenerator oddGen = new;    var oddNumberStream = new stream<int, error>(oddGen);    Creating a stream passing an OddNumberGenerator object to the stream constructor   record {|int value;|}|error? oddNumber = oddNumberStream.next();    if (oddNumber is ResultValue) {  io:println(\"Retrieved odd number: \", oddNumber.value);  }    io:println(\"Filter records and map them to a different type :\");    Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2};    Student[] studentList = [s1, s2, s3];    stream<Student> studentStream = studentList.toStream();    Iterable types can be converted to a stream.   stream<Subscription> subscriptionStream = studentStream.filter(function (Student student) returns boolean {  return student.score > 1;  }).'map(function (Student student) returns Subscription {  Subscription subscription = {  firstName: student.firstName,  lastName: student.lastName,  score: student.score,  degree: \"Bachelor of Medicine\"  };  return subscription;  });    The filter and map functions return streams and work lazily.   io:println(\"Calculate the average score of the subscribed students: \");    float? avg = subscriptionStream.reduce(function (float accum, Student student) returns float {  return accum + <float>student.score / studentList.length();  }, 0.0);    The reduce function reduces the stream to a single value.   if (avg is float) {  io:println(\"Average: \", avg);  }    stream<Student> studentStream2 = studentList.toStream();    A stream can be iterated at most for once. Hence, another stream gets created from the record list.   io:println(\"Calls next method manually and get the next iteration value: \");    record {|Student value;|}|error? student = studentStream2.next();  if (student is StudentValue) {  io:println(student.value);  }    Calls the next() operation to retrieve the data from the stream.   io:println(\"Use foreach method to loop through the rest of the stream: \");    error? e = studentStream2.forEach(function (Student student) {  io:println(\"Student \", student.firstName, \" has a score of \", student.score);  });    If there is any error during the iteration of the  studentList2 stream, the result stream will terminate and return the error.   if (e is error) {  io:println(\"ForEach operation on the stream failed: \", e);  }    Check and handle the error during the iteration of the stream.   stream<Student> studentStream3 = studentList.toStream();  var iterator = studentStream3.iterator();    record {|Student value;|}|error? nextStudent = iterator.next();  if (nextStudent is StudentValue) {  io:println(nextStudent.value);  } }    Calls the next() operation on the iterator to retrieve the next data from the stream.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run streams.bal    Retrieved odd number: 3 Filter records and map them to a different type : Calculate the average score of the subscribed students: Average: 0.8999999999999999 Calls next method manually and get the next iteration value: firstName=Alex lastName=George score=1.5 Use foreach method to loop through the rest of the stream: Student Ranjan has a score of 0.9 Student John has a score of 1.2 firstName=Alex lastName=George score=1.5"},{"page":"/learn/by-example/string-template.html","name":"String Template Literal","summary":"String templates are string literals, which allow embedded expressions of simple basic types (except nil).\n The placeholders for expressions are indicated by the dollar symbol followed by open and close curly braces ${}.\n You can enclose a string literal with the keyword string followed by two back-tick characters.Create a string ...","content":"/  /  / String Template Literal  import ballerina/io;public function main() {  string name = \"Ballerina\";  string template = string `Hello ${name}!!!`;  io:println(template); }    String Template Literal  String templates are string literals, which allow embedded expressions of simple basic types (except nil).  The placeholders for expressions are indicated by the dollar symbol followed by open and close curly braces ${}.  You can enclose a string literal with the keyword string followed by two back-tick characters.    import ballerina/io;    public function main() {  string name = \"Ballerina\";    string template = string `Hello ${name}!!!`;    Create a string template embedding the name variable.   io:println(template); }    Print the defined string value.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run string_template.bal Hello Ballerina!!!"},{"page":"/learn/by-example/taint-checking.html","name":"Taint Checking","summary":"Ballerina is designed to ensure that programs written in Ballerina are inherently secure. Ballerina programs\n are resilient to major security vulnerabilities including SQL injection, path manipulation, file manipulation,\n unauthorized file access, and unvalidated redirect (open redirect).A taint analysis mechanism is used to achieve this. As a result of the taint ...","content":"/  /  / Taint Checking  import ballerina/lang.'int; import ballerinax/java.jdbc; function userDefinedSecureOperation(@untainted string secureParameter) {}type Student record {  string firstname; };public function main(string... args) {  jdbc:Client customerDBEP = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  poolOptions: {maximumPoolSize: 5},  dbOptions: {useSSL: false}  });  var result = customerDBEP->  select(\"SELECT firstname FROM student WHERE\" +  \" registration_id = \" + args[0], ()); if (result is error) {  panic result;  } table<Student> dataTable = <table<Student>>result;  userDefinedSecureOperation(args[0]); if (isInteger(args[0])) {  userDefinedSecureOperation(<@untainted>args[0]);  } else {  error err = error(\"Validation error: ID should be an integer\");  panic err;  } while (dataTable.hasNext()) {  Student jsonData = dataTable.getNext();  userDefinedSecureOperation(jsonData.firstname); string sanitizedData1 = sanitizeAndReturnTainted(jsonData.firstname);  userDefinedSecureOperation(sanitizedData1); string sanitizedData2 = sanitizeAndReturnUntainted(jsonData.firstname);  userDefinedSecureOperation(sanitizedData2);  }  checkpanic customerDBEP.stop();  return; }function sanitizeAndReturnTainted(string input) returns string {  return input; } function sanitizeAndReturnUntainted(string input) returns @untainted string {  return input; }function isInteger(string input) returns boolean {  var intVal = 'int:fromString(input);  if (intVal is error) {  return false;  } else {  return true;  } }    Taint Checking  Ballerina is designed to ensure that programs written in Ballerina are inherently secure. Ballerina programs  are resilient to major security vulnerabilities including SQL injection, path manipulation, file manipulation,  unauthorized file access, and unvalidated redirect (open redirect).  A taint analysis mechanism is used to achieve this. As a result of the taint analysis mechanism, the Ballerina compiler  identifies untrusted (tainted) data by observing how tainted data propagates through the program. If untrusted data  is passed to a security sensitive parameter, a compile error is generated.    import ballerina/lang.'int; import ballerinax/java.jdbc;    function userDefinedSecureOperation(@untainted string secureParameter) {    The @untainted annotation can be used with the parameters of user-defined functions. This allow users to restrict  passing untrusted (tainted) data into a security sensitive parameter.   }    type Student record {  string firstname; };    public function main(string... args) {  jdbc:Client customerDBEP = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  poolOptions: {maximumPoolSize: 5},  dbOptions: {useSSL: false}  });    var result = customerDBEP->  select(\"SELECT firstname FROM student WHERE\" +  \" registration_id = \" + args[0], ());    Sensitive parameters of functions that are built-in to Ballerina are decorated with the @untainted annotation.  This ensures that tainted data cannot pass into the security sensitive parameter.  For example, the taint checking mechanism of Ballerina completely prevents SQL injection vulnerabilities by  disallowing tainted data in the SQL query.  This line results in a compile error because the query is appended with a user-provided argument.   if (result is error) {  panic result;  }    table<Student> dataTable = <table<Student>>result;    userDefinedSecureOperation(args[0]);    This line results in a compiler error because a user-provided argument is passed to a sensitive parameter.   if (isInteger(args[0])) {    userDefinedSecureOperation(<@untainted>args[0]);  } else {  error err = error(\"Validation error: ID should be an integer\");  panic err;  }    After performing necessary validations and/or escaping, we can use type cast expression with @untainted annotation  to mark the proceeding value as trusted and pass it to a sensitive parameter.   while (dataTable.hasNext()) {  Student jsonData = dataTable.getNext();    userDefinedSecureOperation(jsonData.firstname);    The return values of certain functions built-in to Ballerina are decorated with the @tainted annotation to  denote that the return value should be untrusted (tainted). One such example is the data read from a  database.  This line results in a compile error because a value derived from a database read (tainted) is passed to a  sensitive parameter.   string sanitizedData1 = sanitizeAndReturnTainted(jsonData.firstname);    userDefinedSecureOperation(sanitizedData1);    This line results in a compile error because the sanitize function returns a value derived from the tainted  data. Therefore, the return of the sanitize function is also tainted.   string sanitizedData2 = sanitizeAndReturnUntainted(jsonData.firstname);    userDefinedSecureOperation(sanitizedData2);  }  checkpanic customerDBEP.stop();  return; }    This line successfully compiles. Although the sanitize function returns a value derived from tainted data,  the return value is annotated with the @untainted annotation. This means that the return value is safe and can be  trusted.   function sanitizeAndReturnTainted(string input) returns string {    return input; }    transform and sanitize the string here.   function sanitizeAndReturnUntainted(string input) returns @untainted string {    The @untainted annotation denotes that the return value of the function should be trusted (untainted) even though  the return value is derived from tainted data.   return input; }    transform and sanitize the string here.   function isInteger(string input) returns boolean {  var intVal = 'int:fromString(input);  if (intVal is error) {  return false;  } else {  return true;  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run taint_checking.bal error: .::taint_checking.bal:60:36: tainted value passed to untainted parameter 'secureParameter' error: .::taint_checking.bal:31:39: tainted value passed to untainted parameter 'sqlQuery' error: .::taint_checking.bal:41:32: tainted value passed to untainted parameter 'secureParameter' error: .::taint_checking.bal:65:36: tainted value passed to untainted parameter 'secureParameter'"},{"page":"/learn/by-example/strings.html","name":"String","summary":"Ballerina contains a comprehensive set of functions to manipulate Strings.Create a new string, which is a substring of the specified string.\n You must provide the original string\n and the starting and ending indexes of the substring.Retrieve the starting index of the first occurrence of the substring “on” within the statement ...","content":"/  /  / String  import ballerina/io; import ballerina/lang.'string;public function main() { string statement = \"Lion in Town. Catch the Lion\"; string s1 = statement.toUpperAscii();  io:println(\"ToUpper: \", s1); string s2 = statement.toLowerAscii();  io:println(\"ToLower: \", s2);  string s3 = statement.substring(0, 4);  io:println(\"SubString: \", s3);  int? index = statement.indexOf(\"on\");  if (index is int) {  io:println(\"IndexOf: \", index);  }  int length = statement.length();  io:println(\"Length: \", length); string hello = \"Hello\";  string ballerina = \"Ballerina!\";  string s4 = hello.concat(\" \", ballerina);  io:println(\"Concat: \", s4);  string s5 = \",\".'join(hello, ballerina);  io:println(\"Join: \", s5);  byte[] bArray = hello.toBytes();  string|error s6 = 'string:fromBytes(bArray);  if (s6 is string) {  io:println(\"From bytes: \", s6);  }  string toTrim = \" Ballerina Programming Language \";  string s7 = toTrim.trim();  io:println(\"Trim: \", s7);  boolean hasSuffix = statement.endsWith(\"Lion\");  io:println(\"HasSuffix: \", hasSuffix);  boolean hasPrefix = statement.startsWith(\"Lion\");  io:println(\"HasPrefix: \", hasPrefix);  string name = \"Sam\";  int marks = 90;  string[] subjects = [\"English\", \"Science\"];  float average = 71.5;  string s8 = io:sprintf(\"%s scored %d for %s and has an average of %.2f.\",  name, marks, subjects[0], average);  io:println(\"Sprintf: \", s8);  string country = \"Sri Lanka\";  string c = country[4];  io:println(\"Member Access: \", c); }    String  Ballerina contains a comprehensive set of functions to manipulate Strings.    import ballerina/io; import ballerina/lang.'string;    public function main() {    string statement = \"Lion in Town. Catch the Lion\";    string s1 = statement.toUpperAscii();  io:println(\"ToUpper: \", s1);    string s2 = statement.toLowerAscii();  io:println(\"ToLower: \", s2);    string s3 = statement.substring(0, 4);  io:println(\"SubString: \", s3);    Create a new string, which is a substring of the specified string.  You must provide the original string  and the starting and ending indexes of the substring.   int? index = statement.indexOf(\"on\");  if (index is int) {  io:println(\"IndexOf: \", index);  }    Retrieve the starting index of the first occurrence of the substring “on” within the statement string.   int length = statement.length();  io:println(\"Length: \", length);    Retrieve the length of the string.   string hello = \"Hello\";  string ballerina = \"Ballerina!\";    string s4 = hello.concat(\" \", ballerina);  io:println(\"Concat: \", s4);    Concat multiple strings.   string s5 = \",\".'join(hello, ballerina);  io:println(\"Join: \", s5);    Join strings with a separator.   byte[] bArray = hello.toBytes();    Convert hello to a byte array.   string|error s6 = 'string:fromBytes(bArray);  if (s6 is string) {  io:println(\"From bytes: \", s6);  }    Convert a byte array to a string.   string toTrim = \" Ballerina Programming Language \";  string s7 = toTrim.trim();  io:println(\"Trim: \", s7);    Remove leading and trailing white spaces.   boolean hasSuffix = statement.endsWith(\"Lion\");  io:println(\"HasSuffix: \", hasSuffix);    Check whether the given string ends with the suffix “Lion”.   boolean hasPrefix = statement.startsWith(\"Lion\");  io:println(\"HasPrefix: \", hasPrefix);    Check whether the given string starts with the prefix “Lion”.   string name = \"Sam\";  int marks = 90;  string[] subjects = [\"English\", \"Science\"];  float average = 71.5;  string s8 = io:sprintf(\"%s scored %d for %s and has an average of %.2f.\",  name, marks, subjects[0], average);  io:println(\"Sprintf: \", s8);    Format a string according to the given format arguments.   string country = \"Sri Lanka\";  string c = country[4];  io:println(\"Member Access: \", c); }    Member access is allowed with strings to access individual characters  of a string. Member access panics if the integer index is out of range.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run strings.bal ToUpper: LION IN TOWN. CATCH THE LION ToLower: lion in town. catch the lion SubString: Lion IndexOf: 2 Length: 28 Concat: Hello Ballerina! Join: Hello,Ballerina! From bytes: Hello Trim: Ballerina Programming Language HasSuffix: true HasPrefix: true Sprintf: Sam scored 90 for English and has an average of 71.50. Member Access: L"},{"page":"/learn/by-example/table.html","name":"Table","summary":"The type table is a data structure that organizes information in rows and columns. This example demonstrates how to\n create an in-memory table using a type constraint, insert data to it, and then access/delete the data.This is the type created to represent a data row.This creates an in-memory table constrained ...","content":"/  /  / Table  import ballerina/io; import ballerina/jsonutils; import ballerina/xmlutils; type Employee record {  int id;  string name;  float salary; };public function main() {  table<Employee> tbEmployee = table {  {key id, name, salary},  [  {1, \"Mary\", 300.5},  {2, \"John\", 200.5},  {3, \"Jim\", 330.5}  ]  };  io:print(\"Table Information: \");  io:println(tbEmployee);  Employee e1 = {id: 1, name: \"Jane\", salary: 300.50};  Employee e2 = {id: 2, name: \"Anne\", salary: 100.50};  Employee e3 = {id: 3, name: \"John\", salary: 400.50};  Employee e4 = {id: 4, name: \"Peter\", salary: 150.0};  table<Employee> tb = table {  {key id, name, salary},  [  e1,  e2  ]  }; Employee[] employees = [e3, e4];  foreach var emp in employees {  var ret = tb.add(emp);  if (ret is ()) {  io:println(\"Adding record to table successful\");  } else {  io:println(\"Adding to table failed: \", ret.reason());  }  }  io:println(\"Table Information: \", tb);  io:println(\"Using foreach:\");  foreach var x in tb {  io:println(\"Name: \", x.name);  }  io:println(\"Using while loop:\");  while (tb.hasNext()) {  var ret = tb.getNext();  io:println(\"Name: \", ret.name);  }  json retValJson = jsonutils:fromTable(tb);  io:println(\"JSON: \", retValJson.toJsonString());  xml retValXml = xmlutils:fromTable(tb);  io:println(\"XML: \", retValXml);  int|error count = tb.remove(isHigherSalary);  io:println(\"Deleted Count: \", count);  io:println(tb); } function isHigherSalary(Employee emp) returns boolean {  return emp.salary > 300.0; }    Table  The type table is a data structure that organizes information in rows and columns. This example demonstrates how to  create an in-memory table using a type constraint, insert data to it, and then access/delete the data.    import ballerina/io; import ballerina/jsonutils; import ballerina/xmlutils;    type Employee record {  int id;  string name;  float salary; };    This is the type created to represent a data row.   public function main() {    table<Employee> tbEmployee = table {  {key id, name, salary},  [  {1, \"Mary\", 300.5},  {2, \"John\", 200.5},  {3, \"Jim\", 330.5}  ]  };    This creates an in-memory table constrained by the Employee type with the id marked as the  primary key in the column descriptor. Three data records are inserted into the table. The order of  the data values should match the order of the column descriptor.   io:print(\"Table Information: \");  io:println(tbEmployee);    Print the table data.   Employee e1 = {id: 1, name: \"Jane\", salary: 300.50};  Employee e2 = {id: 2, name: \"Anne\", salary: 100.50};  Employee e3 = {id: 3, name: \"John\", salary: 400.50};  Employee e4 = {id: 4, name: \"Peter\", salary: 150.0};    Create Employee records.   table<Employee> tb = table {  {key id, name, salary},  [  e1,  e2  ]  };    Create an in-memory table constrained by the Employee type with  the id as the primary key. Two records are inserted into the table.   Employee[] employees = [e3, e4];    foreach var emp in employees {  var ret = tb.add(emp);  if (ret is ()) {  io:println(\"Adding record to table successful\");  } else {  io:println(\"Adding to table failed: \", ret.reason());  }  }    Add the created records to the table.   io:println(\"Table Information: \", tb);    Print the table data.   io:println(\"Using foreach:\");  foreach var x in tb {  io:println(\"Name: \", x.name);  }    Access the rows using the foreach loop.   io:println(\"Using while loop:\");  while (tb.hasNext()) {  var ret = tb.getNext();  io:println(\"Name: \", ret.name);  }    Access rows using the while loop.   json retValJson = jsonutils:fromTable(tb);  io:println(\"JSON: \", retValJson.toJsonString());    Convert the table to JSON format.   xml retValXml = xmlutils:fromTable(tb);  io:println(\"XML: \", retValXml);    Convert the table to XML format.   int|error count = tb.remove(isHigherSalary);  io:println(\"Deleted Count: \", count);    Remove employees with salaries higher than 300.0  from the table.   io:println(tb); }    Now the table contains the employees with salaries less than 300.0.   function isHigherSalary(Employee emp) returns boolean {  return emp.salary > 300.0; }    Check whether a given employee’s salary is higher than 300.0.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run table.bal Table Information: id=1 name=Mary salary=300.5 id=2 name=John salary=200.5 id=3 name=Jim salary=330.5 Adding record to table successful Adding record to table successful Table Information: id=1 name=Jane salary=300.5 id=2 name=Anne salary=100.5 id=3 name=John salary=400.5 id=4 name=Peter salary=150.0 Using foreach: Name: Jane Name: Anne Name: John Name: Peter Using while loop: Name: Jane Name: Anne Name: John Name: Peter JSON: [{\"id\":1, \"name\":\"Jane\", \"salary\":300.5}, {\"id\":2, \"name\":\"Anne\", \"salary\":100.5}, {\"id\":3, \"name\":\"John\", \"salary\":400.5}, {\"id\":4, \"name\":\"Peter\", \"salary\":150.0}] XML: <results><result><id>1</id><name>Jane</name><salary>300.5</salary></result><result><id>2</id><name>Anne</name><salary>100.5</salary></result><result><id>3</id><name>John</name><salary>400.5</salary></result><result><id>4</id><name>Peter</name><salary>150.0</salary></result></results> Deleted Count: 2 id=2 name=Anne salary=100.5 id=4 name=Peter salary=150.0"},{"page":"/learn/by-example/task-scheduler-appointment.html","name":"Task Scheduler Appointment","summary":"A Task Scheduler can be used to schedule an Appointment. An appointment should\n have an appointmentData field. It can be either a string representing a\n CRON expression or an AppointmentData record. There is an optional\n noOfRecurrences field that can be used to provide the maximum number of times\n the appointment ...","content":"/  /  / Task Scheduler Appointment  import ballerina/io; import ballerina/runtime; import ballerina/task;int reminderCount = 0;public function main() {  task:AppointmentData appointmentData = {  seconds: \"0/2\",  minutes: \"*\",  hours: \"*\",  daysOfMonth: \"?\",  months: \"*\",  daysOfWeek: \"*\",  year: \"*\"  };  task:Scheduler appointment = new ({appointmentDetails: appointmentData});  var attachResult = appointment.attach(appointmentService);  if (attachResult is error) {  io:println(\"Error attaching the service.\");  return;  }  var startResult = appointment.start();  if (startResult is error) {  io:println(\"Starting the task is failed.\");  return;  } runtime:sleep(10000);  var result = appointment.stop();  if (result is error) {  io:println(\"Error occurred while cancelling the task\");  return;  }  io:println(\"Appointment cancelled.\"); } service appointmentService = service {  resource function onTrigger() {  if (reminderCount < 5) {  reminderCount = reminderCount + 1;  io:println(\"Schedule is due - Reminder: \" + reminderCount.toString());  }  } };    Task Scheduler Appointment  A Task Scheduler can be used to schedule an Appointment. An appointment should  have an appointmentData field. It can be either a string representing a  CRON expression or an AppointmentData record. There is an optional  noOfRecurrences field that can be used to provide the maximum number of times  the appointment should run before shutting down.  A service can be attached to the Scheduler using the attach() function.  Then the Scheduler can be started using start() method. When the scheduler  needs to be cancelled, stop() method can be called.    import ballerina/io; import ballerina/runtime; import ballerina/task;    int reminderCount = 0;    public function main() {    task:AppointmentData appointmentData = {  seconds: \"0/2\",  minutes: \"*\",  hours: \"*\",  daysOfMonth: \"?\",  months: \"*\",  daysOfWeek: \"*\",  year: \"*\"  };    The Appointment data record provides the appointment configurations.   task:Scheduler appointment = new ({appointmentDetails: appointmentData});    Create an Appointment using the configurations.   var attachResult = appointment.attach(appointmentService);  if (attachResult is error) {  io:println(\"Error attaching the service.\");  return;  }    Attach the service to the scheduler and exit if there is an error.   var startResult = appointment.start();  if (startResult is error) {  io:println(\"Starting the task is failed.\");  return;  }    Start the scheduler and exit if there is an error.   runtime:sleep(10000);    var result = appointment.stop();  if (result is error) {  io:println(\"Error occurred while cancelling the task\");  return;  }  io:println(\"Appointment cancelled.\"); }    Cancel the appointment.   service appointmentService = service {    Creating a service on the task Listener.   resource function onTrigger() {  if (reminderCount < 5) {  reminderCount = reminderCount + 1;  io:println(\"Schedule is due - Reminder: \" + reminderCount.toString());  }  } };    This resource triggers when the appointment is due.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run task_scheduler_appointment.bal Schedule is due - Reminder: 1 Schedule is due - Reminder: 2 Schedule is due - Reminder: 3 Schedule is due - Reminder: 4 Schedule is due - Reminder: 5 Appointment cancelled.    This example demonstrates an Appointment, which is used to send a reminder  every 2 seconds up to 5 reminders. When the reminder count reaches 5,  the task scheduler will stop running."},{"page":"/learn/by-example/task-scheduler-timer.html","name":"Task Scheduler Timer","summary":"A Task scheduler can be used to create timers to trigger periodically. A\n service can be attached to the task Scheduler object using the attach()\n function and the Listener can be started using the start() function.\n The service that is being attached must contain the onTrigger() resource function.\n Additionally, a ...","content":"/  /  / Task Scheduler Timer  import ballerina/io; import ballerina/runtime; import ballerina/task; public type Person record {|  string name;  int age;  int maxAge; |};public function main() {  int intervalInMillis = 1000;  task:Scheduler timer = new ({  intervalInMillis: intervalInMillis,  initialDelayInMillis: 0  });  Person person = {name: \"Sam\", age: 0, maxAge: 10};  var attachResult = timer.attach(service1, person);  if (attachResult is error) {  io:println(\"Error attaching the service1.\");  return;  } attachResult = timer.attach(service2, person);  if (attachResult is error) {  io:println(\"Error attaching the service2.\");  return;  }  var startResult = timer.start();  if (startResult is error) {  io:println(\"Starting the task is failed.\");  return;  }  while (person.age < person.maxAge) {  runtime:sleep(2000);  } runtime:sleep(1000);  var stopResult = timer.stop();  if (stopResult is error) {  io:println(\"Stopping the task is failed.\");  return;  } io:println(\"End.\"); } service service1 = service {  resource function onTrigger(Person person) {  if (person.age < person.maxAge) {  person.age = person.age + 1;  io:println(\"Hi \" + person.name + \" you are \" + person.age.toString() + \" years old now.\");  }  } };service service2 = service {  resource function onTrigger(Person person) {  if (person.age == 5) {  io:println(person.name + \" started schooling\");  }  } };    Task Scheduler Timer  A Task scheduler can be used to create timers to trigger periodically. A  service can be attached to the task Scheduler object using the attach()  function and the Listener can be started using the start() function.  The service that is being attached must contain the onTrigger() resource function.  Additionally, a user can pass a set of any values to the resource using  the attach() function, which then can be used inside the onTrigger()  function. The Listener can be stopped by calling the stop() function.    import ballerina/io; import ballerina/runtime; import ballerina/task;    public type Person record {|  string name;  int age;  int maxAge; |};    Defines a custom record type to use in the timer.   public function main() {    int intervalInMillis = 1000;    The interval in which the timer should trigger.   task:Scheduler timer = new ({  intervalInMillis: intervalInMillis,  initialDelayInMillis: 0  });    Initializes the timer scheduler using the interval value.  The delay will be equal to the interval as an initial delay is not provided.   Person person = {name: \"Sam\", age: 0, maxAge: 10};    Define a person object   var attachResult = timer.attach(service1, person);  if (attachResult is error) {  io:println(\"Error attaching the service1.\");  return;  }    Attaching the service to the timer. This will not start the timer.  However, it will attach the service to the timer and also passes the  person object into the onTrigger() resource   attachResult = timer.attach(service2, person);  if (attachResult is error) {  io:println(\"Error attaching the service2.\");  return;  }    var startResult = timer.start();  if (startResult is error) {  io:println(\"Starting the task is failed.\");  return;  }    Starts the timer.   while (person.age < person.maxAge) {    While loop will stop the function from exiting until the service ends.   runtime:sleep(2000);  }    Waits until the age of the person reaches the max age.   runtime:sleep(1000);    var stopResult = timer.stop();  if (stopResult is error) {  io:println(\"Stopping the task is failed.\");  return;  }    Cancels the timer. This will stop the timer and all the services  attached to it.   io:println(\"End.\"); }    service service1 = service {    The service, which will be attached to the timer.   resource function onTrigger(Person person) {  if (person.age < person.maxAge) {  person.age = person.age + 1;  io:println(\"Hi \" + person.name + \" you are \" + person.age.toString() + \" years old now.\");  }  } };    The onTrigger resource, which will trigger when the timer runs off.  The usage of the Person object being passed inside the function, which we  attached with the timer.   service service2 = service {  resource function onTrigger(Person person) {  if (person.age == 5) {  io:println(person.name + \" started schooling\");  }  } };    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run task_scheduler_timer.bal Hi Sam you are 1 years old now. Hi Sam you are 2 years old now. Hi Sam you are 3 years old now. Hi Sam you are 4 years old now. Hi Sam you are 5 years old now. Hi Sam you are 6 years old now. Sam started schooling Hi Sam you are 7 years old now. Hi Sam you are 8 years old now. Hi Sam you are 9 years old now. Hi Sam you are 10 years old now. End.    A scheduler can have any number of services attached to it. All the attached services  will run when the scheduler triggers them.  A Person record is attached to the Scheduler when attaching the service.  It is then passed into the resource functions of the service.  When the age of the person reaches the maxAge, the while loop is returned.  Hence the task is stopped."},{"page":"/learn/by-example/task-service-appointment.html","name":"Task Service Appointment","summary":"Task Appointment Services are used to schedule and execute tasks.\n An appointment should have an appointmentData field. It can be either a\n string representing a CRON expression or an AppointmentData record.\n An optional noOfRecurrences field can be used to provide the maximum\n number of times the appointment should run before ...","content":"/  /  / Task Service Appointment  import ballerina/log; import ballerina/task; task:AppointmentConfiguration appointmentConfiguration = {  appointmentDetails: \"* * * * * ?\",  noOfRecurrences: 10 }; listener task:Listener appointment = new (appointmentConfiguration);int count = 0; service appointmentService on appointment {  resource function onTrigger() {  log:printInfo(\"Cleaning up...\");  log:printInfo(count.toString());  count = count + 1;  } }    Task Service Appointment  Task Appointment Services are used to schedule and execute tasks.  An appointment should have an appointmentData field. It can be either a  string representing a CRON expression or an AppointmentData record.  An optional noOfRecurrences field can be used to provide the maximum  number of times the appointment should run before shutting down.    import ballerina/log; import ballerina/task;    task:AppointmentConfiguration appointmentConfiguration = {    Task Appointment configuration record of the Task Listener.  Task Appointment can either have a CRON expression (string) or an  AppointmentData record for the appointmentData field. Optionally, a  noOfRecurrences can be provided to limit the number of executions.   appointmentDetails: \"* * * * * ?\",    This cron expression will schedule the appointment every second.   noOfRecurrences: 10 };    Number of recurrences will limit the number of times the timer runs.   listener task:Listener appointment = new (appointmentConfiguration);    Initialize the listener using pre defined configurations.   int count = 0;    service appointmentService on appointment {    Creating a service on the task Listener.   resource function onTrigger() {  log:printInfo(\"Cleaning up...\");  log:printInfo(count.toString());  count = count + 1;  } }    This resource triggers when the appointment is due.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run task_service_appointment.bal 2019-09-06 13:35:28,259 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:28,260 INFO [ballerina/log] - 0 2019-09-06 13:35:29,004 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:29,004 INFO [ballerina/log] - 1 2019-09-06 13:35:30,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:30,003 INFO [ballerina/log] - 2 2019-09-06 13:35:31,005 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:31,006 INFO [ballerina/log] - 3 2019-09-06 13:35:32,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:32,003 INFO [ballerina/log] - 4 2019-09-06 13:35:33,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:33,003 INFO [ballerina/log] - 5 2019-09-06 13:35:34,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:34,003 INFO [ballerina/log] - 6 2019-09-06 13:35:35,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:35,003 INFO [ballerina/log] - 7 2019-09-06 13:35:36,006 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:36,006 INFO [ballerina/log] - 8 2019-09-06 13:35:37,006 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:37,007 INFO [ballerina/log] - 9    The onTrigger() function is triggered every two seconds starting from the  0th second of a minute. The sample will print logs once every two seconds."},{"page":"/learn/by-example/task-service-timer.html","name":"Task Service Timer","summary":"Task Timer Services are used to execute tasks periodically. A timer should\n have an intervalInMillis specified and an initialDelayInMillis if\n needed. The delay specifies the initial delay before the task is executed\n for the first time. Thereafter, the timer triggers at the provided interval.\n The onTrigger() resource is called when ...","content":"/  /  / Task Service Timer  import ballerina/log; import ballerina/task; task:TimerConfiguration timerConfiguration = {  intervalInMillis: 1000,  initialDelayInMillis: 3000,  noOfRecurrences: 10 }; listener task:Listener timer = new (timerConfiguration);int count = 0; service timerService on timer {  resource function onTrigger() {  log:printInfo(\"Cleaning up...\");  log:printInfo(count.toString());  count = count + 1;  } }    Task Service Timer  Task Timer Services are used to execute tasks periodically. A timer should  have an intervalInMillis specified and an initialDelayInMillis if  needed. The delay specifies the initial delay before the task is executed  for the first time. Thereafter, the timer triggers at the provided interval.  The onTrigger() resource is called when the timer triggers. An optional  noOfRecurrences field can be used to provide the maximum number of times  the Timer should run before shutting down.    import ballerina/log; import ballerina/task;    task:TimerConfiguration timerConfiguration = {  intervalInMillis: 1000,  initialDelayInMillis: 3000,    The Task Timer configuration record to configure the Task Listener.   noOfRecurrences: 10 };    Number of recurrences will limit the number of times the timer runs.   listener task:Listener timer = new (timerConfiguration);    Initialize the listener using the above defined configurations.   int count = 0;    service timerService on timer {    Creating a service on the task Listener.   resource function onTrigger() {  log:printInfo(\"Cleaning up...\");  log:printInfo(count.toString());  count = count + 1;  } }    This resource triggers when the timer goes off.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run task_service_timer.bal 2019-09-06 13:37:17,298 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:17,299 INFO [ballerina/log] - 0 2019-09-06 13:37:18,288 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:18,289 INFO [ballerina/log] - 1 2019-09-06 13:37:19,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:19,289 INFO [ballerina/log] - 2 2019-09-06 13:37:20,288 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:20,289 INFO [ballerina/log] - 3 2019-09-06 13:37:21,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:21,288 INFO [ballerina/log] - 4 2019-09-06 13:37:22,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:22,287 INFO [ballerina/log] - 5 2019-09-06 13:37:23,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:23,288 INFO [ballerina/log] - 6 2019-09-06 13:37:24,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:24,287 INFO [ballerina/log] - 7 2019-09-06 13:37:25,288 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:25,289 INFO [ballerina/log] - 8 2019-09-06 13:37:26,285 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:26,286 INFO [ballerina/log] - 9    The onTrigger() function is triggered every second but with an initial delay of 3 seconds."},{"page":"/learn/by-example/tcp-socket-listener-client.html","name":"Basic TCP Socket","summary":"The TCP Listener is used to expose TCP service over the TCP protocol.\n The TCP Client is used to connect to a remote TCP server.\n This sample demonstrates how the TCP socket listener service interacts with the TCP client.This is the client implementation for the TCP socket with the attached ...","content":"/  /  / Basic TCP Socket  import ballerina/io; import ballerina/socket;public function main() {  socket:Client socketClient = new ({  host: \"localhost\",  port: 61598  });  string content = \"Hello Ballerina\";  byte[] payloadByte = content.toBytes();  int i = 0;  int arrayLength = payloadByte.length();  while (i < arrayLength) {  var writeResult = socketClient->write(payloadByte);  if (writeResult is error) {  io:println(\"Unable to written the content \", writeResult);  } else {  i = i + writeResult;  payloadByte = payloadByte.slice(writeResult, arrayLength);  }  }  var result = socketClient->read();  if (result is [byte[], int]) {  var [reply, length] = result;  if (length > 0) {  var byteChannel =  io:createReadableChannel(reply);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(25);  if (str is string) {  io:println(<@untainted>str);  } else {  io:println(\"Error while reading characters \", str);  }  } else {  io:println(\"Client close: \", socketClient.remotePort);  }  }  } else {  io:println(result);  }  var closeResult = socketClient->close();  if (closeResult is error) {  io:println(closeResult);  } else {  io:println(\"Client connection closed successfully.\");  } } import ballerina/io; import ballerina/log; import ballerina/socket; service echoServer on new socket:Listener(61598) {  resource function onConnect(socket:Caller caller) {  log:printInfo(\"Client connected: \" + caller.id.toString());  }  resource function onReadReady(socket:Caller caller) {  var result = caller->read();  if (result is [byte[], int]) {  var [content, length] = result;  if (length > 0) {  var byteChannel =  io:createReadableChannel(content);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(20);  if (str is string) {  string reply = <@untainted>str + \" back\";  byte[] payloadByte = reply.toBytes();  int i = 0;  int arrayLength = payloadByte.length();  while (i < arrayLength) {  var writeResult = caller->write(payloadByte);  if (writeResult is int) {  log:printInfo(\"Number of bytes written: \"  + writeResult.toString());  i = i + writeResult;  payloadByte = payloadByte.slice(writeResult, arrayLength);  } else {  log:printError(\"Unable to write the content\",  writeResult);  }  }  } else {  log:printError(\"Error while writing content to the caller\",  str);  }  }  } else {  log:printInfo(\"Client left: \" + caller.id.toString());  }  } else {  io:println(result);  }  }  resource function onError(socket:Caller caller, error er) {  log:printError(\"An error occurred\", er);  } }    Basic TCP Socket  The TCP Listener is used to expose TCP service over the TCP protocol.  The TCP Client is used to connect to a remote TCP server.  This sample demonstrates how the TCP socket listener service interacts with the TCP client.    import ballerina/io; import ballerina/socket;    This is the client implementation for the TCP socket with the attached callback service. Callback service is optional.   public function main() {    socket:Client socketClient = new ({  host: \"localhost\",  port: 61598  });  string content = \"Hello Ballerina\";  byte[] payloadByte = content.toBytes();    Create a new socket client by providing the host, port, and callback service.   int i = 0;  int arrayLength = payloadByte.length();  while (i < arrayLength) {  var writeResult = socketClient->write(payloadByte);  if (writeResult is error) {  io:println(\"Unable to written the content \", writeResult);  } else {  i = i + writeResult;  payloadByte = payloadByte.slice(writeResult, arrayLength);  }  }    Send desired content to the server using the write function.   var result = socketClient->read();  if (result is [byte[], int]) {  var [reply, length] = result;  if (length > 0) {  var byteChannel =  io:createReadableChannel(reply);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(25);  if (str is string) {  io:println(<@untainted>str);  } else {  io:println(\"Error while reading characters \", str);  }  } else {  io:println(\"Client close: \", socketClient.remotePort);  }  }  } else {  io:println(result);  }    Reading response from the server.   var closeResult = socketClient->close();  if (closeResult is error) {  io:println(closeResult);  } else {  io:println(\"Client connection closed successfully.\");  } }    Close the connection between the server and the client.   # To run the client, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run tcp_socket_client.bal    # Print the response that is obtained from the server. Hello Ballerina back Client connection closed successfully.    import ballerina/io; import ballerina/log; import ballerina/socket;    This is the server implementation for the TCP socket.   service echoServer on new socket:Listener(61598) {    Bind the service to the port.  The socket listener should have these four predefined resources.   resource function onConnect(socket:Caller caller) {  log:printInfo(\"Client connected: \" + caller.id.toString());  }    This resource is invoked when the new client joins.   resource function onReadReady(socket:Caller caller) {  var result = caller->read();  if (result is [byte[], int]) {  var [content, length] = result;  if (length > 0) {    This resource is invoked once the content is received from the client.   var byteChannel =  io:createReadableChannel(content);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(20);  if (str is string) {  string reply = <@untainted>str + \" back\";  byte[] payloadByte = reply.toBytes();    Create a new ReadableByteChannel using the newly received content.   int i = 0;  int arrayLength = payloadByte.length();  while (i < arrayLength) {  var writeResult = caller->write(payloadByte);  if (writeResult is int) {  log:printInfo(\"Number of bytes written: \"  + writeResult.toString());  i = i + writeResult;  payloadByte = payloadByte.slice(writeResult, arrayLength);  } else {  log:printError(\"Unable to write the content\",  writeResult);  }  }  } else {  log:printError(\"Error while writing content to the caller\",  str);  }  }  } else {  log:printInfo(\"Client left: \" + caller.id.toString());  }  } else {  io:println(result);  }  }    Send the reply to the caller.   resource function onError(socket:Caller caller, error er) {  log:printError(\"An error occurred\", er);  } }    This resource is invoked for the error situation  if it happens during the onConnect and onReadReady.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run tcp_socket_listener.bal    # The socket listener starts listening to the port 61598 for incoming client requests. [ballerina/socket] started socket listener 61598    2019-02-18 11:24:32,429 INFO [] - Client connected: 504372137 2019-02-18 11:24:32,467 INFO [] - Number of bytes written: 20 2019-02-18 11:24:32,487 INFO [] - Client left: 504372137"},{"page":"/learn/by-example/testerina-before-and-after-suite.html","name":"Before and After Suite","summary":"The BeforeSuite feature allows you to execute a function before executing a test suite.\n A module is considered as a suite in testerina. This capability can be used for\n setting up prerequisites before executing a test suite.\n Similarly, the AfterSuite annotation can be used to execute a function after a ...","content":"/  /  / Before and After Suite  import ballerina/io; import ballerina/test; @test:BeforeSuite function beforeSuit() {  io:println(\"I'm the before suite function!\"); } @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); } @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed\"); } @test:AfterSuite function afterSuite() {  io:println(\"I'm the after suite function!\"); }    Before and After Suite  The BeforeSuite feature allows you to execute a function before executing a test suite.  A module is considered as a suite in testerina. This capability can be used for  setting up prerequisites before executing a test suite.  Similarly, the AfterSuite annotation can be used to execute a function after a test suite.    import ballerina/io; import ballerina/test;    @test:BeforeSuite function beforeSuit() {  io:println(\"I'm the before suite function!\"); }    The function annotated with BeforeSuite is executed before all the test functions in the module.   @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }    A Test function.   @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed\"); }    A Test function.   @test:AfterSuite function afterSuite() {  io:println(\"I'm the after suite function!\"); }    The function annotated with AfterSuite will be executed after all the test functions in the module have executed.   # For the moment `ballerina test` works only in projects. $ ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm the before suite function! I'm in test function 2! I'm in test function 1! I'm the after suite function!    [pass] testFunction2  [pass] testFunction1    2 passing  0 failing  0 skipped"},{"page":"/learn/by-example/testerina-assertions.html","name":"Assertions","summary":"Testerina has in-built assertions that enable users to\n assert an outcome against an expected outcome.\n This example illustrates how to use different assertions.The assertEquals() function allows you to compare primitive types (e.g., int) against composite objects.\n Compares values of the type int.Compares values of the type float.Compares values of the ...","content":"/  /  / Assertions  import ballerina/test; @test:Config {} function testAssertIntEquals() {  int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertEquals(answer, 8, msg = \"int values not equal\"); } @test:Config {} function testAssertFloatEquals() {  float a = 10.000;  float b = 20.050;  float answer = floatAdd(a, b);  test:assertEquals(answer, 30.050, msg = \"float values not equal\"); } @test:Config {} function testAssertStringEquals() {  string a = \"John\";  string b = \"Doe\";  string concatenated = stringConcat(a, b);  test:assertEquals(concatenated, \"JohnDoe\", msg = \"string values not equal\"); } @test:Config {} function testAssertJsonEquals() {  json a = {\"name\": \"Ballerina\"};  json b = {\"name\": \"Ballerina\"};  test:assertEquals(a, b, msg = \"JSON values not equal\"); } @test:Config {} function testAssertBooleanEquals() {  boolean x = true;  boolean y = true;  test:assertEquals(x, y, msg = \"boolean values not equal\"); } @test:Config {} function testAssertStringArrayEquals() {  string[] x = [\"A\", \"B\", \"C\"];  string[] y = [\"A\", \"B\", \"C\"];  test:assertEquals(x, y, msg = \"string array values not equal\"); } @test:Config {} function testAssertIntArrayEquals() {  int[] x = [1, 2, 3];  int[] y = [1, 2, 3];  test:assertEquals(x, y, msg = \"int array values not equal\"); } @test:Config {} function testAssertFloatArrayEquals() {  float[] x = [1.1, 2.2, 3.3];  float[] y = [1.1, 2.2, 3.3];  test:assertEquals(x, y, msg = \"float array values not equal\"); } @test:Config {} function testAssertNotEqualsString() {  string s1 = \"abc\";  string s2 = \"def\";  test:assertNotEquals(s1, s2, msg = \"string values are equal\"); } @test:Config {} function testAssertNotEqualsJson() {  json s1 = {\"a\": \"b\"};  json s2 = {\"a\": \"c\"};  test:assertNotEquals(s1, s2, msg = \"JSON values are equal\"); } @test:Config {} function testAssertTrue() {  boolean value = true;  test:assertTrue(value, msg = \"AssertTrue failed\"); } @test:Config {} function testAssertFalse() {  boolean value = false;  test:assertFalse(value, msg = \"AssertFalse failed\"); } @test:Config {} function testAssertFail() {  if (true) {  return;  }  test:assertFail(msg = \"AssertFailed\"); }function intAdd(int a, int b) returns (int) {  return (a + b); }function floatAdd(float a, float b) returns (float) {  return (a + b); }function stringConcat(string a, string b) returns (string) {  return (a + b); }    Assertions  Testerina has in-built assertions that enable users to  assert an outcome against an expected outcome.  This example illustrates how to use different assertions.    import ballerina/test;    @test:Config {} function testAssertIntEquals() {  int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertEquals(answer, 8, msg = \"int values not equal\"); }    The assertEquals() function allows you to compare primitive types (e.g., int) against composite objects.  Compares values of the type int.   @test:Config {} function testAssertFloatEquals() {  float a = 10.000;  float b = 20.050;  float answer = floatAdd(a, b);  test:assertEquals(answer, 30.050, msg = \"float values not equal\"); }    Compares values of the type float.   @test:Config {} function testAssertStringEquals() {  string a = \"John\";  string b = \"Doe\";  string concatenated = stringConcat(a, b);  test:assertEquals(concatenated, \"JohnDoe\", msg = \"string values not equal\"); }    Compares values of the type string.   @test:Config {} function testAssertJsonEquals() {  json a = {\"name\": \"Ballerina\"};  json b = {\"name\": \"Ballerina\"};  test:assertEquals(a, b, msg = \"JSON values not equal\"); }    Compares values of the type json.   @test:Config {} function testAssertBooleanEquals() {  boolean x = true;  boolean y = true;  test:assertEquals(x, y, msg = \"boolean values not equal\"); }    Compares values of the type boolean.   @test:Config {} function testAssertStringArrayEquals() {  string[] x = [\"A\", \"B\", \"C\"];  string[] y = [\"A\", \"B\", \"C\"];  test:assertEquals(x, y, msg = \"string array values not equal\"); }    Compares values of the type string[].   @test:Config {} function testAssertIntArrayEquals() {  int[] x = [1, 2, 3];  int[] y = [1, 2, 3];  test:assertEquals(x, y, msg = \"int array values not equal\"); }    Compares values of the type int[].   @test:Config {} function testAssertFloatArrayEquals() {  float[] x = [1.1, 2.2, 3.3];  float[] y = [1.1, 2.2, 3.3];  test:assertEquals(x, y, msg = \"float array values not equal\"); }    Compares values of the type float[].   @test:Config {} function testAssertNotEqualsString() {  string s1 = \"abc\";  string s2 = \"def\";  test:assertNotEquals(s1, s2, msg = \"string values are equal\"); }    Compares distinct values of the type string.   @test:Config {} function testAssertNotEqualsJson() {  json s1 = {\"a\": \"b\"};  json s2 = {\"a\": \"c\"};  test:assertNotEquals(s1, s2, msg = \"JSON values are equal\"); }    Compares distinct values of the type json.   @test:Config {} function testAssertTrue() {  boolean value = true;  test:assertTrue(value, msg = \"AssertTrue failed\"); }    Asserts true.   @test:Config {} function testAssertFalse() {  boolean value = false;  test:assertFalse(value, msg = \"AssertFalse failed\"); }    Asserts false.   @test:Config {} function testAssertFail() {  if (true) {  return;  }  test:assertFail(msg = \"AssertFailed\"); }    A test-example, which is failing intentionally.   function intAdd(int a, int b) returns (int) {  return (a + b); }    function floatAdd(float a, float b) returns (float) {  return (a + b); }    function stringConcat(string a, string b) returns (string) {  return (a + b); }    # For the moment `ballerina test` works only in projects. $ ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0    [pass] testAssertFail  [pass] testAssertFalse  [pass] testAssertTrue  [pass] testAssertNotEqualsJson  [pass] testAssertNotEqualsString  [pass] testAssertFloatArrayEquals  [pass] testAssertIntArrayEquals  [pass] testAssertStringArrayEquals  [pass] testAssertBooleanEquals  [pass] testAssertJsonEquals  [pass] testAssertStringEquals  [pass] testAssertFloatEquals  [pass] testAssertIntEquals    13 passing  0 failing  0 skipped"},{"page":"/learn/by-example/testerina-before-and-after-test.html","name":"Before and After Test","summary":"The before attribute allows you to execute a function before a test function.\n This capability can be used for setting up prerequisites that need to be executed before executing a test.\n Similarly, the after attribute can be used to execute a function after a test function.This before-function is executed before ...","content":"/  /  / Before and After Test  import ballerina/io; import ballerina/test; function beforeFunc() {  io:println(\"I'm the before function!\"); } @test:Config {  before: \"beforeFunc\",  after: \"afterFunc\" } function testFunction() {  io:println(\"I'm in test function!\");  test:assertTrue(true, msg = \"Failed!\"); } function afterFunc() {  io:println(\"I'm the after function!\"); }    Before and After Test  The before attribute allows you to execute a function before a test function.  This capability can be used for setting up prerequisites that need to be executed before executing a test.  Similarly, the after attribute can be used to execute a function after a test function.    import ballerina/io; import ballerina/test;    function beforeFunc() {  io:println(\"I'm the before function!\"); }    This before-function is executed before the test function.   @test:Config {  before: \"beforeFunc\",  after: \"afterFunc\" } function testFunction() {  io:println(\"I'm in test function!\");  test:assertTrue(true, msg = \"Failed!\"); }    The Test function.  Use the before and after attributes to define the function names  of the functions that need to be executed before and after the test function.   function afterFunc() {  io:println(\"I'm the after function!\"); }    This after-function is executed after the test function.   # For the moment `ballerina test` works only in projects. $ ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm the before function! I'm in test function! I'm the after function!    [pass] testFunction    1 passing  0 failing  0 skipped"},{"page":"/learn/by-example/testerina-before-each-test.html","name":"Before Each Test","summary":"The function specified with the BeforeEach annotation is executed before every test within the test suite.\n This can be used for repeatedly initializing test level aspects before every test function.The before-each function, which is executed before each test function.A test function.A test function.A test function. ...","content":"/  /  / Before Each Test  import ballerina/io; import ballerina/test; @test:BeforeEach function beforeFunc() {  io:println(\"I'm the before function!\"); } @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); } @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); } @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }    Before Each Test  The function specified with the BeforeEach annotation is executed before every test within the test suite.  This can be used for repeatedly initializing test level aspects before every test function.    import ballerina/io; import ballerina/test;    @test:BeforeEach function beforeFunc() {  io:println(\"I'm the before function!\"); }    The before-each function, which is executed before each test function.   @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }    A test function.   @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }    A test function.   @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }    A test function.   # For the moment `ballerina test` works only in projects. $ ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm the before function! I'm in test function 3! I'm the before function! I'm in test function 2! I'm the before function! I'm in test function 1!    [pass] testFunction3  [pass] testFunction2  [pass] testFunction1    3 passing  0 failing  0 skipped"},{"page":"/learn/by-example/testerina-group-tests.html","name":"Group Tests","summary":"You can tag your test cases with a single group name or multiple group names (one or more).\n This allows you to control the execution of selected tests.\n In order to execute tests belonging to a selected test group, you can name the\n test groups that are to be executed ...","content":"/  /  / Group Tests  import ballerina/io; import ballerina/test; @test:Config {  groups: [\"g1\"] } function testFunction1() {  io:println(\"I'm in test belonging to group g1!\");  test:assertTrue(true, msg = \"Failed!\"); } @test:Config {  groups: [\"g1\", \"g2\"] } function testFunction2() {  io:println(\"I'm in test belonging to groups g1 and g2!\");  test:assertTrue(true, msg = \"Failed!\"); } @test:Config {} function testFunction3() {  io:println(\"I'm the ungrouped test\");  test:assertTrue(true, msg = \"Failed!\"); }    Group Tests  You can tag your test cases with a single group name or multiple group names (one or more).  This allows you to control the execution of selected tests.  In order to execute tests belonging to a selected test group, you can name the  test groups that are to be executed when you run tests.  Likewise, you can exclude executing selected tests as well.    import ballerina/io; import ballerina/test;    @test:Config {  groups: [\"g1\"] } function testFunction1() {  io:println(\"I'm in test belonging to group g1!\");  test:assertTrue(true, msg = \"Failed!\"); }    The test function, which belongs to the group g1.   @test:Config {  groups: [\"g1\", \"g2\"] } function testFunction2() {  io:println(\"I'm in test belonging to groups g1 and g2!\");  test:assertTrue(true, msg = \"Failed!\"); }    The test function, which belongs to the groups g1 and g2   @test:Config {} function testFunction3() {  io:println(\"I'm the ungrouped test\");  test:assertTrue(true, msg = \"Failed!\"); }    This test doesn’t belong to any group.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina test` command. # You need to have the ballerina-tools distribution # installed to execute this command. $ ballerina test testerina_group_tests.bal --groups g1 --groups g2 Compiling tests  testerina_group_tests.bal    Running tests  testerina_group_tests.bal I'm in test belonging to groups g1 and g2! I'm in test belonging to group g1!  [pass] testFunction2  [pass] testFunction1    2 passing  0 failing  0 skipped    $ ballerina test testerina_group_tests.bal --groups g1 Compiling tests  testerina_group_tests.bal    Running tests  testerina_group_tests.bal I'm in test belonging to groups g1 and g2! I'm in test belonging to group g1!  [pass] testFunction2  [pass] testFunction1    2 passing  0 failing  0 skipped    $ ballerina test testerina_group_tests.bal --disable-groups g2 Compiling tests  testerina_group_tests.bal    Running tests  testerina_group_tests.bal I'm the ungrouped test I'm in test belonging to group g1!  [pass] testFunction3  [pass] testFunction1    2 passing  0 failing  0 skipped"},{"page":"/learn/by-example/testerina-data-driven-tests.html","name":"Data Driven Tests","summary":"Testerina provides in-built support for data-driven tests.\n You can provide a function pointer as a data-provider. The function returns a\n value-set of data and you can iterate the same test over the returned dataset.The dataProvider attribute allows you to add a data provider function to the test-case.The stringDataProvider function provides ...","content":"/  /  / Data Driven Tests  import ballerina/io; import ballerina/test; @test:Config {  dataProvider: \"stringDataProvider\" } function testAddingValues(string fValue, string sValue, string result) { int|error val1 = int.constructFrom(fValue);  int value1 = val1 is int ? val1 : 0;  int|error val2 = int.constructFrom(sValue);  int value2 = val2 is int ? val2 : 0;  int|error res1 = int.constructFrom(result);  int result1 = res1 is int ? res1 : 0; io:println(\"Input : [\" + fValue + \",\" + sValue + \",\" + result + \"]\");  test:assertEquals(value1 + value2, result1, msg = \"Incorrect Sum\"); } function stringDataProvider() returns (string[][]) {  return [[\"1\", \"2\", \"3\"], [\"10\", \"20\", \"30\"], [\"5\", \"6\", \"11\"]]; }@test:Config {  dataProvider: \"jsonDataProvider\" } function testJsonObjects(json fValue, json sValue, json result) {  json a = {\"a\": \"a\"};  json b = {\"b\": \"b\"};  json c = {\"c\": \"c\"};  test:assertEquals(fValue, a, msg = \"json data provider failed\");  test:assertEquals(sValue, b, msg = \"json data provider failed\");  test:assertEquals(result, c, msg = \"json data provider failed\"); } function jsonDataProvider() returns (json[][]) {  return [[{\"a\": \"a\"}, {\"b\": \"b\"}, {\"c\": \"c\"}]]; }    Data Driven Tests  Testerina provides in-built support for data-driven tests.  You can provide a function pointer as a data-provider. The function returns a  value-set of data and you can iterate the same test over the returned dataset.    import ballerina/io; import ballerina/test;    @test:Config {    The dataProvider attribute allows you to add a data provider function to the test-case.   dataProvider: \"stringDataProvider\" }    The stringDataProvider function provides the data set to this function.   function testAddingValues(string fValue, string sValue, string result) {    Data is passed to the function as function parameters.   int|error val1 = int.constructFrom(fValue);  int value1 = val1 is int ? val1 : 0;  int|error val2 = int.constructFrom(sValue);  int value2 = val2 is int ? val2 : 0;  int|error res1 = int.constructFrom(result);  int result1 = res1 is int ? res1 : 0;    io:println(\"Input : [\" + fValue + \",\" + sValue + \",\" + result + \"]\");  test:assertEquals(value1 + value2, result1, msg = \"Incorrect Sum\"); }    function stringDataProvider() returns (string[][]) {  return [[\"1\", \"2\", \"3\"], [\"10\", \"20\", \"30\"], [\"5\", \"6\", \"11\"]]; }    The data provider function, which returns a string value-set.   @test:Config {    dataProvider: \"jsonDataProvider\" } function testJsonObjects(json fValue, json sValue, json result) {  json a = {\"a\": \"a\"};  json b = {\"b\": \"b\"};  json c = {\"c\": \"c\"};  test:assertEquals(fValue, a, msg = \"json data provider failed\");  test:assertEquals(sValue, b, msg = \"json data provider failed\");  test:assertEquals(result, c, msg = \"json data provider failed\"); }    The jsonDataProvider function provides the data set to this function.   function jsonDataProvider() returns (json[][]) {  return [[{\"a\": \"a\"}, {\"b\": \"b\"}, {\"c\": \"c\"}]]; }    The data provider function, which returns a JSON value-set.   # For the moment `ballerina test` works only in projects. $ ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 Input : [1,2,3] Input : [10,20,30] Input : [5,6,11]    [pass] testJsonObjects  [pass] testAddingValues  [pass] testAddingValues  [pass] testAddingValues    4 passing  0 failing  0 skipped"},{"page":"/learn/by-example/testerina-function-mocks.html","name":"Function Mocks","summary":"Mock functions allow you to hide the real function and engage your own functions when running tests.\n This allows you to isolate your test functions from the rest.This is the mock function, which will replace the real function.Since there is no module declaration, . is the current module.\n You can ...","content":"/  /  / Function Mocks  import ballerina/io; import ballerina/test; @test:Mock {  moduleName: \".\",  functionName: \"intAdd\" } public function mockIntAdd(int a, int b) returns int {  io:println(\"I'm the mock function!\");  return (a - b); } @test:Config {} function testAssertIntEquals() {  int answer = 0;  answer = intAdd(5, 3);  io:println(\"Function mocking test\");  test:assertEquals(answer, 2, msg = \"function mocking failed\"); } public function intAdd(int a, int b) returns int {  return (a + b); }    Function Mocks  Mock functions allow you to hide the real function and engage your own functions when running tests.  This allows you to isolate your test functions from the rest.    import ballerina/io; import ballerina/test;    @test:Mock {    This is the mock function, which will replace the real function.   moduleName: \".\",  functionName: \"intAdd\" }    Since there is no module declaration, . is the current module.  You can include any module (e.g., : ballerina/io).   public function mockIntAdd(int a, int b) returns int {  io:println(\"I'm the mock function!\");  return (a - b); }    The mock function’s signature should match with the actual function’s signature.   @test:Config {} function testAssertIntEquals() {  int answer = 0;  answer = intAdd(5, 3);  io:println(\"Function mocking test\");  test:assertEquals(answer, 2, msg = \"function mocking failed\"); }    This is the test function.   public function intAdd(int a, int b) returns int {  return (a + b); }    The real function, which is mocked above.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina test` command. # Note that you need to have the ballerina-tools distribution # installed in order to run this command. # Function mocking is not supported for testing single BAL files. $ ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm the mock function! Function mocking test    [pass] testAssertIntEquals    1 passing  0 failing  0 skipped"},{"page":"/learn/by-example/testerina-guarantee-test-execution-order.html","name":"Guarantee Test Execution Order","summary":"The dependsOnattribute can be used to define a list of function names that the test\n function depends on. These functions will be executed before the test execution.\n This allows you to ensure that the tests are being executed in the expected order.This test function depends on the testFunction3.You can provide ...","content":"/  /  / Guarantee Test Execution Order  import ballerina/io; import ballerina/test; @test:Config {  dependsOn: [\"testFunction3\"] } function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); } @test:Config {  dependsOn: [\"testFunction1\"] } function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); } @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }    Guarantee Test Execution Order  The dependsOnattribute can be used to define a list of function names that the test  function depends on. These functions will be executed before the test execution.  This allows you to ensure that the tests are being executed in the expected order.    import ballerina/io; import ballerina/test;    @test:Config {    This test function depends on the testFunction3.   dependsOn: [\"testFunction3\"] } function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }    You can provide a list of the dependent functions here.   @test:Config {  dependsOn: [\"testFunction1\"] } function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }    This test function depends on the testFunction1.   @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }    This is a random test function. This will randomly execute without depending on other functions.  However,the other function does depend on this.   # For the moment `ballerina test` works only in projects. $ ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm in test function 3! I'm in test function 1! I'm in test function 2!  3 passing  0 failing  0 skipped"},{"page":"/learn/by-example/the-main-function.html","name":"The Main Function","summary":"A public function named main is considered as an entry point to a Ballerina program.\n The main function is data-binding and can have zero or more parameters whose types are subtypes of anydata,\n including any number of required/defaultable parameters and/or a single rest parameter.\n The main function could also return ...","content":"/  /  / The Main Function  import ballerina/io; public function main(string name,  int age = 18,  string year = \"Freshman\",  string... modules)  returns error? {  if (name.length() < 5) {  error e = error(\"InvalidName\", message = \"invalid length\");  return e;  } string info = string `Name: ${name}, Age: ${age}, Year: ${year}`; if (modules.length() > 0) {  info += \", Module(s): \" + modules.toString();  }  io:println(info); }# To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command.    The Main Function  A public function named main is considered as an entry point to a Ballerina program.  The main function is data-binding and can have zero or more parameters whose types are subtypes of anydata,  including any number of required/defaultable parameters and/or a single rest parameter.  The main function could also return a value whose type is a subtype of error?.    import ballerina/io;    public function main(string name,  int age = 18,  string year = \"Freshman\",  string... modules)  returns error? {    The main function that accepts student information and prints out a formatted string.  The first parameter name is a required parameter, while the second parameter age is a defaultable  parameter with the default value 18. The third parameter year is also a defaultable parameter.  The rest parameter modules represents the additional arguments.  The main function may return an error or ().   if (name.length() < 5) {  error e = error(\"InvalidName\", message = \"invalid length\");  return e;  }    Return an error if the name is invalid.   string info = string `Name: ${name}, Age: ${age}, Year: ${year}`;    if (modules.length() > 0) {  info += \", Module(s): \" + modules.toString();  }  io:println(info); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command.    # Use the ballerina `run` command to invoke the `main` function specifying `Alice` # as the string argument for `name`. `18` would be set as the value for # `age` and `Freshman` would be set as the value for `year`. $ ballerina run the_main_function.bal Alice Name: Alice, Age: 18, Year: Freshman    # Use the ballerina `run` command to invoke the `main` function specifying `Alice` # as the string argument for `name` and `20` as the integer value for # `age`. Both arguments are specified as positional arguments. $ ballerina run the_main_function.bal Alice 20 Name: Alice, Age: 20, Year: Freshman    # Use the ballerina `run` command to invoke the `main` function specifying `Alice` # as the string argument for `name` and `Sophomore` as the string argument for # `year`. The value for `year` is specified as a named argument. $ ballerina run the_main_function.bal Alice -year=Sophomore Name: Alice, Age: 18, Year: Sophomore    # Use the ballerina `run` command to invoke the `main` function specifying values for # all parameters, including the rest parameter. All arguments are specified as # positional arguments. $ ballerina run the_main_function.bal Alice 20 Sophomore math physics Name: Alice, Age: 20, Year: Sophomore, Module(s): math physics    # Use the ballerina `run` command to invoke the `main` function specifying an invalid # string as the argument for `name`. The `error` returned would be printed. $ ballerina run the_main_function.bal Ali error: InvalidName message=invalid length"},{"page":"/learn/by-example/threads-and-strands.html","name":"Threads and Strands","summary":"A strand is a lightweight thread construct. There are two situations in which the Ballerina runtime creates a new strand:\n (1) To execute statements in a named worker declaration\n (2) To execute the function or method in the start action.  By default,\n these new strands will be part of ...","content":"/  /  / Threads and Strands  import ballerina/io; public function case1() {  io:println(\"--- case 1 ---\");  future<int> f1 = start multiply(1, 2);  io:println(\"Before the wait action\");  int result = wait f1;  io:println(\"After the wait action\\n\"); } public function case2() {  io:println(\"--- case 2 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2); io:println(\"Before the wait action\");  int result = wait f1;  io:println(\"After the wait action\\n\"); } public function case3() {  io:println(\"--- case 3 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);  future<int> f2 = @strand {thread: \"any\"} start multiply(4, 5); io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); } public function case4() {  io:println(\"--- case 4 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);  future<int> f2 = start multiply(4, 5); io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); } public function case5() {  io:println(\"--- case 5 ---\");  future<int> f1 = start multiply(1, 2);  future<int> f2 = start multiply(4, 5); io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }public function main() {  case1();  case2();  case3();  case4();  case5(); }function multiply(int x, int y) returns int {  io:println(string `Multiplying ${x} * ${y}`);  return x * y; }    Threads and Strands  A strand is a lightweight thread construct. There are two situations in which the Ballerina runtime creates a new strand:  (1) To execute statements in a named worker declaration  (2) To execute the function or method in the start action. By default,  these new strands will be part of the same thread as the current strand.  Strands that belong to the same thread share the following characteristics. Only one strand can run simultaneously.  The currently-running strand should yield to switch its thread to execute another strand.  Therefore, strands belonging to a particular thread are cooperatively multitasked.  All the strands created in a particular execution of a Ballerina program will be executed  sequentially by a single thread. In some situations, it would be desirable to assign strands to different threads.  The @strand annotation helps you to achieve this.  You can annotate the named worker declarations and start actions with the @strand annotation to instruct  the Ballerina runtime to put new strands in a separate thread from the current strand.    import ballerina/io;    public function case1() {    This function creates a new strand, which belongs to the same  thread as the current strand.   io:println(\"--- case 1 ---\");  future<int> f1 = start multiply(1, 2);    Execution of the start action causes the creation of a new strand and  it will be part of the thread executing the current strand.  However, the Ballerina runtime will not execute the new strand until the current strand yields.   io:println(\"Before the wait action\");  int result = wait f1;  io:println(\"After the wait action\\n\"); }    Here, the wait action causes the current strand to yield.  Once it yields, the Ballerina runtime executes the new strand.   public function case2() {    This function creates a new strand and it should be in a separate thread from the current strand.  The usage of the @strand annotation with the thread field value “any” enforces this behavior.   io:println(\"--- case 2 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);    This new strand does not belong to the thread executing the current strand.  The Ballerina runtime assigns this new strand to a separate thread in the runtime thread pool.   io:println(\"Before the wait action\");  int result = wait f1;  io:println(\"After the wait action\\n\"); }    public function case3() {  io:println(\"--- case 3 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);  future<int> f2 = @strand {thread: \"any\"} start multiply(4, 5);    Create two new strands and assign them to separate threads from the thread executing the current strand.   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }    public function case4() {  io:println(\"--- case 4 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);  future<int> f2 = start multiply(4, 5);    Create two new strands. Ballerina runtime assigns the first one to a separate thread and assigns  the second one to the same thread executing the current strand.   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }    public function case5() {  io:println(\"--- case 5 ---\");  future<int> f1 = start multiply(1, 2);  future<int> f2 = start multiply(4, 5);    Create two new strands. The Ballerina runtime assigns both strands to the same thread executing the current strand.   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }    public function main() {  case1();  case2();  case3();  case4();  case5(); }    function multiply(int x, int y) returns int {  io:println(string `Multiplying ${x} * ${y}`);  return x * y; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run threads-and-strands.bal --- case 1 --- Before the wait action Multiplying 1 * 2 After the wait action    --- case 2 --- Multiplying 1 * 2 Before the wait action After the wait action    --- case 3 --- Multiplying 1 * 2 Multiplying 4 * 5 Before the wait action After the wait action    --- case 4 --- Multiplying 1 * 2 Before the wait action Multiplying 4 * 5 After the wait action    --- case 5 --- Before the wait action Multiplying 4 * 5 Multiplying 1 * 2 After the wait action"},{"page":"/learn/by-example/time.html","name":"Time","summary":"The Ballerina time API manipulates information with relation to\n date and time.To create the time:Time object, use either the currentTime(),\n createTime(), or the parse() function.\n This fetches the current time.Specifies a time with the required year, month, date,\n time, and timezone information.This retrieves the time for a given string representation\n ...","content":"/  /  / Time  import ballerina/io; import ballerina/time;public function main() {  time:Time time = time:currentTime();  int currentTimeMills = time.time;  io:println(\"Current system time in milliseconds: \", currentTimeMills);  time:Time|error timeCreated = time:createTime(2017, 3, 28, 23, 42, 45,  554, \"America/Panama\");  if (timeCreated is time:Time) {  io:println(\"Created Time: \", time:toString(timeCreated));  }  time:Time|error t1 = time:parse(\"2017-06-26T09:46:22.444-0500\",  \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");  if (t1 is time:Time) {  io:println(\"Parsed Time: \", time:toString(t1));  }  string standardTimeString = time:toString(time);  io:println(\"Current system time in ISO format: \", standardTimeString);  string|error customTimeString = time:format(time, \"yyyy-MM-dd-E\");  if (customTimeString is string) {  io:println(\"Current system time in custom format: \", customTimeString);  }  int year = time:getYear(time);  io:println(\"Year: \", year);  int month = time:getMonth(time);  io:println(\"Month: \", month);  int day = time:getDay(time);  io:println(\"Day: \", day);  int hour = time:getHour(time);  io:println(\"Hour: \", hour);  int minute = time:getMinute(time);  io:println(\"Minute: \", minute);  int second = time:getSecond(time);  io:println(\"Second: \", second);  int milliSecond = time:getMilliSecond(time);  io:println(\"Millisecond: \", milliSecond);  string weekday = time:getWeekday(time);  io:println(\"Weekday: \", weekday);  [year, month, day] = time:getDate(time);  io:println(\"Date: \", year, \":\", month, \":\", day);  [hour, minute, second, milliSecond] = time:getTime(time);  io:println(\"Time: \", hour, \":\", minute, \":\", second, \":\", milliSecond);  time:Time tmAdd = time:addDuration(time, 1, 1, 0, 0, 0, 1, 0);  io:println(\"After adding a duration: \", time:toString(tmAdd));  time:Time tmSub = time:subtractDuration(time, 1, 1, 0, 0, 0, 1, 0);  io:println(\"After subtracting a duration: \", time:toString(tmSub));  time:Time|error t2 = time:createTime(2017, 3, 28, 23, 42, 45, 554,  \"America/Panama\");  if (t2 is time:Time) {  io:println(\"Before converting the time zone: \", time:toString(t2));  time:Time|error t3 = time:toTimeZone(t2, \"Asia/Colombo\");  if (t3 is time:Time) {  io:println(\"After converting the time zone: \", time:toString(t3));  }  } }    Time  The Ballerina time API manipulates information with relation to  date and time.    import ballerina/io; import ballerina/time;    public function main() {    time:Time time = time:currentTime();  int currentTimeMills = time.time;  io:println(\"Current system time in milliseconds: \", currentTimeMills);    To create the time:Time object, use either the currentTime(),  createTime(), or the parse() function.  This fetches the current time.   time:Time|error timeCreated = time:createTime(2017, 3, 28, 23, 42, 45,  554, \"America/Panama\");  if (timeCreated is time:Time) {  io:println(\"Created Time: \", time:toString(timeCreated));  }    Specifies a time with the required year, month, date,  time, and timezone information.   time:Time|error t1 = time:parse(\"2017-06-26T09:46:22.444-0500\",  \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");  if (t1 is time:Time) {  io:println(\"Parsed Time: \", time:toString(t1));  }    This retrieves the time for a given string representation  based on the specified String format.   string standardTimeString = time:toString(time);  io:println(\"Current system time in ISO format: \", standardTimeString);    You can retrieve the string representation of the time via the toString()  function or the format() function.  This fetches the ISO 8601 formatted String of a given time.   string|error customTimeString = time:format(time, \"yyyy-MM-dd-E\");  if (customTimeString is string) {  io:println(\"Current system time in custom format: \", customTimeString);  }    This fetches the formatted String of a given time.   int year = time:getYear(time);  io:println(\"Year: \", year);    These functions retrieve information related to a time object.  This fetches the year of a given time.   int month = time:getMonth(time);  io:println(\"Month: \", month);    This fetches the month value of a given time.   int day = time:getDay(time);  io:println(\"Day: \", day);    This fetches the day value of a given time.   int hour = time:getHour(time);  io:println(\"Hour: \", hour);    This fetches the hour value of a given time.   int minute = time:getMinute(time);  io:println(\"Minute: \", minute);    This fetches the minute value of a given time.   int second = time:getSecond(time);  io:println(\"Second: \", second);    This fetches the seconds value of a given time.   int milliSecond = time:getMilliSecond(time);  io:println(\"Millisecond: \", milliSecond);    This fetches the millisecond value of a given time.   string weekday = time:getWeekday(time);  io:println(\"Weekday: \", weekday);    This fetches the day of the week of a given time.   [year, month, day] = time:getDate(time);  io:println(\"Date: \", year, \":\", month, \":\", day);    This fetches the date component of the time using a single function.   [hour, minute, second, milliSecond] = time:getTime(time);  io:println(\"Time: \", hour, \":\", minute, \":\", second, \":\", milliSecond);    This fetches the time component using a single function.   time:Time tmAdd = time:addDuration(time, 1, 1, 0, 0, 0, 1, 0);  io:println(\"After adding a duration: \", time:toString(tmAdd));    This adds a given duration to a time. This example adds  one year, one month, and one second to the current time.   time:Time tmSub = time:subtractDuration(time, 1, 1, 0, 0, 0, 1, 0);  io:println(\"After subtracting a duration: \", time:toString(tmSub));    This subtracts a given duration from a time. This example  subtract sone year, one month, and one second from the current time.   time:Time|error t2 = time:createTime(2017, 3, 28, 23, 42, 45, 554,  \"America/Panama\");  if (t2 is time:Time) {  io:println(\"Before converting the time zone: \", time:toString(t2));  time:Time|error t3 = time:toTimeZone(t2, \"Asia/Colombo\");  if (t3 is time:Time) {  io:println(\"After converting the time zone: \", time:toString(t3));  }  } }    This converts the time to a different timezone.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run time.bal Current system time in milliseconds: 1543938113165 Created Time: 2017-03-28T23:42:45.554-05:00 Parsed Time: 2017-06-26T09:46:22.444-05:00 Current system time in ISO format: 2018-12-04T21:11:53.165+05:30 Current system time in custom format: 2018-12-04-Tue Year: 2018 Month: 12 Day: 4 Hour: 21 Minute: 11 Second: 53 Millisecond: 165 Weekday: TUESDAY Date: 2018:12:4 Time: 21:11:53:165 After adding a duration: 2020-01-04T21:11:54.165+05:30 After subtracting a duration: 2017-11-04T21:11:52.165+05:30 Before converting the time zone: 2017-03-28T23:42:45.554-05:00 After converting the time zone: 2017-03-29T10:12:45.554+05:30"},{"page":"/learn/by-example/tracing.html","name":"Distributed Tracing","summary":"Ballerina supports Observability out of the box, and Tracing is one of the three important aspect of the\n Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.\n The developers can trace their code blocks and measure the time incurred during the actual runtime execution.\n ...","content":"/  /  / Distributed Tracing  import ballerina/http; import ballerina/log; import ballerina/observe; import ballerina/runtime; service hello on new http:Listener(9234) {  resource function sayHello(http:Caller caller, http:Request req)  returns error? {  http:Response res = new;  int spanId = check observe:startSpan(\"MyFirstLogicSpan\");  int rootParentSpanId = observe:startRootSpan(\"MyRootParentSpan\");  runtime:sleep(1000);  int childSpanId = check observe:startSpan(\"MyRootChildSpan\", (),  rootParentSpanId);  runtime:sleep(1000);  error? result = observe:finishSpan(childSpanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }  runtime:sleep(1000);  result = observe:finishSpan(rootParentSpanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }  runtime:sleep(1000);  result = observe:finishSpan(spanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }  res.setPayload(\"Hello, World!\");  result = caller->respond(res); if (result is error) {  log:printError(\"Error sending response\", result);  } return ();  } }    Distributed Tracing  Ballerina supports Observability out of the box, and Tracing is one of the three important aspect of the  Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.  The developers can trace their code blocks and measure the time incurred during the actual runtime execution.  They can choose the hook their measurement with the default trace created or can create a completely new trace.    import ballerina/http; import ballerina/log; import ballerina/observe; import ballerina/runtime;    service hello on new http:Listener(9234) {    Make sure you start the service with the ‘–b7a.observability.enabled=true` property or with tracing enabled.   resource function sayHello(http:Caller caller, http:Request req)  returns error? {  http:Response res = new;    Invoke all resources with arguments of server connector and request.   int spanId = check observe:startSpan(\"MyFirstLogicSpan\");    Start a child span attaching to the system span generated.   int rootParentSpanId = observe:startRootSpan(\"MyRootParentSpan\");    Start a new root span without attaching to the system span.   runtime:sleep(1000);    Some actual logic will go here, and for example we have introduced some delay with sleep.   int childSpanId = check observe:startSpan(\"MyRootChildSpan\", (),  rootParentSpanId);    Start a new child span for the span MyRootParentSpan.   runtime:sleep(1000);    Some actual logic will go here, and for example we have introduced some delay with sleep.   error? result = observe:finishSpan(childSpanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }    Finish MyRootChildSpan span.   runtime:sleep(1000);    Some actual logic will go here, and for example we have introduced some delay with sleep.   result = observe:finishSpan(rootParentSpanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }    Finish MyRootParentSpan span.   runtime:sleep(1000);    Some actual logic will go here, and for example we have introduced some delay with sleep.   result = observe:finishSpan(spanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }    Finish the created child span MyFirstLogicSpan, which was attached to the system trace.   res.setPayload(\"Hello, World!\");    Use a util method to set a string payload.   result = caller->respond(res);    Send the response back to the caller.   if (result is error) {  log:printError(\"Error sending response\", result);  }    return ();  } }    # Jaeger is the default tracing tool used in Ballerina. To start the Jaeger execute the below command. $ docker run -d -p5775:5775/udp -p6831:6831/udp -p6832:6832/udp -p5778:5778 -p16686:16686 -p14268:14268 jaegertracing/all-in-one:latest    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command with '--b7a.observability.enabled=true' property. $ ballerina run tracing.bal --b7a.observability.enabled=true [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9234    $ curl http://localhost:9234/hello/sayHello Hello, World!    Invoke the service using cURL."},{"page":"/learn/by-example/trap.html","name":"Trap","summary":"The trap unary opearator captures a panic making it possible to treat the panic as a normal error.Calling the divide() function with 0 as the divisor results in a panic. A panic will cause the\n runtime to exit. If needed, trap can be used to capture panics and treat them ...","content":"/  /  / Trap  import ballerina/io;public function main() {  int|error result = trap divide(1, 0);  if (result is int) {  io:println(\"int result: \", result);  } else {  io:println(\"Error occurred: \", result.reason());  } }function divide(int a, int b) returns int {  return a / b; }    Trap  The trap unary opearator captures a panic making it possible to treat the panic as a normal error.    import ballerina/io;    public function main() {    int|error result = trap divide(1, 0);  if (result is int) {  io:println(\"int result: \", result);  } else {  io:println(\"Error occurred: \", result.reason());  } }    Calling the divide() function with 0 as the divisor results in a panic. A panic will cause the  runtime to exit. If needed, trap can be used to capture panics and treat them as errors thereafter.   function divide(int a, int b) returns int {  return a / b; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run trap.bal Error occurred: {ballerina}DivisionByZero"},{"page":"/learn/by-example/transactions-distributed.html","name":"Distributed Transactions","summary":"To improve the reliability of microservice-based applications,\n a series of microservice invocations can be bound into a single unit of work.\n The underlying mechanisms are that of infection and agreement protocols.\n This example demonstrates the Ballerina distributed transactions protocol\n in action.\n Ballerina transactions are at experimental stage,\n please use the ...","content":"/  /  / Distributed Transactions  import ballerina/http; import ballerina/log; import ballerina/math; import ballerina/transactions; @http:ServiceConfig {  basePath: \"/\" } service InitiatorService on new http:Listener(8080) { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function init(http:Caller conn, http:Request req) {  http:Response res = new;  log:printInfo(\"Initiating transaction...\");  transaction {  log:printInfo(\"Started transaction: \" +  transactions:getCurrentTransactionId());  boolean successful = callBusinessService();  if (successful) {  res.statusCode = http:STATUS_OK;  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  abort;  }  } committed {  log:printInfo(\"Initiated transaction committed\");  } aborted {  log:printInfo(\"Initiated transaction aborted\");  }  var result = conn->respond(res);  if (result is error) {  log:printError(\"Could not send response back to client\",  err = result);  } else {  log:printInfo(\"Sent response back to client\");  }  } } function callBusinessService() returns boolean {  http:Client participantEP = new (\"http://localhost:8889/stockquote/update\");  float price = <int>math:randomInRange(200, 250) + math:random();  json bizReq = {symbol: \"GOOG\", price: price};  http:Request req = new;  req.setJsonPayload(bizReq);  var result = participantEP->post(\"\", req);  log:printInfo(\"Got response from bizservice\");  if (result is error) {  log:printError(\"Error when calling the backend: \", result);  return false;  } else {  return result.statusCode == http:STATUS_OK;  } }import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/transactions; @http:ServiceConfig {  basePath: \"/stockquote\" } service ParticipantService on new http:Listener(8889) { @http:ResourceConfig {  path: \"/update\"  }  @transactions:Participant {  oncommit: printParticipantCommit,  onabort: printParticipantAbort  }  resource function updateStockQuote(http:Caller conn, http:Request req) {  log:printInfo(\"Received update stockquote request\");  log:printInfo(\"Joined transaction: \" +  transactions:getCurrentTransactionId());  var updateReq = <@untainted>req.getJsonPayload();  http:Response res = new;  if (updateReq is json) {  string msg = io:sprintf(\"Update stock quote request received. \" +  \"symbol:%s, price:%s\", updateReq.symbol, updateReq.price);  log:printInfo(msg);  json jsonRes = {\"message\": \"updating stock\"};  res.statusCode = http:STATUS_OK;  res.setJsonPayload(jsonRes);  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  res.setPayload(updateReq.reason());  log:printError(\"Payload error occurred!\", updateReq);  }  var result = conn->respond(res);  if (result is error) {  log:printError(\"Could not send response back to initiator\",  err = result);  } else {  log:printInfo(\"Sent response back to initiator\");  }  } } function printParticipantAbort(string transactionId) {  log:printInfo(\"Participated transaction: \" + transactionId + \" aborted\"); } function printParticipantCommit(string transactionId) {  log:printInfo(\"Participated transaction: \" + transactionId + \" committed\"); }    Distributed Transactions  To improve the reliability of microservice-based applications,  a series of microservice invocations can be bound into a single unit of work.  The underlying mechanisms are that of infection and agreement protocols.  This example demonstrates the Ballerina distributed transactions protocol  in action.  Ballerina transactions are at experimental stage,  please use the –experimental flag to enable them.    import ballerina/http; import ballerina/log; import ballerina/math; import ballerina/transactions;    @http:ServiceConfig {  basePath: \"/\" } service InitiatorService on new http:Listener(8080) {    This is the initiator of the distributed transaction.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function init(http:Caller conn, http:Request req) {  http:Response res = new;  log:printInfo(\"Initiating transaction...\");    transaction {    When the transaction statement starts, a distributed transaction context is created.   log:printInfo(\"Started transaction: \" +  transactions:getCurrentTransactionId());    Print the current transaction ID   boolean successful = callBusinessService();  if (successful) {  res.statusCode = http:STATUS_OK;  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  abort;  }    When a participant is called, the transaction context is propagated, and that participant  gets infected and joins the distributed transaction.   } committed {  log:printInfo(\"Initiated transaction committed\");  } aborted {  log:printInfo(\"Initiated transaction aborted\");  }    As soon as the transaction block ends, the 2-phase commit  coordination protocol will run. All participants are prepared  and depending on the joint outcome, either a notify commit or  notify abort will be sent to the participants.   var result = conn->respond(res);  if (result is error) {  log:printError(\"Could not send response back to client\",  err = result);  } else {  log:printInfo(\"Sent response back to client\");  }  } }    Send the response back to the client.   function callBusinessService() returns boolean {  http:Client participantEP = new (\"http://localhost:8889/stockquote/update\");    This is the participant business function call.   float price = <int>math:randomInRange(200, 250) + math:random();  json bizReq = {symbol: \"GOOG\", price: price};    Generate the payload   http:Request req = new;  req.setJsonPayload(bizReq);  var result = participantEP->post(\"\", req);  log:printInfo(\"Got response from bizservice\");  if (result is error) {  log:printError(\"Error when calling the backend: \", result);  return false;  } else {  return result.statusCode == http:STATUS_OK;  } }    Send the request to the backend service.   # To start the `initiator` service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. $ ballerina run --experimental initiator.bal [ballerina/http] started HTTP/WS listener 10.100.7.118:64337 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/transactions;    @http:ServiceConfig {  basePath: \"/stockquote\" } service ParticipantService on new http:Listener(8889) {    This service is a participant in the distributed transaction. It will get  infected when it receives a transaction context from the participant. The  transaction context, in the HTTP case, will be passed in as custom HTTP headers.   @http:ResourceConfig {  path: \"/update\"  }  @transactions:Participant {  oncommit: printParticipantCommit,  onabort: printParticipantAbort  }  resource function updateStockQuote(http:Caller conn, http:Request req) {    log:printInfo(\"Received update stockquote request\");    Since a transaction context has been received, this resource will  register with the initiator as a participant.   log:printInfo(\"Joined transaction: \" +  transactions:getCurrentTransactionId());    Print the current transaction ID.   var updateReq = <@untainted>req.getJsonPayload();    Get the json payload.   http:Response res = new;  if (updateReq is json) {  string msg = io:sprintf(\"Update stock quote request received. \" +  \"symbol:%s, price:%s\", updateReq.symbol, updateReq.price);  log:printInfo(msg);  json jsonRes = {\"message\": \"updating stock\"};  res.statusCode = http:STATUS_OK;  res.setJsonPayload(jsonRes);  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  res.setPayload(updateReq.reason());  log:printError(\"Payload error occurred!\", updateReq);  }    Generate the response.   var result = conn->respond(res);  if (result is error) {  log:printError(\"Could not send response back to initiator\",  err = result);  } else {  log:printInfo(\"Sent response back to initiator\");  }  } }    Send the response back to the initiator.   function printParticipantAbort(string transactionId) {  log:printInfo(\"Participated transaction: \" + transactionId + \" aborted\"); }    The participant function that will get called when the distributed  transaction is aborted.   function printParticipantCommit(string transactionId) {  log:printInfo(\"Participated transaction: \" + transactionId + \" committed\"); }    The participant function that will get called when the distributed  transaction is committed.   # To start the `participant` service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. #Run this command to start the `participant` service. $ ballerina run --experimental participant.bal [ballerina/http] started HTTP/WS listener 10.100.1.182:54774 [ballerina/http] started HTTP/WS listener localhost:8889    #Run this curl command to invoke the services. $ curl -v localhost:8080    Outputs similar to the following should be available from the initiator and participant.    Output from initiator:    [ballerina/http] started HTTP/WS listener 10.100.7.118:64337 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 2019-09-04 12:04:58,404 INFO [] - Initiating transaction... 2019-09-04 12:04:58,419 INFO [ballerina/transactions] - Created transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,423 INFO [] - Started transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,833 INFO [ballerina/transactions] - Registered remote participant: f677d80b-710f-4e9c-9d46-c30782086581:$anon$.$0 for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,876 INFO [] - Got response from bizservice 2019-09-04 12:04:58,877 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,899 INFO [ballerina/transactions] - Preparing remote participant: f677d80b-710f-4e9c-9d46-c30782086581:$anon$.$0 2019-09-04 12:04:58,927 INFO [ballerina/transactions] - Remote participant: f677d80b-710f-4e9c-9d46-c30782086581:$anon$.$0 prepared 2019-09-04 12:04:58,928 INFO [ballerina/transactions] - Notify(commit) remote participant: http://10.100.7.118:64553/balcoordinator/participant/2pc/$anon$.$0 2019-09-04 12:04:58,941 INFO [ballerina/transactions] - Remote participant: f677d80b-710f-4e9c-9d46-c30782086581:$anon$.$0 committed 2019-09-04 12:04:58,942 INFO [] - Initiated transaction committed 2019-09-04 12:04:58,945 INFO [] - Sent response back to client    Output from participant:    [ballerina/http] started HTTP/WS listener 10.100.7.118:64553 [ballerina/http] started HTTP/WS listener 0.0.0.0:8889 2019-09-04 12:04:58,683 INFO [ballerina/transactions] - Registering for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 with coordinator: http://10.100.7.118:64337/balcoordinator/initiator/$anon$.$0/register 2019-09-04 12:04:58,847 INFO [ballerina/transactions] - Registered with coordinator for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,848 INFO [ballerina/transactions] - participant registered: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,851 INFO [] - Received update stockquote request 2019-09-04 12:04:58,852 INFO [] - Joined transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,858 INFO [] - Update stock quote request received.  symbol:GOOG, price:249.7214191144464 2019-09-04 12:04:58,872 INFO [] - Sent response back to initiator 2019-09-04 12:04:58,917 INFO [ballerina/transactions] - Prepare received for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,918 INFO [ballerina/transactions] - Prepared transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,935 INFO [ballerina/transactions] - Notify(commit) received for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,936 INFO [] - Participated transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 committed"},{"page":"/learn/by-example/tuple-destructure-binding-pattern.html","name":"Tuple Destructure Binding Pattern","summary":"Tuple binding patterns are used to destructure and assign values to each individual variable of the tuple.\n The tuple destructuring binding patterns will be used to refer to existing variables as a tuple, destructure the\n given value on the right hand side, and assign the values to each individual variable ...","content":"/  /  / Tuple Destructure Binding Pattern  import ballerina/io;public function main() {  [string, [int, boolean]] [a1, [a2, a3]] = [\"Hello\", [123, true]];  [a1, [a2, a3]] = [\"Ballerina\", [453, false]];  io:println(\"Tuple variable : \", a1, \" \", a2, \" \", a3);  [string, [int, boolean]] [b1, [b2, b3]] = [\"Hello\", [123, true]];  b1 = \"Ballerina\";  b2 = 453;  b3 = false;  io:println(\"Tuple variable : \", b1, \" \", b2, \" \", b3);  [string, [int, [boolean, float]]] [c1, [c2, [c3, c4]]] =  [\"Test\", [123, [true, 5.6]]];  [[c1, c2], c3] = [[\"Ballerina\", 453], false];  [c2, c3, c4] = [657, true, 76.8];  io:println(\"Tuple variable : \", c1, \" \", c2, \" \", c3, \" \", c4);  [[string, [int, [boolean, int]]], [float, int]] v1 =  [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]];  [[string, [int, [boolean, int]]],  [float, int]] [[d1, [d2, [d3, d4]]], [d5, d6]] = v1;  [[d1, [d2, [d3, d4]]], [d5, d6]] = bar();  io:println(\"Tuple variable : \",  d1, \" \", d2, \" \", d3, \" \", d4, \" \", d5, \" \", d6);  var [e1, [e2, e3]] = foo();  io:println(\"Tuple variable : \", e1, \" \", e2, \" \", e3); var [[f1, [f2, [f3, f4]]], [f5, f6]] = bar();  io:println(\"Tuple variable : \",  f1, \" \", f2, \" \", f3, \" \", f4, \" \", f5, \" \", f6); }function foo() returns [string, [int, boolean]] {  return [\"Ballerina\", [453, false]]; }function bar() returns [[string, [int, [boolean, int]]], [float, int]] {  return [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]]; }    Tuple Destructure Binding Pattern  Tuple binding patterns are used to destructure and assign values to each individual variable of the tuple.  The tuple destructuring binding patterns will be used to refer to existing variables as a tuple, destructure the  given value on the right hand side, and assign the values to each individual variable of the tuple at runtime.    import ballerina/io;    public function main() {    [string, [int, boolean]] [a1, [a2, a3]] = [\"Hello\", [123, true]];  [a1, [a2, a3]] = [\"Ballerina\", [453, false]];  io:println(\"Tuple variable : \", a1, \" \", a2, \" \", a3);    Tuple variables can be destructured with new values when used as a tuple variable  reference based binding pattern.   [string, [int, boolean]] [b1, [b2, b3]] = [\"Hello\", [123, true]];  b1 = \"Ballerina\";  b2 = 453;  b3 = false;  io:println(\"Tuple variable : \", b1, \" \", b2, \" \", b3);    The variable can also be updated individually because once they are defined they are treated as individual  variables at runtime.   [string, [int, [boolean, float]]] [c1, [c2, [c3, c4]]] =  [\"Test\", [123, [true, 5.6]]];  [[c1, c2], c3] = [[\"Ballerina\", 453], false];  [c2, c3, c4] = [657, true, 76.8];  io:println(\"Tuple variable : \", c1, \" \", c2, \" \", c3, \" \", c4);    The binding patterns are recursive in nature. These examples show how to write complex recursive  variable references for destructuring.   [[string, [int, [boolean, int]]], [float, int]] v1 =  [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]];  [[string, [int, [boolean, int]]],  [float, int]] [[d1, [d2, [d3, d4]]], [d5, d6]] = v1;  [[d1, [d2, [d3, d4]]], [d5, d6]] = bar();  io:println(\"Tuple variable : \",  d1, \" \", d2, \" \", d3, \" \", d4, \" \", d5, \" \", d6);    Tuple variables can also be referenced using tuple-type expressions.   var [e1, [e2, e3]] = foo();  io:println(\"Tuple variable : \", e1, \" \", e2, \" \", e3);    Tuple type can also take “var” as the type label in which the type will be inferred from the right hand side.   var [[f1, [f2, [f3, f4]]], [f5, f6]] = bar();  io:println(\"Tuple variable : \",  f1, \" \", f2, \" \", f3, \" \", f4, \" \", f5, \" \", f6); }    function foo() returns [string, [int, boolean]] {  return [\"Ballerina\", [453, false]]; }    function bar() returns [[string, [int, [boolean, int]]], [float, int]] {  return [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]]; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run tuple_destructure_binding_pattern.bal Tuple variable : Ballerina 453 false Tuple variable : Ballerina 453 false Tuple variable : Ballerina 657 true 76.8 Tuple variable : Ballerina 3 true 34 5.6 45 Tuple variable : Ballerina 453 false Tuple variable : Ballerina 3 true 34 5.6 45"},{"page":"/learn/by-example/type-cast.html","name":"Type Cast","summary":"Type cast casts a value to a target type performing a numeric conversion if required.\n If the value belongs to the target type, the result of the type cast expression is the value itself.\n Else, if the target type contains exactly one basic numeric type, and the value belongs to ...","content":"/  /  / Type Cast  import ballerina/io;type Person record {  string name;  int age; };type Employee record {  string name;  int age;  int empNo; };type Department record {  string code; };public function main() {  Employee employee = {name: \"Jane Doe\", age: 25, empNo: 1};  Person person = <Person>employee;  io:println(\"Person Name: \", person.name);  io:println(\"Person Age: \", person.age);  Employee employeeTwo = <Employee>person;  io:println(\"Employee Name: \", employeeTwo.name);  io:println(\"Employee Age: \", employeeTwo.age);  anydata value = 100;  int i = <int>value;  io:println(\"Integer Value: \", i);  float f = <float>value;  io:println(\"Converted Float Value: \", f);  float|boolean u = <float|boolean>value;  io:println(\"Converted Float Value: \", u);  value = employee;  Department department = <Department>value; }    Type Cast  Type cast casts a value to a target type performing a numeric conversion if required.  If the value belongs to the target type, the result of the type cast expression is the value itself.  Else, if the target type contains exactly one basic numeric type, and the value belongs to a numeric type,  the resultant value would be the numeric conversion of the value to the target numeric type.  If neither is satisfied or if the numeric conversion returns an error, the type cast expression completes abruptly  with a panic.    import ballerina/io;    type Person record {  string name;  int age; };    type Employee record {  string name;  int age;  int empNo; };    type Department record {  string code; };    public function main() {    Employee employee = {name: \"Jane Doe\", age: 25, empNo: 1};  Person person = <Person>employee;  io:println(\"Person Name: \", person.name);  io:println(\"Person Age: \", person.age);    Define an Employee value and cast it to a Person.   Employee employeeTwo = <Employee>person;  io:println(\"Employee Name: \", employeeTwo.name);  io:println(\"Employee Age: \", employeeTwo.age);    Cast the value held by the person variable to an Employee.  This should succeed since person holds an Employee value.   anydata value = 100;  int i = <int>value;  io:println(\"Integer Value: \", i);    Cast an int value held by an anydata typed variable as an  int value.   float f = <float>value;  io:println(\"Converted Float Value: \", f);    Use the type cast expression with value, which currently holds  an int value, to cast it to float.  A numeric conversion would happen from int to float.   float|boolean u = <float|boolean>value;  io:println(\"Converted Float Value: \", u);    Casting to a union type would also work similarly.  If value belongs to the union type, the resultant value would  be value itself. Else, if applicable, a numeric conversion will  be attempted.  A numeric conversion would happen from int to float here.   value = employee;    Assign employee to value.   Department department = <Department>value; }    Casting a value to an incorrect type (the value does not belong  to the type and numeric conversion is not possible) would result  in an abrupt completion with a panic.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run type_cast.bal Person Name: Jane Doe Person Age: 25 Employee Name: Jane Doe Employee Age: 25 Integer Value: 100 Converted Float Value: 100.0 Converted Float Value: 100.0 error: {ballerina}TypeCastError message=incompatible types: 'Employee' cannot be cast to 'Department'  at type_cast:main(type_cast.bal:56)"},{"page":"/learn/by-example/tuple-typed-binding-pattern.html","name":"Tuple-Typed Binding Pattern","summary":"Tuple-binding patterns are used to de-structure and assign values to each individual variable of the tuple.\n The tuple-typed binding patterns will be used in declaring and defining new tuple variables.\n The tuple-type variable definition must have an assignment expression on the right hand side.This is a simple binding pattern, which ...","content":"/  /  / Tuple-Typed Binding Pattern  import ballerina/io;public function main() {  [boolean, float] t = [true, 0.4];  io:println(\"Simple variable : \", t);  [boolean, float] [a1, a2] = [true, 0.4];  io:println(\"Tuple variable : \", a1, \" \", a2);  [[string, int], float] [[b1, b2], b3] = [[\"Ballerina\", 4], 6.7];  io:println(\"Tuple variable : \", b1, \" \", b2, \" \", b3); [[string, int], [boolean, float]] [[c1, c2], [c3, c4]] =  [[\"Ballerina\", 34], [true, 6.7]];  io:println(\"Tuple variable : \", c1, \" \", c2, \" \", c3, \" \", c4);  [[string, [int, [boolean, byte]]], [float, int]] v1 =  [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]];  [[string, [int, [boolean, byte]]],  [float, int]] [[d1, [d2, [d3, d4]]], [d5, d6]] = v1;  io:println(\"Tuple variable : \",  d1, \" \", d2, \" \", d3, \" \", d4, \" \", d5, \" \", d6);  [string|int|float, [string|float, int]] [g1, [g2, g3]] =  [\"Ballerina\", [3.4, 456]];  io:println(\"Tuple variable : \", g1, \" \", g2, \" \", g3); }    Tuple-Typed Binding Pattern  Tuple-binding patterns are used to de-structure and assign values to each individual variable of the tuple.  The tuple-typed binding patterns will be used in declaring and defining new tuple variables.  The tuple-type variable definition must have an assignment expression on the right hand side.    import ballerina/io;    public function main() {    [boolean, float] t = [true, 0.4];  io:println(\"Simple variable : \", t);    This is a simple binding pattern, which involves only a single variable.   [boolean, float] [a1, a2] = [true, 0.4];  io:println(\"Tuple variable : \", a1, \" \", a2);    The same variable definition can be written using a tuple-binding pattern  with separate variables.   [[string, int], float] [[b1, b2], b3] = [[\"Ballerina\", 4], 6.7];  io:println(\"Tuple variable : \", b1, \" \", b2, \" \", b3);    The binding patterns are recursive in nature. These examples show  how to write complex recursive variable definitions.   [[string, int], [boolean, float]] [[c1, c2], [c3, c4]] =  [[\"Ballerina\", 34], [true, 6.7]];  io:println(\"Tuple variable : \", c1, \" \", c2, \" \", c3, \" \", c4);    [[string, [int, [boolean, byte]]], [float, int]] v1 =  [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]];  [[string, [int, [boolean, byte]]],  [float, int]] [[d1, [d2, [d3, d4]]], [d5, d6]] = v1;  io:println(\"Tuple variable : \",  d1, \" \", d2, \" \", d3, \" \", d4, \" \", d5, \" \", d6);    Tuple variables can also be defined using tuple-type expressions.   [string|int|float, [string|float, int]] [g1, [g2, g3]] =  [\"Ballerina\", [3.4, 456]];  io:println(\"Tuple variable : \", g1, \" \", g2, \" \", g3); }    Tuple variable definitions can also take union types.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run tuple_type_binding_pattern.bal Simple variable : true 0.4 Tuple variable : true 0.4 Tuple variable : Ballerina 4 6.7 Tuple variable : Ballerina 34 true 6.7 Tuple variable : Ballerina 3 true 34 5.6 45 Tuple variable : Ballerina 3.4 456"},{"page":"/learn/by-example/tuple-type.html","name":"Tuples","summary":"A tuple is an immutable list of two or more values of a fixed length.\n A tuple type is described by specifying the type of each member in the list.Defines the type of a as a pair that consists of an int and a string.Defines a tuple of variable names ...","content":"/  /  / Tuples  import ballerina/io;public function main() {  [int, string] a = [10, \"John\"];  io:println(a); int aint;  string astr;  [aint, astr] = a;  io:println(aint);  io:println(astr);  var [aint1, astr1] = a;  var [q, r] = divideBy10(6);  io:println(\"06/10: \", \"quotient=\", q, \" remainder=\", r);  var [q1, _] = divideBy10(57);  io:println(\"57/10: \", \"quotient=\", q1); [int, int] returnValue = divideBy10(9);  var [_, r1] = returnValue;  io:println(\"09/10: \", \"remainder=\", r1); } function divideBy10(int d) returns ([int, int]) {  int q = d / 10;  int r = d % 10;  return [q, r]; }    Tuples  A tuple is an immutable list of two or more values of a fixed length.  A tuple type is described by specifying the type of each member in the list.    import ballerina/io;    public function main() {    [int, string] a = [10, \"John\"];  io:println(a);    Defines the type of a as a pair that consists of an int and a string.   int aint;  string astr;    [aint, astr] = a;  io:println(aint);  io:println(astr);    Defines a tuple of variable names on the left with a variable reference of which the type is a tuple.  The assignment statement assigns values of the tuple on the right to the variables on the left.  In Ballerina, this is referred to as tuple destructuring.   var [aint1, astr1] = a;    You can declare and assign values with var like this.   var [q, r] = divideBy10(6);  io:println(\"06/10: \", \"quotient=\", q, \" remainder=\", r);    Invokes a function that returns a tuple.   var [q1, _] = divideBy10(57);  io:println(\"57/10: \", \"quotient=\", q1);    To ignore a value in a tuple, use _.  This ignores the second return value.   [int, int] returnValue = divideBy10(9);    var [_, r1] = returnValue;  io:println(\"09/10: \", \"remainder=\", r1); }    This ignores the first value of a tuple.   function divideBy10(int d) returns ([int, int]) {  int q = d / 10;  int r = d % 10;  return [q, r]; }    This function returns a tuple of two integers.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run tuple_type.bal 10 John 10 John 06/10: quotient=0 remainder=6 57/10: quotient=5 09/10: remainder=9"},{"page":"/learn/by-example/tuple-match-statement.html","name":"Tuple Match","summary":"The match statement in Ballerina will support value-based match patterns only. There are static and structured\n based match patterns that can be used with the match clauses. Structured match patterns will take structured\n binding patterns for matching. Tuple binding pattern is one of the structured binding patterns that can be ...","content":"/  /  / Tuple Match  import ballerina/io;public function main() {  [string, int]|[float, string, boolean]|float a1 = 66.6;  [string, int]|[float, string, boolean]|float a2 = [\"Hello\", 12];  [float, boolean]|[float, string, boolean]|float a3 = [4.5, true];  [string, int]|[float, string, boolean]|float a4 = [6.7, \"Test\", false]; basicMatch(a1);  basicMatch(a2);  basicMatch(a3);  basicMatch(a4);  [string, int]|[boolean, int]|[int, boolean]|int|float b1 = [\"Hello\", 45];  [string, int]|[float, boolean]|[int, boolean]|int|float b2 = [4.5, true];  [float, boolean]|[boolean, int]|[int, boolean]|int|float b3 = [false, 4];  [string, int]|[int, boolean]|int|float b4 = [455, true];  [float, boolean]|[boolean, int]|[int, boolean]|float b5 = 5.6; matchWithMatchGuard(b1);  matchWithMatchGuard(b2);  matchWithMatchGuard(b3);  matchWithMatchGuard(b4);  matchWithMatchGuard(b5); } function basicMatch(any a) {  match a {  var [s, i, b] => {  io:println(\"Matched with three vars : \", io:sprintf(\"%s\", a));  }  var [s, i] => {  io:println(\"Matched with two vars : \", io:sprintf(\"%s\", a));  }  var s => {  io:println(\"Matched with single var : \", io:sprintf(\"%s\", a));  }  } } function matchWithMatchGuard(any b) {  match b {  var [s, i] if (s is string && i is int) => {  io:println(\"'s' is string and 'i' is int : \", io:sprintf(\"%s\", b));  }  var [s, i] if s is float => {  io:println(\"Only 's' is float : \", io:sprintf(\"%s\", b));  }  var [s, i] if i is int => {  io:println(\"Only 'i' is int : \", io:sprintf(\"%s\", b));  }  var [s, i] => {  io:println(\"No type guard : \", io:sprintf(\"%s\", b));  }  var s if s is float => {  io:println(\"'s' is float only : \", io:sprintf(\"%s\", b));  } } }    Tuple Match  The match statement in Ballerina will support value-based match patterns only. There are static and structured  based match patterns that can be used with the match clauses. Structured match patterns will take structured  binding patterns for matching. Tuple binding pattern is one of the structured binding patterns that can be used  with the match. The value will be checked for the “isLike” relationship with the pattern to match at runtime.  The match pattern clauses can also have additional type guard conditions as strong match conditions.    import ballerina/io;    public function main() {    [string, int]|[float, string, boolean]|float a1 = 66.6;  [string, int]|[float, string, boolean]|float a2 = [\"Hello\", 12];  [float, boolean]|[float, string, boolean]|float a3 = [4.5, true];  [string, int]|[float, string, boolean]|float a4 = [6.7, \"Test\", false];    In this example, four variables are created and they will be matched against  the patterns specified in the match statement of the basicMatch() function.   basicMatch(a1);  basicMatch(a2);  basicMatch(a3);  basicMatch(a4);    [string, int]|[boolean, int]|[int, boolean]|int|float b1 = [\"Hello\", 45];  [string, int]|[float, boolean]|[int, boolean]|int|float b2 = [4.5, true];  [float, boolean]|[boolean, int]|[int, boolean]|int|float b3 = [false, 4];  [string, int]|[int, boolean]|int|float b4 = [455, true];  [float, boolean]|[boolean, int]|[int, boolean]|float b5 = 5.6;    In this example, five variables are created and they will be matched  against the match-guarded patterns specified in the match statement of the ‘matchWithMatchGuard()’ function.   matchWithMatchGuard(b1);  matchWithMatchGuard(b2);  matchWithMatchGuard(b3);  matchWithMatchGuard(b4);  matchWithMatchGuard(b5); }    function basicMatch(any a) {  match a {    This method uses tuple match patterns of different sizes. The match expression a  will be matched against the given pattern list at run time based on the  “is-like” relationship between the expression and a pattern.   var [s, i, b] => {  io:println(\"Matched with three vars : \", io:sprintf(\"%s\", a));  }    This pattern check is for a tuple of three members of any type.   var [s, i] => {  io:println(\"Matched with two vars : \", io:sprintf(\"%s\", a));  }    This pattern check is for a tuple of two members of any type.   var s => {  io:println(\"Matched with single var : \", io:sprintf(\"%s\", a));  }  } }    This pattern check is for a single variable, which can be of type any. This has to be the last pattern.   function matchWithMatchGuard(any b) {  match b {    This method uses structured tuple match patterns with different sizes along with match guards. The given  match expression will be checked for “is-like” relationship and also it will check the match guard for the pattern  to match at runtime.   var [s, i] if (s is string && i is int) => {  io:println(\"'s' is string and 'i' is int : \", io:sprintf(\"%s\", b));  }    This pattern check is for a tuple of two members of the types string and int respectively.   var [s, i] if s is float => {  io:println(\"Only 's' is float : \", io:sprintf(\"%s\", b));  }    This pattern check is for a tuple of two members where the first member is of the type float.   var [s, i] if i is int => {  io:println(\"Only 'i' is int : \", io:sprintf(\"%s\", b));  }    This pattern check is for a tuple of two members where the second member is of the type int.   var [s, i] => {  io:println(\"No type guard : \", io:sprintf(\"%s\", b));  }    This pattern check is for a tuple of two members without any match guard.   var s if s is float => {  io:println(\"'s' is float only : \", io:sprintf(\"%s\", b));  }    This pattern check is for a single variable of the type float.   } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run tuple_match_statement.bal Matched with single var : 66.6 Matched with two vars : Hello 12 Matched with two vars : 4.5 true Matched with three vars : 6.7 Test false 's' is string and 'i' is int : Hello 45 Only 's' is float : 4.5 true Only 'i' is int : false 4 No type guard : 455 true 's' is float only : 5.6"},{"page":"/learn/by-example/type-test-expression.html","name":"Type Test Expression","summary":"The type test expression can be used to assert the runtime type of a value in Ballerina.\n It is an expression that always evaluates to true or false.Checks whether the actual value of the any type variable is a string.The type test can be used as a condition of an ...","content":"/  /  / Type Test Expression  import ballerina/io;public function main() {  any a = \"Hello, world!\";  boolean b = a is string;  io:println(\"Is 'a' a string? \", b);  if (a is int) {  io:println(\"'a' is an int with value: \", a);  } else if (a is string) {  io:println(\"'a' is a string with value: \", a);  } else {  io:println(\"'a' is not an int or string, with value: \", a);  }  Student alex = {name : \"Alex\"};  Student|Person|Vehicle x = alex;  if (x is Student) {  io:println(\"Alex is a student\");  } else {  io:println(\"Alex is not a student\");  }  if (x is Person) {  io:println(\"Alex is a person\");  } else {  io:println(\"Alex is not a person\");  }  if (x is Vehicle) {  io:println(\"Alex is a vehicle\");  } else {  io:println(\"Alex is not a vehicle\");  }  boolean isStudent = foo(\"student\") is Student;  io:println(\"Does foo return a student? \", isStudent);  isStudent = foo(\"vehicle\") is Student;  io:println(\"Does foo return a student? \", isStudent); }type Person record {  string name; };type Student record {  string name;  int age = 0; };type Vehicle record {  string brand; };function foo(string t) returns any {  if (t == \"student\") {  return <Student>{name: \"Alex\"};  } else if (t == \"vehicle\") {  return <Vehicle>{brand: \"Honda\"};  }  return \"invalid type\"; }    Type Test Expression  The type test expression can be used to assert the runtime type of a value in Ballerina.  It is an expression that always evaluates to true or false.    import ballerina/io;    public function main() {  any a = \"Hello, world!\";    boolean b = a is string;  io:println(\"Is 'a' a string? \", b);    Checks whether the actual value of the any type variable is a string.   if (a is int) {  io:println(\"'a' is an int with value: \", a);  } else if (a is string) {  io:println(\"'a' is a string with value: \", a);  } else {  io:println(\"'a' is not an int or string, with value: \", a);  }    The type test can be used as a condition of an if statement.   Student alex = {name : \"Alex\"};  Student|Person|Vehicle x = alex;    The type test can be used to find the runtime type of union type variables.   if (x is Student) {  io:println(\"Alex is a student\");  } else {  io:println(\"Alex is not a student\");  }    Type of x is Student. Therefore, the if check will pass.   if (x is Person) {  io:println(\"Alex is a person\");  } else {  io:println(\"Alex is not a person\");  }    Type of x is Student. However, it is structurally equivalent to Person.  Therefore, the if check will pass.   if (x is Vehicle) {  io:println(\"Alex is a vehicle\");  } else {  io:println(\"Alex is not a vehicle\");  }    Type of x is Student. However, it is not structurally equivalent to Vehicle.   boolean isStudent = foo(\"student\") is Student;  io:println(\"Does foo return a student? \", isStudent);  isStudent = foo(\"vehicle\") is Student;  io:println(\"Does foo return a student? \", isStudent); }    The type test expression can be used with any expression.   type Person record {  string name; };    type Student record {  string name;  int age = 0; };    type Vehicle record {  string brand; };    function foo(string t) returns any {  if (t == \"student\") {  return <Student>{name: \"Alex\"};  } else if (t == \"vehicle\") {  return <Vehicle>{brand: \"Honda\"};  }  return \"invalid type\"; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run type_test_expression.bal Is 'a' a string? true 'a' is a string with value: Hello, world! Alex is a student Alex is a person Alex is not a vehicle Does foo return a student? true Does foo return a student? false"},{"page":"/learn/by-example/type-guard.html","name":"Type Guard","summary":"A type guard (based on the type test) is a construct that allows selective code execution based on\n the type of the expression that is being tested.\n The type of the expression within the type guard (except for global variables) would be a narrowed type based on the\n relevant type ...","content":"/  /  / Type Guard  import ballerina/io;public function main() {  string|int|boolean value = 10;  if (value is string) {  string str = value;  io:println(\"value is a string: \", str);  } else if (value is int) {  io:println(\"value is an int: \", value);  io:println(\"value + 1: \", addOneToInt(value));  value = \"Hello World\";  if (value is int) {  int i = value;  io:println(\"- value is an int: \", i);  } else {  string|boolean sb = value;  io:println(\"- value is string|boolean: \", sb);  }  } else {  if (value) {  io:println(\"s is 'true'\");  }  } } function addOneToInt(int i) returns int {  return i + 1; }    Type Guard  A type guard (based on the type test) is a construct that allows selective code execution based on  the type of the expression that is being tested.  The type of the expression within the type guard (except for global variables) would be a narrowed type based on the  relevant type test.    import ballerina/io;    public function main() {    string|int|boolean value = 10;    The value variable can hold a value of the type string, int or boolean.   if (value is string) {    The type guard can be used with value to test to which of the types it belongs to and perform conditional  logic based on the type which it belongs to.   string str = value;  io:println(\"value is a string: \", str);  } else if (value is int) {    The type of value within this block is narrowed to string, and thus, value can be assigned to a  variable of the type string.   io:println(\"value is an int: \", value);  io:println(\"value + 1: \", addOneToInt(value));    The type of value within this block is narrowed to int, and thus, value can be used in a  context where an int is expected.   value = \"Hello World\";    If the value is updated within a type guard, the type is reset to the original type.   if (value is int) {    The type test needs to be used again since the type of value is reset to string|int|boolean.   int i = value;  io:println(\"- value is an int: \", i);  } else {    value is an int here.   string|boolean sb = value;  io:println(\"- value is string|boolean: \", sb);  }  } else {    value is string or boolean here.   if (value) {  io:println(\"s is 'true'\");  }  } }    Within this block, the type of value is boolean since the previous if and else if blocks handle the  other possible scenarios.   function addOneToInt(int i) returns int {  return i + 1; }    A function that expects an int as an argument.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run type_guard.bal value is an int: 10 value + 1: 11 - value is string|boolean: Hello World"},{"page":"/learn/by-example/udp-socket-client.html","name":"Basic UDP Client Socket","summary":"The UDP Client is used to connect to a remote UDP host.\n This sample demonstrates how to send data to a remote server and print the echoed response.This is the client implementation for the UDP socket.Create a new socket client.\n Optionally, you can provide port that this socket need to ...","content":"/  /  / Basic UDP Client Socket  import ballerina/io; import ballerina/socket;public function main() {  socket:UdpClient socketClient = new;  string msg = \"Hello from UDP client\";  byte[] c1 = msg.toBytes();  var sendResult =  socketClient->sendTo(c1, {host: \"localhost\", port: 48826});  if (sendResult is int) {  io:println(\"Number of bytes written: \", sendResult);  } else {  error e = sendResult;  panic e;  }  var result = socketClient->receiveFrom();  if (result is [byte[], int, socket:Address]) {  var [content, length, address] = result;  var byteChannel = io:createReadableChannel(content);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(60);  if (str is string) {  io:println(\"Received: \", <@untainted>str);  } else {  io:println(\"Error: \", str.detail()?.message);  }  }  } else {  io:println(\"An error occurred while receiving the data \",  result);  }  var closeResult = socketClient->close();  if (closeResult is error) {  io:println(\"An error occurred while closing the connection \",  closeResult);  } }    Basic UDP Client Socket  The UDP Client is used to connect to a remote UDP host.  This sample demonstrates how to send data to a remote server and print the echoed response.    import ballerina/io; import ballerina/socket;    This is the client implementation for the UDP socket.   public function main() {    socket:UdpClient socketClient = new;  string msg = \"Hello from UDP client\";  byte[] c1 = msg.toBytes();    Create a new socket client.  Optionally, you can provide port that this socket need to bind or  both interface and port as follows.  socket:UdpClient client = new(localAddress = { port: 48828 });  socket:UdpClient client = new(localAddress = { host: “localhost”, port: 48828 });   var sendResult =  socketClient->sendTo(c1, {host: \"localhost\", port: 48826});  if (sendResult is int) {  io:println(\"Number of bytes written: \", sendResult);  } else {  error e = sendResult;  panic e;  }    Send data to remote host.  Second parameter is the address of the remote host.   var result = socketClient->receiveFrom();  if (result is [byte[], int, socket:Address]) {  var [content, length, address] = result;  var byteChannel = io:createReadableChannel(content);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(60);  if (str is string) {  io:println(\"Received: \", <@untainted>str);  } else {  io:println(\"Error: \", str.detail()?.message);  }  }  } else {  io:println(\"An error occurred while receiving the data \",  result);  }    Wait until data receive from remote host.  This will block until receive at least a single byte.  Optionally, you can specify the length as below.  socketClient->receiveFrom(length = 30)  This will block until specified length of bytes receive from host.   var closeResult = socketClient->close();  if (closeResult is error) {  io:println(\"An error occurred while closing the connection \",  closeResult);  } }    Close the client and release the bound port.   # To run the client, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run udp_socket_client.bal    # This will print the below output upon a successful write. Number of bytes written: 21 # Print the response that is returned from the server as an echo. Received: Hello from UDP client"},{"page":"/learn/by-example/type-conversion.html","name":"Type Conversion","summary":"The .constructFrom() method creates a new value with a target storage type from a given anydata-typed\n value, and assigns it to a target variable.\n .constructFrom() is defined on all structured types, and returns an error if the operation is unsuccessful.This function attempts to convert an anydata record Employee to an ...","content":"/  /  / Type Conversion  import ballerina/io; import ballerina/lang.'decimal; import ballerina/lang.'float; import ballerina/lang.'int;type Person record {  string name;  int age; };type Employee record {  string name;  int age;  int empNo; }; function convertEmployeeToPerson(Employee emp) {  Person|error res = Person.constructFrom(emp);  if (res is Person) {  io:println(\"Employee to Person, name: \", res[\"name\"]);  } else {  io:println(\"Error occurred on conversion\");  } } function convertAnydataMapToPerson(map<anydata> m) {  Person|error res = Person.constructFrom(m);  if (res is Person) {  io:println(\"map<anydata> to Person, name: \", res[\"name\"]);  } else {  io:println(\"Error occurred on conversion: \", res.detail());  } } function createNumericValues() {  string s1 = \"45\";  string s2 = \"abc\";  string s3 = \"12.3\";  string s4 = \"8\";  int|error res1 = 'int:fromString(s1);  if (res1 is int) {  io:println(\"int value: \", res1);  } else {  io:println(\"error: \", res1.detail());  } res1 = 'int:fromString(s2);  if (res1 is int) {  io:println(\"int value: \", res1);  } else {  io:println(\"error: \", res1.detail());  }  float|error res2 = 'float:fromString(s3);  if (res2 is float) {  io:println(\"float value: \", res2);  } else {  io:println(\"error: \", res2.detail());  }  decimal|error res3 = 'decimal:fromString(s4);  if (res3 is decimal) {  io:println(\"decimal value: \", res3);  } else {  io:println(\"error: \", res3.detail());  } }public function main() {  Employee emp = {name: \"Jack Sparrow\", age: 54, empNo: 100};  convertEmployeeToPerson(emp);  map<anydata> m = {name: \"Hector Barbossa\", age: 54, empNo: 100};  convertAnydataMapToPerson(m);  map<anydata> n = {name: \"Elizabeth Swann\"};  convertAnydataMapToPerson(n);  createNumericValues(); }    Type Conversion  The .constructFrom() method creates a new value with a target storage type from a given anydata-typed  value, and assigns it to a target variable.  .constructFrom() is defined on all structured types, and returns an error if the operation is unsuccessful.    import ballerina/io; import ballerina/lang.'decimal; import ballerina/lang.'float; import ballerina/lang.'int;    type Person record {  string name;  int age; };    type Employee record {  string name;  int age;  int empNo; };    function convertEmployeeToPerson(Employee emp) {    This function attempts to convert an anydata record Employee to an anydata record Person.   Person|error res = Person.constructFrom(emp);  if (res is Person) {    Attempts to create a new value of the type Person from the Employee-typed emp value without changing  the inherent type of emp.   io:println(\"Employee to Person, name: \", res[\"name\"]);  } else {  io:println(\"Error occurred on conversion\");  } }    If the conversion is successful, this prints the name field.   function convertAnydataMapToPerson(map<anydata> m) {    This function attempts to convert an anydata constrained map to an anydata record Person.  The conversion would return an error if an incompatible value is found.   Person|error res = Person.constructFrom(m);  if (res is Person) {    Attempts to create a new value of the type Person from the map<anydata> typed m value without changing  the inherent type of m.   io:println(\"map<anydata> to Person, name: \", res[\"name\"]);  } else {  io:println(\"Error occurred on conversion: \", res.detail());  } }    If the conversion is successful, this prints the name field.   function createNumericValues() {  string s1 = \"45\";  string s2 = \"abc\";  string s3 = \"12.3\";  string s4 = \"8\";    This function creates numeric values from string values.   int|error res1 = 'int:fromString(s1);  if (res1 is int) {  io:println(\"int value: \", res1);  } else {  io:println(\"error: \", res1.detail());  }    The fromString() method in the ballerina/lang.int module returns the integer value represented by a  given string if there is a valid representation, else returns an error.   res1 = 'int:fromString(s2);  if (res1 is int) {  io:println(\"int value: \", res1);  } else {  io:println(\"error: \", res1.detail());  }    float|error res2 = 'float:fromString(s3);  if (res2 is float) {  io:println(\"float value: \", res2);  } else {  io:println(\"error: \", res2.detail());  }    The fromString() method in the ballerina/lang.float module returns the float value represented by a given  string if there is a valid representation, else returns an error.   decimal|error res3 = 'decimal:fromString(s4);  if (res3 is decimal) {  io:println(\"decimal value: \", res3);  } else {  io:println(\"error: \", res3.detail());  } }    The fromString() method in the ballerina/lang.decimal module returns the decimal value represented by a given  string if there is a valid representation, else returns an error.   public function main() {    Employee emp = {name: \"Jack Sparrow\", age: 54, empNo: 100};  convertEmployeeToPerson(emp);    Attempts to convert an anydata-typed record to another anydata-typed record.   map<anydata> m = {name: \"Hector Barbossa\", age: 54, empNo: 100};  convertAnydataMapToPerson(m);    Attempts to convert an anydata constrained map to an anydata-typed record.  This conversion would be successful since all the expected elements are present.   map<anydata> n = {name: \"Elizabeth Swann\"};  convertAnydataMapToPerson(n);    This conversion would not be successful since all the required elements are not  present in the map.   createNumericValues(); }    Attempts to convert strings to numeric types.   # To run the program, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run type_conversion.bal Employee to Person, name: Jack Sparrow map<anydata> to Person, name: Hector Barbossa Error occurred on conversion: message='map<anydata>' value cannot be converted to 'Person' int value: 45 error: message='string' value 'abc' cannot be converted to 'int' float value: 12.3 decimal value: 8"},{"page":"/learn/by-example/union-type.html","name":"Union Types","summary":"Union types are types of which, the set of values is the union of the value spaces of its component types.\n For example, you can use a variable of a union type to store a string or an int,\n but there is only one type of value at any given ...","content":"/  /  / Union Types  import ballerina/io; function println(string|int value) {  io:println(value); } function getValue(string key) returns string|error {  if (key == \"\") {  error err = error(\"key '\" + key + \"' not found\");  return err;  } else {  return \"this is a value\";  } }public function main() {  println(\"This is a string\");  println(101);  string|error valueOrError1 = getValue(\"name\");  io:println(valueOrError1);  string|error valueOrError2 = getValue(\"\");  io:println(valueOrError2); }    Union Types  Union types are types of which, the set of values is the union of the value spaces of its component types.  For example, you can use a variable of a union type to store a string or an int,  but there is only one type of value at any given time.  Syntactically, you can define a union type with component types separated by a “|” (i.e., a vertical bar).    import ballerina/io;    function println(string|int value) {  io:println(value); }    This function expects the value parameter to be either a string or an int.   function getValue(string key) returns string|error {  if (key == \"\") {  error err = error(\"key '\" + key + \"' not found\");  return err;  } else {  return \"this is a value\";  } }    This function returns either a string or an error.   public function main() {    println(\"This is a string\");    This passes a string value.   println(101);    This passes an int value.   string|error valueOrError1 = getValue(\"name\");  io:println(valueOrError1);    This function call returns a string value.   string|error valueOrError2 = getValue(\"\");  io:println(valueOrError2); }    This call returns an error.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run union_type.bal This is a string 101 this is a value error key '' not found"},{"page":"/learn/by-example/user-defined-error.html","name":"User-defined Error Types","summary":"Ballerina allows defining custom error types to match\n the errors being modeled. User defined error types in Ballerina should have\n a reason type which is a subtype of string, and a detail type which\n is a subtype of\n record {| string message?; error cause?; (anydata|error)...; |}.The nature of the default ...","content":"/  /  / User-defined Error Types  import ballerina/io;const INVALID_ACC_TYPE = \"InvalidAccountType\"; type InvalidAccountTypeErrorData record {  string message?;  error cause?;  string accountType; }; type InvalidAccountTypeError error<INVALID_ACC_TYPE, InvalidAccountTypeErrorData>;function getTypeId(string accountType) returns int|InvalidAccountTypeError {  match accountType {  \"checking\" => { return 1; }  \"savings\" => { return 2; }  }  InvalidAccountTypeError e = InvalidAccountTypeError(accountType = accountType);  return e; }type AccountNotFoundErrorData record {  string message?;  error cause?;  int accountID; };const INVALID_ACCOUNT_ID = \"InvalidAccountID\"; const ACCOUNT_NOT_FOUND = \"AccountNotFound\"; type AccountNotFoundError error<ACCOUNT_NOT_FOUND|INVALID_ACCOUNT_ID, AccountNotFoundErrorData>;function getAccountBalance(int accountID) returns int|AccountNotFoundError {  if (accountID < 0) {  AccountNotFoundError accountNotFoundError =  error(INVALID_ACCOUNT_ID, accountID = accountID);  return accountNotFoundError;  } else if (accountID > 100) {  AccountNotFoundError accountNotFoundError =  error(ACCOUNT_NOT_FOUND, accountID = accountID);  return accountNotFoundError;  }  return 600; } type InquiryFailedErrorData record {|  string message;  error cause;  int accountID; |};type AccountInquiryFailed error<string, InquiryFailedErrorData>;function transferToAccount(int fromAccountId, int toAccountId, int amount) returns int|AccountInquiryFailed {  var balance = getAccountBalance(fromAccountId);  if (balance is error) {  AccountInquiryFailed e = error(\"AccountInquiryFailed\", message = balance.reason(), cause = balance, accountID = fromAccountId);  return e;  } else {  } return 0; }public function main() {  int|InvalidAccountTypeError result = getTypeId(\"Joined\");  if (result is int) {  io:println(\"Account type ID: \", result);  } else {  io:println(\"Error: \", result.reason(),  \", Account type: \", result.detail().accountType);  } var result2 = getAccountBalance(-1);  if (result2 is int) {  io:println(\"Account Balance: \", result2);  } else {  io:println(\"Error: \", result2.reason(),  \", Account ID: \", result2.detail().accountID);  } var result3 = transferToAccount(-1, 90, 1000);  if (result3 is int) {  io:println(\"Transfer success: \", result3);  } else {  io:println(\"Error: \", result3.reason(),  \", Message: \", result3.detail().message,  \", Cause: \", result3.detail().cause);  } }    User-defined Error Types  Ballerina allows defining custom error types to match  the errors being modeled. User defined error types in Ballerina should have  a reason type which is a subtype of string, and a detail type which  is a subtype of  record {| string message?; error cause?; (anydata|error)...; |}.  The nature of the default error detail record is that each field is optional  and can contain additional anydata|error fields as required.    import ballerina/io;    const INVALID_ACC_TYPE = \"InvalidAccountType\";    type InvalidAccountTypeErrorData record {  string message?;  error cause?;  string accountType; };    Define a record to represent the error details.  This record can have fields of anydata|error types and should be a subtype of the built-in error’s detail type.   type InvalidAccountTypeError error<INVALID_ACC_TYPE, InvalidAccountTypeErrorData>;    User-defined error with a constant reason.   function getTypeId(string accountType) returns int|InvalidAccountTypeError {  match accountType {  \"checking\" => { return 1; }  \"savings\" => { return 2; }  }    InvalidAccountTypeError e = InvalidAccountTypeError(accountType = accountType);  return e; }    When a constant reason is used in the error definition the error type name can be used as the error constructor,  and the error details can be provided as named arguments, without specifying the reason.   type AccountNotFoundErrorData record {  string message?;  error cause?;  int accountID; };    const INVALID_ACCOUNT_ID = \"InvalidAccountID\"; const ACCOUNT_NOT_FOUND = \"AccountNotFound\";    type AccountNotFoundError error<ACCOUNT_NOT_FOUND|INVALID_ACCOUNT_ID, AccountNotFoundErrorData>;    Define an error type where error reason must be either ACCOUNT_NOT_FOUND or INVALID_ACCOUNT_ID.   function getAccountBalance(int accountID) returns int|AccountNotFoundError {  if (accountID < 0) {    AccountNotFoundError accountNotFoundError =  error(INVALID_ACCOUNT_ID, accountID = accountID);  return accountNotFoundError;  } else if (accountID > 100) {    Return an error with “InvalidAccountID” as the reason if the accountID is less than zero.  The default error constructor can be used to construct the error value.   AccountNotFoundError accountNotFoundError =  error(ACCOUNT_NOT_FOUND, accountID = accountID);  return accountNotFoundError;  }    Return an error with “AccountNotFound” as the reason if the accountID is greater than hundred.   return 600; }    Return a value if the accountID is in between zero and hundred inclusive.   type InquiryFailedErrorData record {|  string message;  error cause;  int accountID; |};    Error detail type where message and cause are mandatory.   type AccountInquiryFailed error<string, InquiryFailedErrorData>;    function transferToAccount(int fromAccountId, int toAccountId, int amount) returns int|AccountInquiryFailed {  var balance = getAccountBalance(fromAccountId);  if (balance is error) {    AccountInquiryFailed e = error(\"AccountInquiryFailed\", message = balance.reason(), cause = balance, accountID = fromAccountId);  return e;  } else {    Create a new error, with the error returned from getAccountBalance() as the cause.   }    Perform transfer   return 0; }    public function main() {  int|InvalidAccountTypeError result = getTypeId(\"Joined\");  if (result is int) {  io:println(\"Account type ID: \", result);  } else {  io:println(\"Error: \", result.reason(),  \", Account type: \", result.detail().accountType);  }    var result2 = getAccountBalance(-1);    if (result2 is int) {  io:println(\"Account Balance: \", result2);    If the result is an int, then print the value.   } else {  io:println(\"Error: \", result2.reason(),  \", Account ID: \", result2.detail().accountID);  }    If an error is returned, print the reason and the account ID from the detail record.   var result3 = transferToAccount(-1, 90, 1000);  if (result3 is int) {  io:println(\"Transfer success: \", result3);  } else {    io:println(\"Error: \", result3.reason(),  \", Message: \", result3.detail().message,  \", Cause: \", result3.detail().cause);  } }    Print the mandatory error detail fields message and cause.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run user_defined_error.bal Error: InvalidAccountType, Account type: Joined Error: InvalidAccountID, Account ID: -1 Error: AccountInquiryFailed, Message: InvalidAccountID, Cause: error InvalidAccountID accountID=-1"},{"page":"/learn/by-example/url-encode-decode.html","name":"URL Encode/Decode Operations","summary":"Ballerina encoding API supports encoding/decoding content using different URL encoding mechanisms and algorithms.Encoding a URL into a Base64-encoded string.Decoding a Base64 URL encoded string into a byte array.Encoding a URI component into a string.Decoding an encoded URI component into a string. ...","content":"/  /  / URL Encode/Decode Operations  import ballerina/encoding; import ballerina/io; import ballerina/lang.'string as str;public function main() returns error? {  string encodingValue = \"abc123!?$*&()'-=@~\";  string urlEncodedValue = encoding:encodeBase64Url(encodingValue.toBytes());  io:println(\"Base64 URL encoded value: \" + urlEncodedValue); string decodingValue = \"YWJjMTIzIT8kKiYoKSctPUB-\";  byte[] urlDecodedValue = check encoding:decodeBase64Url(decodingValue);  io:println(\"Base64 URL decoded value: \" + check str:fromBytes(urlDecodedValue)); string encodingUriComp = \"data=value\";  string encodedUriComponent = check encoding:encodeUriComponent(encodingUriComp, \"UTF-8\");  io:println(\"URI encoded value: \" + encodedUriComponent); string data = \"data%3Dvalue\";  string decodedUriComponent = check encoding:decodeUriComponent(data, \"UTF-8\");  io:println(\"URI decoded value: \" + decodedUriComponent); }    URL Encode/Decode Operations  Ballerina encoding API supports encoding/decoding content using different URL encoding mechanisms and algorithms.    import ballerina/encoding; import ballerina/io; import ballerina/lang.'string as str;    public function main() returns error? {  string encodingValue = \"abc123!?$*&()'-=@~\";    string urlEncodedValue = encoding:encodeBase64Url(encodingValue.toBytes());  io:println(\"Base64 URL encoded value: \" + urlEncodedValue);    Encoding a URL into a Base64-encoded string.   string decodingValue = \"YWJjMTIzIT8kKiYoKSctPUB-\";    byte[] urlDecodedValue = check encoding:decodeBase64Url(decodingValue);  io:println(\"Base64 URL decoded value: \" + check str:fromBytes(urlDecodedValue));    Decoding a Base64 URL encoded string into a byte array.   string encodingUriComp = \"data=value\";    string encodedUriComponent = check encoding:encodeUriComponent(encodingUriComp, \"UTF-8\");  io:println(\"URI encoded value: \" + encodedUriComponent);    Encoding a URI component into a string.   string data = \"data%3Dvalue\";    string decodedUriComponent = check encoding:decodeUriComponent(data, \"UTF-8\");  io:println(\"URI decoded value: \" + decodedUriComponent); }    Decoding an encoded URI component into a string.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run url_encode_decode.bal Base64 URL encoded value: YWJjMTIzIT8kKiYoKSctPUB- Base64 URL decoded value: abc123!?$*&()'-=@~ URI encoded value: data%3Dvalue URI decoded value: data=value"},{"page":"/learn/by-example/values.html","name":"Values","summary":"Ballerina programs operate on a universe of values and each value belongs to only one basic type\n such as int, boolean, map, record, function etc. There are three kinds of values\n corresponding to three kinds of basic types. They are simple values (e.g., int, string, boolean),\n structured values (e.g., record, ...","content":"/  /  / Values  import ballerina/io; import ballerina/lang.'float; import ballerina/lang.'int; public function main() {  int i = 10;  io:println(i);  int|error i2 = 'int:fromString(\"100\");  if (i2 is int) {  io:println(i2);  }  float f = 20.0;  io:println(f);  float f1 = 'float:fromBitsInt(i);  float f2 = 22.0;  float max = 'float:max(f1, f2);  io:println(\"Max float: \", max);  float nanVal = 0.0 / 0.0;  io:println(nanVal.isNaN());  float infiniteVal = 12.0 / 0.0;  io:println(infiniteVal.isInfinite());  float finiteVal = 6.0 / 3.0;  io:println(finiteVal.isFinite());  decimal d = 27.5;  io:println(d);  byte c = 23;  io:println(c);  string s = \"Ballerina\";  io:println(s);  boolean b = true;  io:println(b);  () n = ();  io:println(n);  json j = null;  io:println(j); }    Values  Ballerina programs operate on a universe of values and each value belongs to only one basic type  such as int, boolean, map, record, function etc. There are three kinds of values  corresponding to three kinds of basic types. They are simple values (e.g., int, string, boolean),  structured values (e.g., record, map, array), and behavioral values (e.g., function, object).  Simple values belong to one of the simple basic types, namely nil, boolean, int, float, decimal, and  string.    import ballerina/io; import ballerina/lang.'float; import ballerina/lang.'int;    public function main() {    The types int, float, decimal, string, boolean, byte, and nil are called simple basic types  because they are basic types with only simple values. Simple values are always immutable.   int i = 10;  io:println(i);    The int type represents the set of 64-bit signed integers.   int|error i2 = 'int:fromString(\"100\");  if (i2 is int) {  io:println(i2);  }    The ballerina/lang.int module contains common functions that can be used  with int values.   float f = 20.0;  io:println(f);    The float type represents the set of double precision IEEE 754 floating point numbers.   float f1 = 'float:fromBitsInt(i);  float f2 = 22.0;  float max = 'float:max(f1, f2);  io:println(\"Max float: \", max);    The ballerina/lang.float module contains common functions that can be used with float values.   float nanVal = 0.0 / 0.0;  io:println(nanVal.isNaN());    The .isNaN(), .isInfinite(), and .isFinite() langlib functions are supported by the float type.  The .isNaN() function will return true if the float value is neither finite nor infinite.   float infiniteVal = 12.0 / 0.0;  io:println(infiniteVal.isInfinite());    The .isInfinite() function will return true if the float value is neither NaN nor finite.   float finiteVal = 6.0 / 3.0;  io:println(finiteVal.isFinite());    The .isFinite() function will return true if the float value is neither NaN nor infinite.   decimal d = 27.5;  io:println(d);    The decimal type represents the set of 128-bits IEEE 754R decimal floating point numbers.   byte c = 23;  io:println(c);    The byte type represents the set of 8-bit unsigned integers.   string s = \"Ballerina\";  io:println(s);    The string type represents the set of sequences of Unicode code points.   boolean b = true;  io:println(b);    The boolean type has only two values: true and false.   () n = ();  io:println(n);    The nil type has a single value and is used to represent the absence of any other value.  Both the nil type and the nil value are written as ().   json j = null;  io:println(j); }    Another representation for the nil value is the null literal.  However, the use of the null literal in only allowed in JSON contexts.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run values.bal 10 100 20.0 Max float: 22.0 true true true 27.5 23 Ballerina true"},{"page":"/learn/by-example/var.html","name":"Var","summary":"Ballerina allows you to declare variables using the var keyword instead of specifying a type.\n The type of the declared variable is inferred from the expression on the right-hand side.The variable type is inferred from the expression on the right-hand side.\n This is the same as int k = 5;The ...","content":"/  /  / Var  import ballerina/io;public function main() {  var k = 5;  io:println(10 + k);  var strVar = \"Hello!\";  io:println(strVar); }    Var  Ballerina allows you to declare variables using the var keyword instead of specifying a type.  The type of the declared variable is inferred from the expression on the right-hand side.    import ballerina/io;    public function main() {    var k = 5;  io:println(10 + k);    The variable type is inferred from the expression on the right-hand side.  This is the same as int k = 5;   var strVar = \"Hello!\";  io:println(strVar); }    The type of strVar is string.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run var.bal 15 Hello!"},{"page":"/learn/by-example/variables.html","name":"Variables","summary":"Ballerina provides you with two ways to declare variables.\n You can either use the var keyword followed by the variable name and an initializer expression or use a\n type name followed by the variable name in which you can optionally specify the initializer expression.Declare a module-level variable.Declare a constant.Declare a ...","content":"/  /  / Variables  import ballerina/io; int total = 99; const string OK = \"ok\"; public const int COUNT = 1; final int status = 1;public function main() {  io:println(total);  io:println(COUNT);  boolean available = false;  io:println(available); }    Variables  Ballerina provides you with two ways to declare variables.  You can either use the var keyword followed by the variable name and an initializer expression or use a  type name followed by the variable name in which you can optionally specify the initializer expression.    import ballerina/io;    int total = 99;    Declare a module-level variable.   const string OK = \"ok\";    Declare a constant.   public const int COUNT = 1;    Declare a public constant.   final int status = 1;    Declare a final variable.  The value of the final variable is read-only. Once a value is assigned to a final  variable, it becomes immutable. All parameters of a function call are  implicitly final.   public function main() {    io:println(total);    Access a global variable.   io:println(COUNT);    Access a public constant.   boolean available = false;  io:println(available); }    This is a local variable.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run variables.bal 99 1 false"},{"page":"/learn/by-example/websocket-basic-sample.html","name":"Basic Server Functionalities","summary":"This example explains the basic functions of a WebSocket server endpoint.This resource is triggered after a successful client connection.This resource is triggered when a new text frame is received from a client.This resource is triggered when a new binary frame is received from a client.This resource is triggered when a ...","content":"/  /  / Basic Server Functionalities  import ballerina/http; import ballerina/io; import ballerina/log;string ping = \"ping\"; byte[] pingData = ping.toBytes();@http:WebSocketServiceConfig {  path: \"/basic/ws\",  subProtocols: [\"xml\", \"json\"],  idleTimeoutInSeconds: 120 } service basic on new http:Listener(9090) {  resource function onOpen(http:WebSocketCaller caller) {  io:println(\"\\nNew client connected\");  io:println(\"Connection ID: \" + caller.getConnectionId());  io:println(\"Negotiated Sub protocol: \" + caller.getNegotiatedSubProtocol().toString());  io:println(\"Is connection open: \" + caller.isOpen().toString());  io:println(\"Is connection secured: \" + caller.isSecure().toString());  }  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {  io:println(\"\\ntext message: \" + text + \" & final fragment: \"  + finalFrame.toString());  if (text == \"ping\") {  io:println(\"Pinging...\");  var err = caller->ping(pingData);  if (err is http:WebSocketError) {  log:printError(\"Error sending ping\", err);  }  } else if (text == \"closeMe\") {  error? result = caller->close(statusCode = 1001,  reason = \"You asked me to close the connection\",  timeoutInSeconds = 0);  if (result is http:WebSocketError) {  log:printError(\"Error occurred when closing connection\", result);  }  } else {  var err = caller->pushText(\"You said: \" + text);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text\", err);  }  }  }  resource function onBinary(http:WebSocketCaller caller, byte[] b) {  io:println(\"\\nNew binary message received\");  io:print(\"UTF-8 decoded binary message: \");  io:println(b);  var err = caller->pushBinary(b);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary\", err);  }  }  resource function onPing(http:WebSocketCaller caller, byte[] data) {  var err = caller->pong(data);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  }  resource function onPong(http:WebSocketCaller caller, byte[] data) {  io:println(\"Pong received\");  }  resource function onIdleTimeout(http:WebSocketCaller caller) {  io:println(\"\\nReached idle timeout\");  io:println(\"Closing connection \" + caller.getConnectionId());  var err = caller->close(statusCode = 1001, reason =  \"Connection timeout\");  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  }  resource function onError(http:WebSocketCaller caller, error err) {  log:printError(\"Error occurred \", err);  }  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {  io:println(string `Client left with ${statusCode} because ${reason}`);  } }    Basic Server Functionalities  This example explains the basic functions of a WebSocket server endpoint.    import ballerina/http; import ballerina/io; import ballerina/log;    string ping = \"ping\"; byte[] pingData = ping.toBytes();    @http:WebSocketServiceConfig {  path: \"/basic/ws\",  subProtocols: [\"xml\", \"json\"],  idleTimeoutInSeconds: 120 } service basic on new http:Listener(9090) {    resource function onOpen(http:WebSocketCaller caller) {  io:println(\"\\nNew client connected\");  io:println(\"Connection ID: \" + caller.getConnectionId());  io:println(\"Negotiated Sub protocol: \" + caller.getNegotiatedSubProtocol().toString());  io:println(\"Is connection open: \" + caller.isOpen().toString());  io:println(\"Is connection secured: \" + caller.isSecure().toString());  }    This resource is triggered after a successful client connection.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {  io:println(\"\\ntext message: \" + text + \" & final fragment: \"  + finalFrame.toString());  if (text == \"ping\") {  io:println(\"Pinging...\");  var err = caller->ping(pingData);  if (err is http:WebSocketError) {  log:printError(\"Error sending ping\", err);  }  } else if (text == \"closeMe\") {  error? result = caller->close(statusCode = 1001,  reason = \"You asked me to close the connection\",  timeoutInSeconds = 0);  if (result is http:WebSocketError) {  log:printError(\"Error occurred when closing connection\", result);  }  } else {  var err = caller->pushText(\"You said: \" + text);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text\", err);  }  }  }    This resource is triggered when a new text frame is received from a client.   resource function onBinary(http:WebSocketCaller caller, byte[] b) {  io:println(\"\\nNew binary message received\");  io:print(\"UTF-8 decoded binary message: \");  io:println(b);  var err = caller->pushBinary(b);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary\", err);  }  }    This resource is triggered when a new binary frame is received from a client.   resource function onPing(http:WebSocketCaller caller, byte[] data) {  var err = caller->pong(data);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  }    This resource is triggered when a ping message is received from the client. If this resource is not implemented,  a pong message is automatically sent to the connected http:WebSocketCaller when a ping is received.   resource function onPong(http:WebSocketCaller caller, byte[] data) {  io:println(\"Pong received\");  }    This resource is triggered when a pong message is received.   resource function onIdleTimeout(http:WebSocketCaller caller) {  io:println(\"\\nReached idle timeout\");  io:println(\"Closing connection \" + caller.getConnectionId());  var err = caller->close(statusCode = 1001, reason =  \"Connection timeout\");  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  }    This resource is triggered when a particular client reaches the idle timeout that is defined in the  http:WebSocketServiceConfig annotation.   resource function onError(http:WebSocketCaller caller, error err) {  log:printError(\"Error occurred \", err);  }    This resource is triggered when an error occurred in the connection or the transport.  This resource is always followed by a connection closure with an appropriate WebSocket close frame  and this is used only to indicate the error to the user and take post decisions if needed.   resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {  io:println(string `Client left with ${statusCode} because ${reason}`);  } }    This resource is triggered when a client connection is closed from the client side.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run websocket_basic_sample.bal    # To check the sample, use a Chrome or Firefox JavaScript console and run the following commands. <br> # Change `xml` to another sub protocol to observe the behavior of the WebSocket server. $ var ws = new WebSocket(\"ws://localhost:9090/basic/ws\", \"xml\", \"my-protocol\");    $ ws.onmessage = function(frame) {console.log(frame.data)}; $ ws.onclose = function(frame) {console.log(frame)};    # Send a message. $ ws.send(\"hello world\");    # Use an advanced client to check the ping and pong since the browser client does not have the capability to send pings. # Use the following command to observe the behavior when the server sends a ping message to the browser client. $ ws.send(\"ping\");    # Close the connection. $ ws.close(1000, \"I want to go\");    # Close the connection from the server side. $ ws.send(\"closeMe\");    # Wait for 120 seconds to check the connection closure due to the connection timeout # or change the timeout in the configuration annotation."},{"page":"/learn/by-example/websocket-chat-application.html","name":"Chat Application","summary":"This example explains how to write a simple chat application using Ballerina.Upgrade from HTTP to WebSocket and define the service the WebSocket client needs to connect to.Retrieve query parameters from the http:Request.Cancel the handshake by sending a 400 status code if the age parameter is missing in the request.The attributes ...","content":"/  /  / Chat Application  import ballerina/http; import ballerina/log;final string NAME = \"NAME\"; final string AGE = \"AGE\";@http:ServiceConfig {  basePath: \"/chat\" } service chatAppUpgrader on new http:Listener(9090) {  @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/{name}\",  upgradeService: chatApp  }  }  resource function upgrader(http:Caller caller, http:Request req,  string name) {  map<string[]> queryParams = req.getQueryParams();  if (!queryParams.hasKey(\"age\")) {  var err = caller->cancelWebSocketUpgrade(400, \"Age is required\");  if (err is http:WebSocketError) {  log:printError(\"Error cancelling handshake\", err);  }  return;  }  map<string> headers = {};  http:WebSocketCaller|http:WebSocketError wsEp = caller->acceptWebSocketUpgrade(headers);  if (wsEp is http:WebSocketCaller) {  wsEp.setAttribute(NAME, name);  string? ageValue = req.getQueryParamValue(\"age\");  string age = ageValue is string ? ageValue : \"\";  wsEp.setAttribute(AGE, age);  string msg =  \"Hi \" + name + \"! You have successfully connected to the chat\";  var err = wsEp->pushText(msg);  if (err is http:WebSocketError) {  log:printError(\"Error sending message\", err);  }  } else {  log:printError(\"Error during WebSocket upgrade\", wsEp);  }  } } map<http:WebSocketCaller> connectionsMap = {};service chatApp = @http:WebSocketServiceConfig {} service {  resource function onOpen(http:WebSocketCaller caller) {  string msg;  msg = getAttributeStr(caller, NAME) + \" with age \"  + getAttributeStr(caller, AGE) + \" connected to chat\";  broadcast(msg);  connectionsMap[caller.getConnectionId()] = <@untainted>caller;  }  resource function onText(http:WebSocketCaller caller, string text) {  string msg = getAttributeStr(caller, NAME) + \": \" + text;  log:printInfo(msg);  broadcast(msg);  }  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {  _ = connectionsMap.remove(caller.getConnectionId());  string msg = getAttributeStr(caller, NAME) + \" left the chat\";  broadcast(msg);  } }; function broadcast(string text) {  foreach var con in connectionsMap {  var err = con->pushText(text);  if (err is http:WebSocketError) {  log:printError(\"Error sending message\", err);  }  } }function getAttributeStr(http:WebSocketCaller ep, string key) returns (string) {  var name = ep.getAttribute(key);  return name.toString(); }    Chat Application  This example explains how to write a simple chat application using Ballerina.    import ballerina/http; import ballerina/log;    final string NAME = \"NAME\"; final string AGE = \"AGE\";    @http:ServiceConfig {  basePath: \"/chat\" } service chatAppUpgrader on new http:Listener(9090) {    @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/{name}\",  upgradeService: chatApp  }  }  resource function upgrader(http:Caller caller, http:Request req,  string name) {    Upgrade from HTTP to WebSocket and define the service the WebSocket client needs to connect to.   map<string[]> queryParams = req.getQueryParams();    Retrieve query parameters from the http:Request.   if (!queryParams.hasKey(\"age\")) {  var err = caller->cancelWebSocketUpgrade(400, \"Age is required\");  if (err is http:WebSocketError) {  log:printError(\"Error cancelling handshake\", err);  }  return;  }  map<string> headers = {};  http:WebSocketCaller|http:WebSocketError wsEp = caller->acceptWebSocketUpgrade(headers);  if (wsEp is http:WebSocketCaller) {    Cancel the handshake by sending a 400 status code if the age parameter is missing in the request.   wsEp.setAttribute(NAME, name);  string? ageValue = req.getQueryParamValue(\"age\");  string age = ageValue is string ? ageValue : \"\";  wsEp.setAttribute(AGE, age);  string msg =  \"Hi \" + name + \"! You have successfully connected to the chat\";  var err = wsEp->pushText(msg);  if (err is http:WebSocketError) {  log:printError(\"Error sending message\", err);  }  } else {  log:printError(\"Error during WebSocket upgrade\", wsEp);  }  } }    The attributes of the caller is useful for storing connection-specific data.  In this case, the NAMEand AGE are unique to each connection.   map<http:WebSocketCaller> connectionsMap = {};    Stores the connection IDs of users who join the chat.   service chatApp = @http:WebSocketServiceConfig {} service {    resource function onOpen(http:WebSocketCaller caller) {  string msg;  msg = getAttributeStr(caller, NAME) + \" with age \"  + getAttributeStr(caller, AGE) + \" connected to chat\";  broadcast(msg);  connectionsMap[caller.getConnectionId()] = <@untainted>caller;  }    Once a user connects to the chat, store the attributes of the user, such as username and age, and  broadcast that the user has joined the chat.   resource function onText(http:WebSocketCaller caller, string text) {  string msg = getAttributeStr(caller, NAME) + \": \" + text;  log:printInfo(msg);  broadcast(msg);  }    Broadcast the messages sent by a user.   resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {  _ = connectionsMap.remove(caller.getConnectionId());  string msg = getAttributeStr(caller, NAME) + \" left the chat\";  broadcast(msg);  } };    Broadcast that a user has left the chat once a user leaves the chat.   function broadcast(string text) {  foreach var con in connectionsMap {  var err = con->pushText(text);  if (err is http:WebSocketError) {  log:printError(\"Error sending message\", err);  }  } }    Function to perform the broadcasting of text messages.   function getAttributeStr(http:WebSocketCaller ep, string key) returns (string) {  var name = ep.getAttribute(key);  return name.toString(); }    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run websocket_chat_application.bal    # To check the sample, use the Chrome or Firefox JavaScript console and run the following commands. <br> # Run the first 3 lines of the following code in two or more different consoles and see how the messages are received. # Change the names and/or age in the `/chat/fistName?age` URI so that they are different for each client. $ var ws = new WebSocket(\"ws://localhost:9090/chat/bruce?age=30\"); $ ws.onmessage = function(frame) {console.log(frame.data)}; $ ws.onclose = function(frame) {console.log(frame)};    # Send messages. $ ws.send(\"hello world\");"},{"page":"/learn/by-example/websocket-failover.html","name":"Failover","summary":"Ballerina users can configure multiple backends in a given failover config. If the client looses the connection by the server being shut down or by getting any IOExceptions, Ballerina automatically tries to connect with the remaining backends that are specified in the configuration. The trying happens only once for each ...","content":"/  /  / Failover  import ballerina/http; import ballerina/log;final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";@http:WebSocketServiceConfig {  path: \"/failover/ws\" } service failoverProxyService on new http:Listener(9090) {  resource function onOpen(http:WebSocketCaller caller) {  http:WebSocketFailoverClient wsClientEp = new (  {  callbackService: failoverClientService,  targetUrls: [ \"ws://localhost:9095/failover/ws\",  \"ws://localhost:9096/failover/ws\", \"ws://localhost:9094/failover/ws\"],  failoverIntervalInMillis: 2000,  readyOnConnect: false  });  wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);  var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) { http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }  resource function onError(http:WebSocketCaller caller, error err) { http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  log:printError(\"Unexpected error hence closing the connection\", err);  }  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) { http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } } service failoverClientService = @http:WebSocketServiceConfig {} service {  resource function onText(http:WebSocketFailoverClient caller, string text,  boolean finalFrame) { http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }  resource function onError(http:WebSocketFailoverClient caller, error err) { http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  log:printError(\"Unexpected error hense closing the connection\", err);  }  resource function onClose(http:WebSocketFailoverClient caller, int statusCode,  string reason) { http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } }; function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketFailoverClient) {  http:WebSocketFailoverClient wsClient = <http:WebSocketFailoverClient>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsClient; } function getAssociatedServerEndpoint(http:WebSocketFailoverClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint =<http:WebSocketCaller>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }# To start the services, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command.import ballerina/http; import ballerina/log;@http:WebSocketServiceConfig {  path: \"/failover/ws\" } service server on new http:Listener(9094) {  resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connects wih the server 9094. The Connection ID: \"  + caller.getConnectionId());  }  resource function onText(http:WebSocketCaller caller, string text, boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }import ballerina/http; import ballerina/log;@http:WebSocketServiceConfig {  path: \"/failover/ws\" } service server on new http:Listener(9095) {  resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connects wih the server 9095. The Connection ID: \"  + caller.getConnectionId());  }  resource function onText(http:WebSocketCaller caller, string text, boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    Failover  Ballerina users can configure multiple backends in a given failover config. If the client looses the connection by the server being shut down or by getting any IOExceptions, Ballerina automatically tries to connect with the remaining backends that are specified in the configuration. The trying happens only once for each of the backends.    import ballerina/http; import ballerina/log;    final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";    @http:WebSocketServiceConfig {  path: \"/failover/ws\" } service failoverProxyService on new http:Listener(9090) {    resource function onOpen(http:WebSocketCaller caller) {    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until  the execution of the onOpen resource finishes,  operations, which should happen before reading messages should be done  in the onOpen resource.   http:WebSocketFailoverClient wsClientEp = new (  {  callbackService: failoverClientService,    Defines the webSocket failover client.   targetUrls: [ \"ws://localhost:9095/failover/ws\",  \"ws://localhost:9096/failover/ws\", \"ws://localhost:9094/failover/ws\"],    Defines a set of targets.   failoverIntervalInMillis: 2000,    Failover interval in milliseconds.   readyOnConnect: false  });    When creating the client endpoint, if the readyOnConnect flag is set to  false the client endpoint does not start reading frames automatically.   wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);    Associate connections before starting to read messages.   var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }    Once the client is ready to receive frames the remote ready function  of the client needs to be called separately.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from a client.   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onError(http:WebSocketCaller caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  log:printError(\"Unexpected error hence closing the connection\", err);  }    resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed from the client side.   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } }    service failoverClientService = @http:WebSocketServiceConfig {} service {    Client service to receive frames from the remote server.   resource function onText(http:WebSocketFailoverClient caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from the remote backend.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onError(http:WebSocketFailoverClient caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  log:printError(\"Unexpected error hense closing the connection\", err);  }    resource function onClose(http:WebSocketFailoverClient caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed by  the remote backend.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } };    function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketFailoverClient) {  http:WebSocketFailoverClient wsClient = <http:WebSocketFailoverClient>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }    Function to retrieve the associated client for a particular caller.   function getAssociatedServerEndpoint(http:WebSocketFailoverClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint =<http:WebSocketCaller>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }    Function to retrieve the associated caller for a client.   # To start the services, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command.    $ ballerina run websocket_service_9095.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9095    $ ballerina run websocket_service_9094.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9094    $ ballerina run websocket_failover.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Now, this service can be invoked by any WebSocket client using the following URL: \"ws://localhost:9090/failover/ws\"    # To check the sample, you can use Chrome or the Firefox JavaScript console and run the following commands. <br> $ var ws = new WebSocket(\"ws://localhost:9090/failover/ws\"); $ ws.onmessage = function(frame) {console.log(frame.data)};    # Send messages. $ ws.send(\"hello world\");    # To stop the running service, press Ctrl + C.    # Send messages. $ ws.send(\"hello world\");    # Close the connection. $ ws.close(1000, \"I want to go\");    import ballerina/http; import ballerina/log;    @http:WebSocketServiceConfig {  path: \"/failover/ws\" }    service server on new http:Listener(9094) {    Define the backend service with port 9094, which is called by the failover client.   resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connects wih the server 9094. The Connection ID: \"  + caller.getConnectionId());  }    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until the execution of the onOpen  resource finishes, operations, which should happen before reading the messages should be done in  the onOpen resource.   resource function onText(http:WebSocketCaller caller, string text, boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    This resource gets invoked when a server is receiving a text message from the client.   # To start the service, navigate to the directory that contains the # `.bal` file, and run the `ballerina run` command. $ ballerina run websocket_service_9094.bal    [ballerina/http] started HTTP/WS listener 0.0.0.0:9094 2019-11-20 14:05:09,596 INFO [] - WebSocket client connects wih the server 9094. The Connection ID: 08d40cfffe258b13-00003526-00000001-c69a4c7eb8c373f5-76217d0a    import ballerina/http; import ballerina/log;    @http:WebSocketServiceConfig {  path: \"/failover/ws\" }    service server on new http:Listener(9095) {    Define the backend service with port 9095, which is called by the failover.   resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connects wih the server 9095. The Connection ID: \"  + caller.getConnectionId());  }    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until the execution of the onOpen  resource finishes, operations, which should happen before reading messages should be done in  the onOpen resource.   resource function onText(http:WebSocketCaller caller, string text, boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    This resource gets invoked when a server is receiving a text message from the client.   # To start the service, navigate to the directory that contains the # `.bal` file, and run the `ballerina run` command. $ ballerina run websocket_service_9095.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 2019-11-20 14:04:20,515 INFO [] - WebSocket client connects wih the server 9095. The Connection ID: 08d40cfffe258b13-00003366-00000001-0cf944d788c2b464-774dc3ff [ballerina/http] stopped HTTP/WS listener 0.0.0.0:9095"},{"page":"/learn/by-example/websocket-client.html","name":"Client Endpoint","summary":"The WebSocket client can be used to connect to and interact with a WebSocket server.Creates a new WebSocket client with the backend URL and assigns a callback service.Pushes a text message to the server.Prints the error.The client callback service, which handles backend responses.This resource is triggered when a new text ...","content":"/  /  / Client Endpoint  import ballerina/http; import ballerina/io;public function main() {  http:WebSocketClient wsClientEp = new (\"ws://echo.websocket.org\",  config = {callbackService: ClientService});  var err = wsClientEp->pushText(\"Hello World!\");  if (err is error) {  io:println(err);  } } service ClientService = @http:WebSocketServiceConfig {} service {  resource function onText(http:WebSocketClient conn, string text, boolean finalFrame) {  io:println(text);  }  resource function onError(http:WebSocketClient conn, error err) {  io:println(err);  } };    Client Endpoint  The WebSocket client can be used to connect to and interact with a WebSocket server.    import ballerina/http; import ballerina/io;    public function main() {    http:WebSocketClient wsClientEp = new (\"ws://echo.websocket.org\",  config = {callbackService: ClientService});    Creates a new WebSocket client with the backend URL and assigns a callback service.   var err = wsClientEp->pushText(\"Hello World!\");  if (err is error) {    Pushes a text message to the server.   io:println(err);  } }    Prints the error.   service ClientService = @http:WebSocketServiceConfig {} service {    The client callback service, which handles backend responses.   resource function onText(http:WebSocketClient conn, string text, boolean finalFrame) {  io:println(text);  }    This resource is triggered when a new text frame is received from the remote backend.   resource function onError(http:WebSocketClient conn, error err) {  io:println(err);  } };    This is triggered if an error occurs.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run websocket_client.bal    Hello World!"},{"page":"/learn/by-example/websocket-proxy-server.html","name":"Proxy Server","summary":"Ballerina can act as a proxy to another remote service. Ballerina forwards the\nrequests sent by the clients that connect to it via a WebSocket to the respective remote service.The Url of the remote backend.This resource gets invoked when a new client connects.\n Since messages to the server are not read ...","content":"/  /  / Proxy Server  import ballerina/http; import ballerina/log;final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\"; final string REMOTE_BACKEND = \"ws://echo.websocket.org\";@http:WebSocketServiceConfig {  path: \"/proxy/ws\" } service SimpleProxyService on new http:Listener(9090) {  resource function onOpen(http:WebSocketCaller caller) { http:WebSocketClient wsClientEp = new (  REMOTE_BACKEND,  {  callbackService: ClientService,  readyOnConnect: false  }  );  wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);  var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) { http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }  resource function onBinary(http:WebSocketCaller caller, byte[] data,  boolean finalFrame) { http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->pushBinary(data, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary message\", err);  }  }  resource function onError(http:WebSocketCaller caller, error err) { http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  log:printError(\"Unexpected error hence closing the connection\", err);  }  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) { http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  } } service ClientService = @http:WebSocketServiceConfig {} service {  resource function onText(http:WebSocketClient caller, string text,  boolean finalFrame) { http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }  resource function onBinary(http:WebSocketClient caller, byte[] data,  boolean finalFrame) { http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->pushBinary(data, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary message\", err);  }  }  resource function onError(http:WebSocketClient caller, error err) { http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  log:printError(\"Unexpected error hense closing the connection\", err);  }  resource function onClose(http:WebSocketClient caller, int statusCode,  string reason) { http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  } }; function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketClient) {  http:WebSocketClient wsClient =  <http:WebSocketClient>ep.getAttribute(ASSOCIATED_CONNECTION);  return wsClient; } function getAssociatedServerEndpoint(http:WebSocketClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint =  <http:WebSocketCaller>ep.getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }    Proxy Server  Ballerina can act as a proxy to another remote service. Ballerina forwards the requests sent by the clients that connect to it via a WebSocket to the respective remote service.    import ballerina/http; import ballerina/log;    final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";    final string REMOTE_BACKEND = \"ws://echo.websocket.org\";    The Url of the remote backend.   @http:WebSocketServiceConfig {  path: \"/proxy/ws\" } service SimpleProxyService on new http:Listener(9090) {    resource function onOpen(http:WebSocketCaller caller) {    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until the execution of the onOpen resource finishes,  operations which should happen before reading messages should be done in the onOpen resource.   http:WebSocketClient wsClientEp = new (  REMOTE_BACKEND,  {  callbackService: ClientService,    readyOnConnect: false  }  );    When creating client endpoint, if readyOnConnect flag is set to  false client endpoint does not start reading frames automatically.   wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);    Associate connections before starting to read messages.   var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }    Once the client is ready to receive frames the remote function ready  of the client need to be called separately.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from a client.   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onBinary(http:WebSocketCaller caller, byte[] data,  boolean finalFrame) {    This resource gets invoked upon receiving a new binary frame from a client.   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->pushBinary(data, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary message\", err);  }  }    resource function onError(http:WebSocketCaller caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  log:printError(\"Unexpected error hence closing the connection\", err);  }    resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed from the client side.   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  } }    service ClientService = @http:WebSocketServiceConfig {} service {    Client service to receive frames from the remote server.   resource function onText(http:WebSocketClient caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from the remote backend.   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onBinary(http:WebSocketClient caller, byte[] data,  boolean finalFrame) {    This resource gets invoked upon receiving a new binary frame from the remote backend.   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->pushBinary(data, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary message\", err);  }  }    resource function onError(http:WebSocketClient caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  log:printError(\"Unexpected error hense closing the connection\", err);  }    resource function onClose(http:WebSocketClient caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed by the remote backend.   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  } };    function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketClient) {  http:WebSocketClient wsClient =  <http:WebSocketClient>ep.getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }    Function to retrieve associated client for a particular caller.   function getAssociatedServerEndpoint(http:WebSocketClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint =  <http:WebSocketCaller>ep.getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }    Function to retrieve the associated caller for a client.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. $ ballerina run websocket_proxy_server.bal    # Now, this service can be invoked by any WebSocket client using the url \"ws://localhost:9090/proxy/ws\"    # To check the sample, you can use Chrome or Firefox JavaScript console and run the following commands. <br> $ var ws = new WebSocket(\"ws://localhost:9090/proxy/ws\"); $ ws.onmessage = function(frame) {console.log(frame.data)}; $ ws.onclose = function(frame) {console.log(frame)};    # Send messages. $ ws.send(\"hello world\");    #Close the connection. $ ws.close(1000, \"I want to go\");"},{"page":"/learn/by-example/websub-hub-client-sample.html","name":"Hub Client Sample","summary":"Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.\n Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,\n to receive notifications. If specified, the subscription process would be initiated at the startup.\n The subscription/unsubscription process ...","content":"/  /  / Hub Client Sample  import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;public function main() {  io:println(\"Starting up the Ballerina Hub Service\");  websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");  if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }  var registrationResponse = webSubHub.registerTopic(  \"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }  runtime:sleep(5000);  var publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }  runtime:sleep(5000);  publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }  runtime:sleep(2000); } import ballerina/log; import ballerina/websub; listener websub:Listener websubEP = new (8181); @websub:SubscriberServiceConfig {  path: \"/websub\",  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {  resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } } import ballerina/io; import ballerina/runtime; import ballerina/websub;websub:SubscriptionClient websubHubClientEP =  new (\"http://localhost:9191/websub/hub\");public function main() {  websub:SubscriptionChangeRequest subscriptionRequest = {  topic: \"http://websubpubtopic.com\",  callback: \"http://localhost:8181/websub\",  secret: \"Kslk30SNF2AChs2\"  }; var response = websubHubClientEP->subscribe(subscriptionRequest); if (response is websub:SubscriptionChangeResponse) {  io:println(\"Subscription Request successful at Hub [\" + response.hub +  \"] for Topic [\" + response.topic + \"]\");  } else {  error err = response;  string errCause = <string>err.detail()?.message;  io:println(\"Error occurred with Subscription Request: \" + errCause);  }  runtime:sleep(5000);  websub:SubscriptionChangeRequest unsubscriptionRequest = {  topic: \"http://websubpubtopic.com\",  callback: \"http://localhost:8181/websub\"  }; response = websubHubClientEP->unsubscribe(unsubscriptionRequest); if (response is websub:SubscriptionChangeResponse) {  io:println(\"Unsubscription Request successful at Hub [\" + response.hub +  \"] for Topic [\" + response.topic + \"]\");  } else {  error err = response;  string errCause = <string>err.detail()?.message;  io:println(\"Error occurred with Unsubscription Request: \" + errCause);  } }    Hub Client Sample  Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.  Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,  to receive notifications. If specified, the subscription process would be initiated at the startup.  The subscription/unsubscription process could also be initiated via the Ballerina WebSub Hub Client Endpoint.  This example demonstrates the usage of the WebSub Hub Client Endpoint to subscribe and unsubscribe to updates for  a particular topic at the hub. Also, it demonstrates auto intent verification in which intent verification for subscription or  unsubscription requests would happen automatically (against the annotated topic) if the onIntentVerification request  is not included.  The Hub Client Endpoint can be used by subscribers to subscribe/unsubscribe at a Hub, and by publishers to  register topics and publish updates for topics at the Hub.    import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Ballerina WebSub Publisher brings up the internal Ballerina Hub,  registers a topic at the hub, and publishes updates to the topic.   public function main() {    io:println(\"Starting up the Ballerina Hub Service\");  websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");  if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }    Starts the internal Ballerina Hub.   var registrationResponse = webSubHub.registerTopic(  \"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }    Registers a topic at the hub.   runtime:sleep(5000);    Makes the publisher wait until the subscriber subscribes at the hub.   var publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }    Publishes directly to the internal Ballerina Hub.   runtime:sleep(5000);    Makes the publisher wait until the subscriber unsubscribes at the hub.   publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }    Publishes directly to the internal Ballerina Hub.   runtime:sleep(2000); }    Makes the publisher wait until subscribers are notified.   # This sample requires running the subscriber client main program after the # Publisher starts up the hub and registers the topic, and the subscriber # service (representing the callback) is started. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Starting up the Ballerina Hub Service [ballerina/websub] Ballerina WebSub Hub started up. [ballerina/websub] Publish URL: http://localhost:9191/websub/publish [ballerina/websub] Subscription URL: http://localhost:9191/websub/hub [ballerina/http] started HTTP/WS listener 0.0.0.0:9191 Topic registration successful! 2019-11-01 14:06:38,035 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:06:38,255 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:06:38,781 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/websub] Update notification successful! 2019-11-01 14:06:40,572 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:06:40,576 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:06:40,627 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/websub] Update notification successful! 2019-11-01 14:06:45,628 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:06:45,637 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:06:45,695 INFO [ballerina/websub] - Intent verification successful for mode: [unsubscribe], for callback URL: [http://localhost:8181/websub]    import ballerina/log; import ballerina/websub;    The Ballerina WebSub Subscriber service, which represents the callback registered at the Hub.   listener websub:Listener websubEP = new (8181);    The endpoint to which the subscriber service is bound.   @websub:SubscriberServiceConfig {  path: \"/websub\",  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {    Annotations specifying the subscription parameters.  The omission of subscribeOnStartUp as an annotation due to which a subscription request would not be sent  automatically on the start up.  Also, the exclusion of the onIntentVerification resource will result in auto intent-verification.   resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    This resource accepts content delivery requests.   # The update published after unsubscription is not received by the subscriber service. # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. $ ballerina run subscriber_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8181 2019-11-01 14:06:38,171 INFO [ballerina/websub] - Subscription Request successfully sent to Hub[http://localhost:9191/websub/hub], for Topic[http://websubpubtopic.com], with Callback [http://localhost:8181/websub] ballerina: Intent Verification agreed - Mode [subscribe], Topic [http://websubpubtopic.com], Lease Seconds [86400] 2019-11-01 14:06:40,196 INFO [] - WebSub Notification Received: {\"action\":\"publish\", \"mode\":\"internal-hub\"} ballerina: Intent Verification agreed - Mode [subscribe], Topic [http://websubpubtopic.com], Lease Seconds [86400] 2019-11-01 14:06:45,052 INFO [] - WebSub Notification Received: {\"action\":\"publish\", \"mode\":\"internal-hub\"} ballerina: Intent Verification agreed - Mode [unsubscribe], Topic [http://websubpubtopic.com]    import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Ballerina main program, which demonstrates the usage of the Hub client endpoint to subscribe/unsubscribe to notifications.   websub:SubscriptionClient websubHubClientEP =  new (\"http://localhost:9191/websub/hub\");    public function main() {    websub:SubscriptionChangeRequest subscriptionRequest = {  topic: \"http://websubpubtopic.com\",  callback: \"http://localhost:8181/websub\",  secret: \"Kslk30SNF2AChs2\"  };    Sends the subscription request for the subscriber service.   var response = websubHubClientEP->subscribe(subscriptionRequest);    if (response is websub:SubscriptionChangeResponse) {  io:println(\"Subscription Request successful at Hub [\" + response.hub +  \"] for Topic [\" + response.topic + \"]\");  } else {  error err = response;  string errCause = <string>err.detail()?.message;  io:println(\"Error occurred with Subscription Request: \" + errCause);  }    runtime:sleep(5000);    Waits for the initial notification before unsubscribing.   websub:SubscriptionChangeRequest unsubscriptionRequest = {  topic: \"http://websubpubtopic.com\",  callback: \"http://localhost:8181/websub\"  };    Sends the unsubscription request to the subscriber service.   response = websubHubClientEP->unsubscribe(unsubscriptionRequest);    if (response is websub:SubscriptionChangeResponse) {  io:println(\"Unsubscription Request successful at Hub [\" + response.hub +  \"] for Topic [\" + response.topic + \"]\");  } else {  error err = response;  string errCause = <string>err.detail()?.message;  io:println(\"Error occurred with Unsubscription Request: \" + errCause);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run subscription_change_client.bal Subscription Request successful at Hub [http://localhost:9191/websub/hub] for Topic [http://websubpubtopic.com] Unsubscription Request successful at Hub [http://localhost:9191/websub/hub] for Topic [http://websubpubtopic.com]"},{"page":"/learn/by-example/websocket-retry.html","name":"Retry","summary":"If the WebSocket client lost a connection by the server being shut down or by getting any IOExceptions, Ballerina automatically reconnects to the same backend until the connection becomes successful or until the maximum reconnect attempts count is reached.The URL of the remote backend.This resource gets invoked when a new ...","content":"/  /  / Retry  import ballerina/http; import ballerina/log;final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\"; const string REMOTE_BACKEND = \"ws://localhost:9095/retry/ws\";@http:WebSocketServiceConfig {  path: \"/retry/ws\" } service retryProxyService on new http:Listener(9090) {  resource function onOpen(http:WebSocketCaller caller) {  http:WebSocketClient wsClientEp = new (  REMOTE_BACKEND,  {  callbackService: retryClientService,  readyOnConnect: false,  retryConfig: {  intervalInMillis: 3000,  maxCount: 20,  backOffFactor: 2.0,  maxWaitIntervalInMillis: 20000  }  });  wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);  var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) { http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }  resource function onError(http:WebSocketCaller caller, error err) { http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  log:printError(\"Unexpected error hence closing the connection\", e);  }  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) { http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } } service retryClientService = @http:WebSocketServiceConfig {} service {  resource function onText(http:WebSocketClient caller, string text,  boolean finalFrame) { http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }  resource function onError(http:WebSocketClient caller, error err) { http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  log:printError(\"Unexpected error hense closing the connection\", err);  }  resource function onClose(http:WebSocketClient caller, int statusCode,  string reason) { http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } }; function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketClient) {  http:WebSocketClient wsClient = <http:WebSocketClient>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsClient; } function getAssociatedServerEndpoint(http:WebSocketClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint = <http:WebSocketCaller>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }# To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command.import ballerina/http; import ballerina/log; @http:WebSocketServiceConfig {  path: \"/retry/ws\" } service server on new http:Listener(9095) {  resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connected wih the server. \" +  \"The Connection ID: \" + caller.getConnectionId());  }  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    Retry  If the WebSocket client lost a connection by the server being shut down or by getting any IOExceptions, Ballerina automatically reconnects to the same backend until the connection becomes successful or until the maximum reconnect attempts count is reached.    import ballerina/http; import ballerina/log;    final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";    const string REMOTE_BACKEND = \"ws://localhost:9095/retry/ws\";    The URL of the remote backend.   @http:WebSocketServiceConfig {  path: \"/retry/ws\" } service retryProxyService on new http:Listener(9090) {    resource function onOpen(http:WebSocketCaller caller) {    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until  the execution of the onOpen resource finishes,  operations, which should happen before reading messages should be done  in the onOpen resource.   http:WebSocketClient wsClientEp = new (  REMOTE_BACKEND,  {  callbackService: retryClientService,    Defines the webSocket client.   readyOnConnect: false,    When creating client endpoint, if readyOnConnect flag is set to  false, client endpoint does not start reading frames automatically.   retryConfig: {    Retry configuration options.   intervalInMillis: 3000,    The number of milliseconds to delay before attempting to reconnect.   maxCount: 20,    The maximum number of retry attempts.  If the count is zero, the client will retry indefinitely.   backOffFactor: 2.0,    The rate of increase of the reconnect delay.   maxWaitIntervalInMillis: 20000  }  });    Upper limit of the retry interval in milliseconds. If  intervalInMillis into backOffFactor value exceeded  maxWaitIntervalInMillis interval value, then  maxWaitIntervalInMillis will be considered as the retry interval.   wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);    Associate connections before starting to read messages.   var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }    Once the client is ready to receive frames, the remote function ready  of the client needs to be called separately.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from a client.   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onError(http:WebSocketCaller caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  log:printError(\"Unexpected error hence closing the connection\", e);  }    resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed from the client side.   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } }    service retryClientService = @http:WebSocketServiceConfig {} service {    Client service to receive frames from the remote server.   resource function onText(http:WebSocketClient caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from  the remote backend.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onError(http:WebSocketClient caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  log:printError(\"Unexpected error hense closing the connection\", err);  }    resource function onClose(http:WebSocketClient caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed by  the remote backend.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } };    function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketClient) {  http:WebSocketClient wsClient = <http:WebSocketClient>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }    Function to retrieve the associated client of a particular caller.   function getAssociatedServerEndpoint(http:WebSocketClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint = <http:WebSocketCaller>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }    Function to retrieve the associated caller of a client.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command.    $ ballerina run websocket_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 $ ballerina run websocket_retry.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Now, this service can be invoked by any WebSocket client using the URL: \"ws://localhost:9090/retry/ws\".    # To check the sample, you can use Chrome or Firefox JavaScript console and run the following commands. <br> $ var ws = new WebSocket(\"ws://localhost:9090/retry/ws\"); $ ws.onmessage = function(frame) {console.log(frame.data)}; $ ws.onclose = function(frame) {console.log(frame)};    # Send messages. $ ws.send(\"hello world\");    # To stop the running service, press Ctrl + C. # Restart the service.    # Send messages. $ ws.send(\"hello world\");    # Close the connection. $ ws.close(1000, \"I want to go\");    import ballerina/http; import ballerina/log;    @http:WebSocketServiceConfig {  path: \"/retry/ws\" }    The annotation which is used to configure a WebSocket service.   service server on new http:Listener(9095) {    Define the backend service with port 9095, which is called by the client.   resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connected wih the server. \" +  \"The Connection ID: \" + caller.getConnectionId());  }    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service  until the execution of the onOpen resource finishes,  operations which should happen before reading messages should be  done in the onOpen resource.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    This resource gets invoked when a server is receiving  a text message from the client.   # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. $ ballerina run webSocket_service.bal    [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 2019-11-20 13:31:38,842 INFO [] - WebSocket client connected wih the server. The Connection ID: 08d40cfffe258b13-00000bfd-00000001-a1eade696304c59e-7f64181e    # Stop the running service. [ballerina/http] stopped HTTP/WS listener 0.0.0.0:9095    # Restart the service. $ ballerina run websocket_service.bal    [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 2019-11-20 13:34:55,543 INFO [] - WebSocket client connected wih the server. The Connection ID: 08d40cfffe258b13-0000118b-00000001-9bc9b9fb2d07c5b5-8fb73e4f"},{"page":"/learn/by-example/websub-internal-hub-sample.html","name":"Internal Hub Sample","summary":"Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.\n Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,\n to receive notifications. If specified, the subscription process will be initiated at the startup. Signature validation\n is ...","content":"/  /  / Internal Hub Sample  import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;public function main() {  io:println(\"Starting up the Ballerina Hub Service\"); websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");  if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }  var registrationResponse = webSubHub.registerTopic(  \"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }  runtime:sleep(5000);  io:println(\"Publishing update to internal Hub\");  var publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"}); if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }  runtime:sleep(2000); } import ballerina/http; import ballerina/log; import ballerina/websub; listener websub:Listener websubEP = new websub:Listener(8181); @websub:SubscriberServiceConfig {  path: \"/websub\",  subscribeOnStartUp: true,  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {  resource function onIntentVerification(websub:Caller caller,  websub:IntentVerificationRequest request) {  http:Response response =  request.buildSubscriptionVerificationResponse(\"http://websubpubtopic.com\");  if (response.statusCode == 202) {  log:printInfo(\"Intent verified for subscription request\");  } else {  log:printWarn(\"Intent verification denied for subscription request\");  }  var result = caller->respond(<@untainted>response); if (result is error) {  log:printError(\"Error responding to intent verification request\",  err = result);  }  }  resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Internal Hub Sample  Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.  Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,  to receive notifications. If specified, the subscription process will be initiated at the startup. Signature validation  is performed by default for subscribers that receive authenticated content. Ballerina WebSub Subscriber  Services could thus be registered as webhooks to receive event notifications.  Ballerina also comes with an in-built WebSub Hub service, which can be brought up by publishers that need to bring  up a hub.  In this example, a WebSub Publisher brings up an internal hub and publishes updates to it, and a WebSub Subscriber  subscribes at the publisher’s hub to receive notifications of the updates sent to the topic.    import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Ballerina WebSub Publisher brings up the internal Ballerina hub, registers a topic at the hub, and publishes updates to the topic.   public function main() {    io:println(\"Starting up the Ballerina Hub Service\");    Specifies the port that the internal Ballerina hub needs to start on and start the hub.   websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");  if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }    var registrationResponse = webSubHub.registerTopic(  \"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }    Registers a topic at the hub.   runtime:sleep(5000);    Makes the publisher wait until the subscriber subscribes at the hub.   io:println(\"Publishing update to internal Hub\");  var publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});    Publishes directly to the internal Ballerina hub.   if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }    runtime:sleep(2000); }    Keeps the service is running until the subscriber receives the update notification.   # This sample requires starting up the Subscriber Service after the Publisher starts up the hub and registers the topic. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Starting up the Ballerina Hub Service [ballerina/websub] Ballerina WebSub Hub started up. [ballerina/websub] Publish URL: http://localhost:9191/websub/publish [ballerina/websub] Subscription URL: http://localhost:9191/websub/hub Topic registration successful! [ballerina/http] started HTTP/WS listener 0.0.0.0:9191 2019-11-01 14:12:22,809 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:12:22,906 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:12:23,139 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/websub] Publishing update to internal Hub Update notification successful!    import ballerina/http; import ballerina/log; import ballerina/websub;    Ballerina WebSub Subscriber service, which subscribes to notifications at a Hub.   listener websub:Listener websubEP = new websub:Listener(8181);    The endpoint to which the subscriber service is bound.   @websub:SubscriberServiceConfig {  path: \"/websub\",  subscribeOnStartUp: true,  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {    Annotations specifying the subscription parameters.   resource function onIntentVerification(websub:Caller caller,  websub:IntentVerificationRequest request) {    Define sthe resource, which accepts the intent verification requests.  If the resource is not specified, intent verification happens automatically. It verifies if the topic specified in the intent  verification request matches the topic specified as the annotation.   http:Response response =  request.buildSubscriptionVerificationResponse(\"http://websubpubtopic.com\");  if (response.statusCode == 202) {  log:printInfo(\"Intent verified for subscription request\");  } else {  log:printWarn(\"Intent verification denied for subscription request\");  }  var result = caller->respond(<@untainted>response);    Builds the response to the intent verification request that was received for subscription.   if (result is error) {  log:printError(\"Error responding to intent verification request\",  err = result);  }  }    resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Defines the resource that accepts the content delivery requests.   # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. $ ballerina run subscriber.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8181 2019-11-01 14:12:22,870 INFO [ballerina/websub] - Subscription Request successfully sent to Hub[http://localhost:9191/websub/hub], for Topic[http://websubpubtopic.com], with Callback [http://localhost:8181/websub] 2019-11-01 14:12:23,074 INFO [] - Intent verified for subscription request 2019-11-01 14:12:25,035 INFO [] - WebSub Notification Received: {\"action\":\"publish\", \"mode\":\"internal-hub\"}"},{"page":"/learn/by-example/websub-remote-hub-sample.html","name":"Remote Hub Sample","summary":"Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.\n Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,\n to receive notifications. If specified, the subscription process can be initiated at the startup. Signature\n validation is ...","content":"/  /  / Remote Hub Sample  import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;public function main() {  io:println(\"Starting up the Ballerina Hub Service\"); websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\",  hubConfiguration = {  remotePublish: {  enabled: true  }  }  ); if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }  runtime:sleep(10000);} import ballerina/io; import ballerina/runtime; import ballerina/websub; websub:PublisherClient websubHubClientEP =  new (\"http://localhost:9191/websub/publish\");public function main() {  var registrationResponse =  websubHubClientEP->registerTopic(\"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }  runtime:sleep(5000);  io:println(\"Publishing update to remote Hub\");  var publishResponse =  websubHubClientEP->publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"remote-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }} import ballerina/http; import ballerina/log; import ballerina/websub; listener websub:Listener websubEP = new (8181); @websub:SubscriberServiceConfig {  path: \"/websub\",  subscribeOnStartUp: true,  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {  resource function onIntentVerification(websub:Caller caller,  websub:IntentVerificationRequest request) {  http:Response response = request.  buildSubscriptionVerificationResponse(\"http://websubpubtopic.com\"); if (response.statusCode == 202) {  log:printInfo(\"Intent verified for subscription request\");  } else {  log:printWarn(\"Intent verification denied for subscription request\");  }  var result = caller->respond(<@untainted>response); if (result is error) {  log:printError(\"Error responding to intent verification request\",  result);  }  }  resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Remote Hub Sample  Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.  Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,  to receive notifications. If specified, the subscription process can be initiated at the startup. Signature  validation is performed by default for subscribers that receive authenticated content. Ballerina WebSub Subscriber  Services could thus be registered as webhooks to receive event notifications.  Ballerina also comes with an in-built WebSub Hub service, which can be brought up by publishers that need to bring up  a hub.  This example demonstrates a simple WebSub publisher and subscriber scenario, in which a Ballerina WebSub Hub  that is brought up remotely is used by a Ballerina WebSub publisher to publish updates to a topic. A Ballerina  WebSub Subscriber subscribes at this remote hub to get the topic updates.    import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Main program, which brings up the Ballerina WebSub Hub.   public function main() {    io:println(\"Starting up the Ballerina Hub Service\");    Starts the internal Ballerina Hub on port 9191 allowing remote publishers to register topics and publish  updates of the topics.   websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\",  hubConfiguration = {  remotePublish: {  enabled: true  }  }  );    if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }    runtime:sleep(10000);    Waits for the subscriber to subscribe at this hub and for the publisher to publish the notifications.   }    # This sample requires the Hub Service to start via the hub.bal file, prior to running the Publisher main program. The # Subscriber Service needs to start after the publisher registers the topic at the hub. # If the port is not specified, the hub service starts on the default port. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run hub.bal Starting up the Ballerina Hub Service [ballerina/websub] Ballerina WebSub Hub started up. [ballerina/websub] Publish URL: http://localhost:9191/websub/publish [ballerina/websub] Subscription URL: http://localhost:9191/websub/hub [ballerina/http] started HTTP/WS listener 0.0.0.0:9191 2019-11-01 14:36:36,782 INFO [ballerina/websub] - Topic registration successful at Hub, for topic[http://websubpubtopic.com] 2019-11-01 14:36:42,764 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:36:42,807 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:36:43,116 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/websub] 2019-11-01 14:36:46,952 INFO [ballerina/websub] - Update notification done for Topic [http://websubpubtopic.com]    import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Ballerina WebSub Publisher, which registers a topic at the hub and publishes updates to the hub for the topic.   websub:PublisherClient websubHubClientEP =  new (\"http://localhost:9191/websub/publish\");    This is the remote WebSub Hub Endpoint to which registration and publish requests are sent.   public function main() {    var registrationResponse =  websubHubClientEP->registerTopic(\"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }    Registers a topic at the hub.   runtime:sleep(5000);    Makes the publisher wait until the subscriber subscribes at the hub.   io:println(\"Publishing update to remote Hub\");  var publishResponse =  websubHubClientEP->publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"remote-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }    Publishes updates to the remote hub.   }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run publisher.bal Topic registration successful! Publishing update to remote Hub Update notification successful!    import ballerina/http; import ballerina/log; import ballerina/websub;    Ballerina WebSub Subscriber service, which subscribes to notifications at a Hub.   listener websub:Listener websubEP = new (8181);    The endpoint to which the subscriber service is bound.   @websub:SubscriberServiceConfig {  path: \"/websub\",  subscribeOnStartUp: true,  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {    Annotations specifying the subscription parameters.   resource function onIntentVerification(websub:Caller caller,  websub:IntentVerificationRequest request) {    Defines the resource that accepts the intent verification requests.  If the resource is not specified, intent verification happens automatically. It verifies if the topic  specified in the intent verification request matches the topic specified as the annotation.   http:Response response = request.  buildSubscriptionVerificationResponse(\"http://websubpubtopic.com\");    Builds the response for the subscription intent verification request that was received.   if (response.statusCode == 202) {  log:printInfo(\"Intent verified for subscription request\");  } else {  log:printWarn(\"Intent verification denied for subscription request\");  }  var result = caller->respond(<@untainted>response);    if (result is error) {  log:printError(\"Error responding to intent verification request\",  result);  }  }    resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Defines the resource that accepts the content delivery requests.   # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. $ ballerina run subscriber.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8181 2019-11-01 14:36:42,797 INFO [ballerina/websub] - Subscription Request successfully sent to Hub[http://localhost:9191/websub/hub], for Topic[http://websubpubtopic.com], with Callback [http://localhost:8181/websub] 2019-11-01 14:36:43,050 INFO [] - Intent verified for subscription request 2019-11-01 14:36:47,098 INFO [] - WebSub Notification Received: {\"action\":\"publish\", \"mode\":\"remote-hub\"}"},{"page":"/learn/by-example/websub-service-integration-sample.html","name":"Service Integration Sample","summary":"Ballerina provides the capability to easily introduce webhooks via its implementation of the WebSub recommendation.Ballerina Services, which act as WebSub Publishers could start up a Ballerina WebSub Hub to which they would publish\n updates against topics on the occurrence of particular events.Ballerina WebSub subscribers can subscribe at these hubs, by ...","content":"/  /  / Service Integration Sample  import ballerina/http; import ballerina/log; import ballerina/websub;listener http:Listener httpListener = new (9090); final string ORDER_TOPIC = \"http://localhost:9090/ordermgt/ordertopic\"; map<json> orderMap = {}; websub:Hub webSubHub = startHubAndRegisterTopic();@http:ServiceConfig {  basePath: \"/ordermgt\" } service orderMgt on httpListener {  @http:ResourceConfig {  methods: [\"GET\", \"HEAD\"],  path: \"/order\"  }  resource function discoverPlaceOrder(http:Caller caller, http:Request req) {  http:Response response = new;  websub:addWebSubLinkHeader(response, [webSubHub.subscriptionUrl], ORDER_TOPIC);  response.statusCode = 202;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error responding on ordering\", result);  }  }  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/order\"  }  resource function placeOrder(http:Caller caller, http:Request req) {  var orderReq = req.getJsonPayload();  if (orderReq is json) {  string orderId = orderReq.Order.ID.toString();  orderMap[orderId] = <@untainted>orderReq;  http:Response response = new;  response.statusCode = 202;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error responding on ordering\", result);  }  string orderCreatedNotification = \"New Order Added: \" + orderId;  log:printInfo(orderCreatedNotification);  var updateResult = webSubHub.publishUpdate(ORDER_TOPIC,  orderCreatedNotification);  if (updateResult is error) {  log:printError(\"Error publishing update\", updateResult);  }  } else {  error e = orderReq;  log:printError(\"Error retrieving payload\", e);  panic e;  }  }} function startHubAndRegisterTopic() returns websub:Hub {  var hubStartUpResult = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\"); websub:Hub? hubVar = ();  if hubStartUpResult is websub:HubStartupError {  panic hubStartUpResult;  } else {  hubVar = hubStartUpResult is websub:HubStartedUpError  ? hubStartUpResult.startedUpHub : hubStartUpResult;  } websub:Hub internalHub = <websub:Hub>hubVar;  var result = internalHub.registerTopic(ORDER_TOPIC);  if (result is error) {  log:printError(\"Error registering topic\", result);  }  return internalHub; } import ballerina/log; import ballerina/websub; listener websub:Listener websubEP = new (8181); @websub:SubscriberServiceConfig {  path: \"/ordereventsubscriber\",  subscribeOnStartUp: true,  target: \"http://localhost:9090/ordermgt/order\",  leaseSeconds: 3600,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {  resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Service Integration Sample  Ballerina provides the capability to easily introduce webhooks via its implementation of the WebSub recommendation.  Ballerina Services, which act as WebSub Publishers could start up a Ballerina WebSub Hub to which they would publish  updates against topics on the occurrence of particular events.  Ballerina WebSub subscribers can subscribe at these hubs, by specifying the topics, to receive notifications on  the occurrence of particular events.  Any of the Ballerina’s WebSub components (Publisher, Hub, or Subscriber) could be used with non-Ballerina components, which  are WebSub-compliant.    import ballerina/http; import ballerina/log; import ballerina/websub;    The order management HTTP service acting as a Ballerina WebSub Publisher brings up an internal Ballerina WebSub Hub  at which it will publish updates.   listener http:Listener httpListener = new (9090);    final string ORDER_TOPIC = \"http://localhost:9090/ordermgt/ordertopic\";    The topic against which the publisher will publish updates and the subscribers  need to subscribe to, to receive notifications when an order is placed.   map<json> orderMap = {};    An in-memory map to which orders will be added.   websub:Hub webSubHub = startHubAndRegisterTopic();    Invokes the function that starts up a Ballerina WebSub Hub, registers the topic  against which updates will be published, and maintains a reference to the  returned hub object to publish updates.   @http:ServiceConfig {  basePath: \"/ordermgt\" } service orderMgt on httpListener {    @http:ResourceConfig {  methods: [\"GET\", \"HEAD\"],  path: \"/order\"  }  resource function discoverPlaceOrder(http:Caller caller, http:Request req) {  http:Response response = new;    This resource accepts the discovery requests.  Requests received at this resource would respond with a Link Header  indicating the topic to subscribe to and the hub(s) to subscribe at.   websub:addWebSubLinkHeader(response, [webSubHub.subscriptionUrl], ORDER_TOPIC);  response.statusCode = 202;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error responding on ordering\", result);  }  }    Adds a link header indicating the hub and topic.   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/order\"  }  resource function placeOrder(http:Caller caller, http:Request req) {  var orderReq = req.getJsonPayload();  if (orderReq is json) {  string orderId = orderReq.Order.ID.toString();  orderMap[orderId] = <@untainted>orderReq;    This resource accepts order placement requests.   http:Response response = new;  response.statusCode = 202;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error responding on ordering\", result);  }    Creates the response message indicating successful order creation.   string orderCreatedNotification = \"New Order Added: \" + orderId;  log:printInfo(orderCreatedNotification);  var updateResult = webSubHub.publishUpdate(ORDER_TOPIC,  orderCreatedNotification);  if (updateResult is error) {  log:printError(\"Error publishing update\", updateResult);  }  } else {  error e = orderReq;  log:printError(\"Error retrieving payload\", e);  panic e;  }  }    Publishes the update to the Hub to notify the subscribers.   }    function startHubAndRegisterTopic() returns websub:Hub {  var hubStartUpResult = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");    Starts up a Ballerina WebSub Hub on port 9191 and registers the topic against  which updates will be published.   websub:Hub? hubVar = ();  if hubStartUpResult is websub:HubStartupError {  panic hubStartUpResult;  } else {  hubVar = hubStartUpResult is websub:HubStartedUpError  ? hubStartUpResult.startedUpHub : hubStartUpResult;  }    websub:Hub internalHub = <websub:Hub>hubVar;  var result = internalHub.registerTopic(ORDER_TOPIC);  if (result is error) {  log:printError(\"Error registering topic\", result);  }  return internalHub; }    # This sample requires starting up the Subscriber Service after the Publisher Service. # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. $ ballerina run order_mgmt_service.bal [ballerina/websub] Ballerina WebSub Hub started up. [ballerina/websub] Publish URL: http://localhost:9191/websub/publish [ballerina/websub] Subscription URL: http://localhost:9191/websub/hub [ballerina/http] started HTTP/WS listener 0.0.0.0:9191 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2019-11-01 14:15:05,814 INFO [ballerina/websub] - Subscription request received for topic[http://localhost:9090/ordermgt/ordertopic] with callback[http://localhost:8181/ordereventsubscriber] 2019-11-01 14:15:05,858 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/ordereventsubscriber] for topic[http://localhost:9090/ordermgt/ordertopic] 2019-11-01 14:15:06,037 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/ordereventsubscriber] 2019-11-01 14:15:58,756 INFO [] - New Order Added: 1001    $ curl -X POST -d '{ \"Order\": { \"ID\": \"1001\", \"Name\": \"XYZ\" } }' \"http://localhost:9090/ordermgt/order\" -H \"Content-Type:application/json\"    Invoke the service via the below “curl” command to place an order after starting up the subscriber service.   import ballerina/log; import ballerina/websub;    The Ballerina WebSub Subscriber service, which subscribes to notifications at the Hub.   listener websub:Listener websubEP = new (8181);    The endpoint to which the subscriber service is bound.   @websub:SubscriberServiceConfig {  path: \"/ordereventsubscriber\",  subscribeOnStartUp: true,  target: \"http://localhost:9090/ordermgt/order\",  leaseSeconds: 3600,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {    Annotations specifying the subscription parameters for the order management service.  A subscription request would be sent to the hub with the topic discovered at the  resource URL specified.   resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Defines the resource, which accepts the content delivery requests.   # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. $ ballerina run subscriber.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8181 2019-11-01 14:15:05,823 INFO [ballerina/websub] - Subscription Request successfully sent to Hub[http://localhost:9191/websub/hub], for Topic[http://localhost:9090/ordermgt/ordertopic], with Callback [http://localhost:8181/ordereventsubscriber] ballerina: Intent Verification agreed - Mode [subscribe], Topic [http://localhost:9090/ordermgt/ordertopic], Lease Seconds [3600] 2019-11-01 14:15:58,892 INFO [] - WebSub Notification Received: New Order Added: 1001"},{"page":"/learn/by-example/while.html","name":"While","summary":"A while loop statement repeatedly executes the code block that is defined within the while block as long as a given\n condition is met.This is a basic while loop.The break statement can be used to break the loop.The continue statement can be used to move to the\n next loop iteration ...","content":"/  /  / While  import ballerina/io;public function main() {  int i = 0;  while (i < 3) {  io:println(i);  i = i + 1;  } int j = 0;  while (j < 5) {  io:println(j);  j = j + 1;  if (j == 3) {  break;  }  } int k = 0;  while (k < 5) {  if (k < 3) {  k = k + 1;  continue;  } io:println(k);  k = k + 1;  } }    While  A while loop statement repeatedly executes the code block that is defined within the while block as long as a given  condition is met.    import ballerina/io;    public function main() {  int i = 0;    while (i < 3) {  io:println(i);  i = i + 1;  }    This is a basic while loop.   int j = 0;  while (j < 5) {  io:println(j);  j = j + 1;    if (j == 3) {  break;  }  }    The break statement can be used to break the loop.   int k = 0;  while (k < 5) {    if (k < 3) {  k = k + 1;  continue;  }    The continue statement can be used to move to the  next loop iteration immediately.   io:println(k);  k = k + 1;  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run while.bal 0 1 2 0 1 2 3 4"},{"page":"/learn/by-example/worker-interaction.html","name":"Worker Interactions","summary":"Workers interact with each other by sending and receiving messages.\n Messages are sent and received over a communication channel that is transparent to the user.\n Asynchronous sending of the worker does not wait until the message is delivered whereas synchronous sending waits until the message is delivered.\n Flush can be ...","content":"/  /  / Worker Interactions  import ballerina/io; import ballerina/runtime; public function main() {  worker w1 {  int i = 100;  float k = 2.34;  [int, float] t1 = [i, k];  t1 -> w2;  io:println(\"[w1 -> w2] i: \", i, \" k: \", k);  json j = {};  j = <- w2;  string jStr = j.toString();  io:println(\"[w1 <- w2] j: \", jStr);  io:println(\"[w1 ->> w2] i: \", i);  () send = i ->> w2;  io:println(\"[w1 ->> w2] successful!!\");  io:println(\"[w1 -> w3] k: \", k);  k -> w3;  k -> w3;  k -> w3; io:println(\"Waiting for worker w3 to fetch messages..\");  error? flushResult = flush w3;  io:println(\"[w1 -> w3] Flushed!!\");  } worker w2 {  int iw;  float kw;  [int, float] vW1 = [0, 1.0];  vW1 = <- w1;  [iw, kw] = vW1;  io:println(\"[w2 <- w1] iw: \", iw, \" kw: \", kw);  json jw = {\"name\": \"Ballerina\"};  io:println(\"[w2 -> w1] jw: \", jw);  jw -> w1;  int lw;  runtime:sleep(5);  lw = <- w1;  io:println(\"[w2 <- w1] lw: \", lw);  } worker w3 {  float mw;  runtime:sleep(50);  mw = <- w1;  mw = <- w1;  mw = <- w1;  io:println(\"[w3 <- w1] mw: \", mw);  }  wait w1; }    Worker Interactions  Workers interact with each other by sending and receiving messages.  Messages are sent and received over a communication channel that is transparent to the user.  Asynchronous sending of the worker does not wait until the message is delivered whereas synchronous sending waits until the message is delivered.  Flush can be used to check if all asynchronous messages were sent successfully to a given worker.  Both synchronous send and flush may fail if a receiving worker returned an error before receiving the messages.  Similarly ,they may panic if a receiver panicked.    import ballerina/io; import ballerina/runtime;    public function main() {  worker w1 {  int i = 100;  float k = 2.34;    Workers interact with each other by sending and receiving messages.  Ballerina validates every worker interaction (send and receive)  to avoid deadlocks.   [int, float] t1 = [i, k];  t1 -> w2;  io:println(\"[w1 -> w2] i: \", i, \" k: \", k);    Sends messages asynchronously to the worker w2. This message contains a  tuple value with the member types int and float.   json j = {};  j = <- w2;  string jStr = j.toString();  io:println(\"[w1 <- w2] j: \", jStr);  io:println(\"[w1 ->> w2] i: \", i);    Receives a message from the worker w2. This message contains ajson`-typed value.   () send = i ->> w2;    Sends messages synchronously to the worker w2. The worker w1 will wait  until the worker w2 receives the message.   io:println(\"[w1 ->> w2] successful!!\");    The synchronous sending returns nil if the message was successfully sent or  returns an error or panics based on the receiving worker’s state.   io:println(\"[w1 -> w3] k: \", k);  k -> w3;  k -> w3;  k -> w3;    Sends messages asynchronously to the worker w3.   io:println(\"Waiting for worker w3 to fetch messages..\");    error? flushResult = flush w3;  io:println(\"[w1 -> w3] Flushed!!\");  }    Flushes all messages sent asynchronously to the worker w3. The worker  will halt at this point until all messages are sent or until the worker w3  fails.   worker w2 {    int iw;  float kw;  [int, float] vW1 = [0, 1.0];  vW1 = <- w1;  [iw, kw] = vW1;  io:println(\"[w2 <- w1] iw: \", iw, \" kw: \", kw);    Receives a message from the worker w1.   json jw = {\"name\": \"Ballerina\"};  io:println(\"[w2 -> w1] jw: \", jw);  jw -> w1;    Sends a message asynchronously to the worker w1.   int lw;  runtime:sleep(5);  lw = <- w1;  io:println(\"[w2 <- w1] lw: \", lw);  }    Receives the message sent synchronously from the worker w1   worker w3 {  float mw;    runtime:sleep(50);  mw = <- w1;  mw = <- w1;  mw = <- w1;  io:println(\"[w3 <- w1] mw: \", mw);  }    Receives messages from the worker w1 after a certain time.   wait w1; }    Waits for the worker w1to finish.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run worker_interaction.bal [w1 -> w2] i: 100 k: 2.34 [w2 <- w1] iw: 100 kw: 2.34 [w2 -> w1] jw: name=Ballerina [w1 <- w2] j: name=Ballerina [w1 ->> w2] i: 100 [w2 <- w1] lw: 100 [w1 ->> w2] successful!! [w1 -> w3] k: 2.34 Waiting for worker w3 to fetch messages.. [w1 -> w3] Flushed!! [w3 <- w1] mw: 2.34"},{"page":"/learn/by-example/workers.html","name":"Workers","summary":"Workers in Ballerina allow developers to delegate their tasks to independently running executions.\n Worker execution starts immediately after invoking the relevant function, remote function, or resource that encloses the worker(s).\n Workers can be declared within functions, remote functions, or resources.\n Worker execution starts immediately after executing the statements declared before ...","content":"/  /  / Workers  import ballerina/io; public function main() {  io:println(\"Worker execution started\");  worker w1 {  int n = 10000000;  int sum = 0;  foreach var i in 1 ... n {  sum += i;  }  io:println(\"sum of first \", n, \" positive numbers = \", sum);  }  @strand {  thread:\"any\"  }  worker w2 {  int n = 10000000;  int sum = 0;  foreach var i in 1 ... n {  sum += i * i;  }  io:println(\"sum of squares of first \", n,  \" positive numbers = \", sum);  }  _ = wait {w1, w2}; io:println(\"Worker execution finished\"); }    Workers  Workers in Ballerina allow developers to delegate their tasks to independently running executions.  Worker execution starts immediately after invoking the relevant function, remote function, or resource that encloses the worker(s).  Workers can be declared within functions, remote functions, or resources.  Worker execution starts immediately after executing the statements declared before the first worker declaration in the relevant function,  remote function, or resource that encloses the worker(s).    import ballerina/io;    public function main() {  io:println(\"Worker execution started\");    In Ballerina, each function consists of one or more workers, which are  independent execution paths called strands. If explicit workers are  not mentioned within worker blocks, the function code will belong to a  single implicit default worker. The default worker in each function wil be  executed in the same strand as the caller function.   worker w1 {    This block belongs to the worker w1.   int n = 10000000;  int sum = 0;  foreach var i in 1 ... n {  sum += i;  }  io:println(\"sum of first \", n, \" positive numbers = \", sum);  }    Calculates the sum(n).   @strand {  thread:\"any\"  }    By default workers run on the same physical thread of the parent strand.  By adding @strand annotation, this worker’s strand is allowed to run  on any available physical thread.   worker w2 {    This block belongs to the worker w2.   int n = 10000000;  int sum = 0;  foreach var i in 1 ... n {  sum += i * i;  }  io:println(\"sum of squares of first \", n,  \" positive numbers = \", sum);  }    Calculates the sum(n^2).   _ = wait {w1, w2};    Waits for both workers to finish.   io:println(\"Worker execution finished\"); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run workers.bal Worker execution started sum of first 10000000 positive numbers = 50000005000000 sum of squares of first 10000000 positive numbers = 1291990006563070912 Worker execution finished"},{"page":"/learn/by-example/xml-access.html","name":"XML Access","summary":"XML elements can contain child XML items. Ballerina allows you to access these\n child elements conveniently using XML step expressions and XML filter expressions.The XML element with nested children.You can access child XML items using XML step expressions.Accessing a non-existing child will return an empty xml sequence.You can also retrieve ...","content":"/  /  / XML Access  import ballerina/io;public function main() {  xml bookXML = xml `<book>  <name>Sherlock Holmes</name>  <author>  <fname title=\"Sir\">Arthur</fname>  <mname>Conan</mname>  <lname>Doyle</lname>  </author>  <bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year>  <!--Price: $10-->  </book>`;  io:println(bookXML/<author>/<fname>);  io:println(bookXML/<ISBN>/<code>);  io:println(bookXML/<author>/<fname>.title);  io:println(bookXML/**/<fname>);  io:println(bookXML/*);  io:println(bookXML/<*>);  xmlns \"http://ballerina.com/a\" as bar;  io:println(bookXML/<bar:*>/*); xml seq = bookXML/*;  io:println(seq.<name>);  io:println(seq.<bar:year>); }    XML Access  XML elements can contain child XML items. Ballerina allows you to access these  child elements conveniently using XML step expressions and XML filter expressions.    import ballerina/io;    public function main() {    xml bookXML = xml `<book>  <name>Sherlock Holmes</name>  <author>  <fname title=\"Sir\">Arthur</fname>  <mname>Conan</mname>  <lname>Doyle</lname>  </author>  <bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year>  <!--Price: $10-->  </book>`;  The XML element with nested children.   io:println(bookXML/<author>/<fname>);    You can access child XML items using XML step expressions.   io:println(bookXML/<ISBN>/<code>);    Accessing a non-existing child will return an empty xml sequence.   io:println(bookXML/<author>/<fname>.title);    You can also retrieve attributes of the resulting child XML.   io:println(bookXML/**/<fname>);    You can match descendant elements using the following stepping access syntax.   io:println(bookXML/*);    Select all the children elements using the below syntax.   io:println(bookXML/<*>);    Select all children elements using the bellow syntax.   xmlns \"http://ballerina.com/a\" as bar;  io:println(bookXML/<bar:*>/*);    Select all the children belonging to a specific namespace.   xml seq = bookXML/*;    io:println(seq.<name>);  io:println(seq.<bar:year>); }    XML sequences can be filtered using XML filter expressions.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run xml-access.bal <fname title=\"Sir\">Arthur</fname>    Sir <fname title=\"Sir\">Arthur</fname>    <name>Sherlock Holmes</name>  <author>  <fname title=\"Sir\">Arthur</fname>  <mname>Conan</mname>  <lname>Doyle</lname>  </author>  <bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year>  <!--Price: $10-->    <name>Sherlock Holmes</name><author>  <fname title=\"Sir\">Arthur</fname>  <mname>Conan</mname>  <lname>Doyle</lname>  </author><bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year> 2019 <name>Sherlock Holmes</name> <bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year>"},{"page":"/learn/by-example/xa-transactions.html","name":"XA Transactions","summary":"Ballerina XA transactions are used when the transaction is happening over\n two or more databases. This example uses two H2 DBs (these\n are created when executing the example). Before running the example,\n change the DB connection properties as required.\n Ballerina transactions are at the experimental stage.\n Therefore, use  the ...","content":"/  /  / XA Transactions  import ballerina/io; import ballerinax/java.jdbc; jdbc:Client testDB1 = new ({  url: \"jdbc:h2:file:./xa-transactions/Testdb1\",  username: \"test\",  password: \"test\",  poolOptions: {isXA: true} }); jdbc:Client testDB2 = new ({  url: \"jdbc:h2:file:./xa-transactions/Testdb2\",  username: \"test\",  password: \"test\",  poolOptions: {isXA: true} });public function main() {  var ret = testDB1->update(\"CREATE TABLE CUSTOMER (ID INTEGER \" +  \"AUTO_INCREMENT, NAME VARCHAR(30))\");  handleUpdate(ret, \"Create CUSTOMER table\");  ret = testDB2->update(\"CREATE TABLE SALARY (ID INT, VALUE FLOAT)\");  handleUpdate(ret, \"Create SALARY table\");  transaction {  ret = testDB1->update(\"INSERT INTO CUSTOMER(NAME) \" +  \"VALUES ('Anne')\");  int key = -1;  if (ret is jdbc:UpdateResult) {  int count = ret.updatedRowCount;  key = <int>ret.generatedKeys[\"ID\"];  io:println(\"Inserted row count: \", count);  io:println(\"Generated key: \", key);  } else {  io:println(\"Insert to student table failed: \",  <string>ret.detail()?.message);  }  ret = testDB2->update(\"INSERT INTO SALARY (ID, VALUE) VALUES (?, ?)\",  key, 2500);  handleUpdate(ret, \"Insert to SALARY table\");  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  }  ret = testDB1->update(\"DROP TABLE CUSTOMER\");  handleUpdate(ret, \"Drop Table CUSTOMER\"); ret = testDB2->update(\"DROP TABLE SALARY\");  handleUpdate(ret, \"Drop Table SALARY\"); } function handleUpdate(jdbc:UpdateResult|error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    XA Transactions  Ballerina XA transactions are used when the transaction is happening over  two or more databases. This example uses two H2 DBs (these  are created when executing the example). Before running the example,  change the DB connection properties as required.  Ballerina transactions are at the experimental stage.  Therefore, use the –experimental flag to enable them.    import ballerina/io; import ballerinax/java.jdbc;    jdbc:Client testDB1 = new ({  url: \"jdbc:h2:file:./xa-transactions/Testdb1\",  username: \"test\",  password: \"test\",  poolOptions: {isXA: true} });    JDBC Client for the first H2 database. Since this Client  participates in a distributed transaction, the isXA property should be true.   jdbc:Client testDB2 = new ({  url: \"jdbc:h2:file:./xa-transactions/Testdb2\",  username: \"test\",  password: \"test\",  poolOptions: {isXA: true} });    JDBC Client for the second H2 database. Since this endpoint  participates in a distributed transaction, the isXA property should be true.   public function main() {    var ret = testDB1->update(\"CREATE TABLE CUSTOMER (ID INTEGER \" +  \"AUTO_INCREMENT, NAME VARCHAR(30))\");  handleUpdate(ret, \"Create CUSTOMER table\");    Create the table named CUSTOMER in the first database.   ret = testDB2->update(\"CREATE TABLE SALARY (ID INT, VALUE FLOAT)\");  handleUpdate(ret, \"Create SALARY table\");    Create the table named SALARY in the second database.   transaction {    Start the transaction.   ret = testDB1->update(\"INSERT INTO CUSTOMER(NAME) \" +  \"VALUES ('Anne')\");  int key = -1;  if (ret is jdbc:UpdateResult) {  int count = ret.updatedRowCount;  key = <int>ret.generatedKeys[\"ID\"];  io:println(\"Inserted row count: \", count);  io:println(\"Generated key: \", key);  } else {  io:println(\"Insert to student table failed: \",  <string>ret.detail()?.message);  }    This is the first remote function to participate in the transaction. It inserts  the customer name to the first DB and gets the generated key.   ret = testDB2->update(\"INSERT INTO SALARY (ID, VALUE) VALUES (?, ?)\",  key, 2500);  handleUpdate(ret, \"Insert to SALARY table\");  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  }    This is the second remote function to participate in the transaction. It inserts the  salary info to the second DB along with the key generated in the first DB.   ret = testDB1->update(\"DROP TABLE CUSTOMER\");  handleUpdate(ret, \"Drop Table CUSTOMER\");    Drop the tables created for this sample.   ret = testDB2->update(\"DROP TABLE SALARY\");  handleUpdate(ret, \"Drop Table SALARY\"); }    function handleUpdate(jdbc:UpdateResult|error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run --experimental xa_transactions.bal Create CUSTOMER table status: 0 Create SALARY table status: 0 2019-12-16 10:25:35,658 INFO [ballerina/transactions] - Created transaction: ab7cc71e-30f0-45ac-982e-01e0a0e39875 Inserted row count: 1 Generated key: 1 Insert to SALARY table status: 1 2019-12-16 10:25:35,672 INFO [ballerina/transactions] - Running 2-phase commit for transaction: ab7cc71e-30f0-45ac-982e-01e0a0e39875:$anon$.$0 Transaction committed Drop Table CUSTOMER status: 0 Drop Table SALARY status: 0 [ballerina/http] started HTTP/WS listener 10.100.7.118:52159 [ballerina/http] stopped HTTP/WS listener 10.100.7.118:52159"},{"page":"/learn/by-example/xml-attributes.html","name":"XML Attributes","summary":"XML elements may have any number of attributes and any number\n of namespace declarations that apply for that element.\n In Ballerina, both of these types are treated the same.\n XML attribute access in Ballerina is lax-typed similar\n to json, we can use field access expression (.) and\n optional field access ...","content":"/  /  / XML Attributes  import ballerina/io; import ballerina/lang.'xml as xmllib;xmlns \"http://ballerina.com/aa\" as ns0;public function main() {  xmllib:Element x1 = <xmllib:Element> xml `<ns0:book ns0:status=\"available\" count=\"5\"/>`;  io:println(x1);  io:println(x1.ns0:status);  string|error count = x1.count;  io:println(count);  string|error count2 = x1.count2;  io:println(count2 is error);  map<string> attributeMap = x1.getAttributes();  io:println(attributeMap);  string? s = attributeMap[\"{http://ballerina.com/aa}status\"];  io:println(s);  attributeMap[ns0:status] = \"Not Available\";  io:println(x1.ns0:status); }    XML Attributes  XML elements may have any number of attributes and any number  of namespace declarations that apply for that element.  In Ballerina, both of these types are treated the same.  XML attribute access in Ballerina is lax-typed similar  to json, we can use field access expression (.) and  optional field access expressions (`?.) to access the  attribute of an XML value.    import ballerina/io; import ballerina/lang.'xml as xmllib;    xmlns \"http://ballerina.com/aa\" as ns0;    public function main() {    xmllib:Element x1 = <xmllib:Element> xml `<ns0:book ns0:status=\"available\" count=\"5\"/>`;  io:println(x1);    Creates an XML element, which has attributes that are bound to a namespace as well as ones that are not.   io:println(x1.ns0:status);    A single attribute that is bound to a namespace can be accessed using its qualified name.   string|error count = x1.count;  io:println(count);    Attribute access expressions are lax typed.   string|error count2 = x1.count2;  io:println(count2 is error);    Accessing a non-existent attribute will return an error.   map<string> attributeMap = x1.getAttributes();  io:println(attributeMap);    It is possible to get all the attributes of an xml element.   string? s = attributeMap[\"{http://ballerina.com/aa}status\"];  io:println(s);    An attribute can also be accessed using the string representation of the qualified name from the attribute map.   attributeMap[ns0:status] = \"Not Available\";  io:println(x1.ns0:status); }    Update an attribute by updating the attribute map of an xml element.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run xml_attributes.bal <ns0:book xmlns:ns0=\"http://ballerina.com/aa\" ns0:status=\"available\" count=\"5\"/> available 5 true {http://www.w3.org/2000/xmlns/}ns0=http://ballerina.com/aa {http://ballerina.com/aa}status=available count=5 available Not Available"},{"page":"/learn/by-example/xml-functions.html","name":"XML Functions","summary":"Ballerina supports various built-in functions to manipulate XML content.Get the name of an XML element.Concatenate XML and string values.Get the number of XML items in a sequence.Get a subsequence of an XML sequence.Get all the element-type items in an XML sequence.Set the children elements of an XML element.Strip the insignificant ...","content":"/  /  / XML Functions  import ballerina/io; import ballerina/lang.'xml as xmllib;public function main() {  xml bookName = xml `<name>Book1</name>`;  xml bookComment = xml `<!--some comment-->`;  xml someText = xml `Hello, World!`;  xml content = someText + bookName + bookComment; xmllib:Element book = <xmllib:Element> xml `<book/>`;  xmllib:Element bookNameElem = <xmllib:Element> bookName;  io:println(bookNameElem.getName());  xml concat = xmllib:concat(someText, bookName, bookComment);  io:println(concat);  io:println(content == concat);  io:println(concat.length());  xml x = content.slice(2, 3);  io:println(x);  x = content.elements();  io:println(x);  book.setChildren(content);  io:println(book);  x = content.strip();  io:println(x); }    XML Functions  Ballerina supports various built-in functions to manipulate XML content.    import ballerina/io; import ballerina/lang.'xml as xmllib;    public function main() {  xml bookName = xml `<name>Book1</name>`;  xml bookComment = xml `<!--some comment-->`;  xml someText = xml `Hello, World!`;  xml content = someText + bookName + bookComment;    xmllib:Element book = <xmllib:Element> xml `<book/>`;    xmllib:Element bookNameElem = <xmllib:Element> bookName;  io:println(bookNameElem.getName());    Get the name of an XML element.   xml concat = xmllib:concat(someText, bookName, bookComment);  io:println(concat);  io:println(content == concat);    Concatenate XML and string values.   io:println(concat.length());    Get the number of XML items in a sequence.   xml x = content.slice(2, 3);  io:println(x);    Get a subsequence of an XML sequence.   x = content.elements();  io:println(x);    Get all the element-type items in an XML sequence.   book.setChildren(content);  io:println(book);    Set the children elements of an XML element.   x = content.strip();  io:println(x); }    Strip the insignificant parts of an XML value.  Comment items, processing instruction items are considered insignificant.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run xml_functions.bal    name Hello, World!<name>Book1</name><!--some comment--> true 3 <!--some comment--> <name>Book1</name> <book>Hello, World!<name>Book1</name><!--some comment--></book> Hello, World!<name>Book1</name>"},{"page":"/learn/by-example/xml-literal.html","name":"XML Literal","summary":"Ballerina allows you to define XML as part of the language\n and syntactically validates it. You can insert expressions into\n  the XML literal to pass values dynamically at runtime.A complex XML defined using the literal syntax, which contains nested elements of different types.Defines namespaces. These are visible to all ...","content":"/  /  / XML Literal  import ballerina/io;public function main() {  xml x1 = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  io:println(x1);  xmlns \"http://ballerina.com/\";  xmlns \"http://ballerina.com/aa\" as ns0;  xml x2 = xml `<book ns0:status=\"available\">  <ns0:name>Sherlock Holmes</ns0:name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  io:println(x2);  string title = \"(Sir)\"; xml x3 = xml `<ns0:newBook>  <name>Sherlock Holmes</name>  <author>${title} Arthur Conan Doyle</author>  <!--Price: $${ 40 / 5 + 4 }-->  </ns0:newBook>`;  io:println(x3); }    XML Literal  Ballerina allows you to define XML as part of the language  and syntactically validates it. You can insert expressions into  the XML literal to pass values dynamically at runtime.    import ballerina/io;    public function main() {    xml x1 = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  io:println(x1);    A complex XML defined using the literal syntax, which contains nested elements of different types.   xmlns \"http://ballerina.com/\";  xmlns \"http://ballerina.com/aa\" as ns0;    Defines namespaces. These are visible to all the XML literals defined from this point onwards.   xml x2 = xml `<book ns0:status=\"available\">  <ns0:name>Sherlock Holmes</ns0:name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  io:println(x2);    Creates an XML element. Previously-defined namespaces will be added to the element.  The defined prefixes can be applied to elements and attributes inside the element.   string title = \"(Sir)\";    XML can be interpolated with expressions using the ${} notation.  The expression can be a previously-defined variable, arithmetic expressions, or even a function call.  These expressions are evaluated at runtime.   xml x3 = xml `<ns0:newBook>  <name>Sherlock Holmes</name>  <author>${title} Arthur Conan Doyle</author>  <!--Price: $${ 40 / 5 + 4 }-->  </ns0:newBook>`;  io:println(x3); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run xml_literal.bal <book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book> <book xmlns=\"http://ballerina.com/\" xmlns:ns0=\"http://ballerina.com/aa\" ns0:status=\"available\">  <ns0:name>Sherlock Holmes</ns0:name>  <author xmlns=\"http://ballerina.com/\">Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book> <ns0:newBook xmlns:ns0=\"http://ballerina.com/aa\">  <name xmlns=\"http://ballerina.com/\">Sherlock Holmes</name>  <author xmlns=\"http://ballerina.com/\">(Sir) Arthur Conan Doyle</author>  <!--Price: $12-->"},{"page":"/learn/by-example/xml-io.html","name":"XML I/O","summary":"This example demonstrates how XML content can be read from a file and written\n to a file using a character channel and the readXml() and writeXml() functions of the I/O API.Creates XML content from the string.Writes the content.Reads the content.Writes xml content to a given path.Creates a byte channel from ...","content":"/  /  / XML I/O  import ballerina/io; import ballerina/log;public function main() {  string filePath = \"./files/sample.xml\";  xml x1 = xml `<book>The Lost World</book>`;  io:println(\"Preparing to write xml file\");  var wResult = write(x1, filePath);  if (wResult is error) {  log:printError(\"Error occurred while writing xml: \", wResult);  } else {  io:println(\"Preparing to read the content written\");  var rResult = read(filePath);  if (rResult is xml) {  io:println(rResult);  } else {  log:printError(\"Error occurred while reading xml: \", rResult);  }  } } function write(xml content, string path) returns @tainted error? {  io:WritableByteChannel wbc = check io:openWritableFile(path);  io:WritableCharacterChannel wch = new (wbc, \"UTF8\");  var result = wch.writeXml(content);  closeWc(wch);  return result; } function read(string path) returns @tainted xml|error {  io:ReadableByteChannel rbc = check io:openReadableFile(path);  io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");  var result = rch.readXml();  closeRc(rch);  return result; } function closeRc(io:ReadableCharacterChannel rc) {  var result = rc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } } function closeWc(io:WritableCharacterChannel wc) {  var result = wc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    XML I/O  This example demonstrates how XML content can be read from a file and written  to a file using a character channel and the readXml() and writeXml() functions of the I/O API.    import ballerina/io; import ballerina/log;    public function main() {  string filePath = \"./files/sample.xml\";    xml x1 = xml `<book>The Lost World</book>`;  io:println(\"Preparing to write xml file\");    Creates XML content from the string.   var wResult = write(x1, filePath);  if (wResult is error) {  log:printError(\"Error occurred while writing xml: \", wResult);  } else {  io:println(\"Preparing to read the content written\");    Writes the content.   var rResult = read(filePath);  if (rResult is xml) {  io:println(rResult);  } else {  log:printError(\"Error occurred while reading xml: \", rResult);  }  } }    Reads the content.   function write(xml content, string path) returns @tainted error? {    Writes xml content to a given path.   io:WritableByteChannel wbc = check io:openWritableFile(path);    Creates a byte channel from the given path.   io:WritableCharacterChannel wch = new (wbc, \"UTF8\");  var result = wch.writeXml(content);    Derives the character channel from the byte channel.   closeWc(wch);  return result; }    Closes the character channel once you are done with it.   function read(string path) returns @tainted xml|error {    Reads xml from a given path.   io:ReadableByteChannel rbc = check io:openReadableFile(path);    Creates a byte channel from the given path.   io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");    Derives the character channel from the byte Channel.   var result = rch.readXml();    Reads the XML content from the character channel.   closeRc(rch);  return result; }    Closes the character channel once you are done with it.   function closeRc(io:ReadableCharacterChannel rc) {  var result = rc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    Closes a readable channel.   function closeWc(io:WritableCharacterChannel wc) {  var result = wc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    Closes a writable channel.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run xml_io.bal Preparing to write xml file Preparing to read the content written <book>The Lost World</book>"},{"page":"/learn/by-example/xml-namespaces.html","name":"XML Namespaces","summary":"Ballerina has built-in support for defining and using XML namespaces.Namespaces can be declared at the module level as well as at the function level. The identifier followed by the\n as keyword is the prefix bound to this namespace name.Namespaces can be declared without the prefix. This will define a default ...","content":"/  /  / XML Namespaces  import ballerina/io;xmlns \"http://ballerina.com/aa\" as ns0;public function main() {  xmlns \"http://ballerina.com/bb\" as ns1;  xmlns \"http://ballerina.com/default\";  io:println(ns0:foo);  xmlns \"http://ballerina.com/updated\" as ns0;  io:println(ns0:foo); }    XML Namespaces  Ballerina has built-in support for defining and using XML namespaces.    import ballerina/io;    xmlns \"http://ballerina.com/aa\" as ns0;    public function main() {    xmlns \"http://ballerina.com/bb\" as ns1;    Namespaces can be declared at the module level as well as at the function level. The identifier followed by the  as keyword is the prefix bound to this namespace name.   xmlns \"http://ballerina.com/default\";    Namespaces can be declared without the prefix. This will define a default namespace.   io:println(ns0:foo);    Namespaces can be used for XML-qualified names.   xmlns \"http://ballerina.com/updated\" as ns0;  io:println(ns0:foo); }    Module level namespaces can be overridden at the function level.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run xml_namespaces.bal {http://ballerina.com/aa}foo {http://ballerina.com/updated}foo"},{"page":"/learn/by-example/xml.html","name":"XML","summary":"The XML type in Ballerina represents a sequence of zero or more XML items.\n Each item can be an element, a text, a comment, or a processing instruction.The XML element. There can be only one root element.The XML text.The XML comment.The XML processing instructions.Multiple XML items can be combined to ...","content":"/  /  / XML  import ballerina/io;public function main() {  xml x1 = xml `<book>The Lost World</book>`;  io:println(x1);  xml x2 = xml `Hello, world!`;  io:println(x2);  xml x3 = xml `<!--I am a comment-->`;  io:println(x3);  xml x4 = xml `<?target data?>`;  io:println(x4);  xml x5 = x1 + x2 + x3 + x4;  io:println(\"\\nResulting XML sequence:\");  io:println(x5); }    XML  The XML type in Ballerina represents a sequence of zero or more XML items.  Each item can be an element, a text, a comment, or a processing instruction.    import ballerina/io;    public function main() {    xml x1 = xml `<book>The Lost World</book>`;  io:println(x1);    The XML element. There can be only one root element.   xml x2 = xml `Hello, world!`;  io:println(x2);    The XML text.   xml x3 = xml `<!--I am a comment-->`;  io:println(x3);    The XML comment.   xml x4 = xml `<?target data?>`;  io:println(x4);    The XML processing instructions.   xml x5 = x1 + x2 + x3 + x4;  io:println(\"\\nResulting XML sequence:\");  io:println(x5); }    Multiple XML items can be combined to form a sequence of XML. The resulting sequence is another XML on its own.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. $ ballerina run xml.bal <book>The Lost World</book> Hello, world! <!--I am a comment--> <?target data?>    Resulting XML sequence: <book>The Lost World</book>Hello, world!<!--I am a comment--><?target data?>"},{"page":"/learn/by-example/xslt-transformation.html","name":"XSLT Transformation","summary":"This example demonstrates how the XML content can be transformed to HTML using a given XSL transformation.Gets an XML object, which needs to be transformed.Gets an XSL style sheet represented in an XML object.Transforms the XML to another formats.Returns an XML object, which needs to be transformed.Returns an XSL style ...","content":"/  /  / XSLT Transformation  import ballerina/io; import ballerina/xslt;public function main() {  xml sourceXml = getXml();  xml xsl = getXsl();  xml|error target = xslt:transform(sourceXml, xsl);  if (target is xml) {  io:println(\"Transformed xml : \", target);  } else {  io:print(\"Error : \", target);  } } function getXml() returns xml {  return xml `<samples>  <song>  <title>Summer of 69</title>  <artist>Bryan Adams</artist>  <country>Canada</country>  <year>1984</year>  </song>  <song>  <title>Zombie</title>  <artist>Bad Wolves</artist>  <country>USA</country>  <year>2018</year>  </song>  </samples>`; } function getXsl() returns xml {  return xml `<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">  <xsl:template match=\"/\">  <html>  <body>  <h2>All time favourites</h2>  <table border=\"1\">  <tr bgcolor=\"#9acd33\">  <th>Title</th>  <th>Artist</th>  </tr>  <xsl:for-each select=\"samples/song\">  <tr>  <td>  <xsl:value-of select=\"title\"/>  </td>  <td>  <xsl:value-of select=\"artist\"/>  </td>  </tr>  </xsl:for-each>  </table>  </body>  </html>  </xsl:template>  </xsl:stylesheet>`; }    XSLT Transformation  This example demonstrates how the XML content can be transformed to HTML using a given XSL transformation.    import ballerina/io; import ballerina/xslt;    public function main() {    xml sourceXml = getXml();    Gets an XML object, which needs to be transformed.   xml xsl = getXsl();    Gets an XSL style sheet represented in an XML object.   xml|error target = xslt:transform(sourceXml, xsl);  if (target is xml) {  io:println(\"Transformed xml : \", target);  } else {  io:print(\"Error : \", target);  } }    Transforms the XML to another formats.   function getXml() returns xml {  return xml `<samples>  <song>  <title>Summer of 69</title>  <artist>Bryan Adams</artist>  <country>Canada</country>  <year>1984</year>  </song>  <song>  <title>Zombie</title>  <artist>Bad Wolves</artist>  <country>USA</country>  <year>2018</year>  </song>  </samples>`; }    Returns an XML object, which needs to be transformed.   function getXsl() returns xml {  return xml `<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">  <xsl:template match=\"/\">  <html>  <body>  <h2>All time favourites</h2>  <table border=\"1\">  <tr bgcolor=\"#9acd33\">  <th>Title</th>  <th>Artist</th>  </tr>  <xsl:for-each select=\"samples/song\">  <tr>  <td>  <xsl:value-of select=\"title\"/>  </td>  <td>  <xsl:value-of select=\"artist\"/>  </td>  </tr>  </xsl:for-each>  </table>  </body>  </html>  </xsl:template>  </xsl:stylesheet>`; }    Returns an XSL style sheet represented in an XML object.   # To run this sample, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command. $ ballerina run xslt_transformation.bal Transformed xml : <html> <body> <h2>All time favourites</h2> <table border=\"1\"> <tr bgcolor=\"#9acd33\"> <th>Title</th><th>Artist</th> </tr> <tr> <td>Summer of 69</td><td>Bryan Adams</td> </tr> <tr> <td>Zombie</td><td>Bad Wolves</td> </tr> </table> </body> </html>"},{"page":"/learn/cli-commands/","name":"CLI Commands","summary":"The “ballerina” command is your one-stop-shop for all the things you do in Ballerina. You can use it in the below format.ballerina <THE-COMMAND> <ITS-ARGUEMENTS>The below are all the actions you can perform with it:These commands help you check your installation and know that things are set up smoothly.These everyday commands ...","content":"/  / CLI Commands  CLI Commands  The “ballerina” command is your one-stop-shop for all the things you do in Ballerina. You can use it in the below format.  ballerina <THE-COMMAND> <ITS-ARGUEMENTS>  The below are all the actions you can perform with it:    Get started These commands help you check your installation and know that things are set up smoothly.    version Tells you the version of Ballerina you have installed.   home Prints out the location of your current Ballerina distribution. This is useful if you need to help your IDE plugin to figure out where Ballerina is.     Build, test, and run programs  These everyday commands are your best friends! They address the very basics of programming in Ballerina such as compiling, running, testing programs, and generating their documentation.    build Compile a Ballerina program, a single BAL file, an entire project, or a single root module into an executable JAR file.    test Run tests of a particular module or all the modules of a Ballerina project. For more information, see .    run Build and run a Ballerina program, a single BAL file, an entire project, or a previously-built program. For more information, see .    clean Clean all artifacts generated by the build command for a project.    doc Generate API documents for all public symbols of a Ballerina module or project. For more information, see .    format Format Ballerina source files as per the .    Work with Ballerina Central  Ballerina Central is how you share Ballerina modules with others in a safe, secure, and dependable way.    search Search Ballerina Central for modules.    pull Pull a module from Ballerina Central.    push Upload a module to Ballerina Central. For more information, see .     Manage projects  Ballerina projects are the way to organize real world Ballerina development tasks.    new Create a Ballerina project. For more information, see .     Use the supporting tools  These powerful supporting tools extend Ballerina to various ecosystem technologies that are inherently cloud-native. This functionality will grow over time and will even be developer extensible in the future.    encrypt Use this tool to encrypt sensitive data and pass them to a Ballerina program via the configuration system.    openapi This is the OpenAPI (Swagger) stub/skeleton generation tool. For more information, see .   grpc This is the gRPC stub/skeleton generation tool. For more information, see ."},{"page":"/learn/how-to-deploy-ballerina-programs-in-cloud/","name":"How to Deploy Ballerina Programs and Services in the Cloud","summary":"Deploying a Ballerina program or service is the process of creating assets that ready the program and services(s) for activation in another runtime, such as Docker Engine, Moby, Kubernetes, or Cloud Foundry. The Ballerina compiler is able to generate the necessary artifacts for different deployment annotations based upon annotations that ...","content":"/  / How to Deploy Ballerina Programs in the Cloud  How to Deploy Ballerina Programs and Services in the Cloud  Deploying a Ballerina program or service is the process of creating assets that ready the program and services(s) for activation in another runtime, such as Docker Engine, Moby, Kubernetes, or Cloud Foundry. The Ballerina compiler is able to generate the necessary artifacts for different deployment annotations based upon annotations that decorate the source code, which provide compiler instructions for artifact generation.  How Deployment Works Ballerina has builder extensions that run after the compilation phase. These extensions analyze code to generate deployment artifacts and utilities to make deployment of your apps and services easier.  When you start building a project, the system starts parsing. This is followed by dependency analysis, compilation, and a phase at which deployment artifact generation can take place.  These deployment artifacts can be a form of simple files or complex types, like container images, virtual images, etc. The Ballerina builder extension supports the following list of deployment artifacts.    It is possible for third parties and the ecosystem to create their own annotations and builder extensions that generate different kinds of deployment artifacts. You can publish these extensions within Ballerina Central for others to use.  How to Enable Deployment A developer enables deployment artifact generation by adding annotations to their Ballerina code:    Import the relevant extension module in the code.  Add relevant annotations within the code.  Build the Ballerina project.   Docker-Based Deployment  See the following example on how a developer can add Docker support in the code.  Add the following code to the hello_world_docker.bal file.  import ballerina/docker; import ballerina/http; import ballerina/log;  @http:ServiceConfig {  basePath: \"/helloWorld\" } @docker:Config {  registry: \"docker.abc.com\",  name: \"helloworld\",  tag: \"v1.0\" } service helloWorld on new http:Listener(9090) {  resource function sayHello(http:Caller caller, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello, World! \\n\");  var result = caller->respond(response);  if (result is error) {  log:printError(\"error sending response\", result);  }  } }   Now your code is ready to generate deployment artifacts. In this case it is a Docker image.  $ ballerina build hello_world_docker.bal Compiling source  hello_world_docker.bal Generating executables  hello_world_docker.jar  Generating docker artifacts...  @docker - complete 2/2 Run the following command to start a Docker container:  docker run -d -p 9090:9090 docker.abc.com/helloworld:v1.0   $ tree . ├── docker │ └── Dockerfile ├── hello_world_docker.bal └── hello_world_docker.jar  1 directory, 3 files  $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.abc.com/helloworld v1.0 154053b4e4cd About a minute ago 108MB   You can run a Docker container by copying and pasting the Docker run command that displays as output of the Ballerina build command. $ docker run -d -p 9090:9090 docker.abc.com/helloworld:v1.0 938761fa222fde551c5092b7f5fda2a72c3cd43178c7fd86f43f678ec5227d35   $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 938761fa222f docker.abc.com/helloworld:v1.0 \"/bin/sh -c 'java -j…\" 18 seconds ago Up 17 seconds 0.0.0.0:9090->9090/tcp brave_hamilton  Invoke the hello world service with a cURL command: $ curl http://localhost:9090/helloWorld/sayHello Hello, World!   The following features are supported by the Docker builder extension.    Dockerfile generation  Docker image generation  Docker push support with Docker registry  Docker-based Ballerina debug support  Copy file support   Supported Docker Annotations  @docker:Config{}   Supported by Ballerina services, listeners, or functions.     Annotation Name  Description  Default value  name  Name of the Docker image  File name of the generated .jar file  registry  Docker registry URL  None  tag  Docker image tag  latest  env  Environment variables of the Docker image  None  username  Username for the Docker registry  None  password  Password for the Docker registry  None  baseImage  Base image to create the Docker image  ballerina/jre8:v1  buildImage  Enable building the Docker image  true  push  Enable pushing the Docker image to the registry  false  enableDebug  Enable debugging for Ballerina  false  debugPort  Remote debug port  5005  dockerAPIVersion  Docker API Version  None  dockerHost  Docker host IP and Docker PORT. ( e.g., Minikube IP and Docker PORT)  DOCKER_HOST environment variable. If DOCKER_HOST is unavailable, use “unix:///var/run/docker.sock” for Unix or use “tcp://localhost:2375” for Windows  dockerCertPath  Docker certificate path  “DOCKER_CERT_PATH” environment variable  @docker:CopyFiles{}   Supported by Ballerina services, listeners, or functions.     Annotation Name  Description  Default value  sourceFile  Source path of the file (in your machine)  None  target  Target path (inside container)  None  isBallerinaConf  Flag whether the file is a Ballerina config file or not  false  @docker:Expose{}   Supported by Ballerina listeners.   For more information, see the .  Kubernetes-Based Deployment  The Kubernetes builder extension offers native support for running Ballerina programs on Kubernetes with the use of annotations that you can include as part of your service code. Also, it will take care of the creation of the Docker images, so you don’t need to explicitly create Docker images prior to deployment on Kubernetes.  The following Kubernetes configurations are supported:   Kubernetes deployment support  Kubernetes service support  Kubernetes liveness probe support  Kubernetes readiness probe support  Kubernetes ingress support  Kubernetes horizontal pod autoscaler support  Docker image generation  Docker push support with remote Docker registry  Kubernetes secret support  Kubernetes config map support  Kubernetes persistent volume claim support  Kubernetes resource quotas  Istio gateways support  Istio virtual services support  OpenShift build config and image stream support  OpenShift route support   The following Ballerina code section explains how you can use some of these Kubernetes capabilities by using Kubernetes annotation support in Ballerina.  import ballerina/config; import ballerina/http; import ballerina/kubernetes; import ballerina/log;  @kubernetes:Ingress {  hostname: \"ballerina.guides.io\",  name: \"ballerina-guides-user-retrieval-ingress\" } @kubernetes:Service {  serviceType: \"NodePort\",  name: \"ballerina-guides-user-retrieval-service\" } listener http:Listener userRetrievalEP = new (9090, config = {  secureSocket: {  keyStore: {  path: \"./security/ballerinaKeystore.p12\",  password: config:getAsString(\"keystore-password\")  }  } });  @kubernetes:ConfigMap {  conf: \"service-config.toml\" } @kubernetes:Deployment {  image: \"ballerina.guides.io/user_retrieval_service:v1.0\",  name: \"ballerina-guides-user-retrieval-service\" } @http:ServiceConfig {  basePath: \"/users\" } service userRetrievalService on userRetrievalEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/{userId}\"  }  resource function getUserInfo(http:Caller caller, http:Request request, string userId) {  string name = config:getAsString(string `${<@untainted>userId}.name`);  string email = config:getAsString(string `${<@untainted>userId}.email`);   // check if user exists  json payload = { message: \"user not found\" };  if (name != \"\" && email != \"\") {  payload = { name: name, email: email  };  }   var responseResult = caller->respond(payload);  if (responseResult is error) {  log:printError(\"error responding back to client.\", responseResult);  }  } }   Sample content of service-config.toml:  keystore-password=\"ballerina\"  [john] name=\"John Doe\" email=\"john@ballerina.com\"  [jane] name=\"Jane Doe\" email=\"jane@ballerina.com\"   Here, @kubernetes:Deployment is used to specify the Docker image name, which will be created as part of building this service.  The @kubernetes:Service {} annotation will create a Kubernetes service that will expose the Ballerina service running on a Pod.  In addition, you can use @kubernetes:Ingress, which is the external interface to access your service (with path / and host name ballerina.guides.io).  Minikube users please see the for additional configurations required for Minikube.  Create a folder called security and copy the . This is to secure the endpoint of the service.  Now you can use the following command to build the Ballerina service that we developed above. This will also create the corresponding Docker image and the Kubernetes artifacts using the Kubernetes annotations that you have configured above.  $ ballerina build user_retrieval_service.bal Compiling source  user_retrieval_service.bal  Generating executables  user_retrieval_service.jar  Generating artifacts...   @kubernetes:Service - complete 1/1  @kubernetes:Ingress - complete 1/1  @kubernetes:Secret - complete 1/1  @kubernetes:ConfigMap - complete 1/1  @kubernetes:Deployment - complete 1/1  @kubernetes:Docker - complete 2/2 @kubernetes:Helm - complete 1/1   Run the following command to deploy the Kubernetes artifacts: kubectl apply -f ./kubernetes   Run the following command to install the application using Helm: helm install --name ballerina-guides-user-retrieval-service ./kubernetes/ballerina-guides-user-retrieval-service    You can use the docker images command to verify that the Docker image specified in the @kubernetes:Deployment was created. The Kubernetes artifacts related to your service will be generated in addition to the .jar file.  $ tree ├── service-config.toml ├── user_retrieval_service.bal ├── user_retrieval_service.jar ├── security │ └── ballerinaKeystore.p12 ├── docker │ └── Dockerfile ├── kubernetes │ ├── ballerina-guides-user-retrieval-service │ │ ├── Chart.yaml │ │ └── templates │ │ └── user_retrieval_service.yaml │ └── user_retrieval_service.yaml    Now, you can create the Kubernetes deployment using:  $ kubectl apply -f ./kubernetes service/ballerina-guides-user-retrieval-service created ingress.extensions/ballerina-guides-user-retrieval-ingress created secret/userretrievalep-keystore created configmap/userretrievalservice-ballerina-conf-config-map created deployment.apps/ballerina-guides-user-retrieval-service created  You can verify Kubernetes deployment, service, and ingress are running properly by using the following Kubernetes commands.  $ kubectl get pods NAME READY STATUS RESTARTS AGE ballerina-guides-user-retrieval-service-7cfd8b6874-nkdw9 1/1 Running 0 4s  This is the container based on the deployment annotation. This container has the .jar file, secrets, config-maps, and dependencies wrapped within.  $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ballerina-guides-user-retrieval-service NodePort 10.96.96.140 <none> 9090:31417/TCP  This is the Kubernetes service that exposes the listener endpoint.  $ kubectl get ingress NAME HOSTS ADDRESS PORTS AGE ballerina-guides-user-retrieval-ingress ballerina.guides.io localhost 80, 443 38s  This is the Kubernetes nginx rule that exposes the hostname to the outside world.  $ kubectl get secrets NAME TYPE DATA AGE userretrievalep-keystore Opaque 1 3m45s  The secrets are generated automatically for endpoint keystores.  $ kubectl get configmap NAME DATA AGE userretrievalservice-ballerina-conf-config-map 1 4m38s  This is the config-map created for the service-config.toml file, as the conf: \"service-config.toml\" attribute is used. At run time, it is equivalent to: $ ballerina run user_retrieval_service.jar --b7a.config.file=service-config.toml The Kubernetes extension automatically passes the config file to the Ballerina program.  If everything is successfully deployed, you can invoke the service either via Node port or ingress.  Access via Node Port: $ curl -k https://localhost:31417/users/john {\"name\":\"John Doe\", \"email\":\"john@ballerina.com\"}   Access via Ingress:  Add an /etc/hosts entry to match hostname.  127.0.0.1 ballerina.guides.io   Setup the NGINX Ingress Controller.  kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.27.0/deploy/static/mandatory.yaml kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.27.0/deploy/static/provider/cloud-generic.yaml kubectl patch deployments -n ingress-nginx nginx-ingress-controller -p '{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"nginx-ingress-controller\",\"args\":[\"\\/nginx-ingress-controller\",\"--configmap=$(POD_NAMESPACE)\\/nginx-configuration\",\"--tcp-services-configmap=$(POD_NAMESPACE)\\/tcp-services\",\"--udp-services-configmap=$(POD_NAMESPACE)\\/udp-services\",\"--publish-service=$(POD_NAMESPACE)\\/ingress-nginx\",\"--annotations-prefix=nginx.ingress.kubernetes.io\",\"--annotations-prefix=nginx.ingress.kubernetes.io\",\"--enable-ssl-passthrough\"]}]}}}}'   Access the service:  $ curl -kv https://ballerina.guides.io/users/jane {\"name\":\"Jane Doe\", \"email\":\"jane@ballerina.com\"}   Supported Kubernetes Annotations  @kubernetes:Deployment{}   Supported with Ballerina services, listeners and functions.     Annotation Name  Description  Default value  name  Name of the deployment  -deployment or -deployment  labels  Labels for deployment  { app: }  annotations  Annotations for deployment  {}  dockerHost  Docker host IP and Docker PORT.(e.g “tcp://192.168.99.100:2376”)  DOCKER_HOST environment variable. If DOCKER_HOST is unavailable, use “unix:///var/run/docker.sock” for Unix or use “npipe:////./pipe/docker_engine” for Windows 10 or uses “localhost:2375”  dockerCertPath  Docker cert path  DOCKER_CERT_PATH environment variable  registry  Docker registry URL  null  username  Username for the Docker registry  null  password  Password for the Docker registry  null  baseImage  Base image to create the Docker image  ballerina/jre8:v1  image  Docker image with tag  :latest. If field `registry` is set ,then it will be prepended to the Docker image name as /:latest  buildImage  Building the Docker image  true  push  Push the Docker image to registry. This will be effective if the buildImage field of the image is true  false  copyFiles  Copy external files of the Docker image  null  singleYAML  Generate a single YAML file for all K8s resources  true  namespace  Namespace of the deployment  null  replicas  Number of replicas  1  livenessProbe  Enable or disable liveness probe  false  readinessProbe  Enable or disable readiness probe  false  imagePullPolicy  Docker image pull policy  IfNotPresent  env  List of environment variables  null  podAnnotations  Pod annotations  {}  podTolerations  Pod tolerations  {}  buildExtension  Extension for building Docker images and artifacts  null  dependsOn  Listeners on which this deployment depends  null  imagePullSecrets  Image pull secret’s value  null  strategy  Update strategy  null  @kubernetes:Service{}   Supported by Ballerina services and listeners.     Annotation Name  Description  Default value  name  Name of the Service  -service  labels  Labels for the service  { app: }  portName  Name for the port  The protocol of the listener  port  Service port  Port of the Ballerina service  targetPort  Target pod(s) port  Port of the Ballerina service  nodePort  NodePort to expose the service  None  sessionAffinity  Pod session affinity  None  serviceType  Service type of the service  ClusterIP  @kubernetes:Ingress{}   Supported by Ballerina services and listeners.     Annotation Name  Description  Default value  name  Name of the ingress  -ingress  labels  Labels for the service  { app: }  annotations  Map of additional annotations  null  hostname  Host name of the ingress  .com or .com  path  Resource path.  /  targetPath  This will use for rewriting the URL.  null  ingressClass  Ingress class  nginx  enableTLS  Enable ingress TLS  false  @kubernetes:HPA{}   Supported by Ballerina services and functions.     Annotation Name  Description  Default value  name  Name of the Horizontal Pod Autoscaler  -hpa  labels  Labels for the service  { app: }  annotations  Map of annotations  null  minReplicas  Minimum number of replicas  Number of replicas in the deployment  maxReplicas  Maximum number of replicas  minReplicas + 1  cpuPrecentage  CPU percentage to start scaling  50  @kubernetes:Secret{}   Supported by Ballerina services and functions.     Annotation Name  Description  Default value  name  Name of the secret mount  -secret  labels  Labels for the service  { app: }  annotations  Map of annotations  null  mountPath  Path to mount on container  null  readOnly  Is mount read only  true  data  Paths to data files  null  @kubernetes:ConfigMap{}   Supported by Ballerina services and functions.     Annotation Name  Description  Default value  name  Name of the configmap volume mount  <service_name>-config-map  mountPath  Path to mount on container  null  readOnly  Is mount read only  true  ballerinaConf  Ballerina conf file location  null  data  Paths to data files  null  @kubernetes:PersistentVolumeClaim{}   Supported by Ballerina services and functions.     Annotation Name  Description  Default value  name  Name of the volume mount  null  mountPath  Path to mount on container  null  readOnly  Is mount read only  false  accessMode  Access mode  ReadWriteOnce  volumeClaimSize  Size of the volume claim  null  @kubernetes:Job{}   Supported with the Ballerina main() function.     Annotation Name  Description  Default value  name  Name of the job  -job or -job  labels  Labels for the job  { app: }  annotations  Metadata Annotations map  {}  dockerHost  Docker host IP and Docker PORT.(e.g “tcp://192.168.99.100:2376”)  DOCKER_HOST environment variable. If DOCKER_HOST is unavailable, use “unix:///var/run/docker.sock” for Unix or use “npipe:////./pipe/docker_engine” for Windows 10 or uses “localhost:2375”  dockerCertPath  Docker cert path  DOCKER_CERT_PATH environment variable  registry  Docker registry URL  null  username  Username for the Docker registry  null  password  Password for the Docker registry  null  baseImage  Base image to create the Docker image  ballerina/jre8:v1  image  Docker image with tag  :latest. If field `registry` is set, then it will be prepended to the Docker image name as /:latest  buildImage  Building the Docker image  true  push  Push the Docker image to registry. This will be effective if the buildImage field of the image is true  false  copyFiles  Copy external files for the Docker image  null  singleYAML  Generate a single YAML file for all K8s resources  true  namespace  Namespace for the Job  default  imagePullPolicy  Docker image pull policy  IfNotPresent  env  List of the environment variables  null  restartPolicy  Restart policy  Never  backoffLimit  Backoff limit  3  activeDeadlineSeconds  Active deadline seconds  20  schedule  Schedule for CRON jobs  none  imagePullSecrets  Image pull secret’s value  null  Extend Ballerina Deployment and Annotations Ballerina can be augmented with your own annotations that represent your own unique deployment artifacts. You can also write builder extensions that generate these files during compilation. Refer to the example at https://github.com/ballerinax/hello."},{"page":"/learn/how-to-extend-ballerina/","name":"How to Extend Ballerina","summary":"Annotations can be used to provide structured metadata about a particular construct. Annotations are not executable. However, they can be used to alter the behavior of constructs they are attached to.Annotations can be attached to:The Ballerina compiler can be extended using compiler extensions (if required) for additional verification or processing ...","content":"/  / How to Extend Ballerina  How to Extend Ballerina  Annotations can be used to provide structured metadata about a particular construct. Annotations are not executable. However, they can be used to alter the behavior of constructs they are attached to.  Annotations can be attached to:   services and resources  type definitions  function definitions  function parameters  function return  module-level variables and constants  annotations  listeners  workers  type cast expressions   The Ballerina compiler can be extended using compiler extensions (if required) for additional verification or processing (e.g. modifications, artifact generation etc.). Such custom extensions provided will be executed at the end of the compilation phase before generating the Ballerina Intermediate Representation (BIR). A compiler extension can make use of the metadata provided via annotations to introduce additional behavior to the compilation process.  The ballerina/docker and ballerina/kubernetes modules make use of custom annotations. They introduce new annotations such as @docker:Config and @kubernetes:Deployment that can be attached to certain constructs in a Ballerina source file. The respective compiler extensions then run a post-compilation process that reads these annotations and generates the Docker and Kubernetes deployment artifacts.    Note: Currently, there are two caveats when writing compiler extensions:  The Ballerina Compiler is written in Java 8. Therefore, you will need JDK 1.8.  End users will have to install the extension manually.  Hello World: The Annotation Way  In this guide, we will take a look at how to create a custom annotation and how to write a compiler extension to read and act upon our custom annotation. The custom annotation (i.e. @hello:Greeting) is attachable to functions. It has an attribute called salutation, which will be read by the compiler extension and written to a file when building the program. The annotation can be shared with others by publishing it to . Currently, there isn’t a mechanism for sharing compiler extensions. The compiler extension has to be copied to the <BALLERINA_HOME>/bre/lib directory.  The end user would be able to write a program such as the following:  import foo/hello;  @hello:Greeting {  salutation: \"Guten Tag!\" } function add(int x, int y) returns int {  return x + y; }  public function main() {  var sum = add(10, 20); }   At the end of the build, the user should be able to see a <module_name>.txt file in the target/greetings/ directory.  Defining a Custom Annotation  Creating the Annotation Create a new Ballerina project and add a module named hello. For this instance, add a single source file named annotation.bal and remove other boilerplate code and files. Your project structure should look similar to the following: . ├── Ballerina.toml └── src  └── hello  └── annotation.bal   Add the following code to define the @hello:Greeting annotation in the annotation.bal file.  # This record defines the fields of the @hello:Greeting annotation. # # + salutation - The greeting message public type HelloConfiguration record {|  string salutation = \"Hello!\"; |};  # Define an annotation named `Greeting`. Its type is `HelloConfiguration` and it can be # attached to functions. public annotation HelloConfiguration Greeting on function;   Now, build this annotation. The -c flag is used since this module will only be used as a library. $ ballerina build -c hello   If all went well, a /target directory should be created with the built artifacts. target/ ├── balo │ └── hello-2019r3-any-0.1.0.balo ├── caches │ ├── bir_cache │ │ └── foo │ │ └── hello │ │ └── 0.1.0 │ │ └── hello.bir │ └── jar_cache │ └── foo │ └── hello │ └── 0.1.0 │ └── foo-hello-0.1.0.jar └── tmp  └── foo-hello-0.1.0.jar   Verifying the Annotation  At this stage, you can use the annotation in a program to verify the correctness of what was done so far. To do so, create a demo project, add our hello module as a dependency, and attach it to a function. Your program should compile without any errors.  The demo project structure looks like the following: . ├── Ballerina.toml └── src  └── greet  └── greeting.bal   Add the foo/hello module as a path dependency in the Ballerina.toml file.  [project] org-name = \"bar\" version = \"0.1.0\"  [dependencies] \"foo/hello\" = { path = \"<path_to_annotation_project_dir>/hello-annot/target/balo/hello-2019r3-any-0.1.0.balo\" }   Add a function to the greeting.bal file. Note that the function is annotated using the @hello:Greeting annotation.  import foo/hello;  @hello:Greeting {  salutation: \"Guten Tag!\" } function add(int x, int y) returns int {  return x + y; }  public function main() {  var sum = add(10, 20); }   Building the greet module should produce an executable named greet.jar in the target/bin directory.  Writing the Compiler Extension  The Ballerina compiler can be extended through compiler extensions if there are additional verifications or tasks you would like to perform. Such custom extensions will be executed towards the end of the compilation phase. A compiler extension can be created by implementing the CompilerPlugin interface provided by the org.ballerinalang.compiler.plugins package. It defines the following methods, which the user can implement to add additional verifications.   void process(PackageNode packageNode)  void process(BLangTestablePackage testablePackageNode)  void process(ServiceNode serviceNode, List<AnnotationAttachmentNode> annotations)  void process(TypeDefinition typeDefinition, List<AnnotationAttachmentNode> annotations)  void process(FunctionNode functionNode, List<AnnotationAttachmentNode> annotations)  void process(SimpleVariableNode variableNode, List<AnnotationAttachmentNode> annotations)  void process(AnnotationNode annotationNode, List<AnnotationAttachmentNode> annotations)  void codeGenerated(PackageID packageID, Path binaryPath)   Each of the process() methods correspond to annotable constructs of the language. The codegenerated() method gets invoked once the code generation phase is completed. The org.ballerinalang.compiler.plugins package also provides a convenience class named AbstractCompilerPlugin with empty implementations for the above methods.  The extension will read the salutation field of the @hello:Greeting annotation and write its value to a file in the /target directory.  Setting up the Project  Start by creating a Java project for the extension. It needs two classes: HelloPlugin and HelloModel. Also, create a resource file named org.ballerinalang.compiler.plugins.CompilerPlugin in the resources/META-INF/services directory. This file should contain the fully-qualified class name of the extension class (which in this case, is xyz.foo.hello.HelloPlugin). src/ └── main  ├── java  │ └── xyz  │ └── foo  │ └── hello  │ ├── HelloModel.java  │ └── HelloPlugin.java  └── resources  └── META-INF  └── services  └── org.ballerinalang.compiler.plugins.CompilerPlugin   The only dependency you will need for this extension is the ballerina-lang project. Add the following Maven repository to your project to get the ballerina-lang dependency.   http://maven.wso2.org/nexus/content/repositories/releases/   Given below is a sample build.gradle file for the project.  plugins {  id 'java' }  group 'xyz.foo' version '1.0-SNAPSHOT'  sourceCompatibility = 1.8  repositories {  maven {  url \"http://maven.wso2.org/nexus/content/repositories/releases/\"  } }  dependencies {  implementation group: 'org.ballerinalang', name: 'ballerina-lang', version: '1.0.0' }   Adding the Code for the Extension  Add the following code to the HelloPlugin.java file.  import org.ballerinalang.compiler.plugins.AbstractCompilerPlugin; import org.ballerinalang.compiler.plugins.SupportedAnnotationPackages; import org.ballerinalang.model.elements.PackageID; import org.ballerinalang.model.tree.AnnotationAttachmentNode; import org.ballerinalang.model.tree.FunctionNode; import org.ballerinalang.util.diagnostic.Diagnostic; import org.ballerinalang.util.diagnostic.DiagnosticLog; import org.wso2.ballerinalang.compiler.tree.BLangAnnotationAttachment; import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral; import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral; import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral.BLangRecordKeyValue;  import java.io.File; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardOpenOption; import java.util.List;  /**  * Compiler extension to generate greetings.  */ // This annotation specifies that this compiler extension should only be enabled when the mentioned module is used. @SupportedAnnotationPackages(  value = \"foo/hello:0.1.0\" ) public class HelloPlugin extends AbstractCompilerPlugin {   private DiagnosticLog dlog;   @Override  public void init(DiagnosticLog diagnosticLog) {  this.dlog = diagnosticLog;  }   // The annotation is attached to functions. Therefore, the process() method is overridden for functions.  @Override  public void process(FunctionNode functionNode, List<AnnotationAttachmentNode> annotations) {  // Iterate through the annotations attached to the service.  for (AnnotationAttachmentNode annotation : annotations) {  // The `annotations` list contains all the annotations attached to the service.  // Since only the `@hello:Greeting` annotation is considered, skip the other annotations.  if (!\"Greeting\".equals(annotation.getAnnotationName().getValue())) {  continue;  }   // Retrieve the fields of the annotation value.  List<BLangRecordKeyValue> annotFields =  ((BLangRecordLiteral) ((BLangAnnotationAttachment) annotation).expr).getKeyValuePairs();   // In this particular case, there is no need to iterate through the list since the `@hello:Greeting` annotation only has  // one field. Therefore, take the first element of the fields list.  BLangRecordKeyValue salutationField = annotFields.get(0);  String annotFieldValue = ((BLangLiteral) salutationField.getValue()).getValue().toString();  String greeting = String.format(\"%s from %s()\\n\", annotFieldValue, functionNode.getName().getValue());  HelloModel.getInstance().setGreeting(greeting);  }  }   // The `codeGenerated()` method gets invoked once the executable is built. The greeting is written to a text file  // with the same name as the executable and in the same directory as the executable.  @Override  public void codeGenerated(PackageID packageID, Path binaryPath) {  String fileName = binaryPath.getFileName().toString().replace(\".jar\", \".txt\");  Path greetingsPath = Paths.get(\"target\", \"greetings\", fileName);  String greeting = HelloModel.getInstance().getGreetings();  try {  System.out.println(\"\\nGenerating greetings\");  System.out.println(\"\\t\" + greetingsPath.toString());  writeToFile(greeting, greetingsPath);  } catch (IOException e) {  dlog.logDiagnostic(Diagnostic.Kind.ERROR, null, e.getMessage());  }  }   private void writeToFile(String greetings, Path targetFilePath) throws IOException {  File newFile = targetFilePath.toFile();   if (newFile.exists()) {  Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);  return;  }   if (newFile.getParentFile().mkdirs()) {  Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8));  return;  }  Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8));  } }   Add the following code to the HelloModel.java file.  class HelloModel {   private static HelloModel instance = new HelloModel();  private String greeting;   private HelloModel() {  }   static HelloModel getInstance() {  return instance;  }   String getGreetings() {  return greeting;  }   void setGreeting(String greeting) {  this.greeting = greeting;  } }   Finally, build the extension and place the resulting JAR file inside the <BALLERINA_HOME>/distributions/jballerina-<BALLERINA_VERSION>/bre/lib/ directory.  Putting It All Together  Now, build your hello world project again. You should see an additional step logged in the console for generating the greeting.  $ ballerina build greet Compiling source \tbar/greet:0.1.0  Creating balos \ttarget/balo/greet-2019r3-any-0.1.0.balo  Running tests \tbar/greet:0.1.0 \tNo tests found  Generating executables \ttarget/bin/greet.jar  Generating greetings \ttarget/greetings/greet.txt   The target/greetings/greet.txt file should contain the following text: Guten Tag! from add()  Learning More About Writing Compiler Extensions  The example considered in this how-to guide is a basic compiler extension. If you are looking for something which goes beyond this, take a look at the compiler extensions written for generating Docker and Kubernetes artifacts."},{"page":"/learn/how-to-call-java-code-from-ballerina/","name":"How to Call Java Code from Ballerina","summary":"Ballerina offers a straightforward way to call the existing Java code from Ballerina and also provides a Java API to call Ballerina code from Java.  Although Ballerina is not designed to be a JVM language, the current implementation, which targets the JVM, aka jBallerina, provides Java interoperability by adhering ...","content":"/  / How to Call Java Code from Ballerina  How to Call Java Code from Ballerina  Introduction Ballerina offers a straightforward way to call the existing Java code from Ballerina and also provides a Java API to call Ballerina code from Java. Although Ballerina is not designed to be a JVM language, the current implementation, which targets the JVM, aka jBallerina, provides Java interoperability by adhering to the Ballerina language semantics.  Ballerina bindings to Java code Your task is to write Ballerina code (Ballerina bindings) that lets you call the corresponding Java API as illustrated in the below diagram.    This guide teaches you how to write those bindings manually as well as how to generate those bindings automatically but first, let’s look at why you want to call Java from Ballerina.  Why you want to call Java from Ballerina   Ballerina is a relatively new language. Therefore, you may experience a shortage of libraries in . In such situations, as a workaround, you can use an existing Java library.  You are already familiar with a stable Java API that you would like to use in your Ballerina project.  You want to take advantage of the strengths of Ballerina but you don’t want to reinvest in the libraries that you or your company have written already.   There may be other reasons but these are great motivations to use Ballerina bindings.  Writing Ballerina bindings Writing Ballerina bindings manually is a tedious task. You’ll soon see why. Therefore, we’ve developed a tool called bindgen that can generate Ballerina bindings for given Java APIs. The of this guide shows you how to use it. The is a reference guide to the tool.  The explains how to package Java libraries (JAR files) with Ballerina programs. This section is useful because whenever you generate bindings for a Java library, you need to package this Java library and its transitive dependencies to produce a self-contained executable program.  The and sections explain how to write these bindings manually. It is also a useful section for those who want to understand the inner workings of calling Java from Ballerina and for those who want to customize the bindings generated by the bindgen tool.  Overview   How to use SnakeYAML Java library in Ballerina SnakeYAML is a YAML parser for Java. In this section, we’ll learn how to use this library to parse a YAML document using Ballerina.  We’ll develop a Ballerina program that parses the given YAML file and writes the content to the standard out.  Let’s get started.  Step 1: Write the Java code We recommend you to always start by writing the Java code. It gives you an idea of the set of Java classes required to implement your logic. Then, we can use the bindgen tool to generate Ballerina bindings for those classes.  The following Java code uses the SnakeYAML API to parse the given YAML file. Note that this is not the most idiomatic way of writing the Java code for this scenario.  import org.yaml.snakeyaml.Yaml;  import java.io.FileInputStream; import java.io.InputStream; import java.util.Map;  public class SnakeYamlSample {   public static void main(String... a) { \tString filename = a[0]; \ttry (InputStream inputStream = new FileInputStream(filename)) {  Yaml yaml = new Yaml(); Map<String, Object> obj = yaml.load(inputStream);  System.out.println(obj); \t} catch (Exception e) {  System.err.println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + e.getMessage());; \t}  } }   Here, we’ve used four Java classes.   org.yaml.snakeyaml.Yaml  java.io.FileInputStream  java.io.InputStream  java.util.Map   You can see them in the imported class list. We encourage you to generate Ballerina bindings for these four classes as a start.  Now, we’ll create an environment for our Ballerina program.  Step 2: Set up the Ballerina project This section assumes that you have already read .  Create a Ballerina project → ballerina new yaml-project Created new Ballerina project at yaml-project  Next:  Move into the project directory and use `ballerina add <module-name>` to  add a new Ballerina module.  Add a Ballerina module to your project → ballerina add yamlparser Added new ballerina module at 'src/yamlparser’  Add a sample YAML file Copy the below content to a file named invoice.yml in the project root directory. invoice: 34843 date : 2001-01-23 bill-to: &id001  given : Chris  family : Dumars  address:  lines: |  458 Walkman Dr.  Suite #292  city : Royal Oak  state : MI  postal : 48046 ship-to: *id001 product:  - sku : BL394D  quantity : 4  description : Basketball  price : 450.00  - sku : BL4438H  quantity :  description : Super Hoop  price : 2392.00 tax : 251.42 total: 4443.52 comments: >  Late afternoon is best.  Backup contact is Nancy  Billsmer @ 338-4338.\\   Verify the project > ballerina build yamlparser Compiling source \tsameera/yamlparser:0.1.0  Creating balos \ttarget/balo/yamlparser-2020r1-any-0.1.0.balo ... ...  Generating executables \ttarget/bin/yamlparser.jar  > ballerina run target/bin/yamlparser.jar Hello World!  Great! You are all set for the next step.  Step 3: Generate Ballerina bindings In this step, we’ll use the bindgen tool to generate Ballerina bindings for those four classes that we talked about in Step 1. If you want more information about the tool, you can refer .  Copy the SnakeYAML library to your project Download the latest version of the SnakeYAML library and copy it to the project. We need to copy only the SnakeYAML library but for most cases, you may need to copy more than one JAR file. Make sure that you add all the direct and transitive dependencies of them.  Create a directory in your project root to store all the Java libraries. > mkdir javalibs > cp <path-to-snakeyaml-lib>/snakeyaml-1.25.jar javalibs   Add the SnakeYAML library to the Ballerina.toml file Copy and paste the following TOML snippet to the Ballerina.toml file in your project’s root directory. This step ensures that the SnakeYAML library is always packaged with the stand-alone executable JAR generated for your Ballerina program. Refer to the for more details.  [platform] target = \"java8\"   [[platform.libraries]]  path = \"./javalibs/snakeyaml-1.25.jar\"  modules = [\"yamlparser\"]   Generate Ballerina bindings > ballerina bindgen -cp ./javalibs/snakeyaml-1.25.jar -o src/yamlparser  org.yaml.snakeyaml.Yaml java.io.FileInputStream java.io.InputStream java.util.Map  Generating bindings for: java.util.Map \tjava.io.FileInputStream \torg.yaml.snakeyaml.Yaml \tjava.io.InputStream  Generating dependency bindings for: org.yaml.snakeyaml.introspector.BeanAccess \tjava.util.function.BiFunction \torg.yaml.snakeyaml.constructor.BaseConstructor \tjava.util.function.Function \t... ... The -cp option specifies the list of Java libraries required to generate bindings.  The -o option specifies the output directory to which the generated bindings are stored. In this case, we instruct the tool to store bindings inside the yamlparser module.  The argument list specifies the Java class names.   The bindgen tool generate bindings for   The specified Java classes  The Java classes exposed in the public APIs of all the specified classes.   Before we move onto the next step, let’s verify the generated code. > ballerina build yamlparser ... ...  Generating executables \ttarget/bin/yamlparser.jar  > ballerina run target/bin/yamlparser.jar Hello World!   Step 4: Write the Ballerina code   Note: The bindgen tool is still experimental. We are in the process of improving the generated code.   Now, we’ll use the generated bindings and write the Ballerina code, which uses the SnakeYAML library. Here is the Java code. Let’s develop the corresponding Ballerina code step by step. public class SnakeYamlSample {   public static void main(String... a) { \tString filename = a[0]; \ttry (InputStream inputStream = new FileInputStream(filename)) {  Yaml yaml = new Yaml(); Map<String, Object> obj = yaml.load(inputStream);  System.out.println(obj); \t} catch (Exception e) {  System.err.println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + e.getMessage());; \t}  } }   Create the FileInputStream Our goal here is to create a new java.io.FileInputStream instance from the filename. In step 3, we generated bindings for the required Java classes. The following is the code snippet that does the job.  FileInputStream | error fileInputStream = newFileInputStream3(filename);   Here, FileInputStream is the Ballerina object generated for the java.io.FileInputStream class.   You can find functions that start with newFileInputStream in the generated code. Each such function creates a new java.io.FileInputStream instance. Ballerina does not support function overloading. Therefore, the bindgen tool generates a separate Ballerina function for each overloaded method or constructor. We will improve the function names of the generated bindings in a future release.  All the methods in the java.io.FileInputStream class are mapped to methods in the generated Ballerina object.   Next, we’ll handle the error using a type guard.  if fileInputStream is error { \t// The type of fileInputStream is error within this block  io:println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + fileInputStream.reason()); } else { \t// The type of fileInputStream is FileInputStream within this block }  Create the SnakeYAML entry point The org.yaml.snakeyaml.Yaml Class is the entry point to the SnakeYAML API. The corresponding generated Ballerina object is Yaml. The newYaml5() function is mapped to the default constructor of the Java class. Yaml yaml = newYaml5();  Loads the YAML Document We’ll be using the org.yaml.snakeyaml.Yaml.load(InputStream is) method to get a Java Map instance from the given InputStream.  InputStream inputStream = new (fileInputStream.jObj); Object mapObj = yaml.load2(inputStream);  The generated code does not handle Java subtyping at the moment. Therefore, InputStream inputStream = newFileInputStream3(filename) will not compile. We will improve this in a future release. As a workaround, you can create a new java.io.InputStream as above.  The org.yaml.snakeyaml.Yaml.load(InputStream is) is a generic method. The bindgen tool does not support Java generics at the moment. That is why the corresponding Ballerina method returns an Object.  Print the returned Map instance. You can print the content of the Map instance in the the standard out as follows. io:println(mapObj);  Completed code Here, is the complete code. You can replace the contents in src/yamlparser/main.bal with the following code. import ballerina/io;  public function main(string... args) returns error? {  string filename = args[0];  FileInputStream | error fileInputStream = newFileInputStream3(filename);  if fileInputStream is error {  io:println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + fileInputStream.reason());  } else {  Yaml yaml = newYaml5();  InputStream inputStream = new (fileInputStream.jObj);  Object mapObj = yaml.load2(inputStream);  io:println(mapObj);  } }   Let’s build and run this code. > ballerina build yamlparser Compiling source \tsameera/yamlparser:0.1.0  Creating balos \ttarget/balo/yamlparser-2020r1-any-0.1.0.balo ... ...  Generating executables \ttarget/bin/yamlparser.jar   Now, we need to pass the YAML file name as the first argument. > ballerina run target/bin/yamlparser.jar invoice.yaml {invoice=34843, date=Mon Jan 22 16:00:00 PST 2001, bill-to={given=Chris, family=Dumars, address={lines=458 Walkman Dr. Suite #292 , city=Royal Oak, state=MI, postal=48046}}, ship-to={given=Chris, family=Dumars, address={lines=458 Walkman Dr. Suite #292 , city=Royal Oak, state=MI, postal=48046}}, product=[{sku=BL394D, quantity=4, description=Basketball, price=450.0}, {sku=BL4438H, quantity=null, description=Super Hoop, price=2392.0}], tax=251.42, total=4443.52, comments=Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338.\\}  In this section, we explained how to use the bindgen tool to generate Ballerina bindings for Java classes and how to use those generated ones.  The next sections provide more details on various aspects related to Java interoperability in Ballerina.  The bindgen tool  Note that the bindgen tool is still experimental. We are in the process of improving the generated code.  The bindgen is a CLI tool, which generates Ballerina bindings for Java classes.  The bindgen Command  ballerina bindgen [(-cp|--classpath) <classpath>...]  [(-o|--output) <output>]  (<class-name>...)   (-cp|--classpath) <classpath>... This optional parameter could be used to specify one or more comma-delimited classpaths for retrieving the required Java libraries needed by the bindgen tool execution. The classpath could be provided as comma-separated paths of JAR files or as comma-separated paths of directories containing all the relevant Java libraries. If the Ballerina bindings are to be generated from a standard Java library or from a library available inside the Ballerina SDK, then you need not specify the classpath explicitly.  (-o|--output) <output> This optional parameter could be used to specify the directory path into which the Ballerina bindings should be inserted. If this path is not specified, the output will be written onto the same directory from where the command is run. You can point the path of a Ballerina module to generate the code inside a Ballerina module.  <class-name>... One or more space-separated fully-qualified Java class names for which the Ballerina bridge code is to be generated. Please note that these class names should be provided at the end of the command.  Generated Bridge Code  When the tool is run, a .bal file will be created to represent each Java class. This would contain the respective Ballerina object along with the required Java interoperability mappings. These .bal files would reside inside sub directories representing the package structure. Apart from creating bindings for the specified Java classes, the command would also generate empty Ballerina objects for the dependent Java classes. A Java class would be considered dependent if it is used inside one of the Ballerina objects generated. A set of additional utility files will also be generated in order to support the auto-generated Ballerina bindings. The folder structure of the generated bindings will be as follows.  <ballerina_bindings> \t├── <package-name>  └── <class-name>.bal  └── ... \t├── ... └── <dependencies>  ├── <utils>  ├── ArrayUtils.bal  ├── Constants.bal  └── JObject.bal  ├── <package-name>  └── <class-name>.bal  └── ...  └── ...   Mapping Java code with Ballerina  Java Classes A Java class will be mapped onto a Ballerina object. This Ballerina object will have the same name as that of the Java class.  E.g., Generated Ballerina object of the java.utils.ArrayDeque class will be as follows. public type ArrayDeque object {  ... };    Note: If there are multiple classes with the same name, you should change the names manually.   Constructors Constructors of Java classes will be mapped onto public functions outside the Ballerina object. These function names are comprised of the constructor name prefixed with the new keyword. If there exists multiple constructors, they will be suffixed with an auto increment number.  E.g., Generated constructors of the java.utils.ArrayDeque class will be as follows. public function newArrayDeque1() returns ArrayDeque {   ... } public function newArrayDeque2(int arg0) returns ArrayDeque {   ... } public function newArrayDeque3(Collection arg0) returns ArrayDeque {   ... }   Methods All public methods will be exposed through Ballerina bindings. Instance methods will reside inside the Ballerina object and these would take the name of the Java method. However, if there exists overloaded methods, a numeric suffix will be appended at the end of the name.  E.g., Some of the generated instance methods of the java.utils.ArrayDeque class will be as follows. public type ArrayDeque object {  ...  public function add(Object arg0) returns boolean {  ...  }  public function isEmpty() returns boolean {  ...  } };  Static methods would reside outside the Ballerina object as public functions, which take the name of the Java method with the Java class name appended at the beginning as a prefix.  E.g., A generated static method of the java.utils.UUID class will be as follows. public function UUID_randomUUID() returns UUID {  ... }   Fields All public fields of a Java class will be exposed through Ballerina bindings in the form of getters and setters. Instance fields will have the respective getters and setters inside the Ballerina object, whereas the static fields will have getters and setters outside the Ballerina object as public functions.  The getters and setters of an instance field will take the name of the field prefixed with a ‘get’ or ‘set’ at the beginning. For a static field, getters and setters (if the field is not final) will take the name of the field with a ‘get’ or ‘set’ prefix along with the Java class name appended at the beginning.  External Interop Functions These interop functions take the fully-qualified Java method name as the function name. However, if there exists overloaded methods, a numeric suffix will be appended at the end.  Dependency Objects When there are dependent Java classes present inside generated Ballerina bindings (as parameters or return types), the bindgen tool generates an empty Ballerina object to represent each one of these classes. These would represent a Java class mapping without the constructor, method, or field bindings. If one of these classes are required later, the bindgen tool could be re-run to generate the Ballerina bindings.    Note: If the complete implementation of a dependency object is generated using the bindgen tool, the existing empty Ballerina object should be deleted manually as instructed in the command output.   E.g., Generated dependency object representing java.util.List will be as follows. public type List object {  *JObject;  public function __init(handle obj) {  self.jObj = obj;  } };   Ballerina Object A Ballerina object representing a Java class will always store the handle reference of the Java class in it’s jObj field. To explain the implementation further, a Ballerina object representing a Java class would always be implemented using the following JObject abstract class. Hence, the handle reference could be accessed when needed.  public type JObject abstract object {  public handle jObj; };   A Ballerina object could be initialized using the __init function or a constructor. If the first approach is used, you should pass on a handle reference of the Java class to the __init function. This could be used if you have already obtained a handle reference through some means other than using the constructor. If not, you could use the second approach to create a new object using a constructor.  E.g., Generated __init function of a Ballerina object mapping a Java class. public function __init(handle obj) {   self.jObj = obj; }    Type mappings between Java and Ballerina When using the Ballerina bindings, you could use the Ballerina primitive types, Ballerina string type, and the generated Ballerina objects. They will be mapped internally onto the respective Java primitives, Java String object, and the respective handle references of the objects.  Packaging Java libraries with Ballerina programs This section assumes that you have already read the guide . When you compile a Ballerina program with ballerina build <root-module>, the compiler creates an executable JAR file and when you compile a Ballerina module with ballerina build -c <module>, the compiler creates a BALO file. In both cases, the Ballerina compiler produces self-contained archives. There are situations in which you need to package JAR files with these archives. The most common example would be packing the corresponding JDBC driver.  There are two kinds of Ballerina projects:   Produces executable programs  Contains one or more Ballerina modules and at least one of them has to be a root module.  A root module has a main method and/or one or more services.  Build the project with ballerina build <root-module> or use ballerina build -a if there is more than one root module.  The best practice is to maintain a single root module in a Ballerina project.  Produces Ballerina library modules  Contains one or more Ballerina library modules.  Build the modules with ballerina build -c <module> or ballerina build -c -a to build all modules.  Usually, the compiled library modules are pushed to Ballerina central.  How you package JAR files with compiled archives is the same in both kinds of projects. Therefore, a sample Ballerina project, which produces an executable is used here.  Here, is a Ballerina project layout of a microservice called “order management”. The module ordermgt - the root module - contains a RESTFul service, which exposes resource functions to create, retrieve, update, and cancel orders. The dbutils module offers utility functions, which use a MySQL database to store orders.  ordermgt_service/ ├── Ballerina.toml └── javalibs/  └── mysql-connector-java-<version>.jar └── src/  └── ordermgt/  └── dbutils/   The Java MySQL connector is placed inside the javalibs directory. You are free to store the JAR files anywhere in your file system. This example places those JAR files inside the project directory. As a best practice, maintain Java libraries inside the project. The Ballerina.toml file, which marks a directory as a Ballerina project lives at the root of the project. It is also a manifest file that contains project information, dependent Ballerina module information, and platform-specific library information. Java libraries are considered as platform-specific libraries. Here, is how you can specify a JAR file dependency in theBallerina.toml.  [platform] target = \"java8\" [[platform.libraries]] # Absolute or relative path to the JAR file path = \"<path-to-jar-file-1>\" # A comma-separated list of Ballerina module names, which depends on this JAR modules = [\"<ballerina-module-1>\"]  [[platform.libraries]] path = \"<path-to-jar-file-2>\" modules = [\"<ballerina-module-1>\",\"<ballerina-module-2>\"]   Now, let’s look at the contents of the Ballerina.toml file in this project. [platform] target = \"java8\" [[platform.libraries]] path = \"./javalibs/mysql-connector-java-<version>.jar\" modules = [\"ordermgt\"]   If your project has only one root module, then you can attach all the JAR file dependencies to your root module as the best practise.  If your project is a Ballerina library module project, then you should specify the JAR file dependencies in each Ballerina module if that module depends on the JAR file.  Now, use ballerina build ordermgt to build an executable JAR. This command packages all JARs specified in your Ballerina.toml with the executable JAR file.  Ballerina FFI Let’s look at the list of language features that enable Ballerina developers to call foreign code written in other programming languages. E.g., while the jBallerina compiler allows you to call any Java code, the nBallerina compiler will allow you to call any C Code.  The external function body Usually, the body or the implementation of a function is specified in the same source file. The part, which is enclosed by curly braces is called the function body.  function doSomething(int i) returns string { \t... }   Ballerina also allows you to define a function without a function body and marks it with the external keyword to express that the implementation is not provided by the Ballerina source file.  function doSomething(int i) returns string = external;   Now, let’s see how you can link this function with a foriegn function.  import ballerina/java;  function doSomething(int i) returns string = @java:Method { \tname: \"doSomethingInJava\" \tclass: \"a.b.c.Foo\" } external;   The @java:Method annotation instructs the jBallerina compiler to link with the doSomethingInJava static method in the Java class a.b.c.Foo. There exists a set of annotations and other utilities available in the ballerina/java module to make Java interoperability work. This guide covers most of them.  The handle type The handle type describes a reference to an externally-managed storage. These values can only be created by a Ballerina function with an external function body. Within the context of jBallerina, a handle type variable can refer to any Java reference type value: a Java object, an array, or the null value.  Consider the randomUUID method in the Java UUID class, which gives you a UUID object. This is the Java method signature.  static UUID randomUUID()   Here, is the corresponding Ballerina function that returns a value of the handle type.  import ballerina/java;  function randomUUID() returns handle = @java:Method {  name: \"randomUUID\",  class: \"java.util.UUID\" } external;   In Java, you can assign the null value to any variable of a reference type. Therefore, a handle type variable may also refer to the Java null.  The following section describes various aspects of Java interoperability in Ballerina. You can copy and paste following examples into a .bal file and run it using the ballerina run <file_name.bal> command.  Calling Java code from Ballerina The following subsections explain how to call Java code from Ballerina.   Instantiate Java classes Let’s look at how you can create Java objects in a Ballerina program. The @java:Constructor annotation instructs the compiler to link a Ballerina function with a Java constructor.  The ArrayDeque class in the java.util package has a default constructor. The following Ballerina code creates a new ArrayDeque object. As you can see, the newArrayDeque function is linked with the default constructor. This function returns a handle value and it refers the constructed ArrayDeque instance.  import ballerina/java;  public function main() {  handle arrayDeque = newArrayDeque(); }  function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;   You can also create a wrapper Ballerina object for Java classes as follows.  import ballerina/java;  public function main() {  ArrayDeque ad = new; }  type ArrayDeque object {  private handle jObj;   function __init(){  self.jObj = newArrayDeque(); } };  function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;      Note: that these @java:* annotations cannot be attached to Ballerina object methods at the moment.   Dealing with overloaded constructors When there are two constructors with the same number of arguments available, you need to specify the exact constructor that you want to link with the Ballerina function. The ArrayDeque class contains three constructors and the last two are overloaded ones.  public ArrayDeque(); public ArrayDeque(int numElements); public ArrayDeque(Collection<? extends E> c);   Here, is the updated Ballerina code.  import ballerina/java;  function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;  function newArrayDequeWithSize(int numElements) returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\",  paramTypes: [\"int\"] } external;  function newArrayDequeWithCollection(handle c) returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\",  paramTypes: [\"java.util.Collection\"] } external;   The paramTypes field You can use the paramTypes field to resolve the exact overloaded method. This field is defined as follows.  # The `Class` type represents a fully-qualified Java class name. public type Class string;  # The `ArrayType` represents a Java array type. It is used to specify parameter # types in the `Constructor` and `Method` annotations. # # + class - Element class of the array type # + dimensions - Dimensions of the array type public type ArrayType record {|  Class class;  byte dimensions; |};  (Class | ArrayType)[] paramTypes?;   As per the above definition, paramTypes field takes an array of Java classes or array types. The following table contains more details.    Java Type  Description  Example  Primitive  The Java class name of a primitive type is the same as the name of the primitive type.  The boolean.class.getName() expression evaluates to “boolean”. Similarly, the int.class.getName() expression evaluates to “int”.  Class  Fully-qualified class name  “java.lang.String”  Array  Use the ArrayType record defined above to specify Java array types in overloaded methods.  Method signature: void append(boolean[] states, long l, String[][] args); The corresponding value of the paramField: paramField: [{class:”boolean”, dimensions: 1}, “long” {class:”java.lang.String”, dimensions: 2}]  For more details, look at the following example.  public Builder(Person[][] list, int index); public Builder(Student[][] list, int index);   Here, is the corresponding Ballerina code.  import ballerina/java;  function builderWithPersonList(handle list, int index) returns handle = @java:Constructor {  class: \"a.b.c.Builder\",  paramTypes: [{class: \"a.b.c.Person\", dimensions:2}, \"int\"] } external;  function builderWithStudentList(handle list, int index) returns handle = @java:Constructor {  class: \"a.b.c.Builder\",  paramTypes: [{class: \"a.b.c.Student\", dimensions:2}, \"int\"] } external;   Call Java methods You can use the java:@Method annotation to link Ballerina functions with Java static and instance methods. There is a small but important difference in calling Java static methods vs calling instance methods.  Static methods Let’s first look at how to call a static method. The “java.util.UUID” class has a static method with the static UUID randomString() signature.  import ballerina/java; import ballerina/io;  function randomUUID() returns handle = @java:Method {  name: \"randomUUID\",  class: \"java.util.UUID\" } external;  public function main() {  handle uuid = randomUUID();  io:println(uuid); }   The name field is optional here. If the Ballerina function name is the same as the Java method name, you don’t have to specify the name field.  function randomUUID() returns handle = @java:Method {  class: \"java.util.UUID\" } external;   Instance methods Now, let’s look at how to call Java instance methods using the same ArrayDeque class in the java.util package. It can be used as a stack with its pop and push instance methods with the following method signatures.  E pop(); void push(E e);   Here, are the corresponding Ballerina functions that are linked to these methods.  function pop(handle arrayDequeObj) returns handle = @java:Method {  class: \"java.util.ArrayDeque\" } external;  function push(handle arrayDequeObj, handle e) = @java:Method {  class: \"java.util.ArrayDeque\" } external; If you compare these functions with the Java method signatures, you would notice the additional handle arrayDequeObj parameter in Ballerina functions. Let’s look at a sample usage to understand the reason.  public function main() {  // Create a new instance of `ArrayDeque`.  handle arrayDequeObj = newArrayDeque();   // Convert a Ballerina string to a Java string.  string str = “Ballerina”  handle handleStr = java:fromString(str);   push(arrayDequeObj, handleStr);  handle e = pop(arrayDequeObj); }   As you can see, you need to first construct an instance of the ArrayDeque class. The arrayDequeObj variable refers to an ArrayDeque object. Then, you need to pass this variable to both the pop and push functions because the corresponding Java methods are instance methods of theArrayDeque class. Therefore, you need an instance of the ArrayDeque class in order to invoke its instance methods. You can think of the arrayDequeObj variable as the method receiver.  Map Java classes into Ballerina objects The following pattern is useful if you want to present a clearer Ballerina API, which calls to the underneath Java code. This pattern creates wrapper Ballerina objects for each Java class that you want to expose via your API.  Imagine that you want to design an API to manipulate a stack of string values by using the Java ArrayDeque utility. You can create a Ballerina object type as follows.  public type StringStack object {  private handle jObj;   public function __init() {  self.jObj = newArrayDeque();  }   public function push(string element) {  push(self.jObj, java:fromString(element));  }   public function pop() returns string {  handle handleEle = pop(self.jObj);  // Let's talk about error handling and null satefy later in this guide  // This example uses an empty string for now.  return java:toString(handleEle) ?: \"\";   } };  function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;  function pop(handle receiver) returns handle = @java:Method {  class: \"java.util.ArrayDeque\" } external;  function push(handle receiver, handle element) = @java:Method {  class: \"java.util.ArrayDeque\" } external;   This object presents a much clearer API compared to the previous API. Here, is a sample usage of this object.  public function main() {  StringStack stack = new();  stack.push(\"Ballerina\"); string element = stack.pop(); }   Overloaded Java methods The “Instantiate Java classes” section presented about how to deal with overloaded constructors in the. You need to use the same approach to deal with overloaded Java methods. Let’s try to call the overloaded append methods in the `java.lang.StringBuffer class. Here, is a subset of those methods.  StringBuffer append(boolean b); StringBuffer append(int i); StringBuffer append(String str); StringBuffer append(StringBuffer sb); StringBuffer append(char[] str);   Here, is the set of Ballerina functions that are linked with the above Java methods. Notice the usage of the paramTypes annotation field. You can find more details of this field in the “Instantiate Java classes” section.  function appendBool(handle sbObj, boolean b) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"boolean\"],  class: \"java.lang.StringBuffer\" } external;  function appendInt(handle sbObj, int i) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"int\"],  class: \"java.lang.StringBuffer\" } external;  function appendCharArray(handle sbObj, handle str) returns handle = @java:Method {  name: \"append\",  paramTypes: [{class: \"char\", dimensions: 1}],  class: \"java.lang.StringBuffer\" } external;  function appendString(handle sbObj, handle str) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"java.lang.String\"],  class: \"java.lang.StringBuffer\" } external;  function appendStringBuffer(handle sbObj, handle sb) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"java.lang.StringBuffer\"],  class: \"java.lang.StringBuffer\" } external;   Java exceptions as Ballerina errors A function call in Ballerina may complete abruptly by returning an error or by raising a panic. Panics are rare in Ballerina. The best practise is to handle errors in your normal control flow. Raising a panic is similar to throwing a Java exception. The trap action will stop a panic and give you the control back in Ballerina and the try-catch statement does the same in Java.  Errors in Ballerina belong to the built-int type error. The error type can be considered as a distinct type from all other types: The error type does not belong to the any type, which is the supertype of all other Ballerina types. Therefore, errors are explicit in Ballerina programs and it is almost impossible to ignore them. For more details, see BBEs.  How do Java exceptions are mapped to Ballerina errors? A Java function call may complete abruptly by throwing either a checked exception or an unchecked exception. Unchecked exceptions are usually not part of the Java method signature unlike the checked exceptions.  Java interoperability layer in Ballerina handles checked exceptions differently from unchecked exceptions as explained below. Java unchecked exceptions If the linked Java method throws an unchecked exception, then the corresponding Ballerina function will complete abruptly by raising a panic.  The following example tries to pop an element out of an empty queue. The pop method in the ArrayDeque class throws an unchecked java.util.NoSuchElementException exception in such cases. This exception will cause the Ballerina pop function to raise a panic.  import ballerina/java;  function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;  function pop(handle receiver) returns handle = @java:Method {  class: \"java.util.ArrayDeque\" } external;  public function main() {  handle arrayDeque = newArrayDeque();  handle element = pop(arrayDeque); }   Here, is the output:  error: java.util.NoSuchElementException at array_deque:pop(array_deque.bal:65535)  array_deque:main(array_deque.bal:13)   You can use the trap action to stop the propagation of the panic and to get an error value.  public function main() {  handle arrayDeque = newArrayDeque();  handle | error element = trap pop(arrayDeque);  if element is error {  io:println(element.reason());  io:println(element.detail());  io:println(element.stackTrace().callStack);  } else {  // .....  } } Java checked exceptions Let’s see how you can call a Java method that throws a checked exception. As illustrated in the following example, the corresponding Ballerina function should have the error type as part of it’s return type.  The java.util.zip.ZipFile class is used to read entries in a ZIP file. There are many constructors in this class. Here, the constructor that takes the file name as an argument is used.  public ZipFile(String name) throws IOException   Since this Java constructor throws a checked exception, the newZipfile Ballerina function returns ZipFile instances or an error.  import ballerina/java;  function newZipFile(handle filename) returns handle | error = @java:Constructor {  class: \"java.util.zip.ZipFile\",  paramTypes: [\"java.lang.String\"] } external;  public function main() {  handle|error zipFile = newZipFile(java:fromString(\"some_file.zip\")); }   Mapping a Java exception to a Ballerina error value Now, let’s briefly look at how a Java exception is converted to a Ballerina error value at runtime. A Ballerina error value contains three components: a reason, a detail, and stack trace.  The reason: \t* This is a string identifier for the category of error. \t* In this case, reason value is set to the fully-qualified Java class name of the exception. * Unchecked: Class name of of the thrown unchecked exception  * Checked: Class name of the exception that is declared in the method signature The detail: \t* The message field is set to e.getMessage(). \t* The cause field is set to the Ballerina error that represents this Java exception’s cause.  Null safety Ballerina provides strict null safety compared to Java with optional types. The Java null reference can be assigned to any reference type. However, in Ballerina, you cannot assign the nil value to a variable unless the variable’s type is an optional type.  As explained above, Ballerina handle values cannot be created in Ballerina code. They are created and returned by foriegn functions and a variable of the handle type refers to a Java reference value. Since Java null is also a valid reference value, this variable can refer to a Java null value.  Let’s look at an example, which deals with Java null. The following code uses the peek method in the ArrayDeque class. Peek retrieves but does not remove the head of the queue or returns null if the queue is empty.  import ballerina/java;  function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;  function peek(handle receiver) returns handle = @java:Method {  class: \"java.util.ArrayDeque\" } external;  // Linked with the `java.lang.Object.toString()` method in Java. function toString(handle objInstance) returns handle = @java:Method {  class: \"java.lang.Object\" } external;  public function main() {  handle arrayDeque = newArrayDeque();  handle element = peek(arrayDeque);  Handle str = toString(element); }   Since the queue is empty in this case, peek should return null i.e., element should refer to Java null. The output of this program will be as follows.   error: org.ballerinalang.jvm.values.ErrorValue message={ballerina}JavaNullReferenceError \tat array_deque:toString(array_deque.bal:19)  array_deque:main(array_deque.bal:27)   This is equivalent to a Java NPE. In such situations, you should check for null using the java:isNull() function. Here, is the modified example.  public function main() {  handle arrayDeque = newArrayDeque();  handle element = peek(arrayDeque); if java:isNull(element) {  // handle this case  } else {  handle str = toString(element);  } }   There are situations in which you need to pass a Java null to a method or store in a data structure. In such situations, you can create a handle value that refers to a Java null as follows.  handle nullValue = java:createNull();   How Java types are mapped to Ballerina types and vice versa Mapping Java types to Ballerina types The following table summarizes how Java types are mapped to corresponding Ballerina types. This is applicable when mapping a return type of a Java method to a Ballerina type.    Java type  Ballerina type  Notes  Any reference type including “null type”  handle  boolean  boolean  byte  byte, int, float  widening conversion when byte -> int and byte -> float  short  int, float  widening conversion  char  int, float  widening conversion  int  int, float  widening conversion  long  int, float  widening conversion when long -> float  float  float  widening conversion  double  float  Mapping Ballerina types to Java types The following table summarizes how Ballerina types are mapped to corresponding Java types. These rules are applicable when mapping a Ballerina function argument to a Java method/constructor parameter.    Ballerina type  Java type  Notes  handle  Any reference type  As specified by the Java method/constructor signature  boolean  boolean  byte  byte, short, char, int, long, float, double  Widening conversion from byte -> short, char, int, long, float, double  int  byte, char, short, int, long  Narrowing conversion when int -> byte, char, short and int  float  byte, char, short, int, long, float, double  Narrowing conversion when float -> byte, char, short, int, long, float  Access/Mutate Java fields The @java:FieldGet and @java:FieldSet annotations allow you to read and update the value of a Java static or instance field respectively. The most common use case is to read a value of a Java static constant.  import ballerina/java;  public function pi() returns float = @java:FieldGet {  name:\"PI\",  class:\"java/lang/Math\" } external;  public function main() {  float r = 4;  float l = 2 * pi() * r; }   In this example, the pi() function returns the value of the java.lang.Math.PI static field. This uses the annotation field name to specify the name of the field. Likewise, if you want to access an instance field, you need to pass the relevant object instance as discussed in the instance methods section.  The @java:FieldSet annotation has the same structure as the above."},{"page":"/learn/how-to-document-ballerina-code/","name":"How to Document Ballerina Code","summary":"Ballerina has a built-in Ballerina Flavored Markdown (BFM) documentation framework named Docerina. The documentation framework allows you to write unstructured documents with a bit of structure to enable generating HTML content as API documentation.Developers can write the documentation inline with the Ballerina source code using the lightweight  markup language. ...","content":"/  / How to Document Ballerina Code  How to Document Ballerina Code  Ballerina has a built-in Ballerina Flavored Markdown (BFM) documentation framework named Docerina. The documentation framework allows you to write unstructured documents with a bit of structure to enable generating HTML content as API documentation.  Developers can write the documentation inline with the Ballerina source code using the lightweight markup language. They can document special constructs such as parameters, return values, fields, etc. within the code using documentation attributes. Once the code is documented, developers can generate a basic HTML version of their Ballerina modules using the ballerina doc command. Developers are encouraged to have their custom themes and styles, to have a standard presentation of their Ballerina documentation.  Ballerina documentation design and usage is aligned with project and module semantics of Ballerina. You can generate documentation for modules using the ballerina doc command.  Overview    Ballerina programmers can place the documentation inline with the source code using the documentation syntax.  Ballerina type definitions, global variables, annotations, listeners, etc. can be documented using the documentation syntax.  Fields, parameters, return values, etc. can be marked using documentation attributes.  HTML documents can be generated using the ballerina doc command for each Ballerina module and if you have custom handlebars templates, you can use them to generate the HTMLs.   Writing Ballerina Documentation  Ballerina Flavored Markdown documentation is a first class syntax in the Ballerina language. The # at the beginning of a line denotes a line of documentation. If necessary, you can have multiple lines of documentation, which you can group together.  # <documentation line 1> # <documentation line 2> # ...   When you write documentation, you can use the markdown documentation syntax given above. For example:  # Provides the HTTP actions for interacting with an HTTP server. Apart from the standard # HTTP methods, `forward()` and `execute()` functions are provided. # ...   The supported structure of documentation syntax is as follows:  # <description_line_1> # <description_line_2> # ... # + <parameter_name/field_name> - <description_line_1> # <description_line_2> # ... # + <parameter_name/field_name> - <description_line_1> # <description_line_2> # ... # + return - <return_parameter_description_line_1> # <return_parameter_description_line_2>   Sample Usage  # Submits an HTTP request to a service with the specified HTTP verb. # The `submit()` function does not give out a `Response` as the result, # rather it returns an `HttpFuture`, which can be used to do further # interactions with the endpoint. # # Example: # ```ballerina # HttpFuture future = myMsg.submit(\"GET\", \"/test\", req); # ``` # # + httpVerb - The HTTP verb value # + path - The resource path # + request - An HTTP outbound request message # + return - An `HttpFuture` that represents an asynchronous service invocation, # or an `error` if the submission fails public function submit(@sensitive string httpVerb, string path, Request request) returns HttpFuture|error;   Documenting A Module  A Ballerina module can have a Module.md file which describes the module and its usage.  A typical project structure of a Ballerina project is like this:  /  Ballerina.toml # Configuration that defines project intent  src  module1/ # The source in this directory will be named “<org-name>/module1”  Module.md # Optional, contains descriptive metadata for display at  # Ballerina Central  *.bal  [tests/] # Module-specific unit and integration tests  [resources/] # Module-specific resources   modules.can.include.dots.in.dir.name/  Module.md  *.bal  [tests/]  [resources/]   [resources/] # Resources included with every module in the project   target/ # Compiled executables and other artifacts end up here   ballerina doc command will read the Module.md and prepend it to the generated HTML file.  Check for sample HTML that has Module.md content at the top, followed by the other module constructs.  Generating Ballerina Documentation  Ballerina provides a doc command which can be executed against a given Ballerina project. This command will result in generating the Ballerina documentation as HTML files, for all the modules in the project.  First, let’s create a new Ballerina project: $ ballerina new myproject Created new Ballerina project at myproject  Next:  Move into the project directory and use `ballerina add <module-name>` to  add a new Ballerina module. $ cd myproject/ $ ballerina add math -t service Added new ballerina module at 'src/math' $ ballerina add time -t service Added new ballerina module at 'src/time'   Now, let’s generate documentation of the project: $ ballerina doc -a  Output: Compiling source  foo/time:0.1.0  foo/math:0.1.0  Generating API Documentation  target/apidocs   target/apidocs/ folder would contain following; $ ls target/apidocs/ index.html math time ...     index.html - contains an index page of all the modules in the Ballerina project  math - contains the documentation of the module named math  time - contains the documentation of the module named time   If you want to generate documentation for a selected Ballerina module, then you can execute the following command from the Ballerina project root directory:  $ ballerina doc <module_name>   For other options, run ballerina doc --help."},{"page":"/learn/how-to-generate-code-for-protocol-buffers/","name":"How to generate Ballerina code for Protocol Buffer Definition","summary":"The Protocol Buffers to Ballerina tool provides capabilities to generate Ballerina source code for the Protocol\nBuffer definition. The code generation tool can produce ballerina stub and ballerina service/client template files.In Ballerina, Protocol Buffers serialization is only supported in the gRPC module. Therefore, you can only use\nthis tool to generate Ballerina ...","content":"/  / How to generate Ballerina code for Protocol Buffer Definition  How to generate Ballerina code for Protocol Buffer Definition  The Protocol Buffers to Ballerina tool provides capabilities to generate Ballerina source code for the Protocol Buffer definition. The code generation tool can produce ballerina stub and ballerina service/client template files.    In Ballerina, Protocol Buffers serialization is only supported in the gRPC module. Therefore, you can only use this tool to generate Ballerina source code for gRPC service definitions.   CLI Command  You can generate Ballerina source code using the following command:  ./ballerina grpc --input <proto-file-path> [--output <path>] [--mode client | service]   Options  --input - Path of the input .proto file. This is a mandatory field. You need to provide the path of the definition  file.  --output - Location of the generated Ballerina source files. This is an optional field. If output path is not specified, output will be written to a directory corresponding to the package in the Protocol  Buffers definition. If package is not specified, output will be written to a ‘temp’ directory in the current location.  --mode - Set the mode (client or service) to generate code samples. If not specified, only the stub file is  generated.  Sample  The below example shows how you can generate Ballerina source code from the following Protocol Buffers definition (in the helloworld_service.proto file).  syntax = \"proto3\";  service helloWorld {  rpc sayHello(HelloRequest) returns (HelloResponse); }  message HelloRequest { \tstring name = 1; } message HelloResponse { \tstring message = 1; }     Execute the below command to generate the service template file.  $ ballerina grpc --input helloworld_service.proto --mode service --output service  Once you execute the command, the service template file (helloWorld_sample_service.bal) is generated inside the service directory.  Note: If you have multiple services in a Protocol Buffers definition, this command will generate a stub file with common message types and a service template file for each service definition. This is to avoid duplicating message types in all the service files.  Execute the below command to generate the client/service stub and client template.  $ ballerina grpc --input helloworld_service.proto --mode client --output client  Once you execute the command, the stub file(helloworld_service_pb.bal) and the service template file (helloWorld_sample_client.bal) are generated inside the client directory.  Execute the below command to generate only the client/service stub.  $ ballerina grpc --input helloworld_service.proto --output stubs  Once you execute the command, only the stub file (helloworld_service_pb.bal) is generated inside the stubs directory."},{"page":"/learn/how-to-keep-ballerina-up-to-date/","name":"How to Keep Ballerina up to date","summary":"This guide explains how to maintain your Ballerina installation up to date with the latest patch and minor releases. If you haven’t installed Ballerina yet, visit .This section introduces various terms used throughout this guide. We recommend that you read this section before proceeding to the next.Ballerina is a command-line ...","content":"/  / How to Keep Ballerina up to date  How to Keep Ballerina up to date  This guide explains how to maintain your Ballerina installation up to date with the latest patch and minor releases. If you haven’t installed Ballerina yet, visit .    Terminology  This section introduces various terms used throughout this guide. We recommend that you read this section before proceeding to the next.  Ballerina tool  Ballerina is a command-line tool for managing Ballerina source code. It helps you to manage Ballerina projects and modules, test, build and run programs, etc.  It also enables you to easily install, update and switch among Ballerina distributions. The main focus of this guide is to teach you how, but first, let’s talk about Ballerina distributions.  Ballerina distributions    The language specification defines the syntax and semantics of Ballerina programming language. Ballerina compiler is a software program that validates the Ballerina source code and translates it to an executable program. There exist a production-ready official compiler called jBallerina. We also have a plan to do a native compiler called nBallerina.  jBallerina  Ballerina compiler that targets the JVM.  The most stable and production-ready compiler.  nBallerina  Ballerina compiler that targets platforms such as Linux, Windows and Mac OS.  Not available yet.  Ballerina distribution is a term that we use to refer to jBallerina and nBallerina compilers.  Release channels  Ballerina distributions are released on two different release channels at the moment: patch releases and minor releases. Both these channels distribute stable versions. We don’t yet have a release channel for nightly builds that give you access to the latest, perhaps unstable features.  Ballerina distribution releases strictly follow with major.minor.patch version numbers.  Patch release channel  This channel gives you access to patch releases of Ballerina distributions that contain bug fixes and fixes for critical stability and security issues. These releases are strictly time-bound and happen every two weeks. Occasionally, you would see on-demand patch releases as well.  Example patch releases: jballerina-1.0.6, jballerina-1.1.5, jballerina-1.1.10  Minor release channel  This channel gives you access to feature releases of Ballerina distributions. Ballerina programs that you’ve written today should continue to work on these minor releases. There will be four minor releases a year. You will get access to a minor release on the 3rd Wednesday of the 3rd month of every quarter.  Example minor releases: jballerina 1.1.0, jballerina 1.2.0, jballerina 1.3.0  Release maintenance    We maintain a minor release 1.x.0 by issuing a series of patch releases 1.x.y. The maintenance of a particular minor release stops when there are two newer minor releases available.  In other words, patch releases for jBallerina 1.x.0 stop when jBallerina 1.(x+2).0 is released. E.g., when jBallerina 1.2 is available, we stop maintaining jBallerina 1.0.0.   Keeping Ballerina upto date  Now that you are familiar with the terminology, let’s look at how you can keep your Ballerina distributions up to date.    The first step is to install Ballerina. Visit our guide for details. Once the installation is complete, you would see the following directory structure inside the installation directory.   . ├── bin/ │ └── ballerina ├── lib/ │ └── ballerina-command-0.8.0.jar ├── dependencies/ │ └── jdk8u202-b08-jre/ └── distributions/  ├── ballerina-version  ├── jballerina-1.0.5/  ├── jballerina-1.1.0/  └── jballerina-1.1.1/   “distributions” is the directory where we maintain all your installed distributions.  The “active” distribution    One only distribution from the above list can be active at a given time.  Ballerina tool delegates most of the user requests to the active distribution. The commands such as build, test, run, pull, and push are delegated to the active distribution, while the commands such as dist and version are handled by the tool itself. E.g., when you invoke ballerina build, the Ballerina tool dispatches this request to the active distribution.  You can change the active distribution at any time. Refer the section for more details.   The ballerina dist command  Ballerina tool comes with various subcommands to help you manage Ballerina source code. The ballerina dist and ballerina update commands are the ones that will be explained in this guide. The ballerina dist command allows you to manage Ballerina distributions whereas the ballerina update command updates the tool itself.  The dist command has few other subcommands. Here is the output of ballerina help dist.  → ballerina help dist NAME  ballerina-dist - Manage Ballerina distributions  SYNOPSIS  ballerina dist <command> <-h | --help>  ballerina dist <command> [<args>]   DESCRIPTION  Dist enables you to install, update, and switch among Ballerina distributions  from patch and minor release channels.   OPTIONS  -h, --help  Print usage details of a command.   BALLERINA COMMANDS  Here is a list of available subcommands:   update Update to the latest patch version of the active distribution  pull Fetch a distribution and set it as the active version  use Set a distribution as the active distribution  list List locally and remotely available distributions  remove Remove distributions in your local environment   Use 'ballerina help dist <command>' for more information on a specific command.   Most of these subcommands are self-explanatory. Therefore, the following sections introduce them briefly.  Update to the latest patch version  The ballerina dist update command updates your active distribution to the latest patch version.  E.g., If the active distribution in your environment is “jballerina-1.1.0” and there exists patch version “jballerina-1.1.4” in our servers, this command will fetch and set it as the active distribution.  → sudo ballerina dist update Fetching the latest patch distribution for 'jballerina-1.0.4' from the remote server... Fetching the 'jballerina-1.0.5' distribution from the remote server... Downloading jballerina-1.0.5 100% [==========================================================] 96/96 MB Successfully set the latest patch distribution 'jballerina-1.0.5' as the active distribution   List local and remote distributions  The ballerina dist list command lists the installed distributions in your local environment. It also lists the distributions available for you to download.  → ballerina dist list Distributions available locally:   jballerina-1.0.5 * jballerina-1.1.0  Distributions available remotely:   jballerina-1.1.0  jballerina-1.0.0  jballerina-1.0.1  jballerina-1.0.2 jballerina-1.0.3  jballerina-1.0.4  Use 'ballerina help dist' for more information on specific commands.    The star (*) indicates the active distribution.  Remove distributions  The ballerina dist remove <distribution> command allows you to delete a particular distribution from your local environment. If you’ve been updating Ballerina regularly, you may have accumulated many unused distribution versions. This command helps you to clean them up.  → ballerina dist remove jballerina-1.0.5 Distribution 'jballerina-1.0.5' successfully removed   Change the active distribution  The ballerina dist use <distribution> command sets a particular distribution version as the active one. See the following workflow.  → ballerina dist use jballerina-1.0.4 'jballerina-1.1.0' successfully set as the active distribution  → ballerina dist list Distributions available locally:   jballerina-1.1.0  jballerina-1.0.5 * jballerina-1.0.4  jballerina-1.0.0 …   Pull a specific distribution    The ballerina dist pull <distribution> command downloads a particular distribution and stores it in your local environment. It also sets the fetched distribution as the active distribution.   → sudo ballerina dist pull jballerina-1.0.3 Fetching the 'jballerina-1.0.3' distribution from the remote server... Downloading jballerina-1.0.3 100% [==================================] 96/96 MB 'jballerina-1.0.3' successfully set as the active distribution   Update the Ballerina tool    The ballerina update command updates the Ballerina tool itself to the latest version. Ballerina tool versions are independent from distribution versions. We expect these tool updates to be rare compared to distribution releases.   → ballerina update Fetching the latest version from the remote server... Downloading ballerina-command-0.8.1 Downloading ballerina-tool-0.8.1 100% [====================================] 1/1 MB  Updated to latest tool version: 0.8.1 Cleaning old files... Ballerina tool updated successfully"},{"page":"/learn/how-to-observe-ballerina-code/","name":"How to Observe Ballerina Services","summary":"Observability is a measure of how well internal states of a system can be inferred from knowledge of its external\noutputs. Monitoring, logging, and distributed tracing are key methods that reveal the internal state of the system to\nprovide the observability. Ballerina becomes fully observable by exposing itself via these three methods ...","content":"/  / How to Observe Ballerina Services  How to Observe Ballerina Services  Introduction Observability is a measure of how well internal states of a system can be inferred from knowledge of its external outputs. Monitoring, logging, and distributed tracing are key methods that reveal the internal state of the system to provide the observability. Ballerina becomes fully observable by exposing itself via these three methods to various external systems allowing to monitor metrics such as request count and response time statistics, analyze logs, and perform distributed tracing.  HTTP/HTTPS based Ballerina services and any client connectors are observable by default. HTTP/HTTPS and SQL client connectors use semantic tags to make tracing and metrics monitoring more informative.  Getting Started This section focuses on enabling Ballerina service observability with some of its default supported systems.  and are used for metrics monitoring, and is used for distributed tracing. Ballerina logs can be fed to any external log monitoring system like to perform log monitoring and analysis.  Prerequisites  Make sure you have already installed to setup external products such as Jaeger, Prometheus, etc. You can follow to install Docker.  Steps  Step 1: Install and configure Prometheus, Grafana, Jeager and Elastic Stack to Observe Ballerina.    Setup Prometheus for collecting metrics information by following section on Setup Grafana to visualize metrics by following section on Setup Jaeger analyze tracing as mentioned in section Setup Elastic Stack only if you are interested in analysing logs by following section on Step 2: Create Hello World Ballerina service.  Create a Service as shown below and save it as hello_world_service.bal.  import ballerina/http; import ballerina/log;  service hello on new http:Listener(9090) {  resource function sayHello (http:Caller caller, http:Request req) returns error? {  log:printInfo(\"This is a test Info log\");  log:printError(\"This is a test Error log\");  log:printWarn(\"This is a test Warn log\");  http:Response res = new;  res.setPayload(\"Hello, World!\");  check caller->respond(res);  }  }   Step 3: Observe Hello World Ballerina service  Observability is disabled by default and can be enabled by using the --b7a.observability.enabled=true flag or updating the configurations.  When Ballerina observability is enabled, Ballerina runtime exposes internal metrics via an HTTP endpoint for metrics monitoring and tracers will be published to Jaeger. Prometheus should be configured to scrape metrics from the metrics HTTP endpoint in Ballerina.  Ballerina logs are logged on to the console. Therefore, the logs need to be redirected to a file, which can then be pushed to to perform the log analysis.  Start the service using --b7a.observability.enabled=true flag:  The Ballerina service is observable with default settings when the --b7a.observability.enabled=true flag is used along with the Ballerina run command to start the service. This lets you to collect the distributed tracing information with Jaeger and metrics information with Prometheus.  $ ballerina run hello_world_service.bal --b7a.observability.enabled=true  [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090   Redirect the standard output to a file if you want to monitor logs.  For example:  $ nohup ballerina run hello_world_service.bal --b7a.observability.enabled=true > ballerina.log &   Start the service using a configuration file:  Observability of Ballerina service can also be enabled from the configuration. Create a configuration file such as ballerina.conf and add the below configuration that starts metrics monitoring and distributed tracing with default settings.  [b7a.observability.metrics] # Flag to enable Metrics enabled=true  [b7a.observability.tracing] # Flag to enable Tracing enabled=true   The created configuration file can be passed to the Ballerina program with --b7a.config.file option along with the path of the configuration file.  $ ballerina run hello_world_service.bal --b7a.config.file=<path-to-conf>/ballerina.conf  [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090   Redirect the standard output to a file if you want to monitor logs.  For example: $ nohup ballerina run hello_world_service.bal --b7a.config.file=<path-to-conf>/ballerina.conf > ballerina.log &   Step 4: Send few requests.  Send few requests to Example cURL command:  $ curl http://localhost:9090/hello/sayHello   Step 5: View tracing and metrics in dashboard.  View the tracing information on Jaeger via and view metrics information from Grafana dashboard on .  Sample view of Jaeger dashboard for hello_world_service.bal is shown below. Sample view of Grafana dashboard for hello_world_service.bal is shown below. Step 6: Visualize the logs.  If you have configured log analytics, view the logs in Kibana via Monitoring Metrics Metrics help to monitor the runtime behaviour of a service. Therefore, metrics is a vital part of monitoring Ballerina services. However, metrics is not the same as analytics. For example, you should not use metrics to do something like per-request billing. Metrics are used to measure what Ballerina service does at runtime to make better decisions using the numbers. The code generates business value when it continuously run in production. Therefore, it is imperative to continuously measure the code in production.  Metrics, by default, supports Prometheus. In order to support Prometheus, an HTTP endpoint starts with the context of /metrics in default port 9797 when starting the Ballerina service.  Advanced Metrics Configuration for Ballerina This section focuses on the Ballerina configurations that are available for metrics monitoring with Prometheus, and the sample configuration is provided below.  [b7a.observability.metrics] enabled=true reporter=\"prometheus\"  [b7a.observability.metrics.prometheus] port=9797 host=\"0.0.0.0\"   The descriptions of each configuration above are provided below with possible alternate options.    Configuration Key  Description  Default Value  Possible Values  b7a.observability.metrics. enabled  Whether metrics monitoring is enabled (true) or disabled (false)  false  true or false  b7a.observability.metrics. reporter  Reporter name that reports the collected Metrics to the remote metrics server. This is only required to be modified if a custom reporter is implemented and needs to be used.  prometheus  prometheus or if any custom implementation, then name of the reporter.  b7a.observability.metrics. prometheus.port  The value of the port in which the service ‘/metrics’ will bind to. This service will be used by Prometheus to scrape the information of the Ballerina service.  9797  Any suitable value for port 0 - 0 - 65535. However, within that range, ports 0 - 1023 are generally reserved for specific purposes, therefore it is advisable to select a port without that range.  b7a.observability.metrics. prometheus.host  The name of the host in which the service ‘/metrics’ will bind to. This service will be used by Prometheus to scrape the information of the Ballerina service.  0.0.0.0  IP or Hostname or 0.0.0.0 of the node in which the Ballerina service is running.  Setup External Systems for Metrics There are mainly two systems involved in collecting and visualizing the metrics. is used to collect the metrics from the Ballerina service and can connect to Prometheus and visualize the metrics in the dashboard.  Prometheus  is used as the monitoring system, which pulls out the metrics collected from the Ballerina service ‘/metrics’. This section focuses on the quick installation of Prometheus with Docker, and configure it to collect metrics from Ballerina service with default configurations. Below provided steps needs to be followed to configure Prometheus. There are many other ways to install the Prometheus and you can find possible options from .  Step 1: Create a prometheus.yml file in /tmp/ directory.  Step 2: Add the following content to /tmp/prometheus.yml.  global:  scrape_interval: 15s  evaluation_interval: 15s  scrape_configs:  - job_name: 'prometheus'  static_configs:  - targets: ['a.b.c.d:9797']   Here the targets 'a.b.c.d:9797' should contain the host and port of the /metrics service that’s exposed from Ballerina for metrics collection. Add the IP of the host in which the Ballerina service is running as a.b.c.d and its port (default 9797). If you need more information refer .  Step 3: Start the Prometheus server in a Docker container with below command.  $ docker run -p 19090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus   Step 4: Go to and check whether you can see the Prometheus graph. Ballerina metrics should appear in Prometheus graph’s metrics list when Ballerina service is started.  Grafana Let’s use to visualize metrics in a dashboard. For this, we need to install Grafana, and configure Prometheus as a datasource. Follow the below provided steps and configure Grafana.  Step 1: Start Grafana as Docker container with below command.  $ docker run -d --name=grafana -p 3000:3000 grafana/grafana  For more information refer .  Step 2: Go to to access the Grafana dashboard running on Docker.  Step 3: Login to the dashboard with default user, username: admin and password: admin  Step 4: Add Prometheus as datasource with Browser access configuration as provided below.    Step 5: Import the Grafana dashboard designed to visualize Ballerina metrics from . This dashboard consists of service and client invocation level metrics in near real-time view.  Ballerina HTTP Service Metrics Dashboard Panel will be as below.   Ballerina HTTP Client Metrics Dashboard Panel will be as below.   Ballerina SQL Client Metrics Dashboard Panel will be as below.   Distributed Tracing  Tracing provides information regarding the roundtrip of a service invocation based on the concept of spans, which are structured in a hierarchy based on the cause and effect concept. Tracers propagate across several services that can be deployed in several nodes, depicting a high-level view of interconnections among services as well, hence coining the term distributed tracing.  A span is a logical unit of work, which encapsulates a start and end time as well as metadata to give more meaning to the unit of work being completed. For example, a span representing a client call to an HTTP endpoint would give the user the latency of the client call and metadata like the HTTP URL being called and HTTP method used. If the span represents an SQL client call, the metadata would include the query being executed.  Tracing gives the user a high-level view of how a single service invocation is processed across several distributed microservices.    Identify service bottlenecks - The user can monitor the latencies and identify when a service invocation slows down, pinpoint where the slowing down happens (by looking at the span latencies) and take action to improve the latency.  Error identification - If an error occurs during the service invocation, it will show up in the list of tracers. The user can easily identify where the error occurred and information of the error will be attached to the relevant span as metadata.   Ballerina supports standards by default. This means that Ballerina services can be traced using OpenTracing implementations like , and . Jaeger is the default tracer of Ballerina.  Semantic tags used by Ballerina also follow the Advanced Tracing Configuration for Ballerina  Tracing can be enabled in Ballerina with --b7a.observability.enabled=true flag as mentioned in the section, as well as configuration option. This section mainly focuses on the configuration options with description and possible values.  The sample configuration that enables tracing, and uses Jaeger as the sample tracer as provided below.  [b7a.observability.tracing] enabled=true name=\"jaeger\"   The below table provides the descriptions of each configuration option and possible values that can be assigned.    Configuration Key  Description  Default Value  Possible Values  b7a.observability.tracing.enabled  Whether tracing is enabled (true) or disabled (false)  false  true or false  b7a.observability.tracing.name  Tracer name which implements tracer interface.  jaeger  jaeger or zipkin  Jaeger Client Jaeger is the default tracer supported by Ballerina. Below is the sample configuration options that are available in the Jaeger.  [b7a.observability.tracing] enabled=true name=\"jaeger\"  [b7a.observability.tracing.jaeger.sampler] type=\"const\" param=1.0  [b7a.observability.tracing.jaeger.reporter] hostname=\"localhost\" port=5775  [b7a.observability.tracing.jaeger.reporter.flush.interval] ms=2000  [b7a.observability.tracing.jaeger.reporter.max.buffer] spans=1000   The below table provides the descriptions of each configuration option and possible values that can be assigned.    Configuration Key  Description  Default Value  Possible Values  b7a.observability.tracing. jaeger.reporter.hostname  Hostname of the Jaeger server  localhost  IP or hostname of the Jaeger server. If it is running on the same node as Ballerina, it can be localhost.  b7a.observability.tracing. jaeger.reporter.port  Port of the Jaeger server  5775  The port which the Jaeger server is listening to.  b7a.observability.tracing. jaeger.sampler.type  Type of the sampling methods used in the Jaeger tracer.  const  const, probabilistic, or ratelimiting.  b7a.observability.tracing. jaeger.sampler.param  It is a floating value. Based on the sampler type, the effect of the sampler param varies  1.0  For const 0 (no sampling) or 1 (sample all spans), for probabilistic 0.0 to 1.0, for ratelimiting any positive integer (rate per second).  b7a.observability.tracing. jaeger.reporter.flush.interval.ms  Jaeger client will be sending the spans to the server at this interval.  2000  Any positive integer value.  b7a.observability.tracing. jaeger.reporter.max.buffer.spans  Queue size of the Jaeger client.  2000  Any positive integer value.  Zipkin Client The tracing of Ballerina service can be done via Zipkin as well, but the required dependencies are not included in default Ballerina distribution. Follow the below steps to add the required dependencies to the Ballerina distribution.  Step 1: Go to and clone the GitHub repository in any preferred location.  Step 2: Make sure you have installed .  Step 3: Open the command line and build the repository by using with below command, while being in the root project directory ballerina-observability.  $ mvn clean install   Step 4: Go to the path - ballerina-observability/tracing-extensions/modules/ballerina-zipkin-extension/target/ and extract distribution.zip.  Step 5: Copy all the JAR files inside the distribution.zip to ‘bre/lib’ directory in the Ballerina distribution.  Step 6: Add following configuration to the Ballerina.toml of your module.  [platform] target = \"java8\"   [[platform.libraries]]  artifactId = \"ballerina-zipkin-extension\"  version = \"1.0.0-rc1-SNAPSHOT\"  path = \"/<absolute_path_to>/ballerina-zipkin-extension-1.0.0-rc1-SNAPSHOT.jar\"  groupId = \"org.ballerinalang\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"brave-opentracing\"  version = \"4.17.1\"  path = \"/<absolute_path_to>/brave-4.17.1.jar\"  groupId = \"io.opentracing.brave\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"brave\"  version = \"0.29.0\"  path = \"/<absolute_path_to>/brave-opentracing-0.29.0.jar\"  groupId = \"io.zipkin.brave\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"zipkin-reporter\"  version = \"2.6.1\"  path = \"/<absolute_path_to>/zipkin-2.6.1.jar\"  groupId = \"io.zipkin.reporter2\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"zipkin\"  version = \"2.5.0\"  path = \"/<absolute_path_to>/zipkin-reporter-2.5.0.jar\"  groupId = \"io.zipkin.zipkin2\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"zipkin-sender-okhttp3\"  version = \"2.5.0\"  path = \"/<absolute_path_to>/zipkin-sender-okhttp3-2.5.0.jar\"  groupId = \"io.zipkin.reporter2\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"zipkin-sender-urlconnection\"  version = \"2.5.0\"  path = \"/<absolute_path_to>/zipkin-sender-urlconnection-2.5.0.jar\"  groupId = \"io.zipkin.reporter2\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"kotlin-stdlib\"  version = \"1.3.31\"  path = \"/<absolute_path_to>/kotlin-stdlib-1.3.31.jar\"  groupId = \"org.jetbrains.kotlin\"  modules = [\"yourModuleName\"]   Step 7: Change the following configuration name to Zipkin. This ensures that all tracers are sent to Zipkin instead of the default Jaeger tracer.  [b7a.observability.tracing] name=\"zipkin\"   Step 8: The following configuration is a sample configuration option available for Zipkin tracer.  [b7a.observability.tracing.zipkin.reporter] hostname=\"localhost\" port=9411  [b7a.observability.tracing.zipkin.reporter.api] context=\"/api/v2/spans\" version=\"v2\"  [b7a.observability.tracing.zipkin.reporter.compression] enabled=true   The below table provides the descriptions of each configuration option and possible values that can be assigned.    Configuration Key  Description  Default Value  Possible Values  b7a.observability.tracing.zipkin. reporter.hostname  Hostname of the Zipkin server  localhost  IP or hostname of the Zipkin server. If it is running on the same node as Ballerina, it can be localhost.  b7a.observability.tracing.zipkin. reporter.port  Port of the Zipkin server  9411  The port that the Zipkin server is listening to.  b7a.observability.tracing.zipkin. reporter.api.context  API context of the Zipkin server  /api/v2/spans  The API context of the Zipkin API. For V1 API, the context will be /api/v1/spans, and for V2 API, the context will be /api/v2/spans for default Zipkin server.  b7a.observability.tracing.zipkin. reporter.api.version  API version of the Zipkin API  v2  v1 or v2.  b7a.observability.tracing.zipkin. reporter.compression.enabled  Enable the compression for the spans request  true  true or false.  Setup External Systems for Tracing Ballerina by default supports Jaerger and Zipkin for distributed tracing. This section focuses on configuring the Jaeger and Zipkin with Dockers as a quick installation.  Jaeger Server Jaeger is the default distributed tracing system that is supported. There are many possible ways to deploy Jaeger and you can find more information on this . Here we focus on all in one deployment with Docker.  Step 1: Install Jaeger via Docker and start the Docker container by executing below command.  $ docker run -d -p5775:5775/udp -p6831:6831/udp -p6832:6832/udp -p5778:5778 -p16686:16686 -p14268:14268 jaegertracing/all-in-one:latest   Step 2: Go to and load the web UI of the Jaeger to make sure it is functioning properly.  The below image is the sample tracing information you can see from Jaeger.    Zipkin Server Similar to Jaeger, Zipkin is another distributed tracing system that is supported by the Ballerina. There are many different configurations and deployment exist for Zipkin, please go to for more information. Here we focus on all in one deployment with Docker.  Step 1: Install Zipkin via Docker and start the Docker container by executing following command.  $ docker run -d -p 9411:9411 openzipkin/zipkin   Step 2: Go to and load the web UI of the Zipkin to make sure it is functioning properly. The below shown is the sample Zipkin dashboard for the hello world sample in the Distributed Logging Ballerina distributed logging and analysis is supported by Elastic Stack. Ballerina has a log module for logging in to the console. In order to monitor the logs, the Ballerina standard output needs to be redirected to a file.  This can be done by running the Ballerina service as below.  $ nohup ballerina run hello_world_service.bal > ballerina.log &   You can view the logs with below command.  $ tail -f ~/wso2-ballerina/workspace/ballerina.log   Setup External Systems for Log Analytics  Elastic Stack The elastic stack comprises of the following components.    Beats - Multiple agents that ship data to Logstash or Elasticsearch. In our context, Filebeat will ship the Ballerina logs to Logstash. Filebeat should be a container running on the same host as the Ballerina service. This is so that the log file (ballerina.log) can be mounted to the Filebeat container.  Logstash - Used to process and structure the log files received from Filebeat and send to Elasticsearch.  Elasticsearch - Storage and indexing of the logs received by Logstash.  Kibana - Visualizes the data stored in Elasticsearch   Elasticsearch and Kibana are provided as Alternatively, Docker containers can be used to set up Elasticsearch and Kibana as well.  Step 1: Download the Docker images using the following commands.  # Elasticsearch Image $ docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.1 # Kibana Image $ docker pull docker.elastic.co/kibana/kibana:6.5.1 # Filebeat Image $ docker pull docker.elastic.co/beats/filebeat:6.5.1 # Logstash Image $ docker pull docker.elastic.co/logstash/logstash:6.5.1   Step 2: Start Elasticsearch and Kibana containers by executing the following commands.  $ docker run -p 9200:9200 -p 9300:9300 -it -h elasticsearch --name elasticsearch docker.elastic.co/elasticsearch/elasticsearch:6.5.1 $ docker run -p 5601:5601 -h kibana --name kibana --link elasticsearch:elasticsearch docker.elastic.co/kibana/kibana:6.5.1   If you run on Linux you may have to increase the vm.max_map_count for the Elasticsearch container to start. Execute the following command to do that.  $ sudo sysctl -w vm.max_map_count=262144   Step 3: Create a logstash.conf file in the /tmp/pipeline/ directory and include the following content in the file.  input {  beats {  port => 5044  } } filter {  grok {  match => { \"message\" => \"%{TIMESTAMP_ISO8601:date}%{SPACE}%{WORD:logLevel}%{SPACE}\\[%{GREEDYDATA:module}\\]%{SPACE}\\-%{SPACE}%{GREEDYDATA:logMessage}\"}  } } output {  elasticsearch {  hosts => \"elasticsearch:9200\"  index => \"ballerina\"  document_type => \"ballerina_logs\"  } }   Here the 3 stages are specified in the pipeline. Input is specified as beats and listens to port 5044. A grok filter is used to structure the Ballerina logs and the output is specified to push to Elasticsearch on elasticsearch:9200.  Step 4: Start the Logstash container by the following command.  $ docker run -h logstash --name logstash --link elasticsearch:elasticsearch -it --rm -v /tmp/pipeline:/usr/share/logstash/pipeline/ -p 5044:5044 docker.elastic.co/logstash/logstash:6.5.1   Step 5: Configure Filebeat to ship the Ballerina logs. Create a filebeat.yml file in the /tmp/ directory and include the following content in the file.  filebeat.prospectors: - type: log  paths:  - /usr/share/filebeat/ballerina.log output.logstash:  hosts: [\"logstash:5044\"]   Step 6: Start the Filebeat container with the following command.  The -v flag is used for bind mounting, where the container will read the file from the host machine. Provide the path to the ballerina.log file, to be bind mounted to the filebeat container.  $ docker run -v /tmp/filebeat.yml:/usr/share/filebeat/filebeat.yml -v /<path-to-ballerina.log>/ballerina.log:/usr/share/filebeat/ballerina.log --link logstash:logstash docker.elastic.co/beats/filebeat:6.5.1   Step 7: Access Kibana to visualize the logs at . Add an index named ballerina and click on Discover to visualize the logs."},{"page":"/learn/how-to-publish-modules/","name":"How to Publish a Module","summary":"Pushing a module uploads it to .Before you push your module, you must enter your Ballerina Central access token in Settings.toml in your home repository (<USER_HOME>/.ballerina/).To get your token, register on Ballerina Central and visit the user dashboard at .If you are connected to the internet via an HTTP proxy, ...","content":"/  / How to Publish a Module  How to Publish a Module  CLI Command  Pushing a module uploads it to .  ballerina push <module-name>   Setting up  Before you push your module, you must enter your Ballerina Central access token in Settings.toml in your home repository (<USER_HOME>/.ballerina/).  To get your token, register on Ballerina Central and visit the user dashboard at .  If you are connected to the internet via an HTTP proxy, add the following section to Settings.toml and change accordingly.  [proxy] host = \"localhost\" port = \"3128\" username = \"\" password = \"\"   Organizations  When you push a module to Ballerina Central, the runtime validates organizations for the user against the org-name defined in your module’s Ballerina.toml file. Therefore, when you have more than one organization in Ballerina Central, be sure to pick the organization name that you intend to push the module into and set that as the org-name in the Ballerina.toml file inside the project directory."},{"page":"/learn/how-to-run-ballerina-programs/","name":"How to Run Ballerina Programs and Services","summary":"A Ballerina application can have:A  function that runs as a terminating process.A , which is a hosted non-terminating process.Both of these are considered as entry points for program execution.These applications can be structured into a single program file or a Ballerina module. A collection of modules can be managed ...","content":"/  / How to Run Ballerina Programs  How to Run Ballerina Programs and Services  A Ballerina application can have:    A function that runs as a terminating process.  A , which is a hosted non-terminating process.  Both of these are considered as entry points for program execution.  These applications can be structured into a single program file or a Ballerina module. A collection of modules can be managed together with versioning and dependency management as part of a Ballerina project.  Source files and modules can contain zero or more entrypoints, and the runtime engine has precedence and sequence rules for choosing which entrypoint to execute.  Running Standalone Source Code A single Ballerina source code file can be placed into any folder.  If the source file contains at least one entry point, it can be executed using the run command.  $ ballerina run foo.bal   You can compile a source file with an entry point into an executable jar.  $ ballerina build [-o outputfilename.jar] foo.bal   And you can run .jar files directly: $ ballerina run filename.jar   Running a Project A project is a folder that manages modules as part of a common versioning, dependency management, build, and execution. You can build and run items collectively or individually as modules. See for in-depth structuring of projects.  Build all modules of a project: $ ballerina build   Build a single module in a project: $ ballerina build <module-name>   Options for running programs with entrypoints in a project: $ ballerina run main.bal $ ballerina run main.jar   Configuring Your Ballerina Runtimes  Ballerina Runtime Configuration Files  A Ballerina runtime can be configured using configuration parameters, which are arbitrary key/value pairs with structure. The ballerina/config module provides an API for sourcing configuration parameters and using them within your source code. See for details.  The configuration APIs accept a key and an optional default value. If a mapping does not exist for the specified key, the default value is returned as the configuration value. The default values of these optional configurations are the default values of the return types of the functions.  Sourcing Parameters Into Ballerina Programs Configuration parameters for your programs and apps can be defined on the CLI, as an environment variable, or from a configuration file, with loading and override precedence in the same order.  Sourcing CLI Parameters Consider the following example, which reads a Ballerina config value and prints it.  import ballerina/io; import ballerina/config;  public function main() {  string name = config:getAsString(\"hello.user.name\");  io:println(\"Hello, \" + name + \" !\"); }   The config key is hello.user.name. To pass a value to this config from the CLI, we can use --key=value format as the following command. $ ballerina run main.bal --hello.user.name=Ballerina Hello, Ballerina !   Sourcing Configuration Values  The value can be passed as a config file as well. A configuration file should conform to the format. Ballerina only supports the following features of TOML: value types (string, int, float, and boolean), tables, and nested tables. Given below is a sample ballerina.conf:  [hello.user] name=\"Ballerina\"   When running a program with config API lookups, Ballerina looks for a ballerina.conf file in the directory where the source files are located.  If ballerina.conf resides in the same directory as main.bal, balllerina run can be used without any argument. $ ballerina run main.bal Hello, Ballerina !  To explicitly specify a configuration file, use the --b7a.config.file property. The path to the configuration file can be either an absolute or a relative path. $ ballerina run main.bal --b7a.config.file=path/to/conf/file/custom-config-file-name.conf Hello, Ballerina !   Configure Secrets as Configuration Items Ballerina provides support for encrypting sensitive data such as passwords and allows access to them securely through the configuration API in the code.  Creating a Secured Value The ballerina encrypt command will encrypt parameters that can be securely sourced from your code files. For example, let’s create a secure parameter named Ballerina with the value 12345 as the secret.  $ ballerina encrypt Enter value: Enter secret: Re-enter secret to verify: Add the following to the runtime config: <key>=\"@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=}\"  Or add to the runtime command line: --<key>=@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=}   Using the Secured Value at Runtime The secured value can be placed in a config file as a value or passed on the command line.  [hello.user] name=\"@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=}\"   or (Enter secret 12345 when prompted.):  $ ballerina run main.bal --hello.user.name=@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=} ballerina: enter secret for config value decryption:  Hello, Ballerina !   Decrypting the Value If a configuration contains an encrypted value, Ballerina looks for a secret.txt file in the directory where the source files are located. The secret.txt should contain the secret used to encrypt the value. The secret.txt file will be deleted after it is read. $ echo 12345 > secret.txt $ ballerina run main.bal --b7a.config.file=ballerina.conf Hello, Ballerina !   If the secret.txt file is not present, then CLI prompts the user for the secret. Enter secret 12345 when prompted. $ ballerina run main.bal --b7a.config.file=ballerina.conf ballerina: enter secret for config value decryption:  Hello, Ballerina !"},{"page":"/learn/how-to-structure-ballerina-code/","name":"How to Structure Ballerina Code","summary":"This document demonstrates the development of a Ballerina project and shows how to use the Ballerina Tool to fetch, \nbuild, and install Ballerina modules. These commands work with repositories that are both local and remote.Ballerina Central is a globally hosted module management system that is used to discover, download, and ...","content":"/  / How to Structure Ballerina Code  How to Structure Ballerina Code This document demonstrates the development of a Ballerina project and shows how to use the Ballerina Tool to fetch, build, and install Ballerina modules. These commands work with repositories that are both local and remote.  Ballerina Central is a globally hosted module management system that is used to discover, download, and publish modules.  The Ballerina Tool requires you to organize your code in a specific way. This document explains the simplest way to get it up and running with a Ballerina installation.  Overview   Ballerina programmers can either place their code into a single source code file or in a project directory.  A Ballerina program residing in a single source code file should have a .bal extension and an entry point (i.e., either a main method or a service).  A Ballerina program is a compiled and linked binary.  A module is a directory that contains Ballerina source code files.  A repository is a versioned collection of compiled or source code modules.  A project atomically manages a collection of modules.   Programs A program is a runtime executable ending with a .jar extension. A program is the transitive closure of one Ballerina module without including ballerina/* modules, since those are dynamically linked within Ballerina’s runtime engine during execution. A module, which is a program compiles into a file with a .jar extension. Otherwise, it is treated as a to-be-linked library that ends with a .balo extension.  To generate an executable .jar file, the program’s module must contain either a main() function (a process entry point) or a service (a network-accessible API).  A program can import dependent modules that are stored within a repository.  Suppose you have the following structure:  /local/ballerina/src  sample.bal   The sample.bal file contains both a main() entry point and a service:  import ballerina/http; import ballerina/io; import ballerina/log;  public function main() {  io:println(\"Hello, World!\"); }  service hello on new http:Listener(9090) {  resource function sayHello (http:Caller caller, http:Request req) {  http:Response res = new;  res.setPayload(\"Hello, World!\");  var respondResult = caller->respond(res);  if (respondResult is error) {  log:printError(\"Error sending response\", err = respondResult);  }  } }   Build and Run Programs To generate an executable .jar, you can build a Ballerina program, which contains a main() function or a service(s):  $ cd /local/ballerina/src $ ballerina build sample.bal  # This generates 'sample.jar'.   You can use the following command to run the main() function or services in a generated .jar file: $ ballerina run sample.jar   Modules A module is a directory, which contains Ballerina source code files and is part of a namespace. Modules facilitate collaboration, sharing, and reuse. Modules can include functions, clients, constants, annotations, services, and objects. To share a module among programs, projects, and users, you need to push the module into a repository.  Modules:   May or may not have a version However, modules cannot be pushed into a registry for sharing without a version Are referenced by <org-name>/<module-name> where <org-name> is a namespace from within a repository.   Module names can contain alphanumeric characters including dots (.). Dots in a module name has no meaning other than the last segment after the final dot being used as a default alias within your source code.  Importing Modules Your Ballerina source files can import modules:  import [<org-name>]/<module-name> [as <identifier>];   When you import a module, you can use its functions, annotations, and other objects in your code. You can also reference the objects with a qualified identifier followed by a colon (:). For example, <identifier>:<module-object>.  Identifiers are either derived or explicit. The default identifier is either the module name or if the module name has dots (.) included, then the last word after the last dot. For example, import ballerina/http; will have http:as the derived identifer and the module import ballerinax/java.jdbc would have jdbc: as the default identifier.  You can have an explicit identifier by using the as <identifier> syntax.  import ballerina/http;  // The listener comes from the imported module. service hello on new http:Listener(9090) {   // The 'Request' object comes from the imported module.  resource function sayHello (http:Caller caller, http:Request req) {  ...  } }   Or you can override the default identifier: import ballerina/http as network;  service hello on new network:Listener(9090) {   // The 'Request' object comes from the imported module.  resource function sayHello (network:Caller caller, network:Request req) {  ...  } }   Module Version Dependency If your source file or module is a part of a project, then you can explicitly manage version dependencies of imported modules within the project by defining it in the Ballerina.toml file:  [dependencies] \"wso2/twitter\" = \"2.3.4\" \"wso2/github\" = { path = \"path/to/github.balo\", version = \"1.2.3\"}  Often, you would want to depend on a module of another project, which you have not pushed to the Ballerina Central. This can be achieved using a path dependency as shown above with the wso2/github dependency.  If an import version is not specified in Ballerina.toml, the compiler will use the latest module version from a repository, if one exists.  import foo/http;  public function main() {  http:Person x = http:getPerson(); }   Compiled Modules A compiled module is the compiled representation of a single module of Ballerina code, which includes transitive dependencies into the compiled unit.  Modules can only be created, versioned, and pushed into a repository as part of a project.  Running Compiled Modules An entrypoint such as a main() or a service that is compiled as part of a named module is automatically linked into a .jar. You can run the compiled module .jar:  ballerina run module.jar   Projects   A project is a directory, which atomically manages a collection of modules. It has:  A user-managed manifest file, Ballerina.toml  An src folder with module source code  Projects are managed atomically. Therefore, dependency management, compilation, unit tests, and artifact generation are done collectively across the source code files and modules defined within a project.  Create a Project You can create a project using the ballerina new command:  ballerina new <project-name>   The new command will create a project directory with the given name. A Ballerina project cannot reside in another ballerina project. If you run ballerina new from inside a Ballerina project directory or from inside a sub directory of a Ballerina project, it will give an error.  It will create the Ballerina.toml file, and src folder.  Add a Module Once the project is initialized, a module can be created inside the project using the ballerina add command. Each subdirectory of the project src folder defines a single module. The subdirectory’s name will be used to name the module.  ballerina add <module-name>   The folders tests/ and resources/ are reserved folder names within the module. The tests/ folder contains unit test files of the module and the resources/ folder contains the resources of the module that will be available at runtime. Any additional subdirectories within the module have no semantic meaning and can be used by the developer for organizing files. The module subdirectories can have as many Ballerina source files and all will be included within the module when it is built.  Project Structure /  project-name/  .gitignore  Balleirna.lock # Generated during the build and used to rebuild identical binary  Ballerina.toml # Configuration, which defines project intent  src/  module1/ # The source in this directory will be named “<org-name>/module1”  Module.md # Contains descriptive metadata for display at Ballerina Central  main.bal # Contains the default main method  *.bal # In this dir and recursively in subdirs except tests/ and resources/  [tests/] # Module-specific unit and integration tests  main_test.bal # The test file for main  [resources] # Resources for the tests  [resources/] # Module-specific resources module2/  Module.md  *.bal  [tests/]  [resources/] target/ # Compiled executables and other artifacts end up here  balo/ # BALO files, one per each module, will be created here  bin/ # Executables will be created here  caches/  bir_cache/  jar_cache/   Build a Project A project should be built if it is required to generate the executable JAR files from the modules in the project. The executable JAR files will be generated only if there are entry points (main method or a service) in the module. Building a project will build all modules found in the project’s root folder. Building a project runs through phases including dependency resolution, compilation, artifact generation, and unit test execution.  ballerina build -a   Build a Module You can build a single module contained within a project:  ballerina build <module-name>  Use the --skip-tests flag with the ballerina build command to skip running the tests during the build process.  ballerina build --skip-tests <module-name>   Compile a Project A project should be compiled if it is required to generate the libraries (i.e., BALOs) from the modules in the project. Compiling a project will compile all the modules found in the project’s root folder. Building a project runs through phases including dependency resolution, compilation, artifact generation, and unit test execution.  ballerina build -c -a   Compile a Module You can build a single module contained within a project:  ballerina build -c <module-name>  Use the --skip-tests flag with the ballerina compile command to skip running the tests during the compile process.  ballerina build -c --skip-tests <module-name>   Version a Module Modules in a project are assigned their version from within the Ballerina.toml file:  # The current version, obeying [semver](https://semver.org/) version = \"string\"   All modules built in a project are assigned the same version. If you need two modules to have different versions, then those modules should be placed into different projects.  Version labels must follow .  Assign an Organization Name to a Module A module is assigned an <org-name> when it is pushed into a repository. The <org-name> is defined in the Ballerina.toml and all modules in the same project are assigned the same organization name:  # Org name assigned to modules when installed into a repository org-name = \"foo\"   Module Caches  Caches  Ballerina will maintain several caches to speed up the compile and build process. Following artifacts will be cached by Ballerina.    BALO files fetched from Central.  BIR files generated during the compilation.  JAR file generated during the compilation   Here, the BALO cache will be common across any version of Ballerina and the BIR and JAR caches will be specific to the Ballerina version.  BALO Cache  BALO cache is responsible for keeping BALOs of dependent modules. There is a BALO cache inside the Ballerina distribution, which contains the BALOs of libraries that will get packed into the distribution. There is another cache at the user’s home repository, which is used to cache the BALOs fetched from Central.  BIR Cache  BIR files of the standard library that gets packed into a distribution are generated during the distribution build time. The BIR files of the other dependencies will be kept inside the target directory when compiling a Ballerina project.  JAR Cache  The JAR files generated during the build will be kept inside the target directory when building a Ballerina project. The JAR file will be generated only if there is an entry point (main function or service) within the module.  Module Repository - Ballerina Central A repository is a collection of compiled Ballerina modules. A repository helps to organize modules used by multiple programs by managing their versions and assets in a central location. [Ballerina Central] (http://central.ballerina.io) is the only module repository for Ballerina developers.  Organizations An organization is a logical name used for grouping modules together under a common namespace within a repository.  All modules installed into a repository must have an organization name. Any installation or pushing of a module into a repository will fail without an organization name.  Organization names can contain lowercase alphanumeric characters and underscores. None of the characters in an organization name have any semantic meaning.  The organization names ballerina and ballerinax are reserved for system use. Modules in ballerina and ballerinax are included within the system distribution.  At Ballerina Central, every account is assigned a personal organization name, which is chosen by a user when creating their account initially or is derived from the email address of the user.  When pushing a module from a local computer into Ballerina Central, the user’s organization name in the Ballerina Central MUST match the <org-name> assigned in the Ballerina.toml file. If the names do not match, then the push operation will fail. This enforcement may seem arbitrary. However, it is a simple way to ensure organization naming consistency across remote and local development environments.  Pulling Remote Modules You can install modules that exist in Ballerina Central into your BALO cache in the home directory via “pulling” them. Pulling a module discovers and downloads the module source and binaries from Ballerina Central and installs them into the BALO cache.  ballerina pull <org-name>/<module-name>[:<version>]   If a version is not specified for the module to be pulled, the latest version of the module will be pulled from the Ballerina Central. Projects that perform dependency analysis will automatically pull modules into the BALO cache in the home directory.  Pushing Modules “Pushing” a module uploads the associated module files and installs the module into Ballerina Central.  The org-name and the version of the module will be read from the manifest file Ballerina.toml inside the project. It is required to build the module before pushing it to Ballerina Central.  # Push a single module ballerina push <module-name>  Configure Ballerina Central Access  Ballerina Central requires an account in order to push modules. Your account is represented by a CLI token that is installed into your local Ballerina configuration file, i.e., ~/.ballerina/Settings.toml. The CLI token is automatically installed into this file the first time you perform a ballerina push as Ballerina redirects to an OAuth authorization screen, configures your account, and then copies your CLI token from Ballerina Central into your local CLI configuration. To get your token, register on Ballerina Central and visit the .  Every push of the same module into Ballerina Central REQUIRES a new version even for minor text updates. This policy is enforced to ensure that projects, which make use of dependencies cannot experience accidental behavior drift across two versions of the same module given the same version. Essentially, there is no way to “update” a module for a specific version in Ballerina Central."},{"page":"/learn/how-to-test-ballerina-code/","name":"How to Test Ballerina Code","summary":"Ballerina has a built-in test framework named Testerina. Testerina enables developers to write testable code. The test framework provides a set of building blocks to help write tests and a set of tools to help test.Developers and testers can cover multiple levels of the test pyramid including unit testing, integration ...","content":"/  / How to Test Ballerina Code  How to Test Ballerina Code  Ballerina has a built-in test framework named Testerina. Testerina enables developers to write testable code. The test framework provides a set of building blocks to help write tests and a set of tools to help test.  Developers and testers can cover multiple levels of the test pyramid including unit testing, integration testing and end to end testing with the building blocks the framework provides. It provides the flexibility to programmers and testers to build intelligent tests that suit the domain and application needs.  Testerina design and usage is aligned with project and module semantics of Ballerina. You can test the project modules while you are building the project in a seamless manner using the test constructs.  Overview    Ballerina programmers can place their test code in a tests folder in a module  Ballerina tests are defined using a set of annotations  Test assertions can be used to verify the set of program behaviour expectations  Data providers can be used to feed in the test data sets  Function mocks can be used to mock a function in a module that you are testing or a function of an imported module   Writing and Running Tests  To write tests, you need to import the test module in all Ballerina test source files.  import ballerina/test;   For structured projects, it is recommended to use a structured test model that is aligned with standard module semantics. Structured test model consists of a separate tests directory in a Ballerina module, which allows you to isolate the source from the tests.  In a standard Ballerina project, a module is mapped to a test suite. Unit and integration tests bound to a module need to be placed in a subfolder called tests/ within the module. All tests within a module’s tests/ subfolder are considered to be part of the same test suite.  Project Structure project-name/ - Ballerina.toml - src/ -- mymodule/ --- Module.md <- module level documentation --- main.bal <- Contains default main method. --- resources/ <- resources for the module (available at runtime) --- tests/ <- tests for this module (e.g. unit tests) ---- testmain.bal <- test file for main ---- resources/ <- resources for these tests  The test source files could have any name. The test functions are just Ballerina functions that use a special annotation to mark the function as a test. Test functions must be specified with the @test:Config { } annotation and there is no restriction on the test function name.  The ballerina test command can be used to execute tests.  Execute tests within the specified module with the following command.  ballerina test <module_name> Execute tests in the entire project, using the --all option.  ballerina test --all   For more information on the test command, run the following.  ballerina help test Annotations  Testerina defines the following test annotations.  @test:BeforeSuite {} The function specified following the annotation will be run once before any of the tests in the test suite is run. This can be used for initializing test suite level aspects.  @test:BeforeSuite {} function testSuiteInitialize() { // module level test initialization logic here }   Sample :  import ballerina/io; import ballerina/test;  // The `BeforeSuite` function is executed before all test functions in this module. @test:BeforeSuite function beforeFunc() {  io:println(\"I'm the before suite function!\"); }  // Test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }  // Test function. @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed\"); }  @test:BeforeEach {} The function specified following the annotation will be run before every test within the test suite is run. This can be used for repeatedly initializing test level aspects before every test function.  @test:BeforeEach {} function beforeEachTest() { // test initialization logic here to be // executed before each test being run }   Sample :  import ballerina/io; import ballerina/test;  // Before each function, which is executed before each test function @test:BeforeEach function beforeFunc() {  io:println(\"I'm the before function!\"); }  // Test function @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // Test function @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }  // Test function @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }   @test:Config {} The function specified following the annotation is a test function. This annotation supports the following parameters.  Annotation Value Fields: enable: {true | false}: Enable/disable the test. Default: true  before: \"<function name>\": Name of the function to be run just before the test is run. Default: none  after: \"<function name>\": Name of the function to be run just after the test is run.  dependsOn: [\"<function names>\", …]: A list of function names on which the test function depends. These will be run before the test. The list of functions provided has no order of execution. The current test function will depend on the list provided and that list will run in whatever order. Thus, the order in which the comma-separated list appears has no prominence. In case there needs to be an order, define a sequence of test functions with one pointing to another based on dependency using the dependsOn parameter in each one’s config.  dataProvider: “<function name>”: Specifies the name of the function that will be used to provide the value sets to execute the test against. The given Ballerina function should return an array of arrays (e.g., string[][] for a test function that accepts string parameters). Each array of the returned array of arrays should have a length similar to the number of arguments of the function (e.g., function testSuffixC(string input, string expected) could have a dataProvider function that returns a string[][] like [ [“ab”, “abc”], [“de”, “dec”] ] ). The length of the array of arrays represents the number of time the same test case would run (e.g., in the above example the test function testSuffixC would run 2 times with input parameters “ab”, “abc” and “de”, “dec” respectively).  groups: [“<test group name”, …]: List of test group names (one or more) that this test belongs to. You can group a given test to a list of named test groups using this configuration.  @test:Config {  before: \"beforeTestBar\", after: \"afterTestBar\", dependsOn: [\"testFunctionPre1\", \"testFuncctionPre2\"],  groups: [\"group1\"] } function testBar() { // test logic for function bar() }   Sample :  import ballerina/io; import ballerina/test;  function beforeFunc() {  // This is the before Test Function }  function afterFunc() {  // This is the before Test Function }  // This test function depends on `testFunction3`. @test:Config {  before: \"beforeFunc\",  // You can provide a list of depends on functions here.  dependsOn: [\"testFunction3\"],  groups:[\"group1\"],  after:\"afterFunc\" } function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // This is a random test function, this will randomly execute without depending on other functions. // But note that other function do depend on this. @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }   @test:AfterSuite {}  The function specified following the annotation will be run once after all of the tests in the test suite is run. This can be used for cleaning up test suite level aspects. The test suite covers tests related to a module.  @test:AfterSuite {} function testSuiteCleanup() { // module level test cleanup logic here }   Sample :  import ballerina/io; import ballerina/test;  // Test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }  // The `AfterSuite` function is executed after all the test functions in this module. @test:AfterSuite function afterFunc() {  io:println(\"I'm the after suite function!\"); }   Assertions Testerina supports the following assertions.  assertTrue(boolean expression, string message) Asserts that the expression is true with an optional message.  import ballerina/test;  @test:Config {} function testAssertTrue() {  boolean value = false;  test:assertTrue(value, msg = \"AssertTrue failed\"); }   assertFalse(boolean expression, string message)  Asserts that the expression is false with an optional message.  import ballerina/test;  @test:Config {} function testAssertFalse() {  boolean value = false;  test:assertFalse(value, msg = \"AssertFalse failed\"); }   assertEquals(Any actual, Any expected, string message)  Asserts that the actual is equal to the expected, with an optional message.  import ballerina/test;  @test:Config {} function testAssertIntEquals() {   int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertEquals(answer, 8, msg = \"IntAdd function failed\"); }  function intAdd(int a, int b) returns (int) {  return (a + b); }   assertNotEquals(Any actual, Any expected, string message)  Asserts that the actual is not equal to the expected, with an optional message.  import ballerina/test;  @test:Config {} function testAssertIntEquals() {   int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertNotEquals(answer, 8, msg = \"Matches\"); }  function intAdd(int a, int b) returns (int) {  return (a + b); }   assertFail(string message)  Fails the test. Useful when we want to fail a test while in execution based on a check for a condition.  import ballerina/test;  @test:Config {} function foo() {  error? e = trap bar(); // Expecting `bar()` to panic  if (e is error) {  test:assertEquals(e.reason(), \"Invalid Operation\", msg = \"Invalid error reason\"); // Some other assertions  } else {  test:assertFail(msg = \"Expected an error\");  } }   Function Mocks  Ballerina test framework provides the capability to mock a function. Using the mocking feature you can easily mock a function in a module that you are testing or a function of an imported module. This feature will help you to test your Ballerina code independently from other modules and functions  @test:Mock {}  The function specified with the @test:Mock {} annotation will be considered as a mock function that gets triggered every time the original function is called. The original function that will be mocked should be defined using the annotation parameters.  Annotation Value Fields  moduleName : \"<moduleName>\" : Name of the module where the function to be mocked resides in. If the function is within the same module, this can be left blank or “.” (No module) can be passed. If the function is in a different module, but within the same project, just passing the module name will suffice. For functions in completely seperate modules, the fully qualified module name must be passed, which includes the orgName and the version. ie. orgName/module:version. For native function, the ballerina module needs to be specified.  functionName : \"<functionName>\" : Name of the function to be mocked.  Sample :  The following is an example for function mocking.  The following is the function definition in the module that we are trying to mock in the test case   public function intAdd(int a, int b) returns (int) {  return (a + b); }    The following is the Ballerina test file where the function mocking takes place  import ballerina/io; import ballerina/test; import ballerina/math;   // This is the mock function which will replace the real `intAdd` function @test:Mock {  // Since the function is defined in the same module, \".\" can be passed as the current module.  // This can also be left blank.  moduleName : \".\",  functionName : \"intAdd\" } // The mock function signature should match the actual function signature. public function mockIntAdd(int a, int b) returns (int) {  io:println(\"I am the mockIntAdd function\");  return (a - b); }   // This test function calls the local `intAdd()` function but it expects the mocked result @test:Config {} function test_intAdd() {  int answer = 0;  answer = intAdd(5, 3);  test:assertEquals(answer, 2, msg = \"function mocking failed\"); }  // This test function calls the native `sqrt()` function but it expects the mocked result @test:Config {} function test_sqrt() {  float answer = 0;  answer = math:sqrt(5);   test:assertEquals(answer, 125.0, \"mocking did not take place\"); }  // This is a mock function which will replace `sqrt()` by `ballerina/math`. @test:Mock {  moduleName : \"ballerina/math\",  functionName : \"sqrt\" } function mocksqrt(float a) returns (float) {  io:println(\"I am the mocksqrt function\");  return a*a*a; }"},{"page":"/learn/how-to-use-openapi-tools/","name":"Ballerina OpenAPI ToolsSamples","summary":"OpenAPI Specification is a specification that creates a RESTFUL contract for APIs, detailing all of its resources and operations in a human and machine-readable format for easy development, discovery, and integration. Ballerina OpenAPI tooling will make it easy for users to start development of a service documented in OpenAPI contract ...","content":"/  / Ballerina OpenAPI Tools  Ballerina OpenAPI Tools  OpenAPI Specification is a specification that creates a RESTFUL contract for APIs, detailing all of its resources and operations in a human and machine-readable format for easy development, discovery, and integration. Ballerina OpenAPI tooling will make it easy for users to start development of a service documented in OpenAPI contract in Ballerina by generating Ballerina service and client skeletons.  The OpenAPI tools provides following capabilities.    Generate the Ballerina Service or Client code for a given OpenAPI definition.  Generate the client stub for an existing Ballerina service at build time.  Export the OpenAPI definition of a Ballerina service.   The openapi command in Ballerina is used for OpenAPI to Ballerina and Ballerina to OpenAPI code generation. Code generation from OpenAPI to Ballerina can produce ballerina mock services and ballerina client stubs.  For build time client stub generation, annotation support is provided.  Mock service from OpenAPI ballerina openapi gen-service <moduleName>:<serivceName> <openapi_contract>  [-c: copy-contract] [-o: outputFile]  Generates a Ballerina service for the OpenAPI file.  This generated service is a mock version of the actual Ballerina service. Generated sources contain the service definition in src/<module-name>/ and the OpenAPI contract that used to generate will be copied to src/<module-name>/resources.  Client stub from OpenAPI ballerina openapi gen-client [<moduleName>]:<clientName> <openapi-contract> [-o <dir-path> | --output <dir-path>]  Generates a Ballerina client stub for the service defined in a OpenAPI file.  This client can be used in client applications to call the service defined in the OpenAPI file.  Service to OpenAPI export ballerina openapi gen-contract [<moduleName>:]<serviceName> [-i: <ballerinaFile> | --ballerina-file <ballerina-file>] [-o: <openapi-contract> | --output <openapi-contract>] [-s | --skip-bind]  Export the Ballerina service to a definition of OpenApi Specification 3.0. For the export to work properly, the input Ballerina service should be defined using basic service and resource level HTTP annotations.  Client stub for service Generates a Ballerina client stub to communicate with a Ballerina service.  All endpoint(s) that are used for client stub generation should be marked with the @openapi:ClientEndpoint annotation. If not, there might be errors during client stub generation. Endpoints that are not marked with this annotation are not picked for client stub generation. The @openapi:ClientConfig { generate: true } annotation is used to enable or disable client stub generation per service.  Samples  Mock service from OpenAPI ballerina openapi gen-service helloworld:helloService hello_service.yaml  This will generate a Ballerina service, for hello_service.yaml OpenAPI contract, named helloService in the module named helloworld. This command should be executed inside a Ballerina project. Client stub from OpenAPI ballerina openapi gen-client hello_client hello_service.yaml  This will generate a Client named hello_client in a module named client for the service documented in hello_service.yaml. This command should be executed inside a Ballerina project. OpenAPI from service ballerina openapi gen-contract helloworld:helloService -i src/helloworld/helloService.bal  This will generate the OpenAPI contract for the Ballerina service hello which is in hello.bal Ballerina file. Client stub from service Apply annotation to say that client generation is enabled by adding @openapi:ClientConfig { generate: true } and point the client endpoint to be applied on generation by adding @openapi:ClientEndpoint annotation to the client endpoint. import ballerina/http; import ballerina/log; import ballerina/openapi;  // Define this endpoint as a selected endpoint for client generation. @openapi:ClientEndpoint listener http:Listener helloEp = new(9090);  // Enable client code generation for this service. @openapi:ClientConfig {  generate: true } @http:ServiceConfig {  basePath: \"/sample\" } service Hello on helloEp { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/hello\"  }  resource function hello(http:Caller caller, http:Request req) {  http:Response res = new;  res.setPayload(\"Hello\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error when responding\", err = result);  }  } }"},{"page":"/learn/","name":"Let’s learn Ballerina!","summary":"Ballerina is meant to be a quick start for anyone with prior programming experience. ...","content":"/ Let’s learn Ballerina!  Let’s learn Ballerina!  Ballerina is meant to be a quick start for anyone with prior programming experience. The below resources will help you to get going with Ballerina.  Gear Yourself Up  Download Ballerina, set the tools up, and take the Quick Tour.   Take Ballerina for a Spin  Try out the Ballerina By Examples and use the Playground.   Sharpen Your Skills  Learn more about Ballerina by exploring its features.   Know it Inside Out  Master Ballerina by reading through the reference materials."},{"page":"/learn/installing-ballerina/","name":"Installing Ballerina","summary":"a Ballerina distribution based on your operating system.Ballerina binary distributions are available for the following supported operating systems and architectures. Ensure that your system meets the below requirements before you proceed with the installation.If a binary distribution is not available for your combination of operating system and architecture, try ...","content":"/  / Installing Ballerina  Installing Ballerina    Downloading the Ballerina distribution   a Ballerina distribution based on your operating system.    Ballerina binary distributions are available for the following supported operating systems and architectures. Ensure that your system meets the below requirements before you proceed with the installation.  Windows Vista SP2 x64 or later  Ubuntu Linux 12.04 x64 - LTS and above  OS X 10.8.3 x64 and above  If a binary distribution is not available for your combination of operating system and architecture, try .  Installing Ballerina via installers  If you are upgrading to a new version of Ballerina from an older version, you can download and use the installer for the latest version. The installer will automatically uninstall the old version. If you are building from source, you must update the path with the new version of Ballerina.  Installing on OS X   and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution to /Library/Ballerina.  The package automatically sets your PATH environment variable for you. You may need to restart any open Terminal sessions for the change to take effect.  Installing on Windows   and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution to C:\\Program Files\\Ballerina\\.  The installer should put the C:\\Program Files\\Ballerina\\<ballerina-directory>\\bin directory in your PATH environment variable. You may have to restart any open command prompts for the change to take effect.  Installing on Linux    the latest version of Ballerina.  If you downloaded the DEB file, use the following command to install Ballerina. Replace <ballerina-home>/<ballerina-binary>.deb with the actual file path. This installs Ballerina to the /usr/lib/ballerina directory.   dpkg -i <ballerina-binary>.deb  Installing from source  Alternatively, follow the instructions below to install Ballerina from the source.  Setting up the prerequisites  You need to download and install the below to build the Ballerina modules.   Java SE Development Kit (JDK) version 8 (from one of the following locations)  Note: Set the JAVA_HOME environment variable to the path name of the directory into which you installed JDK.  Obtaining the source code Follow the steps below to obtain the Ballerina source code.    Execute the below command to clone the source repository.   git clone --recursive https://github.com/ballerina-platform/ballerina-lang.git  Tip: If you have already forked the repository to your GitHub account, then execute the below command replacing with your Git username.  git clone --recursive https://github.com/<YOUR-GITHUB-USERNAME>/ballerina-lang.git  Execute the below command to update the Git submodules.   git submodule update --init  Building the source  Follow the steps below to build the project of the obtained source.    Navigate to the root directory of the Ballerina repo (i.e., ) and execute one of the below Gradle commands to build the project using Gradle.   On Unix/Mac OS: ./gradlew build  Windows: gradlew build  Extract the built Ballerina distributions created in the below locations:   runtime only: <BALLERINA_PROJECT_ROOT>/distribution/zip/jballerina/build/distributions/jballerina-<version>-SNAPSHOT.zip  runtime and tools (e.g., Ballerina Language Server): <BALLERINA_PROJECT_ROOT>/distribution/zip/jballerina-tools/build/distributions/jballerina-tools-<version>-SNAPSHOT.zip  Note: If you face an IOException error stating “Too many open files”, this is due to the default number of possible open files being set to a lower number on your operating system than required for Ballerina to be compiled. You may have to increase the number of open files/file descriptors (FD) on your operating system to 1000000 (or higher).   Uninstalling Ballerina  To remove an existing Ballerina installation, go to the Ballerina installation location and delete the Ballerina directory.    Note:  The installation location is usually /Library/Ballerina in Mac OS X, /usr/lib/ballerina/ in Ubuntu and C:\\Program Files\\Ballerina\\ in Windows.  Getting help  To get help when you work with Ballerina, see .  What’s next  Once you have successfully installed Ballerina, click the below links to set up your IDE."},{"page":"/learn/how-to-write-secure-ballerina-code/","name":"How to Write Secure Ballerina Programs","summary":"This document demonstrates different security features and controls available within Ballerina, and serves the purpose of providing guidelines on writing secure Ballerina programs.Table of ContentsThis approach makes it unnecessary for developers to review best practice coding lists that itemize how to avoid security vulnerabilities. The Ballerina compiler ensures that Ballerina ...","content":"/  / How to Write Secure Ballerina Programs  How to Write Secure Ballerina Programs  This document demonstrates different security features and controls available within Ballerina, and serves the purpose of providing guidelines on writing secure Ballerina programs.  Table of Contents                                                          Secure by Design  This approach makes it unnecessary for developers to review best practice coding lists that itemize how to avoid security vulnerabilities. The Ballerina compiler ensures that Ballerina programs do not introduce security vulnerabilities.  A taint analysis mechanism is used to achieve this.  Parameters in function calls can be designated as security-sensitive. The compiler will generate an error if you pass untrusted data (tainted data) into a security-sensitive parameter:  tainted value passed to sensitive parameter 'sqlQuery'   We require developers to explicitly mark all values passed into security-sensitive parameters as ‘trusted’. This explicit check forces developers and code reviewers to verify that the values being passed into the parameter are not vulnerable to a security violation.  Ballerina standard library makes sure untrusted data cannot be used with security sensitive parameters such as SQL queries, file paths, file name, permission flags, request URLs and configuration keys, preventing vulnerabilities, including:    SQL Injection  Path Manipulation  File Manipulation  Unauthorized File Access  Unvalidated Redirect (Open Redirect)   Ensuring security of Ballerina standard libraries  Security-sensitive functions and remote methods of Ballerina standard libraries are annotated with the @untainted parameter annotation. This denotes that untrusted (tainted) data should not be passed to the parameter.  For example, the sqlQuery parameter of the ballerinax/java.jdbc select remote method is annotated as @untainted.  public remote function select(@untainted string sqlQuery, typedesc<record{}>? recordType, Param... parameters) returns @tainted table<record {}>|Error   The following example constructs an SQL query with a tainted argument:  import ballerinax/java.jdbc;  type ResultStudent record {  string name; };  public function main(string... args) {   jdbc:Client testDB = new({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  poolOptions: { maximumPoolSize: 5 },  dbOptions: { useSSL: false }  });   // Construct student ID based on user input.  string studentId = \"S_\" + args[0];   // Execute select query using the untrusted (tainted) student ID  var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = \" + studentId,  ResultStudent);  testDB.stop(); }   The Ballerina compiler will generate an error:  tainted value passed to sensitive parameter 'sqlQuery'   In order to compile, the program is modified to use query parameters:  jdbc:Parameter paramId = {sqlType:jdbc:TYPE_VARCHAR, value:studentId}; var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = ?\", ResultStudent,  paramId);   Command-line arguments passed to Ballerina programs and inputs received through service resources are considered as tainted. Additionally, return values of certain functions are marked with the @tainted annotation to denote that the resulting value should be considered as untrusted data.  For example, the select remote method of the java:jdbc client highlighted above returns a @tainted table<record {}>|Error. This means that any value read from a database is considered as untrusted.  When the Ballerina compiler can determine that a function is returning tainted data without tainted data being passed in as parameters to that function, it is required to annotate the function’s return type as @tainted. If not, the function author has to clean up the data before returning. For instance, if you are to read from the database and return that result, you either need to annotate that function’s return type as @tainted or you have to clean up and make sure the returned data is not tainted.  Securely using tainted data with security-sensitive parameters  There can be certain situations where a tainted value must be passed into a security-sensitive parameter. In such situations, it is essential to do proper data validation or data sanitization to make sure the input does not result in a security threat. Once proper controls are in place, the @untainted annotation can be used with a type cast operator to denote that the value is trusted:  // Execute select query using the untrusted (tainted) student ID boolean isValid = isNumeric(studentId); if (isValid) {  var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = \" +  <@untainted> studentId, ResultStudent); } // ...   Additionally, return values can be annotated with@untainted. This denotes that the return value should be trusted (even if the return value is derived from tainted data):  // Execute the select query using the untrusted (tainted) student ID function sanitizeSortColumn (string columnName) returns @untainted string {  string sanitizedSortColumn = columnName;  // Insert sanitization logic to ensure that the return value is safe.  return sanitizedSortColumn; } // ...   Securing Passwords and Secrets  Ballerina provides an API to access configuration values from different sources. For more information, see .  Configuration values containing passwords or secrets should be encrypted. The Ballerina Config API will decrypt such configuration values when being accessed.  Use the following command to encrypt a configuration value:  $ ballerina encrypt   The encrypt command will prompt for the plain-text value to be encrypted and an encryption secret.  $ ballerina encrypt Enter value: Enter secret: Re-enter secret to verify: Add the following to the configuration file: <key>=\"@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=}\"  Or provide it as a command line argument: --<key>=@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=}   Ballerina uses AES, CBC mode with PKCS#5 padding for encryption. The generated encrypted value should be used in place of the plain-text configuration value.  For example, contents of a configuration file that includes a secret value should look as follows:  api.secret=\"@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=}\" api.provider=\"not-a-security-sensitive-value\"   When running a Ballerina program that uses encrypted configuration values, Ballerina will require the secret used during the encryption process to perform the decryption.  Ballerina will first look for a file named secret.txt. If such file exists, Ballerina will read the decryption secret from the file and immediately remove the file to make sure secret cannot be accessed afterwards. If the secret file is not present, the Ballerina program will prompt for the decryption secret.  The file based approach is useful in automated deployments. The file containing the decryption secret can be deployed along with the Ballerina program. The name and the path of the secret file can be configured using the ballerina.config.secret runtime parameter:  $ ballerina run --b7a.config.secret=path/to/secret/file securing_configuration_values.bal   Authentication and Authorization  Inbound Authentication & Authorization  Ballerina HTTP services can be configured to enforce authentication and authorization. Ballerina has built-in support for the following inbound authentication mechanisms whereas it is possible to add custom mechanisms:    Basic authentication  JWT authentication  OAuth2 authentication  LDAP authentication   Ballerina inbound authentication is abstracted out into 2 layers called http:InboundAuthHandler and auth:InboundAuthProvider.  The auth:InboundAuthProvider is a protocol-independent entity that only knows how to authenticate a user when the necessary information is provided. The http:InboundAuthHandler can be protocol dependent. Even-though the current focus is on HTTP, the ballerina/auth module can operate with other protocols as well.  The http:InboundAuthHandler is used to perform HTTP-level actions, which are extracting the required HTTP header or body, extracting the credentials out of it, passing them into the associated auth:InboundAuthProvider, and getting the credentials validated. The auth:InboundAuthProvider is used to validate the credentials passed by the http:InboundAuthHandler.  In a particular authentication scheme, the implemented instance of the auth:InboundAuthProvider is initialized with the required configurations and it is passed to the implemented instance of the http:InboundAuthHandler.  Next, the implemented instance of the http:InboundAuthHandler is passed to the http:Listener configuration as follows and the listener is initialized with authentication.  The following example represents how a listener is secured with Basic Auth with the above-mentioned configurations.  import ballerina/auth; import ballerina/http; import ballerina/config;  auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [basicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }     Note: It is a must to use HTTPS when enforcing authentication and authorization checks, to ensure the confidentiality of sensitive authentication data.   Optionally, the scopes attribute is configured for the authorization as follows. If it is not specified, that means the service is authorized for any authenticated user.  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler],  scopes: [\"test-scope\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }   Inbound Advanced Use Cases  Using Multiple Auth Handlers  The authHandlers can be configured for advanced use cases, which use multiple auth handlers as follows:  Case 1: Auth should be successful for authHandler1 OR authHandler1. authHandlers: [authHandler1, authHandler2]  Case 2: Auth should be successful for authHandler1 AND authHandler12. authHandlers: [[authHandler1], [authHandler2]]  Case 3: Auth should be successful for ((authHandler1 OR authHandler2) AND (authHandler3 OR authHandler4)). authHandlers: [[authHandler1, authHandler2], [authHandler3, authHandler4]]  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler1, authHandler2]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }   Using Multiple Scopes  The scopes can be configured for advanced use cases as follows:  Case 1: Auth should be successful for scope-1 OR scope-2. scopes: [\"scopes-1\", \"scopes-2\"]  Case 2: Auth should be successful for scope-1 AND scope-2. scopes: [[\"scopes-1\"], [\"scopes-2\"]]  Case 3: Auth should be successful for ((scope-1 OR scope-2) AND (scope-3 OR scope-4)). scopes: [[\"scopes-1\", \"scopes-2\"], [\"scopes-3\", \"scopes-4\"]]  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler],  scopes: [\"scopes-1\", \"scopes-2\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }   Per-Resource and Per-Service Customization  The security enforcements can be customized by the @http:ServiceConfig annotation and the @http:ResourceConfig annotation.  For example, authentication and authorization can be modified for a particular service as follows by configuring the auth attribute of the @http:ServiceConfig.   Authentication can be disabled only for a particular service by using the enabled attribute  The authentication mechanism can be changed for a particular service by using the authHandlers attribute  Authorization scopes can be changed for a particular service by using the scopes attribute   @http:ServiceConfig {  basePath: \"/hello\",  auth: {  enabled: false,  authHandlers: [authHandlerA],  scopes: [\"scope-A\"]  } } service helloWorld on secureHelloWorldEp { // ... }   Further, authentication and authorization can be modified for a particular resource as follows by configuring the auth attribute of the @http:ResourceConfig:  @http:ResourceConfig {  basePath: \"/\",  auth: {  enabled: false,  authHandlers: [authHandlerA],  scopes: [\"scope-A\"]  } } resource function sayHello (http:Caller caller, http:Request req) { // ... }   The same configuration patterns used for the listener-level configurations are applied for authHandlers and the scopes attributes in service-level configurations and resource-level configurations.  Implementing Inbound Custom Authentication Mechanism  The user can implement a custom version of AuthHandler and AuthProvider with the use of the object-equivalency pattern as follows. With that, the http:Listener can be enforced with custom authentication and authorization mechanisms.  public type InboundCustomAuthHandler object {   *http:InboundAuthHandler;   public function canProcess(http:Request req) returns @tainted boolean {  // Custom logic to check whether the request can be processed.  }  public function process(http:Request req) returns boolean|http:AuthenticationError {  // Custom logic to process the request, extract the credentials, and get them validated from the AuthProvider.  } };   public type InboundCustomAuthProvider object {   *auth:InboundAuthProvider;   public function authenticate(string credential) returns boolean|auth:Error {  // Custom logic to authenticate the given credentials.  } };   Disable HTTPS Enforcement  The enforcement of HTTPS can be disabled by configuring the value mandateSecureSocket into false as follows:  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler],  mandateSecureSocket: false  } }); service helloWorld on secureHelloWorldEp { // .... }   Modify Authn or Authz Filter Index  The authn/authz filters are engaged as the top most filters of the filter array, which is configured in the HTTP listener configuration. The uer can configure the index of the authn/authz filters if it is needed to engage a custom filter before the authn/authz filters.  The position attribute represents the authn/authz filter position of the filter array. The position values starts from 0 and it is set to 0 implicitly.  The following example engages the authn/authz filters in between the customFilter1 and customFilter2. Then, the internally-updated filter chain would be [customFilter1, authnFilter, authzFilter, customFilter2].  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler],  position: 1  },  filters: [customFilter1, customFilter2],  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }   JWT Inbound Authentication and Authorization  Ballerina supports JWT Authentication and Authorizations for services. The http:BearerAuthHandler is used to extract the HTTP Authorization header from the request and extract the credential from the header value which is Bearer <token>. Then the extracted credential will be passed to the initialized AuthProvider and get validated. The jwt:InboundJwtAuthProvider is used to validate the credentials (JWT) passed by the AuthHandler against the jwt:JwtValidatorConfig provided by the user.  JWT validation requires several additional configurations for the jwt:JwtValidatorConfig including:    issuer - The issuer of the JWT  audience - The audience value for the current service  clockSkewInSeconds - Clock skew in seconds that can be used to avoid token validation failures due to clock synchronization problems  trustStoreConfig - JWT trust store configurations  trustStore - Trust store used for signature verification  certificateAlias - Token-signed public key certificate alias  jwtCache - Cache used to store parsed JWT information as CachedJwt   The jwt:JwtValidatorConfig record should be provided into the jwt:InboundJwtAuthProvider when initializing. The initialized jwt:InboundJwtAuthProvider is passed to the `http:BearerAuthHandler.    Note: For demonstration purposes, the ballerinaTruststore.p12 included with Ballerina runtime is used. In a production deployment, the truststore should only contain the public key certificates of the trusted JWT issuers.   import ballerina/http; import ballerina/jwt; import ballerina/config;  jwt:InboundJwtAuthProvider jwtAuthProvider = new({  issuer: \"ballerina\",  audience: [\"ballerina.io\"],  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler jwtAuthHandler = new(jwtAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [jwtAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\",  auth:{  scopes:[\"hello\"],  enabled: true  }  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Hello, World!\");  checkpanic caller->respond(resp);  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur:  curl -k -v https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure   Once a request is made with a valid, signed JWT, but without the expected “scope”, an authorization failure will occur. An example of a JWT without “scope” attribute is as follows.  {  \"sub\": \"ballerina\",  \"iss\": \"ballerina\",  \"exp\": 2818415019,  \"iat\": 1524575019,  \"jti\": \"f5aded50585c46f2b8ca233d0c2a3c9d\",  \"aud\": [  \"ballerina\",  \"Ballerina.org\",  \"ballerina.io\"  ] }   curl -k -v https://localhost:9091/hello -H \"Authorization:Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwianRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiYmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdfQ.X2mHWCr8A5UaJFvjSPUammACnTzFsTdre-P5yWQgrwLBmfcpr9JaUuq4sEwp6to3xSKN7u9QKqRLuWH1SlcphDQn6kdF1ZrCgXRQ0HQTilZQU1hllZ4c7yMNtMgMIaPgEBrStLX1Ufr6LpDkTA4VeaPCSqstHt9WbRzIoPQ1fCxjvHBP17ShiGPRza9p_Z4t897s40aQMKbKLqLQ8rEaYAcsoRBXYyUhb_PRS-YZtIdo7iVmkMVFjYjHvmYbpYhNo57Z1Y5dNa8h8-4ON4CXzcJ1RzuyuFVz1a3YL3gWTsiliVmno7vKyRo8utirDRIPi0dPJPuWi2uMtJkqdkpzJQ\"  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJ pbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwian RpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiY mFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdfQ.X2mHWCr8A5UaJFvjSPUammACnTzFsTdre-P5y WQgrwLBmfcpr9JaUuq4sEwp6to3xSKN7u9QKqRLuWH1SlcphDQn6kdF1ZrCgXRQ0HQTilZQU1hllZ4c 7yMNtMgMIaPgEBrStLX1Ufr6LpDkTA4VeaPCSqstHt9WbRzIoPQ1fCxjvHBP17ShiGPRza9p_Z4t897 s40aQMKbKLqLQ8rEaYAcsoRBXYyUhb_PRS-YZtIdo7iVmkMVFjYjHvmYbpYhNo57Z1Y5dNa8h8-4ON4 CXzcJ1RzuyuFVz1a3YL3gWTsiliVmno7vKyRo8utirDRIPi0dPJPuWi2uMtJkqdkpzJQ >  < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure   A request with a correct “scope” attribute will result in a successful invocation. An example of a JWT that has the correct “scope” attribute is as follows.  {  \"sub\": \"ballerina\",  \"iss\": \"ballerina\",  \"exp\": 2818415019,  \"iat\": 1524575019,  \"jti\": \"f5aded50585c46f2b8ca233d0c2a3c9d\",  \"aud\": [  \"ballerina\",  \"ballerina.org\",  \"ballerina.io\"  ],  \"scope\": \"hello\" }   curl -k -v https://localhost:9091/hello -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwianRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiYmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdLCJzY29wZSI6ImhlbGxvIn0.bNoqz9_DzgeKSK6ru3DnKL7NiNbY32ksXPYrh6Jp0_O3ST7WfXMs9WVkx6Q2TiYukMAGrnMUFrJnrJvZwC3glAmRBrl4BYCbQ0c5mCbgM9qhhCjC1tBA50rjtLAtRW-JTRpCKS0B9_EmlVKfvXPKDLIpM5hnfhOin1R3lJCPspJ2ey_Ho6fDhsKE3DZgssvgPgI9PBItnkipQ3CqqXWhV-RFBkVBEGPDYXTUVGbXhdNOBSwKw5ZoVJrCUiNG5XD0K4sgN9udVTi3EMKNMnVQaq399k6RYPAy3vIhByS6QZtRjOG8X93WJw-9GLiHvcabuid80lnrs2-mAEcstgiHVw'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZX JpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwia nRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwi YmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdLCJzY29wZSI6ImhlbGxvIn0.bNoqz9_DzgeKSK6 ru3DnKL7NiNbY32ksXPYrh6Jp0_O3ST7WfXMs9WVkx6Q2TiYukMAGrnMUFrJnrJvZwC3glAmRBrl4BY CbQ0c5mCbgM9qhhCjC1tBA50rjtLAtRW-JTRpCKS0B9_EmlVKfvXPKDLIpM5hnfhOin1R3lJCPspJ2e y_Ho6fDhsKE3DZgssvgPgI9PBItnkipQ3CqqXWhV-RFBkVBEGPDYXTUVGbXhdNOBSwKw5ZoVJrCUiNG 5XD0K4sgN9udVTi3EMKNMnVQaq399k6RYPAy3vIhByS6QZtRjOG8X93WJw-9GLiHvcabuid80lnrs2- mAEcstgiHVw >  < HTTP/1.1 200 OK < content-type: text/plain < Hello, World!   OAuth2 Inbound Authentication and Authorization  Ballerina supports OAuth2 Authentication and Authorization for services. The http:BearerAuthHandler is used to extract the HTTP Authorization header from the request and extract the credentials from the header value, which is the Bearer <token>. Then, the extracted credentials will be passed to the initialized AuthProvider to get them validated. The oauth2:InboundOAuth2Provider is used to validate the credentials passed by the AuthHandler against the introspection endpoint configured at oauth2:IntrospectionServerConfig, which is provided by the user.  OAuth2 token validation requires several additional configurations for the oauth2:IntrospectionServerConfig including:    url - URL of the introspection server  tokenTypeHint - A hint about the type of the token submitted for introspection  clientConfig - HTTP client configurations, which calls the introspection server   The oauth2:IntrospectionServerConfig record should be provided into the oauth2:InboundOAuth2Provider when initializing and the initialized oauth2:InboundOAuth2Provider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/oauth2; import ballerina/config;  oauth2:InboundOAuth2Provider oauth2Provider = new({  url: \"https://localhost:9196/oauth2/token/introspect\",  tokenTypeHint: \"access_token\" }); http:BearerAuthHandler oauth2Handler = new(oauth2Provider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [oauth2Handler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Hello, World!\");  checkpanic caller->respond(resp);  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur:  curl -k -v https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure   Once a request is made with a valid, authentication information, but if the introspection endpoint does not respond with the “scope” attribute of the response JSON payload or respond with the “scope” attribute, which are not the expected scopes, an authorization failure will occur.  curl -k -v https://localhost:9091/hello -H \"Authorization:Bearer <token>\"  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer <token> >  < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure   A request, which gets a successful response from the introspection endpoint with a correct “scope” attribute will result in a successful invocation.  curl -k -v https://localhost:9091/hello -H 'Authorization: Bearer <token>'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> >  < HTTP/1.1 200 OK < content-type: text/plain < Hello, World!   LDAP Inbound Authentication and Authorization  Ballerina supports LDAP Authentication and Authorizations for services. The http:BasicAuthHandler is used to extract the HTTP Authorization header from the request and extract the credentials from the header value, which is Basic <token>. Then, the extracted credentials will be passed to the initialized AuthProvider to get validated. The ldap:InboundLdapAuthProvider is used to validate the credentials passed by the AuthHandler against the LDAP server configured at ldap:LdapConnectionConfig, which is provided by the user.  LDAP token validation requires several additional configurations for the ldap:LdapConnectionConfig including:    domainName - Unique name to identify the user store  connectionURL - Connection URL to the LDAP server  connectionName - The username to connect to the LDAP server  connectionPassword - Password for the ConnectionName user  userSearchBase - DN of the context or object under which the user entries are stored in the LDAP server  userEntryObjectClass - Object class used to construct user entries  userNameAttribute - The attribute used for uniquely identifying a user entry  userNameSearchFilter - Filtering criteria used to search for a particular user entry  userNameListFilter - Filtering criteria for searching user entries in the LDAP server  groupSearchBase - DN of the context or object under which the group entries are stored in the LDAP server  groupEntryObjectClass - Object class used to construct group entries  groupNameAttribute - The attribute used for uniquely identifying a group entry  groupNameSearchFilter - Filtering criteria used to search for a particular group entry  groupNameListFilter - Filtering criteria for searching group entries in the LDAP server  membershipAttribute - Define the attribute that contains the distinguished names (DN) of user objects that are in a group  userRolesCacheEnabled - To indicate whether to cache the role list of a user  connectionPoolingEnabled - Define whether LDAP connection pooling is enabled  connectionTimeoutInMillis - Timeout in making the initial LDAP connection  readTimeoutInMillis - Read timeout in milliseconds for LDAP operations  retryAttempts - Retry the authentication request if a timeout happened  secureClientSocket - The SSL configurations for the LDAP client socket. This needs to be configured in order to communicate through LDAPs   The ldap:LdapConnectionConfig record should be provided into the ldap:InboundLdapAuthProvider when initializing and the initialized ldap:InboundLdapAuthProvider is passed to the http:BasicAuthHandler.  import ballerina/http; import ballerina/ldap; import ballerina/config;  ldap:LdapConnectionConfig ldapConfig = {  domainName: \"ballerina.io\",  connectionURL: \"ldap://localhost:20100\",  connectionName: \"uid=admin,ou=system\",  connectionPassword: \"secret\",  userSearchBase: \"ou=Users,dc=ballerina,dc=io\",  userEntryObjectClass: \"identityPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=person)(uid=?))\",  userNameListFilter: \"(objectClass=person)\",  groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeoutInMillis: 5000,  readTimeoutInMillis: 60000,  retryAttempts: 3 }; ldap:InboundLdapAuthProvider ldapAuthProvider = new(ldapConfig, \"ldap01\"); http:BasicAuthHandler ldapAuthHandler = new(ldapAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [ldapAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"hello\"]  } } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Hello, World!\");  checkpanic caller->respond(resp);  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur:  curl -k -v https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure   Once a request is made with a valid, authentication information, but if the LDAP server responds with an empty group list or unexpected scopes, an authorization failure will occur.  curl -k -v https://localhost:9091/hello -H \"Authorization: Basic <token>\"  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer <token> >  < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure   A request, which gets a successful response from the LDAP server for the “scope” request will result in a successful invocation.  curl -k -v https://localhost:9091/hello -H 'Authorization: Basic <token>'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> >  < HTTP/1.1 200 OK < content-type: text/plain < Hello, World!   Basic Auth Inbound Authentication and Authorization  Ballerina supports Basic Authentication and Authorizations for services. The http:BasicAuthHandler is used to extract the HTTP Authorization header from the request and extract the credential from the header value, which is the Basic <token>. Then, the extracted credentials will be passed to the initialized AuthProvider and gets validated. The jwt:InboundBasicAuthProvider is used to read the user information from the configuration file and authenticate the credentials passed by the AuthHandler.  import ballerina/auth; import ballerina/http; import ballerina/config;  auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [basicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"hello\"]  } } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Hello, World!\");  checkpanic caller->respond(resp);  } }   To enforce Basic Authentication, users and scopes should be configured through a configuration file. The following example file introduces two users. The generalUser has no scopes and the admin user has the hello scope.  sample-users.toml [b7a.users]  [b7a.users.generalUser] password=\"@encrypted:{pIQrB9YfCQK1eIWH5d6UaZXA3zr+60JxSBcpa2PY7a8=}\"  [b7a.users.admin] password=\"@encrypted:{pIQrB9YfCQK1eIWH5d6UaZXA3zr+60JxSBcpa2PY7a8=}\" scopes=\"hello\"   Restart the service using the following command.  ballerina run --config sample-users.toml basic_auth_sample.bal   Since passwords are encrypted, the Config API will request for the decryption key. Use ballerina as the decryption key in this sample.  Also, the passwords can be hashed and provided with the configuration file. The following example file introduces three users along with the passwords hashed with sha256, sha384, and sha512 hashing algorithms.  sample-users.toml [b7a.users]  [b7a.users.userA] password=\"@sha256:{cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860}\"  [b7a.users.userB] password=\"@sha384:{1249e15f035ed34786a328d9fdb2689ab24f7c7b253d1b7f66ed92a679d663dd502d7beda59973e8c91a728b929fc8cd}\"  [b7a.users.userC] password=\"@sha512:{9057ff1aa9509b2a0af624d687461d2bbeb07e2f37d953b1ce4a9dc921a7f19c45dc35d7c5363b373792add57d0d7dc41596e1c585d6ef7844cdf8ae87af443f}\"   Once the service is restarted with the first configuration file in place, the generalUser will not be able to invoke the service due to authorization failure:  curl -k -v -u generalUser:password https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */*  < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure   ‘Admin’ users will be able to invoke the service:  curl -k -v -u admin:password https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */*  < HTTP/1.1 200 OK < content-type: text/plain < Hello, World!     Outbound Authentication & Authorization  The Ballerina HTTP client can be configured to send authentication and authorization information to the endpoint being invoked. Ballerina has built-in support for the following outbound authentication mechanisms, whereas it is possible to add custom mechanisms:    Basic authentication  JWT authentication  OAuth2 authentication   Ballerina outbound authentication is also abstracted out into 2 layers called http:OutboundAuthHandler and auth:OutboundAuthProvider.  The auth:OutboundAuthProvider is a protocol-independent entity, which only knows how to generate credentials with the necessary information provided by the user. The http:OutboundAuthHandler can be protocol dependent. Even-though the current focus is on HTTP, the ballerina/auth module can operate with other protocols as well.  The auth:OutboundAuthProvider is used to create the credentials according to the provided configurations. The http:OutboundAuthHandler is used to get the created credentials from the auth:OutboundAuthProvider and perform HTTP-level actions, which are adding the required HTTP headers or body using the received credentials.  In a particular authentication scheme, the implemented instance of the auth:OutboundAuthProvider is initialized with required configurations and it is passed to the implemented instance of the http:OutboundAuthHandler.  Next, the implemented instance of the http:OutboundAuthHandler is passed to the http:Client configuration as follows and the client is initialized with authentication.  The following example represents how a client is secured with Basic Auth with the above-mentioned configurations.  import ballerina/auth; import ballerina/http; import ballerina/config;  auth:OutboundBasicProvider basicAuthProvider = new({  username: \"user\",  password: \"ballerina\" }); http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  http:Client secureHelloWorldClient = new(\"https://localhost:9092\", {  auth: {  authHandler: basicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });     Note: It is better to use HTTPS when enforcing authentication and authorization checks to ensure the confidentiality of sensitive authentication data.   Outbound Advanced Use Cases  Implementing Outbound Custom Authentication Mechanism  The user can implement a custom version of the AuthHandler and AuthProvider with the use of the object equivalency pattern as follows. With that, the http:Client can be enforced with custom authentication and authorization mechanisms.  public type OutboundCustomAuthHandler object {   *http:OutboundAuthHandler;   public function prepare(http:Request req) returns http:Request|http:AuthenticationError {  // Custom logic to prepare the request.  }   public function inspect(http:Request req, http:Response resp) returns http:Request|http:AuthenticationError? {  // Custom logic to inspect the request after the initial outbound call.  } };   public type OutboundCustomAuthProvider object {   *auth:OutboundAuthProvider;   public function generateToken() returns string|auth:Error {  // Custom logic to generate the token. }   public function inspect(map<anydata> data) returns string|auth:Error? {  // Custom logic to inspect the data map received from the AuthHandler. } };   JWT Outbound Authentication  Ballerina supports JWT Authentication for clients. The jwt:OutboundJwtAuthProvider is used to issue a JWT against the jwt:JwtIssuerConfig provided by the user. The http:BearerAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Bearer <token>.  JWT issuing requires several additional configurations for the jwt:JwtIssuerConfig including:    username - JWT token username  issuer - JWT token issuer  audience - JWT token audience  customClaims - Map of custom claims  expTime - JWT token expiry time  keyStoreConfig - JWT key store configurations  keyStore - Keystore to be used in JWT signing  keyAlias - Signing key alias  keyPassword - Signing key password  signingAlg - JWT signing algorithm  jwt:RS256 - The RSA-SHA256 algorithm  jwt:RS384 - The RSA-SHA384 algorithm  jwt:RS512 - The RSA-SHA512 algorithm  jwt:NONE - Unsecured JWTs (no signing)  Thejwt:JwtIssuerConfig record should be provided into the jwt:OutboundJwtAuthProvider when initializing and the initialized jwt:OutboundJwtAuthProvider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/jwt; import ballerina/config;  jwt:OutboundJwtAuthProvider jwtAuthProvider = new({  username: \"ballerinaUser\",  issuer: \"ballerina\",  audience: [\"ballerina.io\"],  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler jwtAuthHandler = new(jwtAuthProvider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: jwtAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   The http:Client defined in the program calls the the http:Listener, which is secured with JWT authentication (For more information, see the example added under JWT inbound authentication).  OAuth2 Outbound Authentication  Ballerina supports OAuth2 Authentication for clients. It supports the Client Credentials grant type, Password grant type, and Direct Token mode, in which, the credentials can be provided manually and after that refreshing is handled internally.  The oauth2:OutboundOAuth2Provider is used to create a token against the configuration provided by the user. It can be the oauth2:ClientCredentialsGrantConfig, oauth2:PasswordGrantConfig, or oauth2:DirectTokenConfig according to the grant type that is required by the user. The http:BearerAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Bearer <token>.  Client Credentials Grant Type  OAuth2 token issuing requires several additional configurations for the oauth2:ClientCredentialsGrantConfig including:    tokenUrl - Token URL for the authorization endpoint  clientId - Client ID for the client credentials grant authentication  clientSecret - Client secret for the client credentials grant authentication  scopes - Scope of the access request  clockSkewInSeconds - Clock skew in seconds  retryRequest - Retry the request if the initial request returns a 401 response  credentialBearer - How authentication credentials are sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER | NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  clientConfig - HTTP client configurations,which calls the authorization endpoint   The oauth2:ClientCredentialsGrantConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/oauth2; import ballerina/config;  oauth2:OutboundOAuth2Provider oauth2Provider = new({  tokenUrl: \"https://localhost:9196/oauth2/token/authorize\",  clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68\",  clientSecret: \"9205371918321623741\",  scopes: [\"token-scope1\", \"token-scope2\"] }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: oauth2AuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   Password Grant Type  OAuth2 token issuing requires several additional configurations for the oauth2:PasswordGrantConfig including:    tokenUrl - Token URL for the authorization endpoint  username - Username for password grant authentication  password - Password for password grant authentication  clientId - Client ID for password grant authentication  clientSecret - Client secret for password grant authentication  scopes - Scope of the access request  refreshConfig - Configurations for refreshing the access token  refreshUrl - Refresh token URL for the refresh token server  scopes - Scope of the access request  credentialBearer - How authentication credentials are sent to the authorization endpoint  clientConfig - HTTP client configurations, which calls the authorization endpoint  clockSkewInSeconds - Clock skew in seconds  retryRequest - Retry the request if the initial request returns a 401 response  credentialBearer - How authentication credentials are sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER|NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  clientConfig - HTTP client configurations, which calls the authorization endpoint   The oauth2:PasswordGrantConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/oauth2; import ballerina/config;  oauth2:OutboundOAuth2Provider oauth2Provider = new({  tokenUrl: \"https://localhost:9196/oauth2/token/authorize\",  username: \"johndoe\",  password: \"A3ddj3w\",  clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68\",  clientSecret: \"9205371918321623741\",  scopes: [\"token-scope1\", \"token-scope2\"],  refreshConfig: {  refreshUrl: \"https://localhost:9196/oauth2/token/refresh\",  scopes: [\"token-scope1\", \"token-scope2\"]  } }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: oauth2AuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   Direct Token Mode  OAuth2 token issuing requires several additional configurations for the oauth2:DirectTokenConfig including:    accessToken - Access token for the authorization endpoint  refreshConfig - Configurations for refreshing the access token  refreshUrl - Refresh token URL for the refresh token server  refreshToken - Refresh token for the refresh token server  clientId - Client ID for authentication with the authorization endpoint  clientSecret - Client secret for authentication with the authorization endpoint  scopes - Scope of the access request  credentialBearer - How authentication credentials are sent to the authorization endpoint  clientConfig - HTTP client configurations, which calls the authorization endpoint  clockSkewInSeconds - Clock skew in seconds  retryRequest - Retry the request if the initial request returns a 401 response  credentialBearer - How authentication credentials are sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER|NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  The oauth2:DirectTokenConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/oauth2;  oauth2:OutboundOAuth2Provider oauth2Provider = new({  accessToken: \"34060588-dd4e-36a5-ad93-440cc77a1cfb\",  refreshConfig: {  refreshToken: \"15160398-ae07-71b1-aea1-411ece712e59\",  refreshUrl: \"https://ballerina.io/sample/refresh\",  clientId: \"rgfKVdnMQnJSSr_pKFTxj3apiwYa\",  clientSecret: \"BRebJ0aqfclQB9v7yZwhj0JfW0ga\"  } }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: oauth2AuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   Basic Auth Outbound Authentication  Ballerina supports Basic Authentication for clients. The auth:OutboundBasicAuthProvider is used to create a token against the auth:Credential provided by the user. The http:BasicAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Basic <token>.  Token issuing requires several additional configurations for the auth:Credential config including:    username - The username for Basic authentication  password - The password for Basic authentication   The auth:Credential record should be provided into the auth:OutboundBasicAuthProvider when initializing and the initialized auth:OutboundBasicAuthProvider is passed to the http:BasicAuthHandler.  import ballerina/auth; import ballerina/http; import ballerina/config;  auth:OutboundBasicProvider basicAuthProvider = new({  username: \"user\",  password: \"ballerina\" }); http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: basicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   Token Propagation for Outbound Authentication  Ballerina supports token propagation for outbound authentication. The token propagation happens if the user does not provide any configuration when initializing the auth:OutboundAuthProvider.  The auth:OutboundAuthProvider reads the token/username from the runtime:InvocationContext according to the outbound authentication scheme and uses that for the outbound request. The runtime:InvocationContext is initialized based on the authentication information from the inbound request.  Example - 1  The following program has an http:Client secured with Basic authentication and it is configured inside an http:Listener secured with Basic authentication. The auth:OutboundBasicAuthProvider is initialized without providing any configurations. Therefore, the program gets the token from the runtime:InvocationContext and uses it for the outbound request. If the downstream service is also secured with Basic authentication and as same as the upstream service, the user does not need to configure the client.    Note: This scenario is the same for all the scenarios in which both the upstream and downstream services are secured using the same authentication scheme and clients are also configured using the same authentication scheme but without any configurations. The token propagation happens internally.   import ballerina/auth; import ballerina/http; import ballerina/config;  auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new(inboundBasicAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [inboundBasicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  auth:OutboundBasicAuthProvider outboundBasicAuthProvider = new; http:BasicAuthHandler outboundBasicAuthHandler = new(outboundBasicAuthProvider);  http:Client downstreamClientEP = new(\"https://localhost:9092\", {  auth: {  authHandler: outboundBasicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"hello\"]  } } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) returns error? {  // http:Request req = new;  http:Response response = check downstreamClientEP->get(\"/downstream\");  checkpanic caller->respond(response);  } }  // ---------------------------------------------- // Following code creates the downstream service // ----------------------------------------------  listener http:Listener downstreamServiceEp = new(9092, {  auth: {  authHandlers: [inboundBasicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/downstream\" } service downStreamService on downstreamServiceEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function downStreamResource(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Downstream service received authenticated request with the token: \" + req.getHeader(\"Authorization\"));  checkpanic caller->respond(resp);  } }   To enforce Basic Authentication, create a configuration file as follows:  sample-users.toml [b7a.users]  [b7a.users.tom] password=\"123\" scopes=\"hello\"   Start the service using the following command after creating the sample-users.toml file.  ballerina run --config sample-users.toml example.bal   The Tom user will be able to invoke the /hello resource and invoke the Basic Auth protected downstream service.  curl -k -v -u tom:123 https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > Authorization: Basic dG9tOjEyMw== > User-Agent: curl/7.60.0 > Accept: */*  < HTTP/1.1 200 OK < content-type: text/plain < content-length: 602 < Downstream service received authenticated request with the token: Basic dG9tOjEyMw==   Example - 2  The following program has an http:Client secured with JWT authentication and it is configured inside an http:Listener secured with Basic Authentication. The jwt:OutboundJwtAuthProvider is initialized using the provides configurations but without the username. Therefore, the program gets the username from the runtime:InvocationContext, which is set based on the inbound authentication information and uses it for the outbound request. In this example, the downstream service is secured using JWT authentication and expects a JWT issued against the user authenticating by the upstream service (protected by Basic authentication). Ballerina can dynamically issue such JWT while propagating the user information internally.  import ballerina/auth; import ballerina/http; import ballerina/jwt; import ballerina/config;  auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new(inboundBasicAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [inboundBasicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  jwt:OutboundJwtAuthProvider outboundJwtAuthProvider = new({  issuer: \"ballerina\",  audience: [\"ballerina.io\"],  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler outboundJwtAuthHandler = new(outboundJwtAuthProvider);  http:Client downstreamClientEP = new(\"https://localhost:9092\", {  auth: {  authHandler: outboundJwtAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"hello\"]  } } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) returns error? {  // http:Request req = new;  http:Response response = check downstreamClientEP->get(\"/downstream\");  checkpanic caller->respond(response);  } }  // ---------------------------------------------- // Following code creates the downstream service // ----------------------------------------------  jwt:InboundJwtAuthProvider inboundJwtAuthProvider = new({  issuer: \"ballerina\",  audience: [\"ballerina.io\"],  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  } }); http:BearerAuthHandler inboundJwtAuthHandler = new(inboundJwtAuthProvider);  listener http:Listener downstreamServiceEp = new(9092, {  auth: {  authHandlers: [inboundJwtAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/downstream\" } service downStreamService on downstreamServiceEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function downStreamResource(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Downstream service received authenticated request with the token: \" + req.getHeader(\"Authorization\"));  checkpanic caller->respond(resp);  } }   To enforce Basic Authentication, create a configuration file as follows:  sample-users.toml [b7a.users]  [b7a.users.tom] password=\"123\" scopes=\"hello\"   Start the service using the following command after creating the sample-users.toml file.  ballerina run --config sample-users.toml example.bal   The ‘Tom’ user will be able to invoke the /hello resource and invoke the Basic Auth protected downstream service.  curl -k -v -u tom:123 https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > Authorization: Basic dG9tOjEyMw== > User-Agent: curl/7.60.0 > Accept: */*  < HTTP/1.1 200 OK < content-type: text/plain < content-length: 602 < Downstream service received authenticated request with the token: Bearer eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QifQ==.eyJzdWIiOiJ0b20iLCAiaXNzIjoiYmFsbGVyaW5hIiwgImV4cCI6MTU2NTUwMzUzNywgImlhdCI6MTU2NTUwMzIzNywgImp0aSI6ImJhMjczNTM5LTcxZWItNDExOC04MzNiLTQyNDlhMjY0MmZmNCIsICJhdWQiOlsiYmFsbGVyaW5hLmlvIl19.OwMHPrQfjpIujHSAIq3ycKsP4SYTR2nW9lBHXBOgIZV6-FcM1Lxz8xtjY1AwcIAd_L4XmiODN_5HYUluZb3jDj1F6ZeI4FQeTKygiGgJs_nTww56bHFQXPe9_IW1zxRGM8G51cJBKxTH6YsOTXgNVhcGoe5f-kaESmGze-XLCnCXgj0GYnG2ECnejSHRh89gjWMyfyMFRDhioPi9IYZEQGIFBQzrModFWXNKQZh5vxaF5KW4KWXLTRgrBX8uY2IIS6S80nf83oaUlrrApieaGf88cwSqOjGjaPpxj3I810qGa996ZVE3P5DkzgxrJYHrJMwcVgBX7sgDFUUcD3RrEA=="},{"page":"/learn/intellij-plugin/","name":"The IntelliJ IDEA Ballerina Plugin","summary":"The IntelliJ Ballerina plugin provides the Ballerina development capabilities in IntelliJ IDEA. The below sections include instructions on how to download, install, and use the features of the IntelliJ plugin.You need  installed.Note: Your IntelliJ IDE version should be compatible with the corresponding Ballerina plugin version (i.e., the same as ...","content":"/  / The IntelliJ IDEA Ballerina Plugin  The IntelliJ IDEA Ballerina Plugin  The IntelliJ Ballerina plugin provides the Ballerina development capabilities in IntelliJ IDEA. The below sections include instructions on how to download, install, and use the features of the IntelliJ plugin.    Prerequisites  You need installed.    Note: Your IntelliJ IDE version should be compatible with the corresponding Ballerina plugin version (i.e., the same as the Ballerina distribution version) as shown in the below table.     Plugin Version  Platform Version Compatibility  0.8.0 - 0.8.2  IntelliJ IDEA 2016.3 - 2016.4  0.8.3 - 0.981.0  IntelliJ IDEA 2016.3 - 2017.2  0.982.0 - 0.991.0  IntelliJ IDEA 2017.3 - 2018.2  0.991.1 - 1.2.1  IntelliJ IDEA 2018.3 - 2019.3  1.2.2+  IntelliJ IDEA 2018.3+  Installing the plugin  Use either of the below approaches to install the IntelliJ Ballerina plugin.    Installing via the IntelliJ IDE    Open IntelliJ, click IntelliJ IDEA in the top menu, click Preferences, and then click Plugins.  Tip: If you are using Ubuntu/Windows, click File, click Settings, and then click Plugins.  In the search bar, type “Ballerina” and press the Enter key.  Click Install, and then click Accept.  Click Restart IDE, and then click Restart.     This downloads the plugin and installs it.  Installing using the ZIP file  Follow the steps below to install the plugin using its ZIP file.    Obtaining the ZIP file  Follow either of the below approaches to obtain the ZIP file of the Ballerina plugin.    Downloading from the JetBrains Plugin Repository  Download the .  Building from the source  Follow the steps below to obtain the ZIP file by building it from its source.    Clone the GitHub repo.  In a new Command Line tab, navigate to the source directory of the plugin (i.e., the <CLONED_BALLERINA_DIRECTORY>/tool-plugins/intellij directory), and execute the below command.  Info: In the above step,<CLONED_BALLERINA_DIRECTORY> refers to the path of the ballerina-lang Git repository, which you cloned locally. Tip: You need to install the to execute the below command.  ./gradlew buildPlugin  This creates the /build/distributions/ballerina-intellij-idea-plugin-[VERSION].zip file locally in the <CLONED_BALLERINA_DIRECTORY>/tool-plugins/intellij directory.  Installing the ZIP file via the IDE  After obtaining the ZIP file using either of the above approaches, follow the steps below to install it using the IntelliJ IDE.    Open IntelliJ, click IntelliJ IDEA in the top menu, click Preferences, and then click Plugins.  Tip: If you are using Ubuntu/Windows, click File, click Settings, and then click Plugins.  Click the cogwheel icon, and then click Install plugin from disk….  Browse and select the ZIP file of the plugin you downloaded.  Important: Make sure you install the ZIP file and not the extracted JAR files. This is because the ZIP file contains of an additional library that is required by the plugin to function as expected.  Click the Installed tab, click Restart IDE, and then click Restart.     Using the plugin  The below sections include information on using the IntelliJ Ballerina plugin to write Ballerina programs.    Using the features of the plugin  The below sections include information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process."},{"page":"/learn/intellij-plugin/using-intellij-plugin-features/","name":"Using the features of the IntelliJ plugin","summary":"The below sections include information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process.You can run Ballerina main/service programs with a single click without adding or changing any configurations.The below sections include instructions on how to run different elements of a Ballerina file.Follow ...","content":"/  /  / Using the features of the IntelliJ plugin  Using the features of the IntelliJ plugin  The below sections include information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process.    Running Ballerina programs  You can run Ballerina main/service programs with a single click without adding or changing any configurations.  The below sections include instructions on how to run different elements of a Ballerina file.    Running the main method  Follow the steps below to run the main function of a Ballerina file.    Click the green color icon located near the main function.   Click the corresponding **Run ** command.   This executes the main function of the Ballerina file and displays the output in the Run window.      Tip: Alternatively, you can right click on the name of the file and run the main method of it.   Running Ballerina services  Follow the steps below to run a service of a Ballerina file.    Click the green color icon located near the definition of the service.  Click the corresponding **Run **** command.  This starts the service and displays the output in the Run window. If you have multiple services in the Ballerina file, this starts all of them.      Tip: Alternatively, you can right click on the name of the file and run the service(s) of it.   Debugging Ballerina programs  You can debug Ballerina main/service programs with a few clicks.    Troubleshooting   Stepping over code lines in non-blocking paths (eg: action invocations) will not pause VM on next line  workaround: manually put a breakpoint to next line  There are some cases where stepping over gives unexpected behavior  Eg: When there are multiple workers and a wait expression waiting for them, even though step over hit and pass wait line in source, workers are not yet finished execution.  Viewing the sequence diagram  The underlying language semantics of Ballerina were designed by modeling how independent parties communicate via structured interactions. Subsequently, every Ballerina program can be displayed as a sequence diagram of its flow including endpoints as well as synchronous and asynchronous calls.  To view the sequence diagram of a Ballerina file, click the () in the top right corner of the IDE window as shown in the below example.    Importing modules on the fly  You can add import declarations to your Ballerina programs on the fly. When you select the module name from the lookup list, the module declaration will be added automatically.    Importing unambiguous modules  When you copy and paste Ballerina code to IntelliJ, this feature allows you to import unambiguous imports. You can apply these imports by clicking on the module name and pressing Alt + Enter keys.    Note: This is disabled by default since this might cause issues if the file contains grammar mistakes. Follow the steps below to enable it.  Open IntelliJ, click IntelliJ IDEA in the top menu, click Preferences, and then click Languages and Frameworks.  Tip: If you are using Windows, click File, click Settings, and then click Languages and Frameworks.  Click Ballerina and then click Auto Import.  Select the Add unambiguous imports on the fly checkbox and click OK.  Formatting Ballerina codes  You can reformat the Ballerina codes by pressing the Ctrl+Alt+L keys.    Viewing documentation  You can view the documentation of a function, remote function, etc. by pressing the Ctrl+Q keys or by hovering over the element while pressing the Ctrl key.    Adding annotation fields via suggestions  You can add annotation fields to your code using the annotation field names that are suggested inside annotation attachments.    Using file templates  Three types of Ballerina file templates are available.    Ballerina Main - contains a sample main program  Ballerina Service - contains a sample service  Empty File - contains an empty file     Using code snippet templates  Code snippet templates contain boilerplate codes and allows you to write your code efficiently.    Checking spellings  The spell-checker is enabled for all identifiers. You can rename all of the definitions and references as well.    Analyzing semantics  The Ballerina IDEA plugin provides capabilities to diagnose and analyze semantics of your Ballerina programs through the Ballerina Language Server.    Code folding  You expand/collapse the following Ballerina code segments using the icons in the IntelliJ IDE.    imports  services  objects  records  functions and object functions  annotations  markdown documentation  multiline comments     Go to definition  This option allows you to view the definition of a selected variable, function, an object etc. within the same file, in a separate file, in the same module, or in a file of a different module, of the same project or of the .    What’s next?    For more information on the Ballerina IntelliJ IDEA plugin, see .  For information on all the tools and IDEs that are supported by Ballerina, see ."},{"page":"/learn/intellij-plugin/using-the-intellij-plugin/","name":"Using the IntelliJ Ballerina Plugin","summary":"The below sections include information to start using the IntelliJ Ballerina plugin after .Follow the steps below to create a new Ballerina project.Open IntelliJ, click File in the top menu, click New, and then click Project.Select Ballerina as the type of the project, and click Next.\nSelect a Ballerina SDK for ...","content":"/  /  / Using the IntelliJ Ballerina Plugin  Using the IntelliJ Ballerina Plugin  The below sections include information to start using the IntelliJ Ballerina plugin after .    Creating a new Ballerina project  Follow the steps below to create a new Ballerina project.    Open IntelliJ, click File in the top menu, click New, and then click Project.  Select Ballerina as the type of the project, and click Next.   Select a Ballerina SDK for the project, and click Next.   Tip: If you do not have an already-configured Ballerina SDK to select, click Configure, select the location of the Ballerina distribution, click Open, and then click Next to continue with the project creation. However, if you do not configure, the plugin will auto detect the Ballerina Home by executing the ballerina home command.  Enter a name for the project, a location to save it, and click Finish.   Now, you have successfully created a new Ballerina project.    Setting up Ballerina SDK for an existing project  Follow the steps below to set up Ballerina SDK for an existing project.    Open the Project to which you want to set up a Ballerina SDK.  In the IDE, click File in the top menu, and then click Project Structure.   If you do not have an already-configured Ballerina SDK, in the Project tab, click New under Project SDK:, click Ballerina SDK, and then click OK.   Tip: If you have already-configured Ballerina SDKs, select one under Project SDK:, and click OK to continue.  Select the location of the Ballerina distribution and click Open.   Click Apply to save the changes.   Tip This prompts a restart request. Click Restart to apply the changes.  Now, you have successfully added the Ballerina SDK to an existing project.  Creating a new Ballerina file  Follow the steps below to create a new Ballerina file within a Ballerina project.    Right-click on the name of the project, click New, and then click Ballerina File.   Enter a name for the file, and click OK.   Tip: In this example, since the default Main template is selected as the Kind, it creates a new file with a main function.  Now, you have successfully created a new Ballerina file with a main function.    Configuring the plugin settings  Ballerina Home auto detection  In order to automatically detect the Ballerina Home that is being used (without setting up a Ballerina SDK), enable the Settings -> Languages and Frameworks -> Ballerina -> Ballerina Home Auto Detection option.    Experimental features  Ballerina Language Specification supports a set of experimental features such as transactions syntax. In order to be compatible with the experimental features and for supporting language intelligence in IntelliJ plugin, enable the Allow Experimental option in Settings -> Languages and Frameworks -> Ballerina -> Experimental Features.    Language Server Debug logs  In order to view the plugin debug logs, enable the Settings -> Languages and Frameworks -> Ballerina -> Language Server Debug Logs option.  Then, the language server debug logs will be added to the IDEA log files. (Click Help -> Show Log In Files option to view them).    What’s next?  Next, for information on using the features of the IntelliJ Ballerina plugin, see ."},{"page":"/learn/quick-tour/","name":"Quick Tour","summary":"Now, that you know a little bit of Ballerina, let’s take it for a spin!Write a simple Hello World service in a file with the .bal extension.Now, you can run the service by running the following command.You get the following output.This means your service is up and running. You can ...","content":"/  / Quick Tour  Quick Tour  Now, that you know a little bit of Ballerina, let’s take it for a spin!  Install Ballerina    Ballerina based on the Operating System you are using.  Follow the instructions given on the page to set it up.  Follow the instructions given on the page or the page to set up your preferred editor for Ballerina.   Write a Service, Run It, and Invoke It  Write a simple Hello World service in a file with the .bal extension.  import ballerina/http; import ballerina/io;  # A service representing a network-accessible API # bound to port `9090`. service hello on new http:Listener(9090) {   # A resource respresenting an invokable API method  # accessible at `/hello/sayHello`.  #  # + caller - the client invoking this resource  # + request - the inbound request  resource function sayHello(http:Caller caller, http:Request request) {   // Sends a response back to the caller.  error? result = caller->respond(\"Hello Ballerina!\");  if (result is error) {  io:println(\"Error in responding: \", result);  }  } }   Now, you can run the service by running the following command.  $ ballerina run hello_world.bal   You get the following output.  [ballerina/http] started HTTP/WS listener 0.0.0.0:9090   This means your service is up and running. You can invoke the service using an HTTP client. In this case, we use cURL.  $ curl http://localhost:9090/hello/sayHello     Tip: If you do not have cURL installed, you can download it from .   You get the following response.  Hello Ballerina!   Alternatively, you can use a Ballerina HTTP client to invoke the service.  Use a Client to Interact with a Network Accessible Service  A Ballerina client is a component, which interacts with a network-accessible service. It aggregates one or more actions that can be executed on the network-accessible service and accepts configuration parameters related to the network-accessible service.  There are two kinds of clients in Ballerina, inbound (or ingress) and outbound (or egress) clients. An outbound client object can be used to send messages to a network service.  Having said that, let’s see how you can use a Ballerina client to invoke the Hello World service.  First, you need to create the client with the relevant endpoint URL as follows. We will use a Ballerina program with a main function, which will perform the invocation.    Note: returning error? allows you to use the check keyword to avoid handling errors explicitly. This is only done to keep the code simple. However, in real production code, you may have to handle those errors explicitly.   http:Client helloClient = new(\"http://localhost:9090/hello\");   As the next step, add the below code to do a GET request to the Hello World service.  http:Response helloResp = check helloClient->get(\"/sayHello\");   The remote call would return an http:Response if successful, or an error on failure. If successful, attempt retrieving the payload as a string and print the payload.  io:println(check helloResp.getTextPayload());   The complete source code should look similar to the following:  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client helloClient = new(\"http://localhost:9090/hello\");  http:Response helloResp = check helloClient->get(\"/sayHello\");  io:println(check helloResp.getTextPayload()); }   Make sure the service is up and running.  Now, you can run the .bal file containing the main function that invokes the service.  $ ballerina run hello_client.bal   This would produce the following output.  Hello Ballerina!   Similarly, you can use a Ballerina HTTP client to interact with any HTTP service.  Now, let’s look at a simple HTTP client that retrieves sunrise/sunset time details for Colombo.  Create a client with the relevant endpoint URL as follows.  http:Client sunriseApi = new(\"http://api.sunrise-sunset.org\");   As the next step, add the below code to do a GET request to the sunrise-sunset backend.  http:Response sunriseResp = check sunriseApi->get(\"/json?lat=6.9349969&lng=79.8538463\");   Now, add the below code snippet to retrieve the payload and print it.  json sunrisePayload = check sunriseResp.getJsonPayload(); io:println(sunrisePayload);   The complete source code should look similar to the following:  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client sunriseApi = new(\"http://api.sunrise-sunset.org\");  http:Response sunriseResp = check sunriseApi->get(\"/json?lat=6.9349969&lng=79.8538463\");  json sunrisePayload = check sunriseResp.getJsonPayload();  io:println(sunrisePayload); }   Now, you can invoke the service using this client by running the following command.  $ ballerina run sunrise_client.bal   This should print out the sunrise/sunset details.  Follow the Repo  \"Star\" \"Watch\"  Star and show appreciation to Ballerina maintainers for their work. Watch the repo to keep track of Ballerina issues.  What’s Next  Now, that you have taken Ballerina around for a quick tour, you can explore Ballerina more.    Go through the to learn Ballerina incrementally with commented examples that cover every nuance of the syntax."},{"page":"/learn/managing-ballerina/keeping-ballerina-up-to-date.html","name":"Keeping Ballerina up to date","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat ...","content":"/  /  / Keeping Ballerina up to date  Keeping Ballerina up to date  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."},{"page":"/learn/learning-the-basics/","name":"Learning the Basics","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat ...","content":"/  / Learning the Basics  Learning the Basics  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."},{"page":"/learn/standard-library/","name":"Standard Library","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat ...","content":"/  / Learning the Basics  Standard Library  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  Lorem ipsum dolor sit amet,  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."},{"page":"/learn/style-guide/annotations_documentation_and_comments/","name":"Annotations, Documentation and Comments","summary":"Example,Example,Example,Example,Example,andExample,Example,Example,Example, ...","content":"/  /  / Annotations, Documentation and Comments  Annotations, Documentation and Comments  Annotations   Do not have spaces around the @ symbol.  Indent annotations to align them with the starting position of the owner (statement or definition).   Example,  // Service annotations are indented to align it with the starting position of the service. @http:ServiceConfig {  ... } service greetingService on new http:Listener(8080) {  // Resource annotation is indented to align it with the starting position of the resource.  @http:ResourceConfig {  ...  }  resource function hello(http:Caller caller, http:Request req) returns error? {  ...  } }     Each annotation attribute (i.e., key-value pairs) should block indent on its own line..   Example,  @http:ServiceConfig {  basePath: \"greet\",  methods: [\"GET\"] }     If an annotation is empty, place it in a single line and do not have spaces between both braces.   Example,  @http:ServiceConfig {}     If you are annotating a parameter or a return type, the annotation should be added inline to the parameter or the return type.   Example,  // Parameter annotation. public function secureFunction1(@sensitive string secureInName, @sensitive int secureInId, string insecureIn) {  ... }  public function secureFunction2(@sensitive string secureInName,  @sensitive int secureInId, string insecureIn) {  ... }  // Return type annotation. public function taintedReturn1() returns @tainted string {  ... }  public function taintedReturn2() returns @tainted string {  ... }  Comments   Use // for both single-line and multi-line comments.   Example,  // This is a single-line comment.   and  // Copyright (c) 2019 WSO2 Inc. (http://www.wso2.org) All Rights Reserved. // // WSO2 Inc. licenses this file to you under the Apache License, // Version 2.0 (the \"License\"); you may not use this file except // in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License.     Add a single space between the // and the content.  If the comment is in its own line, then indent it considering its context (i.e., top level or in a block).   Example,  // This is a top level comment.  function func1() {  // This is a block level comment. }  function func2() {  if (true) {  if (true) {  // This is a nested if block level comment.  }  } }     If the comment is in line with the code, add a space before it.   Example,   type People record {}; // Inline comment  function func1() {  int a = 0; // Inline comment }    Documentation   Always, indent them to align with the starting position of the owner.  Add a space after the # symbol.  Add an empty line after the description.   Example,  # Description. # # + value - value input parameter # + return - return a integer value function getValue(int value) returns int {  return value; }     Add only one space after the parameter marker (+), divider (-), and return.  Begin the param identifier and description with a single space.   Example,  # Description. # # + value - Parameter description # + return - Return value description function getValue(int value) returns int {...}  # Description. @http:ServiceConfig {...} service greet on new http:Listener(8080) {  # Description.  #  # + caller - Parameter description.  # + request - Parameter description.  @http:ResourceConfig {...}  resource function sayHello(http:Caller caller, http:Request request) {...} }"},{"page":"/learn/style-guide/definitions/","name":"Top Level definitions","summary":"Do’sDon’tsExample,Example,Example,Example,Example,Example,Example,Example,Example,Block indent each of the field definitions (including the Rest field) in their own line.Example,Example,Example: ...","content":"/  /  / Top Level definitions  Top Level definitions    Do not indent the top level definitions.   Do’s   import ballerina/http;  const int MIN_AGE = 20; int repetitions = 0;  service hello on ep1 {  ... }    Don’ts  // This import is indented correctly. import ballerina/http; const int MIN_AGE = 20; // Not indented correctly.  int repetitions = 0; // Not indented correctly.  // Not indented correctly. service hello on ep1 {  ...  }  Imports    Do not keep spaces between the organization name, divider /, and module name.   Example,  import ballerina/http;     Imports should be sorted alphabetically, first by the organization name and then by the module name.   Function definition   Do not keep spaces between the function name and the open parentheses ( of the function signature.   Example,  function func1() {}     If the function has an object attached to it, do not keep spaces around the Dot .. Also, keep a single space between the function keyword and the name of the object.   Example,  function Person.getName() {}     If the function needs to be split in to new lines due to it exceeding the max line length,  can break lines from the parameter list by moving a parameter value only to a new line and indenting it with four spaces from the starting position of the function.  Example,  function getAddress(int value,  string name) returns (string|()) {  ... }     can break before the returns keyword and indent it with four spaces from the starting position of the function.   Example,  function getAddress(int value, string name)  returns (string|()) {  ... } can break after the returns keyword by moving the return value to a new line  and indenting it with four spaces from the starting position of the function.   Example,  function getAddress(int value, string name) returns  (string|()) {  ... } Service definition    Keep the listener inline with the service signature.   Example,  service hello on new http:Listener(9090) {  ... }     When formatting resource functions and function definitions, block indent each element and follow the .   Example,  service hello on ep1, ep2 {  resource function sayHello(http:Caller caller, http:Request req) returns error? {  http:Response res = new;  res.setPayload(self.getGreeting());  _ = caller->respond(res);  }  function getGreeting() returns string {  return \"Hello\";  } }     Block indent each function definition, resource definition, and field definition inside a service definition.   Object definition    Block indent each field definition and each function definition on their own line.  Init function should be placed before all the other functions.  For function definitions in the object definition, follow the .   Example,  type Person object {  // Object field definitions.  public boolean isMarried = false;  int age;  string name;  // Object init function.  function __init(string name, int age = 0) {  self.age = age;  self.name = name;  }  // Object function definitions.  function getName() returns string {  return self.name;  }  function setIsMarried(boolean isMarried) {  self.isMarried = isMarried;  }  function getIsMarried() returns boolean {  return self.isMarried;  } }   Record definition Block indent each of the field definitions (including the Rest field) in their own line.  Example,  type Person record {  string name;  int...; }  // or  type Person record {|  int id;  string name; |}   Referencing record or abstract object   Do not keep spaces between the *, the abstract object name, or the record name.   Example,  *Person;    Also, block-indent.   Example:  type UserId record {  string id = \"\"; };  type User record {  *UserId; // Reference to UserId record.  string name = \"john\";  int age = 20; };  // or type Person abstract object {  string name;  // Object function definitions.  function getName() returns string; };  type Employee object {  *Person; // Reference to Person abstract object.   function __init() {  self.name = \"asd\";  }   function getName() returns string {  return self.name;  } };"},{"page":"/learn/set-up-ballerina-sdk/","name":"Setting up Ballerina SDK","summary":"After , you need to set up Ballerina SDK for your Ballerina projects to activate all the capabilities of the plugin.Click on the below links for instructions on how to set up Ballerina SDK.Follow the steps below to set up Ballerina SDK when creating a new Ballerina project.Tip: If you ...","content":"/  / Setting up Ballerina SDK  Setting up Ballerina SDK  After , you need to set up Ballerina SDK for your Ballerina projects to activate all the capabilities of the plugin.  Click on the below links for instructions on how to set up Ballerina SDK.    Setting up for a new project  Follow the steps below to set up Ballerina SDK when creating a new Ballerina project.    In the editor, click File in the top menu, click New, and then click Project.       Click Ballerina and then click Next.       If you do not have an already-configured Ballerina SDK, click Configure to add a new Ballerina SDK.     Tip: If you have already-configured Ballerina SDKs, you can select one of them and click Next to continue with the project creation.       Select the location of the Ballerina distribution and click Open.     Now, you have successfully added the Ballerina SDK. Click Next and continue with the project creation.    Setting up for an existing project  Follow the steps below to set up Ballerina SDK for an exisitng Ballerina project.    Open the Project to which you want to set up a Ballerina SDK.  In the editor, click File in the top menu, click Project Structure.  If you do not have an already-configured Ballerina SDK, in the Project tab, click New under Project SDK:, click Ballerina SDK, and then click OK.     Tip: If you have already-configured Ballerina SDKs, select one under Project SDK: and click OK to continue.       Select the location of the Ballerina distribution and click Open.       Click Apply to save the changes.       Tip This prompts a restart request. Click Restart to apply the changes.   Now, you have successfully added the Ballerina SDK to this project."},{"page":"/learn/style-guide/expressions/","name":"Expressions","summary":"Do not keep spaces between the function name and opening parentheses (.If it is unable to keep the function invocation in a single line due to it exceeding the max line length, split each argument to its own block-indented line.Example,Example,Example,Example,Do’sDon’tsExample,Example,Example,Example,Example,Example,Do’sDon’tsExample, ...","content":"/  /  / Expressions  Expressions  Function invocation    Do not keep spaces between the function name and opening parentheses (.  If it is unable to keep the function invocation in a single line due to it exceeding the max line length, split each argument to its own block-indented line.  Example,   setAgeForEmployee(  employeeName,  employeeID  );   Record literal    If empty, keep it as an empty block.   Example,  Person p = {};     In a record literal, arrange the fields in a single line. Then, add a space after the comma and leave no spaces between the braces and fields.   Example,  Person p = {name: \"john\", age: 20};     Do not keep any spaces between the key and the colon. Also, Keep only one space between the colon and the value.   Example,  Person person = {  name: \"john\", // in this field Key is the \"name\" and value is \"john\". };     You can define the fields in new lines. If so, make sure all the fields are in a separate line and they are block indented.   Do’s  Person p = {  name: \"john\",  age: 20 };   Don’ts  Person p = {name: \"john\",  age: 20};  //Or  Person p = { name: \"john\", age: 20 };  //Or  Person p = {  name: \"john\",  age: 20};   Map literal    For Map literals, follow the same formatting guidelines as .   Example,   // Inline map literal. map<string> mapOfString1 = {name: \"john\", id: \"0\"};  // Mulitline map literal. map<string> mapOfString2 = {  name: \"john\",  id: \"0\" }   Tuple    Always, place a tuple in a single line.   Example,  [string, int] tuple = [\"john\", 20];     If a tuple exceeds the maximum line length limit, move the whole tuple to a new line and indent with four spaces from the starting position of the statement or definition.   Example,  (string, int) tuple = (nameOfEmployee, ageOfTheEmployee);   Array literal    Place simple arrays in a single line.  Do not keep any spaces between the opening bracket, value, and the closing bracket.   Example,  string[] names = [\"john\", \"doe\", \"jane\", \"doe\"];     If an array cannot be placed on a single line due to it exceeding the max line length, split each value in the array to its own block-indented line.   Example,   string[] names = [  \"john\",  \"doe\",  \"jane\",  \"doe\" ];  Type casting    Do not keep spaces between the type and the angle brackets (i.e., <string>).  Do not keep spaces between the closing angle bracket and value reference, which will be casted.   Example,  string name = <string>json.name;     Avoid line breaks in type casting.   Do’s  <string>   Don’ts  <  string >   Table literal    Follow formatting when formatting a table block.   Example,  table<Employee> employee1 = table {  {key id, name, address} };  table<Employee> employee2 = table {  {  key id,  name,  address  },  [{\"1\", \"test\", \"No:123 hty RD\"}, {\"1\", \"john\", \"No:123\"}] };  table<Employee> employee3 = table {  {id, name, address},  [  {\"1\", \"john\", \"No:123\"},  {\"2\", \"jane\", \"No:342\"}  ]  };  table<Employee> employee4 = table {  {id, name, address},  [  {  \"1\",  \"john\",  \"No:123\"  },  {\"2\", \"jane\", \"No:342\"}  ] }"},{"page":"/learn/style-guide/","name":"Ballerina Style Guide","summary":"The Ballerina Style Guide aims at maintaining a standard coding style among the Ballerina community. Therefore, the Ballerina code formatting tools are based on this guide.You can follow your own coding style when writing Ballerina source code. Also, plugins and tools can be configured to match your coding style.Note: You ...","content":"/  / Style Guide  Ballerina Style Guide  The Ballerina Style Guide aims at maintaining a standard coding style among the Ballerina community. Therefore, the Ballerina code formatting tools are based on this guide.  You can follow your own coding style when writing Ballerina source code. Also, plugins and tools can be configured to match your coding style.  Indentation and line length   Use four spaces (not tabs) for each level of indentation.  Keep the maximum length of a line to 120 characters.     Note: You can configure tools and plugins to use tabs when indenting and to change the number of maximum characters of the line length.   Line spacing    Use only a single space to separate keywords, types, and identifiers.   Do’s  public function getFullName() returns string {  string fullName = \"john doe\";  return fullName; }   Don’ts  public function getFullName() returns string {  string fullName = \"john doe\";  return fullName; }   Few exceptions for this rule are:   Do not keep spaces around a type when it is enclosed using angle brackets <string>.   Example,  map<string> names = {};     Do not keep spaces between the type and the opening bracket in the array definition string[].   Example,   string[] names = [];     If it is a list of values separated by commas, add only a single space after each comma and don’t add spaces before the comma.   Example,  [string, int, boolean] tupleVar = [\"\", 0, false];  int[] arrayOfInteger = [1, 2, 3, 4];  map<string> stringMap = {one: st1, two: st2, three: st3};  Person personRecord = {name:\"marcus\", id: 0};  function foo(string name, int id) {}  service hello on ep1, ep2 {...}   Blank lines  Separate both statements and top level definitions by zero or one blank lines.  Example,  import ballerina/http; import ballerina/io;  const string CITY = \"Colombo\"; const int CITY_NO = 1;  function getName() returns string {  string firstName = \"john\";  string lastName = \"doe\";  return firstName + lastName; }  function setName(string name) {} function setAge(int age) {}     Note: You can configure tools and plugins to change the number of minimum and maximum blank lines used when formatting.   Blocks   Opening curly braces of a block should be placed inline.   Do’s  if (true) { }  function setName(string name) {  }   Don’ts  if (true) {  }  function setName(string name) {  }     Add a single space before the opening curly braces.   Example,   function func1() {  if (true) {} }      If a block is empty, do not keep spaces in between the opening and closing braces.   Example,  function func1() {}     Indent all the statements inside a block to be at the same level.  Indent the closing brace of a block to align it with the starting position of the block statement.   Example,  if (false) {  ... }  match a {  ... }   Parentheses and Brackets   Do not have spaces after opening parentheses/bracket and before closing parentheses/bracket.   Example,  [string, int] tupleVar = [\"\", 0];  function setValue(string value) {...}  setValue(\"value\");     To define an empty parentheses, do not keep spaces between the opening and closing parentheses ().   Example,  int|() result = getResult();   Line breaks    Have only one statement in a line.  When splitting lines, which contains operator(s), split them right before an operator.   Example,  // Binary operations. string s = \"added \" + People.name  + \" in to database.\";  // Function invocation. string s = person  .getName();  // Binary operations in if condition if (isNameAvailable && (i == 1)) {  }     When splitting lines, which contains separator(s), split them right after a separator.   Example,  // Function parameters. function getName(int id, int age,  string searchValue) returns string {  ... }     If there isn’t any operator or separator to break the line from, move the whole expression to a new line.   Example,  // String literal. string s1 =  \"My name is not in this description\";  // Function invocation. string s2 =  getPersonNameWithUpperCaseLetters();     If a line exceeds the max line length, start from the end of the line and come towards the start of the line until you find a point, which matches the above rules to break the line.  Indent split lines with relation to the starting position of the statement or definition.   Example,  if (isNameAvailable && (i == 1)) {  }  // Function parameters. function getName(int id, int age,  string searchValue) returns string {  ... }     However, if you cannot add the type-casting expression or statement with the constrained type in a single line due to it exceeding the max line length,  move the casting type with the operators to a new line.   Example,   string name =  <string>json.name;     keep the constrained type on the same line by splitting the statement from a point before the constraint type.   Example,  map<int|string> registry = {  name: \"marcus\" };  table<Employee> employee = table {  {key id, name, address}  };   Top Level Definitions  For style guidelines on imports, service definition, object definition, record definition, referencing record or abstract object, etc., see .  Operators, Keywords, and Types  For style guidelines on operators, keywords, and types, see .  Statements  For style guidelines on statements such as if, match, transaction etc., see .  Expressions  For style guidelines on function invocation, literals, tuple, type casting etc. see .  Annotations, Documentation, and Comments  For style guidelines on annotations, documentation, and comments, see ."},{"page":"/learn/style-guide/operators_keywords_and_types/","name":"Operators, keywords, and types","summary":"Example,Example,Do’sDon’tsExample,Example,Example,Example,Example, ...","content":"/  /  / Operators, keywords, and types  Operators, keywords, and types  Keywords and types   Do not keep spaces between the type and the pipe operator when it is in an union type (e.g., string|int).   Example,  type method \"POST\"|\"GET\"|\"PUT\";  (int|string) variable = 0;  function getValue(string key) returns (string|error) {  ... }  function getName() returns string|error {  (string|error) valueOrError = getValue(\"name\");  ... }     Do not keep spaces between the type and the optional operator ?.   Example,  string? name;     Avoid line breaks in constrained types.   Do’s   map<int|string> // map reference type   Don’ts  map<  int  |  string > Operators   Keep only a single space before and after the = operator.   Example,  int a = 0;     Do not keep spaces around the semicolon ;.  Do not keep spaces between the unary operator and the expression.   Example,  a = -a;     Keep a single space before and after any binary or ternary operator.   Example,  var fullName = firstName + lastName;  string|() name = isNameAvailable() ? getName() : \"Unknown\";  var elvisOperator = name ?: \"Unknown\";     Keep a single space before and after a compound operator such as -= and +=.   Example,  name += lastName;     When accessing a function, object, or record from another module, do not keep spaces around :.   Example,  io:println(\"john\"); http:Response res = new();"},{"page":"/learn/style-guide/statements/","name":"Statements","summary":"Do’sDon’tsExample,Example,Example,If pattern body is empty, then keep it as an empty block.Example,Example, ...","content":"/  /  / Statements  Statements  If statement    Always enclose the condition with parentheses in the If statement.   Do’s  if (true) {  ... } else if (false) {  ... }   Don’ts  if true {  ... } else if false {  ... }     Keep the else and else if keywords in the same line with the matching if or else if block’s closing brace separated only by a single space.   Empty block    Do not have any empty if, else if, or else blocks.  If empty, add an empty line between the opening and closing braces.   Example,  if (inProperSallaryRange) {  } else if (inSallaryRange) {  } else {  }   Match statement  Match patterns clause    Block indent each pattern clause in its own line.  Keep a single space before and after the => sign.  If a pattern clause contains only one statement, place it in the same line as the pattern clause enclosing it with curly braces.   Example,  function foo(string|int|boolean a) returns string {  match a {  12 => {  return \"Value is '12'\";  }  }  return \"Value is 'Default'\"; }     If a pattern clause has more than one statement, block indent each statement in its own line.   Example,  match x {  var (s, i) if s is string => {  io:println(\"string\");  }  var (s, i) if s is int => {  io:println(\"int\");  } }     If pattern body is empty, then keep it as an empty block.   Example,  match x {  var (s, i) if s is string => {}  var (s, i) if s is int => {} }   Transaction statement    Start each optional clause (onretry, committed, and aborted) in the same line as the closing brace of the matching clause.  If transaction, onretry, committed, and aborted blocks are empty, add an empty line between the braces.   Example,  function func1() {  transaction with retries = 2 {  } onretry {  } aborted {  } committed {  } }"},{"page":"/learn/vscode-plugin/language-intelligence/","name":"Language intelligence","summary":"The VS Code Ballerina extension brings in language intelligence to enhance the development experience and increase its efficiency.Language intelligence is built in to the extension via a Language Server implementation, which consists of the below language intelligence options.When there are syntax or semantic errors in your code, you will be ...","content":"/  /  / Language intelligence  Language intelligence  The VS Code Ballerina extension brings in language intelligence to enhance the development experience and increase its efficiency.  Language intelligence is built in to the extension via a Language Server implementation, which consists of the below language intelligence options.    Semantic and syntactic diagnostics  When there are syntax or semantic errors in your code, you will be notified with appropriate diagnostics during the development time.    Tip: The detailed description that appears when you hover over the lines underlined in red will be consistent with the error message that you get during compile-time.     Suggestions and auto completion  The extension provides you with suggestions on keywords, variables, and code snippets of language constructs (such as functions, services, and iterable constructs etc.).      Tip: You can use these suggestions to access the contents of the modules available in your Ballerina home repo as well as in the Ballerina distribution.   Code actions  These allow you to perform the below tasks easily based on the diagnostics and the current scope where the cursor resides.    Add documentation for an entity such as a function, service, resource, object, record etc.  Add documentation for all the available entities in the current file  Add missing imports  Create variable definitions  Create an undefined function   For example, you can add documentation for a function as shown below.    Hover support  Hover support provides you quick access to information about a certain entity.  For an example, if you hover over a function name, you can view its description, information about its parameters, and the description of its return type as shown below.      Tip: Likewise, if you hover over an entity name of an object or a record, you can view the description of the object/record as well as descriptions of its fields.   Go to definition  This option allows you to view the definition of a selected variable, function, an object etc. within the same file, in a separate file, in the same module, or in a file of a different module, of the same project or of the .    What’s next?    For information on the next capability of the VS Code Ballerina extension, see .  For information on the VS Code Ballerina extension, see ."},{"page":"/learn/vscode-plugin/","name":"The Visual Studio Code Extension","summary":"The VS Code Ballerina extension provides the Ballerina development capabilities in VS Code. The below sections include instructions on how to download, install, and use the features of the VS Code extension.Download the .Use either of the below approaches to install the VS Code Ballerina extension.Click Extensions on the left-most ...","content":"/  / The Visual Studio Code Plugin  The Visual Studio Code Extension  The VS Code Ballerina extension provides the Ballerina development capabilities in VS Code. The below sections include instructions on how to download, install, and use the features of the VS Code extension.    Downloading VS Code  Download the .  Installing the extension  Use either of the below approaches to install the VS Code Ballerina extension.    Installing via the VS Code editor  Click Extensions on the left-most menu of the editor, search for the Ballerina extension, and click Install.    Tip: Click Reload to reload the editor to apply the change.     This downloads the extension and installs it.  Installing by downloading the extension    Download the .  Follow either of the below approaches to install the extension.  Using the VS Code editor    Click View in the top menu of the editor and click Command Palette.  In the search bar, type “vsix” and click Extensions: Install from VSIX….  Browse and select the VSIX file of the extension you downloaded.     Using the Command Line In a new Command Line tab, execute the below command. $ code --install-extension <BALLERINA-EXTENSION-DIRECTORY>    Tip: In the above command, <BALLERINA_EXTENSION-DIRECTORY> refers to the path of the Ballerina extension directory (i.e., the VSIX file) you downloaded.   Using the extension    Tip: Ballerina Language Specification supports a set of experimental features such as transactions syntax. In order to be compatible with the experimental features and for supporting language intelligence in VSCode Extension, enable the Allow Experimental option in user settings.     Troubleshooting: If you installed a new Ballerina version recently, you might need to restart the VS Code Editor to pick the new Ballerina version. Herein, If you are using Mac OS, press ‘Command+Q’ keys to quit the app and reopen it.   The below sections include information on the various capabilities that are facilitated by the VS Code Ballerina Extension for the development process."},{"page":"/learn/vscode-plugin/documentation-viewer/","name":"Documentation Viewer","summary":"The VS Code Ballerina extension is shipped with a Documentation Viewer. You can add documentation for the functions and other public entities in your module for the reference of other users of it.The Documentation Viewer represents the documented entities in a file in an organized manner. Follow the steps below ...","content":"/  /  / Documentation Viewer  Documentation Viewer  The VS Code Ballerina extension is shipped with a Documentation Viewer. You can add documentation for the functions and other public entities in your module for the reference of other users of it.  The Documentation Viewer represents the documented entities in a file in an organized manner. Follow the steps below to launch the Documentation Viewer.    Click View in the top menu and click Command Palette.  In the search box, type “Show” and click Ballerina: Show Documentation Preview.     What’s next?    For information on the Ballerina VSCode extension, see For information on all the tools and IDEs that are supported by Ballerina, see ."},{"page":"/learn/vscode-plugin/run-all-tests/","name":"Run all tests","summary":"This option allows you to run all the tests that belong to multiple modules of your project. Follow the steps below to do this. ...","content":"/  /  / Run all tests  Run all tests  This option allows you to run all the tests that belong to multiple modules of your project. Follow the steps below to do this.    Click View in the top menu and click Command Palette.  In the search box, type “Ballerina” and click Ballerina: Run All Tests.     What’s next?    For information on the next capability of the VS Code Ballerina extension, see .  For information on the VS Code Ballerina extension, see"},{"page":"/learn/vscode-plugin/graphical-editor/","name":"Graphical View","summary":"A rich set of visualization tools will immensely enhance your development experience especially in the integration space.The Graphical Editor of the VS Code Ballerina extension allows you to design your integration scenario graphically. Thus, by using it, you can visualize your code in a sequence diagram, which presents the endpoint ...","content":"/  /  / Graphical View  Graphical View  A rich set of visualization tools will immensely enhance your development experience especially in the integration space.  The Graphical Editor of the VS Code Ballerina extension allows you to design your integration scenario graphically. Thus, by using it, you can visualize your code in a sequence diagram, which presents the endpoint interactions and parallel invocations that happen in the code.  The bellow sections discuss how to use the Graphical Editor and explore its capabilities.    Launching the Graphical View  The below are the two types of Graphical Views you can find in the VSCode extension.  1. Project Overview  This gives a graphical representation of a grouping of the content in the project modules. Click the name of the entity under BALLERINA PROJECT OVERVIEW to view its graphical representation.    2. File Overview  This gives a graphical representation of the content of the current Ballerina file. Use one of the methods to view it.    Click the Show File Overview icon in the top right corner.   Select the Show File Overview command option from the Command Palette.  Exploring the features of the Graphical View  The below sections include information to explore the features of the Graphical Editor.    Viewing the source  From the design view you can jump to the respective source segment as shown below.    Expanding the Diagram View  You can expand the Diagram View to show not only the control flow but also to show more fine-grained statements of the constructs.    What’s next?    For information on the next capability of the VS Code Ballerina plugin, see .  For information on the VS Code Ballerina extension, see ."},{"page":"/learn/vscode-plugin/run-and-debug/","name":"Run and debug","summary":"The VS Code Ballerina extension gives you the  same debugging experience as the conventional VS Code Debugger.Thus, you can run or debug your Ballerina programs easily via the VS Code Ballerina extension by launching its debugger.Follow the steps below to start a \ndebug session.You view the output in the ...","content":"/  /  / Run and debug  Run and debug  The VS Code Ballerina extension gives you the same debugging experience as the conventional VS Code Debugger.  Thus, you can run or debug your Ballerina programs easily via the VS Code Ballerina extension by launching its debugger.  Follow the steps below to start a debug session.    Click the Debug icon in the left menu or press the Control + Shift + D keys, to launch the Debugger view.  Add the debug points you require by clicking on the respective line numbers of the file.  Click No Configurations and select Add Configuration….  Click Ballerina Debug. This opens the launch.json file. You can edit this file to change the debug configuration options as required.  Click on the name of the file that you want to debug.  Click the Start Debugging icon.   You view the output in the DEBUG CONSOLE.    For more information on debugging your code using VS Code, go to .  Troubleshooting   Stepping over code lines in non-blocking paths (eg: action invocations) will not pause VM on next line  workaround: manually put a breakpoint to next line  There are some cases where stepping over gives unexpected behavior  Eg: When there are multiple workers and a wait expression waiting for them, even though step over hit and pass wait line in source, workers are not yet finished execution.  What’s next?    For information on the next capability of the VS Code Ballerina extension, see .  For information on the VS Code Ballerina extension, see ."},{"page":"/license-of-site/","name":"Ballerina Website License","summary":"Except as detailed below, the content on this website is licensed under the .We say “nearly everything” as there are a few simple conditions that apply.Ballerina’s trademarks and other brand features are not included in this license. If you’re looking to understand if and how you can use the Ballerina ...","content":"/ Ballerina Website License  Ballerina Website License  Except as detailed below, the content on this website is licensed under the .  What is not licensed? We say “nearly everything” as there are a few simple conditions that apply.  Ballerina’s trademarks and other brand features are not included in this license. If you’re looking to understand if and how you can use the Ballerina brand in a project, you’ve come to the right place. After reading through this site, if you still have questions, please fill out and submit a formal request form.  All of our brand features are protected by applicable trademark, copyright and other intellectual property laws. If you would like to use any of our brand features on your website, in an ad, in an article or book, or reproduce them anywhere else, or in any other medium, you’ll need to receive permission from Ballerina first. And please note that the user experience with all our products should never be altered.  In some cases, a page may include content consisting of images, audio or video material, or a link to content on a different webpage (such as videos or slide decks). This content is not covered by the license, unless specifically noted.  Attribution Proper attribution is required when you reuse or create modified versions of content that appears on a page made available under the terms of the Creative Commons Attribution license. The complete requirements for attribution can be found in section 4 of the .  In practice we ask that you provide attribution to Ballerina to the best of the ability of the medium in which you are producing the work.  There are several typical ways in which this might apply:  Exact Reproductions If your online work exactly reproduces text or images from this site, in whole or in part, please include a paragraph at the bottom of your page that reads:  Portions of this page are reproduced from work created and shared by Ballerine and used according to terms described in the Creative Commons 3.0 Attribution License.  Also, please link back to the original source page so that readers can refer to it for more information.  Modified Versions If your online work shows modified text or images based on the content from this site, please include a paragraph at the bottom of your page that reads:  Portions of this page are modifications based on work created and shared by Ballerina and used according to terms described in the Creative Commons 3.0 Attribution License.  Again, please link back to the original source page so that readers can refer to it for more information. This is even more important when the content has been modified.  Other Media If you produce non-hypertext works, such as books, audio, or video, we ask that you make a best effort to include a spoken or written attribution in the spirit of the messages above.  Ballerina Website Attributions In the creation of this website, we used the following Creative Commons Attribution license:    sample pages are generated using a developed by , licensed under and modified from the original.   Contact If you have any comments regarding Ballerina.io license policies, please send feedback to ."},{"page":"/privacy-policy/","name":"Privacy PolicyCookie PolicyContact us","summary":"At WSO2, we recognize that privacy is important. This privacy policy applies to the Ballerina sites and services offered at  and any other site to which a link to these terms may appear. We’ve set out below the details of how we collect, use, share and secure the personal ...","content":"/ Privacy Policy  Privacy Policy  At WSO2, we recognize that privacy is important. This privacy policy applies to the Ballerina sites and services offered at and any other site to which a link to these terms may appear. We’ve set out below the details of how we collect, use, share and secure the personal information you provide. “You” or “Your” means the person visiting the above mentioned Ballerina sites (the “Sites”) or using any services on it. “We” “us” and “our” means WSO2 Inc.  What information do we collect?  When you register on the Ballerina Sites for updates or sign up for an event or service, or when you login through single sign on through certain designated federated identity providers mentioned on the Sites, we may ask that you submit some or all of the following information:    Your user name  Your email address   You may choose to visit our site anonymously without providing any of the above information. However, certain services on our site – may require that such details be entered on a mandatory basis. This is because those details are essential for us to be able to provide you with such services.  We also collect certain standard information that your browser sends to every website you visit, such as your IP address, browser type and language, access times, and referring website addresses.  Why do we collect your information?  The information we collect from you maybe used in one of the following ways:    To perform the services requested (for instance if you’ve filled in a contact us form asking to receive updates we use your information to get in touch with you).  To improve our website (we continually strive to improve our website offerings based on the type of content our users click on or download).  To conduct analysis on how effective our marketing campaigns are, how our products and services are used or downloaded, and to track lead generation for our sales process.  To create your online profile, which we create for every user who registers on our site or for a service.  To send marketing material, event invitations and updates - If you indicate that you are interested in certain areas or subjects when you give us your contact details, we will send you marketing material and/or event and workshop invitations related to those areas. The email address you provide may also be used to send you important updates related to the site or the services you use.  To administer a contest, survey, or other site feature.  We track and analyze your actions on our website such as navigation, number of visits, downloads, and search items to gain a better understanding of our visitors and their movements through the site. Please see our on how we use and store cookies.   Who is your information shared with?  We do not sell, trade, or otherwise share your information with outside parties. However, we do share your information with our subsidiaries, affiliates, service providers, and partners who assist us in operating our website, conducting our business, or servicing you.  We sometimes need to give our service providers who help us run our website and services access to the data we have in order for them to perform those services. They are only authorised to use information that is strictly relevant for them to perform their tasks and we ensure that they are under obligations of confidentiality to us so that your data is secure.  We may share your data with our subsidiaries or affiliates within our corporate group. WSO2 ‘s parent company is WSO2 Inc. and is located in the United States of America. Our affiliates are WSO2 UK Limited (located in the United Kingdom), WSO2 Lanka (Private) Limited (located in Sri Lanka), and WSO2 Brasil Tecnologia E Software Ltda (located in Brazil). We share information within this group because these entities also carry out support, marketing, account management, and technical operations for WSO2 that are relevant to the provision of the website and services.  We may also release your information when we believe release is appropriate to comply with the law, enforce our privacy policy, or protect our or others’ rights, property, or safety.  How do we process your data?  We will only collect and process personal data about you where we have lawful bases. Lawful bases include consent (where you have given consent), contract (where processing is necessary for the performance of a contract with you), and legitimate interests (such as to protect you, us, or others from security threats, comply with laws that apply to us and to enable or administer our business through consolidated reporting, customer service etc.).  Where we rely on your consent to process personal data, you have the right to withdraw or decline your consent at any time and where we rely on legitimate interests, you have the right to object. If you have any questions about the lawful bases upon which we collect and use your personal data or wish to withdraw consent or object, please contact our Data Protection Officer at .  Security of your data  We implement security safeguards designed to protect your data such as HTTPS. We regularly monitor our systems for possible vulnerabilities and attacks. However, we cannot warrant the security of any information that you send us. There is no guarantee that data may not be accessed, disclosed, altered, or destroyed by breach of any of our physical, technical, or managerial safeguards.  Your rights to your data and how to manage your preferences  We may retain your information for a period of time consistent with the original purpose of collection. For instance, we may retain your information during the time in which you have an account to use our website or services. We also may retain your information during the period of time needed for WSO2 to pursue our legitimate business interests, conduct audits, comply with our legal obligations, resolve disputes, and enforce our agreements. At the end of these periods, we ensure that your data is deleted securely using an industry standard methodology.  WSO2 acknowledges your right to access your data. If information pertaining to you as an individual has been submitted to us then you have the right to access, correct, or edit your data. If you wish, we can provide all the personal information on our records to you or to someone you nominate in a portable format as well. Our contact details are provided at the bottom of the page or you can reach out to us as dpo@wso2.com. All you have to do is to request, and we are happy to help.  You can ask us to stop using all or some of your personal data (e.g., if we have no legal right to keep using it) or to limit our use of it (e.g., if your personal data is inaccurate or unlawfully held).  You may also choose to delete your data from our website at any time you choose, and unsubscribe from any Ballerina mailing lists you are on. You can unsubscribe from our emails by clicking on the unsubscribe link which is at the bottom of every marketing email we send. You can also contact us on the email address(es) provided at the bottom of this notice, if you would like us to this on your behalf.  We only ever retain your personal data even after you have ceased using our services, requested to unsubscribe or delete your data only if reasonably necessary to comply with our legal obligations (including law enforcement requests), meet regulatory requirements, resolve disputes, maintain security, prevent fraud and abuse, or fulfill your request to “unsubscribe” from further messages from us.  Thord party offerings and services  At our discretion, we may include or offer third party products or services on our site. These third party sites have separate and independent privacy policies. We have no responsibility or liability for the content and activities of these linked sites. We encourage you to review the privacy statements of those websites to understand how your data is secured by them. Nonetheless, we seek to protect the integrity of our site and welcome any feedback about these sites.  Information about our website  This privacy policy applies only to information collected through the Sites and not to information collected offline. Please also visit our section relating to use, disclaimers, indemnities, and limitations of liability governing the use of our site and services.  Changes to our Privacy Policy  We reserve the right to amend this Privacy Policy at any time. We will not send individual email notifications on the updates. Any amendments will be posted on this page. You are therefore encouraged to visit this page periodically.  By using the Sites, you consent to our Privacy Policy and any revisions thereto. If you do not agree with our privacy policy or any changes we make to it, you may delete your profile.    For EU/EEA/Switzerland residents: If you are located within the European Union, the European Economic Area or Switzerland, WSO2 UK Limited will be the controller of your personal data provided to, or collected by or for, or processed in connection with our services. If you have any issues with regard to your data security on our website, then in addition to informing us, you also have the right to write directly to the independent data protection monitoring organization in your country. Within the UK, this is the . The ICO is the UK’s independent authority set up to uphold information rights in the public interest, promoting openness by public bodies and data privacy for individuals. Please do email our data protection officer at if you have any issues, concerns, or questions regarding your personal data and we are happy to help.   Cookie Policy  Below is information about how the (the “Site”) uses cookies.  The Site stores and retrieves information on your browser using cookies. This information is used to make the Site work as you expect it to. It is not personally identifiable to you, but it can be used to give you a more personalized web experience.  This Cookie Policy is part of our Privacy Policy. It explains the following:  What are cookies?  A browser cookie is a small piece of data that is stored on your device to help websites and mobile apps remember things about you. Other technologies, including Web storage and identifiers associated with your device, may be used for similar purposes. In this policy, we use the term “cookies” to discuss all of these technologies.  What do we use cookies for?  Cookies are used to protect your data and account on the Ballerina Site. Cookies help us see which features are most popular, count visitors to a page, improve our users’ experience, keep our services secure, and to provide you with a better, more intuitive, and satisfying experience.  We use cookies for the following purposes:  Security  We use these cookies to help identify and prevent security risks.  For example, we may use these cookies to store your session information to prevent others from changing your password without your username and password.  Performance  We use these cookies to collect information about how you interact with our services and to help us improve them.  For example, we may use these cookies to determine if you have interacted with a certain page.  Analytics  We use these cookies to help us improve our services.  For example, we can use these cookies to learn more about which features are the most popular with our users and which ones might need some tweaks.  Third party cookies  Our website will set several types of third-party cookie, and we do not control the operation of any of them. The third-party cookies, which maybe set include:    Google Analytics - we use Google Analytics to collect data about website usage. This data does not include personally identifiable information. For more information, view the .   What type of cokkies do we use?  We use session cookies. A session cookie is a cookie that is erased when the user closes the Web browser. The session cookie is stored in temporary memory and is not retained after the browser is closed. Session cookies do not collect information from the users computer.  How do I control my cookies?  Most browsers allow you to control cookies through their settings preferences. However, if you limit the ability of websites to set cookies, you may worsen your overall user experience since it will no longer be personalized to you. It may also stop you from saving customized settings like login information.  Contact us  For further information about our Privacy Policy or if you have any questions, complaints, or concerns regarding the use of cookies, please contact our Data Protection Officer at .  Effective April 12, 2018"},{"page":"/security/","name":"Security Policy","summary":"Ballerina project maintainers take security issues very seriously and all the vulnerability reports are treated with the highest priority and confidentiality.Ensure you are using the latest Ballerina version before you run an automated security scan or perform a penetration test against it.Based on the ethics of responsible disclosure, you must ...","content":"/ Reporting a Security Vulnerability  Security Policy  Ballerina project maintainers take security issues very seriously and all the vulnerability reports are treated with the highest priority and confidentiality.    Reporting a vulnerability  Ensure you are using the latest Ballerina version before you run an automated security scan or perform a penetration test against it.  Based on the ethics of responsible disclosure, you must only use the mailing list to report security vulnerabilities and any other concerns regarding the security aspects of the source code or any other resource in this repo.    WARNING: To protect the end-user security, please do not use any other medium to report security vulnerabilities. Also, kindly refrain from disclosing the vulnerability details you come across with other individuals, in any forums, sites, or other groups - public or private before it’s mitigation actions and disclosure process are completed.   Use the following key to send secure messages to security@ballerina.io:    security@ballerina.io: 0168 DA26 2989 0DB9 4ACD 8367 E683 061E 2F85 C381 Also, use the following template when reporting vulnerabilities so that it contains all the required information and helps expedite the analysis and mitigation process.    Vulnerable Ballerina artifact(s) and version(s): list of the Ballerina artifacts/versions that are considered as vulnerable  Overview: high-level overview of the issue and self-assessed severity  Description: include the steps to reproduce  Impact: self-assessed impact  Solution: any proposed solution   We will keep you informed of the progress towards a fix and disclosure of the vulnerability if the reported issue is identified as a true positive.  Handling a vulnerability  The below is an overview of the vulnerability handling process.    The vulnerability will be reported privately to security@ballerina.io. (The initial response time will be less than 24 hours).  The reported vulnerability gets fixed and the solution gets verified by the relevant teams at WSO2.  The fix gets applied to the master branch and a new version of the distribution gets released if required.  The reported user is kept updated on the progress of the process."},{"page":"/terms-of-service/","name":"Terms of Service","summary":"The following Terms of Use (“Terms”) govern your access to and use of the  and any other site to which a link to these terms may appear (“Sites”). These Terms are a legal agreement between you and WSO2. Your registration for, or use of the Sites and any software, ...","content":"/ Terms of Service  Terms of Service  The following Terms of Use (“Terms”) govern your access to and use of the and any other site to which a link to these terms may appear (“Sites”). These Terms are a legal agreement between you and WSO2. Your registration for, or use of the Sites and any software, repositories, other services, or projects hosted on the Sites (“Services”) shall be deemed to be your acceptance of these Terms. These Terms do not govern your access and use of the Ballerina programming language or related commercial support and services offerings, which may be made available to you under separate license terms.  If you are agreeing to these Terms on behalf of a company or other legal entity, you represent that you have the authority to, and do hereby bind such entity to these Terms. You may not use the Ballerina Sites or Services if you are a person barred from using the Sites or Services under the laws of the United States or other countries, including the country in which you are resident or from which you use the Sites, or international laws or treaties. You may not use the Ballerina Sites or Services if you are or represent an entity that is listed on any U.S. Government Denied Party/Person List. You affirm that you are over the age of 13 as the Service is not intended for children under 13. IF YOU ARE 13 OR OLDER BUT UNDER THE AGE OF 18, OR THE LEGAL AGE OF MAJORITY WHERE YOU RESIDE IF THAT JURISDICTION HAS AN OLDER AGE OF MAJORITY, THEN YOU AGREE TO REVIEW THE TERMS WITH YOUR PARENT OR GUARDIAN TO MAKE SURE THAT BOTH YOU AND YOUR PARENT OR GUARDIAN UNDERSTAND AND AGREE TO THESE TERMS. YOU AGREE TO HAVE YOUR PARENT OR GUARDIAN REVIEW AND ACCEPT THESE TERMS ON YOUR BEHALF. IF YOU ARE A PARENT OR GUARDIAN AGREEING TO THE TERMS FOR THE BENEFIT OF A CHILD OVER 13, THEN YOU AGREE TO AND ACCEPT FULL RESPONSIBILITY FOR THAT CHILD’S USE OF THE SERVICE, INCLUDING ALL FINANCIAL CHARGES AND LEGAL LIABILITY THAT HE OR SHE MAY INCUR.    Certain disclaimers  You understand and agree that the Sites and all Services on it are provided “AS-IS” and that we assume no responsibility for the timeliness, deletion, mis-delivery, or failure to store any user communications or personalization settings. We also assume no responsibility in relation to User Content made available through the Sites. You are responsible for obtaining access to the Services and that access may involve third-party fees (such as internet service provider or airtime charges).  You agree that you are responsible for your own use of the Services, for any posts you make, or code or data files you provide and for any consequences thereof. You agree that you will use the Services in compliance with all applicable local, state, national, and international laws, rules and regulations, including any laws regarding the transmission of technical data exported from your country of residence and all United States export control laws.  Your use of the Sites and Services    As a condition to using certain Services on the Sites, we may require that you log in with your existing SSO credentials through certain federated identity service providers as set out in the account registration procedure on the Sites. You will provide us with true, accurate, current, and complete information. You may not use anyone else’s password. You are solely responsible for maintaining the confidentiality of your account and password. You agree to immediately notify WSO2 of any unauthorized use of your password or accounts or any other breach of security. WSO2 will not be responsible for any loss or damage that may result if you fail to comply with these requirements. You will not employ the use of automation, mashups, programs, robots, or agents in the process of registering your account.  You will be responsible for all activity occurring under your accounts and will comply with all applicable local, state and foreign laws, treaties, and regulations in connection with your use of the Services, including without limitation, laws, and regulations governing data privacy, international communications, and transmission of technical or personal data.  You agree not to (a) access (or attempt to access) the administrative interface of the Services by any means other than through the interface that is provided by WSO2 in connection with the Services unless you have been specifically allowed to do so in a separate agreement with WSO2, and (b) engage in any activity that interferes with or disrupts the Sites and Services (or the servers and networks which are connected to the Sites and Services).  You may not access or use the Sites and Services for the purpose of bringing an intellectual property infringement claim against WSO2 or for the purpose of creating a product or service competitive with the Sites or Services.  Your account may have usage limits as further explained on the Services or other documentation provided by WSO2. The Services may not permit you to exceed the hard usage limits. WSO2 reserves the right to enforce soft usage limits in its sole discretion. Repeated exceeding of the hard or soft usage limits may lead to termination of your account.  The software and technology relating to the Ballerina Sites and the Services are the property of WSO2, its partners, and affiliates. You agree not to modify, adapt, distribute, reverse engineer, sell, assign, or otherwise transfer any portion of the Sites for any purpose including the unauthorized access to the Ballerina Sites. Copyright and other intellectual property laws protect these materials. Reproduction or retransmission of the materials, in whole or in part, in any manner, without the prior written consent of WSO2, is a violation of copyright law. For more details, see .  Privacy and restrictions on use    Our describes how we collect, use, and store any personal information belonging to you and is hereby incorporated by reference into these Terms. You agree that you will protect the privacy and legal rights of the end users of your repositories or other content stored or managed via the Services. You must provide a legally adequate privacy notice and protection for such end users.  You agree that you are responsible for your own conduct while accessing or using the Sites and Services and for any consequences thereof. You agree to use the Services only for purposes that are legal, proper, and in accordance with these Terms and any applicable laws or regulations. By way of example, and not as a limitation, you may not and may not allow any third party to:   send, upload, post, email, transmit, or otherwise make available any Content (as defined in the that is unlawful, harmful, threatening, abusive, harassing, tortious, defamatory, vulgar, obscene, libelous, invasive of another’s privacy, hateful, or racially, ethnically, or otherwise objectionable;  harm minors in any way;  impersonate any person or entity (via the use of an email address or otherwise), including, but not limited to, a WSO2 official, guide or host, or falsely state, or otherwise misrepresent your affiliation with a person or entity;  forge headers or otherwise manipulate identifiers in order to disguise the origin of any User Content transmitted through the service;  remove any copyright, trademark, or other proprietary rights notices contained in or on the Sites and Services or any content posted thereon;  send, upload, post, email, transmit, or otherwise make available any Content that you do not have a right to make available under any law or under contractual or fiduciary relationships (such as inside information, proprietary and confidential information learned or disclosed as part of employment relationships or under nondisclosure agreements);  send, upload, post, email, transmit, or otherwise make available any Content that infringes any patent, trademark, trade secret, copyright, or other proprietary rights (“Rights”) of any party;  send, upload, post, email, transmit, or otherwise make available any unsolicited or unauthorized advertising, promotional materials, spam, pyramid schemes, or any other form of solicitation;  send, upload, post, email, transmit, or otherwise make available any material that contains software viruses or any other computer code, files, or programs designed to interrupt, destroy, or limit the functionality of any computer software, hardware, or telecommunications equipment;  interfere with or disrupt the Sites and Services, servers, or networks connected to the Sites and Services, or disobey any requirements, procedures, policies, or regulations of networks connected to the Sites and Services;  display any portion of the Site via an HTML IFRAME;  submit content that falsely expresses or implies that such content is sponsored or endorsed by WSO2;  use the Sites and Services to send emails to distribution lists, newsgroups, or group mail aliases;  add deep hyperlinks to images or other non-hypertext content served by the Services;  intentionally or unintentionally violate any applicable local, state, national, or international law, ordinance, or regulation;  provide material support or resources (or to conceal or disguise the nature, location, source, or ownership of material support or resources) to any organization(s) designated by the United States government as a foreign terrorist organization pursuant to section 219 of the Immigration and Nationality Act;  stalk or otherwise harass another;  exploit the Sites and Services for any unauthorized commercial purposes;  use the Services in connection with illegal peer-to-peer file sharing;  collect or store personal data about other users in connection with the prohibited conduct and activities set forth above; and  use the Sites and Services or any interfaces provided with the Services to access any Ballerina software or Services in a manner that violates these Terms or other terms and conditions for use of such Ballerina software or Service.  You acknowledge, consent, and agree that WSO2 may access, preserve, and disclose your account information and User Content if required to do so by law or in a good faith belief that such access preservation or disclosure is reasonably necessary to:   comply with a legal process;  enforce these Terms;  perform any part of the Services;  respond to claims that any User Content violates the rights of third parties;  respond to your requests for customer service; or  protect the rights, property, or personal safety of WSO2, its users, and the public.  You understand that the Services and software embodied within the Services may include security components that permit digital materials to be protected, and that use of these materials is subject to usage rules set by WSO2 and/or content providers who provide content to the Services. You may not attempt to override or circumvent any of the usage rules embedded into the Services. Any unauthorized reproduction, publication, further distribution, or public exhibition of the materials provided on the service, in whole or in part, is strictly prohibited.  Using the Ballerina Sites or Services for acts or content in violation of these Terms may result in disabling or blocking of your account or access to the Sites without warning and WSO2 may take maximum legal action applicable within law. If we determine (in our sole discretion) that your account has been used to submit any content that violates our terms, we may remove such content from the site at any time without notice to you, and your account will be considered for blocking or disabling in our sole discretion.  User content    You understand that all code, data files, text, documentation, software, sound, graphics, illustrations, video, or other materials (“Content”), whether publicly posted or privately transmitted, are the sole responsibility of the person from whom such Content originated. This means that you, and not WSO2, are entirely responsible for all Content that you upload, post, email, transmit, or otherwise make available via the Services (“User Content”), as well as for any actions taken by WSO2 or other users as a result of your User Content. In connection with User Content, you affirm, represent, and warrant that you either own your User Content or have the necessary licenses, rights, consents, and permissions to grant the rights and licenses granted in these Terms.  You retain all ownership rights in User Content owned by you. WSO2 simply displays or makes the User Content available and does not control the User Content posted via the Services and, as such, does not guarantee the accuracy, integrity or quality of such User Content. You understand that by using the Services, you may be exposed to Content that is inaccurate, misleading, offensive, indecent, infringing, or otherwise objectionable. Under no circumstances will WSO2 be liable in any way for any User Content, including, but not limited to, any errors or omissions in any User Content, or any loss or damage of any kind incurred as a result of the use of any User Content posted, emailed, transmitted, or otherwise made available via the Sites and Services. You understand that WSO2 cannot, and does not, review all User Content and does not endorse any User Content. You further understand that WSO2 does not scan the User Content for malicious computer code such as computer viruses, trojans, computer worms, rootkits, back doors, adware, or spyware and that such content may contain such malicious code, and you agree to use such User Content at your own risk.  By submitting User Content to the Ballerina Sites you acknowledge and agree that:   your User Content does not contain confidential or proprietary information;  we are not under any obligation of confidentiality, express or implied, with respect to your User Content;  you have the right to specify or upload the terms under which other users of the Sites or Services will be licensed to use your User Content. We encourage users to, where possible, grant permissive licenses to their User Content. However, we will neither monitor nor bear responsibility for ensuring that the license terms attached to your User Content are complied with. We undertake no liability for any violation of the license terms under which you make your User Content available. If you do not specify or upload such license terms with respect to any User Content, you hereby grant us and all other users of the Sites and Services, a worldwide, perpetual, non-exclusive, irrevocable, sub-licensable, royalty-free license to use, distribute, reproduce, modify, adapt, publish, translate, publicly perform, and publicly display your User Content (in whole or in part) on the Sites and Services and to incorporate such User Content into other works in any format or medium now known or later developed;  we may delete or archive any User Content where such content has not been used for a certain period of time as determined by us, in our discretion. We may also delete or limit access to any User Content that we determine is violating these terms or any other applicable laws, rules, or regulations; and  you are not entitled to any compensation or reimbursement of any kind from WSO2 under any circumstances.  Copyright information  It is our policy to respond to notices of alleged infringement that comply with the Digital Millennium Copyright Act. If you believe that your work has been copied in a way that constitutes copyright infringement or your intellectual property rights have been otherwise violated, please provide WSO2’s Copyright Agent the following information:    an electronic or physical signature of the person authorized to act on behalf of the owner of the copyright or other intellectual property interest;  a description of the copyrighted work or other intellectual property that you claim has been infringed;  a description of where the material that you claim is infringing is located on the Sites;  your address, telephone number, and email address;  a statement by you that you have a good faith belief that the disputed use is not authorized by the copyright owner, its agent, or the law; and  a statement by you made under penalty of perjury, that the above information in your notice is accurate and that you are the copyright or intellectual property owner, or authorized to act on the copyright or intellectual property owner’s behalf.   WSO2’s agent for notice of claims of copyright or other intellectual property infringement can be reached as follows:    By mail: Attn: Copyright Agent, WSO2 Inc. 787 Castro Street, Mountain View CA 94041, USA  By phone: (+1) 408 754 7388  By Fax: (+1) 408 689 4328   User disagreements  You alone are responsible for your involvement and interactions with other users of the Services. WSO2 reserves the right but has no obligation to monitor disagreements between you and other users. If you have a dispute with any other users of the Services, you irrevocably and forever release WSO2 (and WSO2’s affiliates, officers, directors, agents, subsidiaries, joint ventures, and employees) from claims, demands, and damages (actual and consequential) of every kind and nature, known and unknown, arising out of or in any way connected with such disputes. IF YOU ARE A CALIFORNIA RESIDENT, YOU WAIVE CALIFORNIA CIVIL CODE SECTION 1542, WHICH SAYS: “A GENERAL RELEASE DOES NOT EXTEND TO CLAIMS WHICH THE CREDITOR DOES NOT KNOW OR SUSPECT TO EXIST IN HIS OR HER FAVOR AT THE TIME OF EXECUTING THE RELEASE, WHICH IF KNOWN BY HIM OR HER MUST HAVE MATERIALLY AFFECTED HIS OR HER SETTLEMENT WITH THE DEBTOR.”  Our trademarks and proprietary rights    You acknowledge and agree that WSO2 (or its licensors) own all legal right, title, and interest in and to the Sites and the Services. The visual interfaces, graphics, design, systems, methods, information, computer code, software, services, “look and feel”, organization, compilation of the content, code, data, and all other elements of the Sites and Services (collectively, “Ballerina Materials“) are protected by United States copyright, trade dress, patent, and trademark laws, international conventions, and all other relevant intellectual property and proprietary rights, and applicable laws. Except for any User Content owned and/or posted by you or other users, all Ballerina Materials are the copyrighted property of WSO2 or its licensors. Furthermore, all trademarks, service marks, and trade names contained in the Ballerina Materials are proprietary to WSO2 or its licensors. Except as expressly set forth herein, your use of the Sites or Services does not grant you ownership of, or any other rights with respect to, any content, code, data, user comments or other materials that you may access on or through the Sites or Services. WSO2 reserves all rights to the Ballerina Materials not expressly granted in the Terms.  The following names, trademarks, service marks, logos, and product and service names are trademarks of WSO2: “Ballerina”, “BallerinaCon”, “Ballerina Central”, and “WSO2” and the WSO2 and Ballerina logos. Without WSO2’s prior permission, you agree not to display or use in any manner such names and marks, except for reasonable attribution purposes.  Third party Sites and Services  The Sites and Services may hyperlink to and integrate with third-party applications, websites, and other services. You decide whether and how to use and interact with such services. We do not make any warranty regarding such services or content they may provide, and will not be liable to you for any damages related to such services. Use of such third-party services may be governed by other terms and privacy notices that are not part of this Agreement and are not controlled by us.  Revisions to these Terms and termination    We may at any time revise these Terms by updating this page. We will not send individual email notifications on these updates. By using the Ballerina Sites and Services, you agree to be bound by any such revisions and are therefore encouraged to periodically visit this page. Your continued use of the Sites and Services after revisions are made to this policy will constitute your acceptance of such revised terms.  You agree that WSO2 in its sole discretion and for any or no reason may terminate these Terms and your account for the Services. You agree that any termination of your access to the Services may be without prior notice, and you agree that WSO2 will not be liable to you or any third party for such termination. If WSO2 terminates these Terms or your access or use of the Services due to your breach of these Terms or any suspected fraudulent, abusive, or illegal activity, then termination of these Terms shall be in addition to any other remedies WSO2 may have at law or in equity.  Upon any termination or expiration of these Terms, whether by you or WSO2, ANY INFORMATION (INCLUDING USER CONTENT) THAT YOU HAVE POSTED OR SUBMITTED ON OR THROUGH THE SERVICE OR THAT WHICH IS RELATED TO YOUR ACCOUNT MAY NO LONGER BE ACCESSED BY YOU and WSO2 will have no obligation to maintain any such information in its databases or to forward any such information to you or any third party. However, you acknowledge that the ecosystem and community beyond WSO2 may build a lasting dependency upon your User Content once it is posted upon the Sites. To ensure community continuity, WSO2 retains the right to continue to host and maintain your User Content on the Sites and Services even after the termination of your account, or the expiration of these terms, at our sole discretion. In the event of any contradiction between the right granted herein and any term of the license specified with your User Content, you agree that the right granted in this section 9.3 shall prevail. You are solely responsible for retrieving your User Content from the Services prior to termination of your account for any reason, provided that if we terminate your account, we will attempt to provide you a with reasonable opportunity to retrieve your User Content.  Subscriptions and mail notifications  It’s your choice. If you have chosen to subscribe to receive any services related information, Ballerina updates, newsletters, or other informational material, you have the right to opt-out of receiving such email notifications at any point by clicking on the “unsubscribe” link at the bottom of any email sent by us, or by notifying us at if you would like us to delete all contact information and personal data we have from you.  Limitation of liability and disclaimer of warranties  YOUR USE OF THE SITES AND SERVICE IS AT YOUR SOLE RISK. THE SERVICE IS PROVIDED ON AN “AS IS” AND “AS AVAILABLE” BASIS. WSO2 AND ITS SUBSIDIARIES, AFFILIATES, OFFICERS, EMPLOYEES, AGENTS, PARTNERS, AND LICENSORS EXPRESSLY DISCLAIM ALL WARRANTIES OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  YOU EXPRESSLY UNDERSTAND AND AGREE THAT WSO2 AND ITS SUBSIDIARIES, AFFILIATES, OFFICERS, EMPLOYEES, AGENTS, PARTNERS, AND LICENSORS SHALL NOT BE LIABLE TO YOU FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DAMAGES FOR LOSS OF PROFITS, GOODWILL, USE, DATA OR OTHER INTANGIBLE LOSSES (EVEN IF WSO2 HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES), RESULTING FROM:    THE USE OR THE INABILITY TO USE THE SERVICE;  THE COST OF PROCUREMENT OF SUBSTITUTE GOODS AND SERVICES RESULTING FROM ANY GOODS, DATA, INFORMATION OR SERVICES PURCHASED OR OBTAINED OR MESSAGES RECEIVED OR TRANSACTIONS ENTERED INTO THROUGH OR FROM THE SERVICE;  UNAUTHORIZED ACCESS TO OR ALTERATION OF YOUR TRANSMISSIONS OR DATA;  STATEMENTS OR CONDUCT OF ANY THIRD PARTY ON THE SERVICE; OR  ANY OTHER MATTER RELATING TO THE SERVICE.   Indemnification  YOU AGREE TO HOLD HARMLESS AND INDEMNIFY WSO2 AND ITS SUBSIDIARIES, AFFILIATES, OFFICERS, AGENTS, EMPLOYEES, ADVERTISERS, LICENSORS, SUPPLIERS, OR PARTNERS FROM AND AGAINST ANY THIRD PARTY CLAIM ARISING FROM OR IN ANY WAY RELATED TO (A) YOUR BREACH OF THE TERMS, (B) YOUR VIOLATION OF APPLICABLE LAWS, RULES OR REGULATIONS IN CONNECTION WITH THE SERVICE, OR (C) YOUR USER CONTENT, INCLUDING ANY LIABILITY OR EXPENSE ARISING FROM ALL CLAIMS, LOSSES, DAMAGES (ACTUAL AND CONSEQUENTIAL), SUITS, JUDGMENTS, LITIGATION COSTS, AND ATTORNEYS’ FEES, OF EVERY KIND AND NATURE. IN SUCH CASE, WSO2 WILL PROVIDE YOU WITH WRITTEN NOTICE OF SUCH CLAIM, SUIT OR ACTION; WILL PROVIDE YOU THE OPPORTUNITY TO CONTROL THE DEFENSE AND/OR SETTLEMENT OF SUCH CLAIM, SUIT OR ACTION; AND WILL PROVIDE YOU REASONABLE ASSISTANCE IN SUCH DEFENSE OR SETTLEMENT, UPON REASONABLE REQUEST.  General  These Terms will be governed by and construed in accordance with the laws of the State of California, without giving effect to its conflict of laws provisions. Any claims, legal proceeding or litigation arising in connection with the service will be brought solely in Santa Clara County, California, and you consent to the jurisdiction of such courts. The failure of WSO2 to exercise or enforce any right or provision of these Terms not constitute a waiver of such right or provision. If any provision of the Terms is found by a court of competent jurisdiction to be invalid, the parties nevertheless agree that the court should endeavor to give effect to the parties’ intentions as reflected in the provision, and the other provisions of these Terms remain in full force and effect. These Terms constitute the entire agreement between you and WSO2 and govern your use of the Sites and Services superseding any prior agreements between you and WSO2 with respect to the Sites and Services."}];