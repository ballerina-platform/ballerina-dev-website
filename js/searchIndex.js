let contentIndex = [{"page":"/learn/cli-commands","content":" layout: ballerina-inner-page title: CLI Commands permalink: /learn/cli-commands/ CLI Commands Ballerina init Creates a scaffolding project if run from an empty directory. If run from an existing source directory, converts it to a project directory by creating .ballerina directory. Flags used --interactive or -i : Interactive mode Ballerina push Pushes a package to Ballerina Central or the home repository. If no flags are provided it will push the package to central. The org-name and version of the package will be extracted from Ballerina.toml, which resides in the package path. Flags used --repository <repoName> : Pushes the package to a given repository Example ballerina push twitter : Pushes the package to central ballerina push twitter --repository home : Pushes the package to the home repository Ballerina pull / : Downloads a given package to home repository. Providing the version is optional. If a version is not specified, the latest version of the package available in central will be downloaded. Example ballerina pull wso2/twitter Ballerina search Searches for information about packages located in Ballerina Central and shows the search results. Example ballerina search wso2 : Lists all packages which contains the keyword \"wso2\" Ballerina list Identifies and lists packages and local transitive dependencies of a project. Example ballerina list twitter : Lists dependencies of the Twitter package. Ballerina run [flags] <balfile \" packagename \" balxfile> [args...] Compiles and executes a Ballerina program or package. By default, 'ballerina run' executes the main function. If the main function is not there, it executes services. If the -s flag is given, ballerina run executes services instead of the main function. Flags used --service or -s : run services instead of main --sourceroot : path to the directory containing source files and packages --offline : packages will not be pulled from central while building --config or -c : path to the Ballerina configuration file --observe : enable observability with default configs Ballerina build Builds all packages as part of a single project, without including transitive dependencies. ballerina build <balfile \" package-name> [-o output] builds a single package into a project Flags used --offline : packages will not be pulled from central while building -c : build a compiled package -o: write output to the given file Ballerina install Installs packages to the home repository. This command is the same as ballerina push <package-name> --repository home. "},{"page":"/learn/ballerina-streaming-reference","content":" layout: ballerina-inner-page title: Ballerina Streaming Reference Guide permalink: /learn/ballerina-streaming-reference/ Ballerina Streaming Reference Guide Ballerina streaming is designed to process event streams in a streaming manner, detect complex event occurrences, and produce notifications in real-time. Note: Ballerina Streaming capabilities are shipped as the experimental feature in the latest release. Please use --experimental flag when compiling Ballerina files which have streaming constructs. For example, following scenarios are supported by Ballerina stream processing: Data preprocessing Generating alerts based on thresholds Calculating aggregations over a short window or a long time period Joining multiple data streams Correlating data while finding missing and erroneous events The following topics explains the high level concepts about Ballerina streaming Stream Forever Statement Query Stream A stream is a logical series of events ordered in time. Its schema is defined/constrained via the record definition. A record definition contains a unique name and a set of uniquely identifiable attributes with specific types within the record. All the events of a specific stream have the same schema (i.e., have the same attributes in the same order). Purpose Defining a schema unifies common types of events together. This enables them to be processed via queries using their defined attributes, in a streaming manner. Syntax The syntax for defining a new stream is as follows. type <record name> record { <attribute type> <attribute name>; <attribute type> <attribute name>; <attribute type> <attribute name>; ... }; stream<record name> <stream name> = new; The following parameters are configured in a stream definition. Parameter Description stream name The name of the created stream. record name The name of the record that constrains the stream. attribute name The uniquely identifiable attribute name. The schema of a record is defined by its attributes. attribute type The type of each attribute defined in the record. Example type Employee record { string name; int age; string status; }; stream<Employee> employeeStream = new; The code given above creates a stream named employeeStream that is constrained by the Employee type having the following attributes. name of type string age of type int status of type string Forever Statement The forever statement block can include one or more streaming queries defining stream processing and complex event processing rules. Purpose The forever statement block let streaming queries to run continuously till the Ballerina program is exited. Here each streaming query within the forever block executes as an independent isolated processing unit to one another. Grammar One or more streaming queries can be defined in a single forever statement block as shown in the syntax given below. foreverStatement : FOREVER LEFT_BRACE streamingQueryStatement+ RIGHT_BRACE ; streamingQueryStatement : FROM (streamingInput (joinStreamingInput)? \" patternClause) selectClause? orderByClause? outputRateLimit? streamingAction ; Sample query This query filters out the sensor events, which have the temperature greater than 30 celsius, and for every 100 sensor events, it groups them based on their type, count number of sensor events for each type and publishes all the types have more than one event to the highTemperatureSensorStream stream. forever { from sensorTemperatureStream where sensorTemperatureStream.temperature > 30 window lengthBatch (100) select sensorTemperatureStream.type, count() as totalCount group by sensorTemperatureStream.type having totalCount > 1 => (HighTemperature [] values) { foreach var value in values { highTemperatureSensorStream.publish(value); } } } Query Each streaming query can consume one or more streams, process the events continuously in a streaming manner, and simultaneously generate output. Purpose A query enables you to perform complex event processing and stream processing operations by processing incoming events one by one in the order they arrive. Syntax Each query contains an input and an output section. Some also contain a projection section. The following is a simple query with all three sections. from <input stream> select <attribute name>, <attribute name>, ... => (<array type> <parameter name>) { ... ... } Example This query consumes events from the tempStream stream (that is already defined) and outputs the room temperature and the room number to the roomTempStream stream. type temperature record { int deviceID; int roomNo; float value; }; type roomTemperature record { int roomNo; float value; }; stream<temperature> tempStream = new; stream<roomTemperature> roomTempStream = new; public function initQuery() { forever { from tempStream select tempStream.roomNo, tempStream.value => (roomTemperature[] temperatures) { foreach var value in temperatures { roomTempStream.publish(value); } } } } For more information about streaming queries, see the following subsections: Query Projection Filter Window Aggregation Function Group By Having Order By Join Query Projection Streaming queries support the following for query projections. Action Description Selecting required objects for projection This involves selecting only some of the attributes from the input stream to be inserted into an output stream. e.g., The following query selects only the `roomNo` and `temp` attributes from the `tempStream` stream. from tempStream select tempStream.roomNo, tempStream.temp => ( ) { } Selecting all attributes for projection This involves selecting all the attributes in an input stream to be inserted into an output stream. This can be done by using an asterisk ( * ) or by omitting the `select` statement. e.g., The following query select all the attributes in the `tempStream` stream. from tempStream select * => ( ) { } Renaming attributes This selects attributes from the input streams and inserts them into the output stream with different names. e.g., This query renames `roomNo` to `roomNumber` and `temp` to `temperature`. from tempStream select tempStream.roomNo as roomNumber, tempStream.temp as temperature => ( ) { } Introducing the constant value This adds constant values by assigning it to an attribute using `as`. e.g., This query specifies 'C' to be used as the constant value for the `scale` attribute. from tempStream select tempStream.roomNo, tempStream.temp, 'C' as scale => ( ) { } Using mathematical and logical expressions This uses attributes with mathematical and logical expressions in the precedence order given below, and assigns them to the output attribute using `as`. Operator precedence Operator Distribution Example () Scope (cost + tax) * 0.05 == () Nil check deviceID == () ! Logical NOT ! (price > 10) * / % Multiplication, division, modulo temp * 9/5 + 32 + - Addition, substraction temp * 9/5 - 32 < <= > >= Comparators: less-than, greater-than-equal, greater-than, less-than-equal totalCost >= price * quantity == != Comparisons: equal, not equal totalCost != price * quantity && Logical AND temp < 40 && (humidity < 40 or humidity >= 60) \"\" Logical OR temp < 40 \"\" (humidity < 40 && humidity >= 60) e.g., This query converts Celsius to Fahrenheit, and identifies rooms of which the room number is between 10 and 15 as server rooms. from tempStream select tempStream.roomNo, tempStream.temp * 9/5 + 32 as temp, 'F' as scale, tempStream.roomNo > 10 && tempStream.roomNo < 15 as isServerRoom => (RoomFahrenheit [] events ) { } Filter Filters are included in queries to filter information from input streams based on a specified condition. Purpose A filter allows you to separate events that match a specific condition as the output or for further processing. Syntax Filter conditions should be defined with the where keyword next to the input stream name as shown below. from <input stream> where <filter condition> select <attribute name>, <attribute name>, ... => ( ) { } Example This query filters all the server rooms of which the room number is within the range of 100-210, and that have temperature greater than 40 degrees from the tempStream stream, and inserts the results into the highTempStream stream. from tempStream where (tempStream.roomNo >= 100 && tempStream.roomNo < 210) && tempStream.temp > 40 select tempStream.roomNo, tempStream.temp => (RoomTemperature [] values) { foreach var value in values { highTempStream.publish(value); } } Window Windows allow you to capture a subset of events based on a specific criterion from an input stream for calculation. Each input stream can only have a maximum of one window. Purpose To create subsets of events within a stream based on time duration, number of events, etc for processing. A window can operate in a sliding or tumbling (batch) manner. Syntax The window prefix should be inserted next to the relevant stream in order to use a window. from <input stream> window <window name>(<parameter>, <parameter>, ... ) select <attribute name>, <attribute name>, ... => ( ) { } Note : Filter condition can be applied both before and/or after the window Example If you want to identify the maximum temperature out of the last 10 events, you need to define a length window of 10 events. This window operates in a sliding mode where the following 3 subsets are calculated when a list of 12 events are received in a sequential order. Subset Event Range 1 1-10 2 2-11 3 3-12 The following query finds the maximum temperature out of last 10 events from the tempStream stream, and inserts the results into the maxTempStream stream. from tempStream window length(10) select max(tempStream.temp) as maxTemp => ( ) { } If you define the maximum temperature reading out of every 10 events, you need to define a lengthBatch window of 10 events. This window operates as a batch/tumbling mode where the following 3 subsets are calculated when a list of 30 events are received in a sequential order. Subset Event Range 1 1-10 2 11-20 3 21-30 The following query finds the maximum temperature out of every 10 events from the tempStream stream, and inserts the results into the maxTempStream stream. from tempStream window lengthBatch(10) select max(tempStream.temp) as maxTemp => ( ) { } Note : Similar operations can be done based on time via time windows and timeBatch windows and for others. Code segments such as window time(10000) considers events that arrive during the last 10 seconds in a sliding manner, and the window timeBatch(2000) considers events that arrive every 2 seconds in a tumbling manner. Following are some inbuilt windows shipped with Ballerina Streams. time timeBatch timeLength length lengthBatch sort externalTime externalTimeBatch uniqueLength delay timeAccum hopping timeOrder time window time(int windowTime) A sliding time window that holds events that arrived during the last windowTime period at a given time, and gets updated for each event arrival and expiry. timeBatch window timeBatch(int windowTime) A batch (tumbling) time window that holds events that arrive during windowTime periods, and gets updated for each windowTime. timeLength window timelength(int windowTime, int windowLength) A sliding time window that, at a given time holds the last windowLength events that arrived during last windowTime period, and gets updated for every event arrival and expiry. length window length(int windowLength) A sliding length window that holds the last windowLength events at a given time, and gets updated for each arrival and expiry. lengthBatch window lengthBatch(int windowLength) A batch (tumbling) length window that holds a number of events specified as the windowLength. The window is updated each time a batch of events that equals the number specified as the windowLength arrives. externalTime window externalTime(timeStamp, int windowTime) A sliding time window based on external time. It holds events that arrived during the last windowTime period from the external timestamp, and gets updated on every monotonically increasing timestamp. Here the timeStamp should be an attribute of the record which is used as the constraint type of relevant input stream. As the timeStamp parameter you should pass <streamName>.<attiributeName>. externalTimeBatch window externalTimeBatch(timeStamp, int windowTime, int? startTime, int? timeout, boolean? replaceTimestampWithBatchEndTime) A batch (tumbling) time window based on external time, that holds events arrived during windowTime periods, and gets updated for every windowTime. Here the timeStamp should be an attribute of the record which is used as the constraint type of relevant input stream. As the timeStamp parameter you should pass <streamName> .<attiributeName>. Parameters startTime and timeout are optional parameters. startTime can be used to specify a user defined time to start the first batch. timeout is time to wait for arrival of new event, before flushing and giving output for events belonging to a specific batch. Usually timeout is greater than windowTime. If replaceTimestampWithBatchEndTime is true replaces the event time with the current time batch's end time. uniqueLength window uniqueLength(uniqueAttribute, int windowLength) A sliding length window that returns unique events within the windowLength based on the given uniqueAttribute . Here the uniqueAttribute should be an attribute of the record which is used as the constraint type of relevant input stream. delay window delay(int delayTime) A delay window holds events for a specific time period( delayTime) that is regarded as a delay period before processing them. sort window sort(int windowLength, attributeName, string order) A sort sort window holds a batch of events that equal the number specified as the windowLength and sorts them in the given order of given attributeName. Here the attributeName should be an attribute of the record which is used as the constraint type of relevant input stream. You can have multiple attributeName fields followed by it's order. timeAccum window timeAccum(int timePeriod) A sliding window that accumulates events until no more events arrive within the timePeriod, and only then releases the accumulated events. hopping window hopping(int windowTime, int hoppingTime) A hopping window holds the events arrived within last windowTime and release them in every hoppingTime period. timeOrder window timeOrder(timestamp, int windowTime, boolean dropOlderEvents) A timeOrder window orders events that arrive out-of-order, using timestamp values provided by timestamp, and bycomparing that timestamp value to system time. windowTime is the window duration. dropOlderEvents flag determines whether to drop the events which has timestamp value less than the tail-time of current window. Tail-time is the time, an amount of windowTime before the system time. Here the timeStamp should be an attribute of the record which is used as the constraint type of relevant input stream. As the timeStamp parameter you should pass <streamName>.<attiributeName>. Aggregate function Aggregate functions perform aggregate calculations in the query. When a window is defined the aggregation is restricted within that window. If no window is provided aggregation is performed from the start. Syntax from <input stream> window <window name>(<parameter>, <parameter>, ... ) select <aggregate function>(<parameter>, <parameter>, ... ) as <attribute name>, <attribute2 name>, ... => ( ) { } Aggregate Parameters Aggregate parameters can be attributes, constant values, results of other functions or aggregates, results of mathematical or logical expressions, or time parameters. Aggregate parameters configured in a query depends on the aggregate function being called. Example The following query calculates the average value for the temp attribute of the tempStream stream. This calculation is done for the last 10 minutes in a sliding manner, and the result is output as avgTemp to the avgTempStream output stream. from tempStream window time(600000) select avg(tempStream.temp) as avgTemp, tempStream.roomNo, tempStream.deviceID => (AvgTemperature [] values) { foreach var value in values { avgTempStream.publish(value); } } Following are some inbuilt aggregation functions shipped with Ballerina, for more aggregation functions, see execution. avg : Calculates the average for a given argument for all the events. sum : Returns the sum of a given argument for all the events. max : Returns the maximum value of a given argument for all the events. min : Returns the minimum value of a given argument for all the events. count : Returns the count of all the events. distinctCount : Returns the count of distinct occurrences for a given argument. maxForever : This stores the maximum value for a given attribute throughout the lifetime of the query regardless of any windows in-front. minForever : This stores the minimum value for a given attribute throughout the lifetime of the query regardless of any windows in-front. stdDev : Returns the calculated standard deviation of a given argument for all the events. More samples with above aggregation functions. The following query calculates the distinct count of page visits of each user. from pageVisitStream window time(5000) select pageVisitStream.userID, pageVisitStream.pageID, distinctCount(pageVisitStream.pageID) as distinctPages group by pageVisitStream.userID => (UserPageVisit [] visits) { foreach var visit in visits { outputStream.publish(visit); } } The following query calculates the forever max temperature of the room. from tempStream select tempStream.room, tempStream.timestamp, maxForever(tempStream.temperature) as maxTemp => (RoomTemperature [] roomTemps) { foreach var roomTemp in roomTemps { maxTempStream.publish(roomTemp); } } The following query calculates standard deviation value of the stock price for the price change of each 1000 stock. from stockExchangeStream window lengthBatch(1000) select stdDev(stockExchangeStream.price) as deviation, stockExchangeStream.symbol => (SymbolDeviation[] deviations) { foreach var deviation in deviations { priceDeviationStream.publish(deviation); } } Group By The group by clause allows you to group the aggregate based on specified attributes. Syntax The syntax for the 'group by` aggregate function is as follows: from <input stream> window <window name>(...) select <aggregate function>( <parameter>, <parameter>, ...) as <attribute1 name>, <attribute2 name>, ... group by <attribute1 name>, <attribute2 name> ... => ( ) { } Example The following query calculates the average temperature per roomNo and deviceID combination, for events that arrive at the tempStream stream for a sliding time window of 10 minutes. from tempStream window time(600000) select avg(tempStream.temp) as avgTemp, tempStream.roomNo, tempStream.deviceID group by tempStream.roomNo, tempStream.deviceID => (AvgTemperature [] values) { foreach var value in values { avgTempStream.publish(value); } } Having The having clause allows you to filter events after processing the select statement. Purpose This allows you to filter the aggregation output. Syntax The syntax for the having clause is as follows: from <input stream> window <window name>( ... ) select <aggregate function>( <parameter>, <parameter>, ...) as <attribute1 name>, <attribute2 name>, ... group by <attribute1 name>, <attribute2 name> ... having <condition> => ( ) { } Example The following query calculates the average temperature per room for the last 10 minutes, and alerts if it exceeds 30 degrees. from tempStream window time(600000) select avg(tempStream.temp) as avgTemp, tempStream.roomNo group by tempStream.roomNo having avgTemp > 30 => (Alert [] values) { foreach var value in values { alertStream.publish(value); } } Order By The order by clause allows you to order the aggregated result in ascending and/or descending order based on specified attributes. By default ordering will be done in ascending manner. User can use descending keyword to order in descending manner. Syntax The syntax for the order by clause is as follows: from <input stream> window <window name>( ... ) select <aggregate function>( <parameter>, <parameter>, ...) as <attribute1 name>, <attribute2 name>, ... group by <attribute1 name>, <attribute2 name> ... having <condition> order by <attribute1 name> (ascending \" descending)?, <attribute2 name> (<ascending \" descending>)?, ... => ( ) { } Example The following query calculates the average temperature per per roomNo and deviceID combination for every 10 minutes, and generate output events by ordering them in the ascending order of the room's avgTemp and then by the descending order of roomNo. from tempStream window timeBatch(600000) select avg(tempStream.temp) as avgTemp, tempStream.roomNo, tempStream.deviceID group by tempStream.roomNo, tempStream.deviceID order by avgTemp, roomNo descending => (AvgTemperature [] values) { foreach var value in values { avgTempStream.publish(value); } } Join Joins allow you to get a combined result from two streams in real-time based on a specified condition. Purpose Streams are stateless. Therefore, in order to join two streams, they need to be connected to a window so that there is a pool of events that can be used for joining. Joins also accept conditions to join the appropriate events from each stream. During the joining process each incoming event of each stream is matched against all the events in the other stream's window based on the given condition, and the output events are generated for all the matching event pairs. Syntax The syntax for a join is as follows: from <input stream> window <window name>(<parameter>, ... ) {unidirectional} {as <reference>} join <input stream> window <window name>(<parameter>, ... ) {unidirectional} {as <reference>} on <join condition> select <attribute name>, <attribute name>, ... => ( ) { } Here, the <join condition> allows you to match the attributes from both the streams. Unidirectional join operation By default, events arriving at either stream can trigger the joining process. However, if you want to control the join execution, you can add the unidirectional keyword next to a stream in the join definition as depicted in the syntax in order to enable that stream to trigger the join operation. Here, events arriving at other stream only update the window of that stream, and this stream does not trigger the join operation. Note : The unidirectional keyword cannot be applied to both the input streams because the default behaviour already allows both streams to trigger the join operation. Example Assuming that the temperature of regulators are updated every minute. Following is a streaming query that controls the temperature regulators if they are not already on for all the rooms with a room temperature greater than 30 degrees. from tempStream where (tempStream.temp > 30.0) window time(60000) as T join regulatorStream where (regulatorStream.isOn == false) window length(1) as R on T.roomNo == R.roomNo select T.roomNo, R.deviceID, 'start' as action => (RegulatorAction [] values) { foreach var value in values { regulatorActionStream.publish(value); } } Supported join types Following are the supported operations of a join clause. Inner join (join) This is the default behaviour of a join operation. join is used as the keyword to join both the streams. The output is generated only if there is a matching event in both the streams. Left outer join The left outer join operation allows you to join two streams to be merged based on a condition. left outer join is used as the keyword to join both the streams. Here, it returns all the events of left stream even if there are no matching events in the right stream by having null values for the attributes of the right stream. Example The following query generates output events for all events from the stockStream stream regardless of whether a matching symbol exists in the twitterStream stream or not. from stockStream window time(60000) as S left outer join twitterStream window length(1) as T on S.symbol== T.symbol select S.symbol as symbol, T.tweet, S.price => ( ) { } Right outer join This is similar to a left outer join. right outer join is used as the keyword to join both the streams. It returns all the events of the right stream even if there are no matching events in the left stream. Full outer join The full outer join combines the results of left outer join and right outer join. full outer join is used as the keyword to join both the streams. Here, output events are generated for each incoming event even if there are no matching events in the other stream. Example The following query generates output events for all the incoming events of each stream regardless of whether there is a match for the symbol attribute in the other stream or not. from stockStream window time(60000) as S full outer join twitterStream window length(1) as T on S.symbol== T.symbol select S.symbol as symbol, T.tweet, S.price => ( ) { } Table Operations Ballerina provides extensive support to deal with tables. It provides various types of operations such as create, insert, delete, etc. with in-memory or external storage tables. Purpose In Streaming context, a table is a stored version of a stream or a table of events. Ballerina provides support to interactively query the state of the stored events in the table when processing events which are arrived through a stream. We could perform operations such as add, delete, update and join with tables. Example - Add In the following example, query events that arrive in stockStream are added into the table itemStockTable after projecting a few attributes from the event. import ballerina/io; import ballerina/runtime; //This is the record that holds item details in the stockTable. type Item record {\" string name; float price; int stockAmount; \"}; //This is the record that holds stock details. type Stock record {\" string name; float price; int stockAmount; string manufactureName; int manufactureId; \"}; // This is the input stream that uses `Stock` as the constraint type. stream<Stock> stockStream = new; // This is the table that holds the item stock data. table<Item> itemStockTable = table { { name, price, stockAmount }, [ {\"Book\", 100.0, 10}, {\"Pen\", 20.0, 4} ] }; public function main() { initQuery(); Stock d = {name : \"FOO\", price: 100.3, stockAmount: 2000, manufactureName: \"BAR\", manufactureId: 23}; stockStream.publish(d); runtime:sleep(2000); io:println(\"Records in table after inserting new record: \"); while(itemStockTable.hasNext()) { io:println(\" \", itemStockTable.getNext()); } } public function initQuery() { forever { from stockStream select stockStream.name, stockStream.price, stockStream.stockAmount => (Item[] items) { foreach var item in items { _ = checkpanic itemStockTable.add(item); } } } } Example - Join with Table In the following query, we perform a join operation between the event stream and table. Whenever an order event is published to orderStream, it is matched against the itemStockTable through the queryItemTable function. If there is a match, an alert event is published to orderAlertStream. import ballerina/io; import ballerina/runtime; //This is the record that holds item details in the stockTable. type Item record { string name; float price; int stockAmount; }; // This is the record that holds order events from the customer. type Order record { string itemName; int orderingAmount; }; //This is the record that holds alert events. type OutOfStockAlert record { string itemName; int stockAmount; }; // This is the input stream that uses `Order` as the constraint type. stream<Order> orderStream = new; // This is the table that holds the item stock data. table<Item> itemStockTable = table { { name, price, stockAmount }, [ {\"Book\", 100.0, 10}, {\"Pen\", 20.0, 4} ] }; // This is the output stream that contains the events/alerts that are generated based on streaming logic. stream<OutOfStockAlert> orderAlertStream = new; function initOutOfStockAlert() { forever { from orderStream window length(1) as itemOrder join queryItemTable(itemOrder.itemName, itemOrder.orderingAmount) as item select item.name as itemName, item.stockAmount => (OutOfStockAlert[] alerts) { foreach var alert in alerts { orderAlertStream.publish(alert); } } } } //`queryItemTable` function returns a table of items whose stock is not enough to satisfy the order. public function queryItemTable(string itemName, int orderingAmount) returns table<Item> { table<Item> result = table { { name, price, stockAmount }, [] }; foreach var item in itemStockTable { if (item.name == itemName && orderingAmount > item.stockAmount) { var ret = result.add(item); } } return result; } public function main() { initOutOfStockAlert(); Order o1 = {itemName: \"Book\", orderingAmount: 20}; Order o2 = {itemName: \"Pen\", orderingAmount: 3}; orderAlertStream.subscribe(function(OutOfStockAlert alert) { io:println(\"Aert: Stocks unavailable for: \", alert.itemName, \" Available stocks: \", alert.stockAmount); }); orderStream.publish(o1); orderStream.publish(o2); runtime:sleep(2000); } "},{"page":"/learn/getting-started","content":" layout: ballerina-inner-page title: Getting Started permalink: /learn/getting-started/ Getting Started Download the Ballerina distribution You can download the Ballerina distribution from download page for your operating system. If a binary distribution is not available for your combination of operating system and architecture, try installing from source . System requirements Ballerina binary distributions are available for the following supported operating systems and architectures. Ensure that your system meets the requirements before you proceed with the installation. Windows Vista SP2 x64 or later Ubuntu Linux 12.04 x64 - LTS and above OS X 10.8.3 x64 and above If your operating system or architecture is not on the list, you can install from source . Installing Ballerina via installers If you are upgrading to a new version of Ballerina from an older version, you can download and use the installer for the latest version. The installer will automatically uninstall the old version. If you are building from source, you must update the path with the new version of Ballerina. Installing on OS X Download the package file and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution to /Library/Ballerina. The package automatically sets your PATH environment variable for you. You may need to restart any open Terminal sessions for the change to take effect. Installing on Windows Download the MSI file and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution to C:\\Program Files\\Ballerina\\. The installer should put the C:\\Program Files\\Ballerina\\<ballerina-directory>\\bin directory in your PATH environment variable. You may have to restart any open command prompts for the change to take effect. Installing on Linux Download the latest version of Ballerina. If you downloaded the DEB file, use the following command to install Ballerina. Replace <ballerina-home>/<ballerina-binary>.deb with the actual file path. This installs Ballerina to the /usr/lib/ballerina directory. dpkg -i <ballerina-binary>.deb Uninstalling Ballerina To remove an existing Ballerina installation, go to the Ballerina installation location and delete the Ballerina directory. Note: The installation location is usually /Library/Ballerina in Mac OS X, /usr/lib/ballerina/ in Ubuntu and C:\\Program Files\\Ballerina\\ in Windows. Getting help To get help when you work with Ballerina, see the community page . What's next Once you have successfully installed Ballerina, try out the Quick Tour and take Ballerina for its first spin. "},{"page":"/learn/faq","content":" layout: ballerina-inner-page title: FAQs FAQs What is the purpose of the project? Ballerina is an approach to addressing the integration gap between integration products and general purpose programming languages. Integration with ESBs is still waterfall development. The server must be deployed, connectors configured, service logic programmed with XML, and data querying and transformation with XPath. This is not developer friendly. Programming languages with frameworks like Spring and Node.js offer agility, but do not make it simple to program distributed system constructs with concurrency models not suited for sequence parallelization. Ballerina is a compiled, transactional, statically and strongly typed programming language with textual and graphical syntaxes. Ballerina incorporates fundamental concepts of distributed system integration into the language and offers a type safe, concurrent environment to implement microservices with distributed transactions, reliable messaging, stream processing, and workflows. Ballerina's concurrency model is built on the sequence diagram metaphor and offers simple constructs for writing concurrent programs. Its type system is a modern type system designed with sufficient power to describe data that occurs in distributed applications. It also includes a distributed security architecture to make it easier to write applications that are secure by design. Ballerina is designed for modern development practices with a modularity architecture based on modules that are easily shared widely. Version management, dependency management, testing, documentation, building and sharing are part of the language design architecture and not left for later add-on tools. The Ballerina standard library is in two parts: the usual standard library level functionality (akin to libc) and a standard library of network protocols, interface standards, data formats, authentication/authorization standards that make writing secure, resilient distributed applications significantly easier than with other languages. Ballerina has been inspired by Java, Go, C, C++, Rust, Haskell, Kotlin, Dart, Typescript, Javascript, Swift and other languages. What is the status of the project? Ballerina became a public open source project on February 21s, 2017, hosted at http://ballerinalang.org and http://github.com/ballerinalang/ballerina . Through 2017 and the first part of 2018, the language was redesigned based upon feedback from the community. In Q2 2018, Ballerina was moved to http://ballerina.io and http://github.com/ballerina-platform/ . The current revision of Ballerina is pre-1.0. However, stability is happening quickly, and the .990.0 version is a candidate for 1.0 language-lock. We anticipate that the language changes leading up to the 1.0 release will be increasingly minor moving forward. The Ballerina project is currently working towards Ballerina 1.0, which includes a language specification, a virtual machine, standard libraries, build management, centralized module management at central.ballerina.io , unit test framework, and observability extension. Ballerina is currently community supported on Stack Overflow, and WSO2 now offers early access development support for Ballerina. There may be a Ballerina 2.0 specification in many years, though we will instead focus on iterative improvement around the language with long term 1.0 language backwards compatibility. Our focus will be on using Ballerina to develop programs, products, and tools rather than actively changing the language and libraries. The purpose of Ballerina 1.0 is to provide long-term stability. Backwards-incompatible changes will not be made to any Ballerina 1.0 point release. Of course, development will continue on Ballerina itself, but the focus will be on performance, reliability, portability and the addition of new functionality, such as streams and stateful orchestrations. What is the origin of the logo? The Ballerina logo and the shoes, which are \"en pointe\", were designed by Eric and Christine Strohl, of StrohlSF.com . Why are you creating a new language? Ballerina was born out of frustration with programming frameworks and integration products that embed programming logic within YAML, XML, or other configuration-based files. These approaches disrupted the developer flow, requiring special purpose tools and debuggers that took developers away from focusing on iterative development. One had to either choose robust, complex, and heavy server products for managing integrations, or use a general purpose language with a framework that varied by programming language and objectives. There has not existed a way to get agility with rapid code development that runs microintegration servers for message brokering, service hosting, and transaction coordination. Ballerina is an attempt to combine the agility of a type safe programming language with the syntax of integration sequence diagrams. Once compiled, the resulting binaries embed micro engines that perform inline integration semantics such as mediation, orchestration, transformations, asynchrony, event generation and transactions. Finally, working with Ballerina is intended to be cloud native - the language has constructs that define the architectural environment so the compiler understands the logical environment the application will be running within. This enables the compiler to generate numerous runtime environment artifacts that are typically generated by continuous integration solutions. What are Ballerina's ancestors? In the creation of Ballerina, we were inspired by so many technologies. Thank you to all that have come before us (and forgive us if we missed one): Java, Go, C, C++, Rust, Haskell, Kotlin, Dart, TypeScript, JavaScript, Flow, Swift, RelaxNG, NPM, Crates, Maven, Gradle, Kubernetes, Docker, Envoy, Markdown, GitHub, and WSO2. However, it is a new language. In every respect the language was designed by thinking about what integration programmers do and how to make integration programming agile, more effective, and more fun. What are the guiding principles in the design? Sequence Diagrammatic Ballerina's underlying language semantics were designed by modeling how independent parties communicate via structured interactions. Subsequently, every Ballerina program can be displayed as a sequence diagram of its flow with endpoints, including synchronous and asynchronous calls. Sequence diagrams are a reflection of how designers and architects think and document interconnected systems. Ballerina's syntax is structured to let any tool or system derive a sequence diagram, and subsequently the way a developer thinks when writing Ballerina code encourages strong interaction best practices. This theory is elaborated upon in Sanjiva Weerawarana's blog . Concurrency Workers Ballerina's execution model is composed of lightweight parallel execution units known as workers. Workers use a full non-blocking policy where no function locks an executing thread, such as an HTTP I/O call awaiting response. These semantics manifest sequence concurrency where workers are independent concurrent actors that do not share state but can interact using messages. Workers and fork/wait language semantics abstract the underlying non-blocking approach to enable a simpler concurrency programming model. Network Aware Type Safety Ballerina has a structural type system with primitive, object, union, and tuple types. Network systems return messages with different payload types and errors. Ballerina's type system embraces this variability with an approach based on union types. This typesafe model incorporates type inference at assignment provide numerous compile time integrity checks for network-bound payloads. DevOps Ready Over the past 15 years, best practices and expectations on the associated toolset that a language provides have evolved. Now, a language is not ready for adoption unless it includes unit test framework, build system, dependency management and versioning, and a way to share modules of reusable code. Ballerina includes all of these subsystems as part of its core distribution so that there is no risk of community drift, which is what happens when the ecosystem needs to build tools on top of a language instead of designing it within the language. Environment Aware Ballerina the language and its components are intended to be used within distributed, event-driven architectures. Subsequently, each service written within Ballerina is residing in an environment that may also include other services, legacy services, service meshes, orchestrators, API gateways, identity gateways, message brokers and databases. Ballerina's language and annotations extension are intentionally environment-aware, treating these other components as syntactical objects and also relationships as decorated annotations. By having the language and build system be environmentally aware of other components surrounding our service, we can generate essential artifact code ahead of CI/CD, perform data and integrity checks around network-bound payloads, and pre-package dependent but not yet deployed components as part of the Ballerina binary. How does Ballerina compare to Spring? Ballerina is a modern programming language that has a concise way of programming interaction scenarios. Its syntax represents the powerful elements of what Java, Spring, and Spring Cloud offer separately. Additionally, Spring requires developers to choose and configure a separate build system (maven or gradle), unit test framework, registry for sharing modules, and deployment artifact generation. The nature of agile programming has evolved where these lifecycle concepts for microservices are well understood and their best practices are baked into Ballerina in the form of Ballerina's build system, Ballerina Central, Testerina and Docker / Kubernetes artifact generation during build. Given Ballerina is a programming language what about frameworks like Spring? Why should our Java developers learn another language? Unlike Spring, Ballerina is both agile and integration simple. While general purpose programming languages make software development agile, developers must still take responsibility for the hard problems of integration by writing their own integration logic or frameworks like Spring. This approach is not integration simple. In this sense, Ballerina is the language, the framework, the runtimes, the gateway, the circuit breaker, the message broker, and transaction coordinator all rolled into a single design and implementation. Developers will always have their favorite language of choice. However, in a polyglot world where services are disaggregating, there is potential for a new language that makes it easier to be the glue between endpoints written in any language, including Java and Spring, with a shorter learning curve. We think Ballerina can play a role as part of the glue. How does Ballerina compare to a Service Mesh like Istio? Service meshes exist to make it easier to write resilient distributed systems. They apply transaction resilience at the network request level and Ballerina applies it within the logic level. Ballerina works both with and without a service mesh! In situations where a service mesh is not present, Ballerina provides network bridging and transaction management for invocations in between services written with Ballerina or integrated via the Ballerina Bridge. In situations where a service mesh already exists, Ballerina services can be configured to delegate routing and transaction capabilities to the underlying mesh. Will you accept my language change? People often suggest improvements to the language - the developer mailing list contains a rich history of such discussions, but very few of these changes have been accepted. Although Ballerina is an open source project, the language and libraries are protected by a compatibility standard that prevents changes that break existing programs. If your proposal violates the Ballerina 1.0 specification we cannot entertain the idea, regardless of its merit. A future major release of Ballerina may be incompatible with Ballerina 1.0, but we're not ready to start talking about that idea as we are still working towards long term stability of Ballerina 1.0! Even if your proposal is compatible with Ballerina 1.0 specification, it might not be in the spirit of Ballerina's design goals. The language designers are generous with their time in elaborating on the various design intentions to help provide deeper background on its history and direction. What is the roadmap for Ballerina? The roadmap is driven by separate teams working on aspects of the language and platform. The key themes that are driving development teams are 1.0 language lock, commercial supportability, runtime and platform enhancements, and developer / integration tooling that includes Central, ballerinax/* modules, Ballerina API gateway, Ballerina transaction coordinator, and workflow. The language Language lock, stability Community review of language specification Language test suite Merging / collapsing sequence diagrams the BVM runtime, performance, etc. LLVM prototype, Native compilation via LLVM Longevity, stability, performance optimizations Build system rationalization - common output Build system - environment-specific builds Internationalizing the grammar Standard library Enhance the seamless operation of cross platform behavior Expand the list of supported database management systems Extension / ecosystem improvements, such as Ballerina Central, registry, modules, customization Private version of Ballerina registry, powering Ballerina Central Ability to write compiler extensions packaged with Ballerina modules Ability to push compiled Ballerina programs into a registry (not just modules) Integration related things around API gateway, message broker, transaction coordinator Persistent and stateful services, ie \"workflow\" Streaming SQL API throttling support and API observability around API gateway Optimize transaction model to support distributed transactions with MB Transaction coordination - more coordination patterns will be introduced In relation to workflow we plan checkpoint/restart, forward recoverability and compensation Docker / Kubernetes compositions Tooling Observability integration into composer to facilitate tracing Heterogeneous data transformations Does WSO2 use Ballerina internally? Yes! There are several Ballerina programs deployed in production inside WSO2. A public example is the server behind central.ballerina.io. Its module management interfaces were built as Ballerina services and then deployed as containers on Google's Kubernetes engine. Other examples include the WSO2 Update Manager, which WSO2 customers use to access WSO2 software and WSO2's API Manager gateway component. Can I translate the Ballerina home page into another language? Absolutely. We encourage developers to make Ballerina language sites in their own languages. You can issue pull requests and we'll host the translated versions at ballerina.io. Will Testerina automatically generate service mocks? Yes, it generates mocks when OpenApi is present. Which Ballerina connectors are currently available? The best place to see the latest set of connectors is Ballerina Central at central.ballerina.io , or by using ballerina search on the command line. You can also write your own Ballerina connectors, maintain them locally, or push them into Ballerina Central. The Ballerina team and WSO2 are publishing a series of additional modules around Twitter, Gmail, Github, Salesforce.com, and others. You can browse the modules that WSO2 is publishing by viewing the http://github.com/wso2-ballerina organization. Each repository is an additional module we are shipping. Are there any restrictions for third parties in publishing modules to Ballerina Central? Ballerina Central is open for anyone to push modules that contain annotations, builder extensions, functions, and connectors. We have a terms of service similar to what NPM or DockerHub has on their site. You should review the TOS to understand which type of content is accessible. Module authors retain a number of rights related to their modules and can choose any license for their software. Is there a way to run a private registry for Ballerina modules? Ballerina Central is implemented as a hosted registry service. WSO2 is offering an option to host private registries that are optionally mirrored to Ballerina Central. How can I decouple and manage deployment environment details outside the implementation? You can override the values in annotations on the command line, enabling the build system to generate different artifacts for different environments. In a future version of Ballerina, we'll also extend the Ballerina.toml with environmental overrides so that you can generate artifacts for multiple environments simultaneously. What analytics and monitoring does Ballerina support? For details, see the How to Observe Ballerina Programs document. What are the secure coding guidelines? For details, see the How to Secure Ballerina Programs document on ballerina.io . How can we integrate legacy code (written on Java or other languages) with Ballerina? Ballerina Bridge is a project within the Ballerina organization that provides a containerized sidecar that is able to bridge legacy services to work with Ballerina transactions. The sidecar connects to the legacy service over localhost and bridges the transaction initiated by a Ballerina service with the internal transaction semantics of the legacy service managed by the sidecar. What build tools should be used for large projects with Ballerina? Ballerina ships with its own build system and module management. What are the recommendations on Continuous Integration / Continuous Delivery and Application Lifecycle Management for Ballerina? How do you track requirements to test results traceability with Ballerina? What DevOps tools are available for Ballerina? Development teams should continue to use their favorite or existing lifecycle solutions. Ballerina works with all of them. Though we will note that because Ballerina is able to generate deployment artifacts during compilation and run its own unit tests, there are many phases of iterative development which can be done directly by Ballerina instead of using the traditional CI/CD. What are the best practices for versioning Ballerina based applications? We require Ballerina modules to follow semver semantics. If you are creating a shared module that is pushed into a Ballerina registry, like Ballerina Central , every push requires a versioning increment. We do not allow updates to an existing version as this creates confusion and difficulties with downstream adopters. What are the guidelines for application governance with Ballerina? Ballerina creates services with APIs. These services can be governed using your organizations best practices. We would encourage you to consider WSO2 API Manager as a leading governance and lifecycle product for APIs. What are the best practices for testing Ballerina based projects? Ballerina ships with Testerina, a built-in mechanism for running unit tests against hosted services. For integration and system tests, Ballerina works with your existing lifecycle management solutions. How do you write testable and maintainable code with Ballerina? For details, see How to Structure Ballerina Code and How to Test Ballerina Code . Can we embed our legacy libraries with Ballerina? Legacy libraries cannot be linked to a Ballerina program. However, you can make your legacy libraries into microservices and then invoke them over the network The Ballerina Bridge enables legacy services to participate in transactions with other Ballerina services for this purpose. Will business designers be able to do graphical GUI development still? How can we keep the design to code alignment with Ballerina? Yes, it is entirely possible for business designers to use Ballerina IDE plugins to use graphical constructs to create Ballerina services. Ballerina's syntax is structured to represent the core constructs of integration. By designing the keywords and the language layout using integration semantics, it is possible for IDEs to provide a graphical representation of the code that is identical to a sequence or interaction diagram in UML. This diagram does not require intermediate formats or translation. The IDE plugins can be used to generate new code in your Ballerina files through drag and drop, provide a visualization to others that document how your code interacts with other endpoints, and to provide dev tracing flows of interactions during debugging. What forms of debugging does Ballerina support? Ballerina has command-line debugger support which integrates into your favorite IDE. You can also perform graphical debugging within Ballerina Composer. Ballerina services have transaction tracing information collected which can be sent to product that provides runtime observability. Do you have any benchmarks that compare Ballerina with other languages? We do not have any yet. What is the footprint? The memory footprint depends on the use case and the load. A simple Ballerina service which simultaneously serves 500 concurrent users will have a low memory footprint of 50 MB. A ballerina main() program with simple logic (such as a loop counter) consumes 15 MB. What is the update process for Ballerina? What is the update frequency? We will update Ballerina once / month with a community release. These releases will require a roll-forward support requirement. Ballerina will have levels of language backwards compatibility commitments so that adopters can depend upon stability. When WSO2 releases commercial support we will have a binary patch model that works against older versions of Ballerina. How do I report security vulnerabilities? See http://ballerina.io/security . Can I write my MVC app with Ballerina? Ballerina does not currently have an MVC framework. We'd love for the community to add one and publish on Ballerina Central. Ballerina's object and record model makes it easy to synchronize data and models. Is this more functional than object oriented? Ballerina is a modern language that attempts to bring together productive features of functional, imperative, and object-oriented programming. Is Ballerina an object-oriented language? Both objects ( types) and functions are first class constructs in Ballerina. Developers have the flexibility to choose the most appropriate option depending on the requirement. While Ballerina has objects it can technically be designated an OOP, however, development methodology is not predominantly OOP-based. The design principles are based on sequence diagramming concepts that include declarative elements that are not purely OOP. Why is there no type inheritance? Ballerina is based on type equivalence, rather than type inheritance. The type system in Ballerina is based on set theory and, therefore, type equivalence has more meaning for this domain than type inheritance. Why does Ballerina not support overloading of methods and operators? This is for simplicity purposes. In Ballerina, functions can be defined with required parameters, defaultable parameters, and optional rest parameters. Ballerina supports calling defaultable parameters in any order by passing explicit name=value on invocation, and this approach cannot be combined with parameter overloading. We felt that this model offered module designers and developers more flexibility than overloading. Ballerina also supports the use of function name as a function pointer. This makes it easy to understand code because there is a single function corresponding to a given function name and is more powerful than the use of function overloading. For more information on the function pointer syntax, see the Function Pointer example . What compiler technology is used to build the compiler? The Ballerina compiler is written in Java with a generated LL parser using ANTLR4. It generates binary files containing a Ballerina bytecode format that is platform neutral and different than Java's bytecode. Ballerina compiler is a multi-pass compiler with stages for lexical and syntax analysis, semantic analysis, code analysis, desugar (remove syntactic sugar), and code generation. How is the runtime support implemented? Ballerina has a virtual machine (BVM) that executes Ballerina byte code instructions. You can run both source files and compiled byte code files with BVM. The runtime consists of an interpreter, a primitive type system, support for objects, methods and functions, and a parallel programming model based on workers. The capabilities are extended with a standard library, set of endpoints plus transports, and built-in models for documentation, testing, observability, secure coding, event streams and transactions. Why is my trivial service such a large binary? The linker in the Ballerina toolchain creates statically-linked binaries by default. All Ballerina binaries therefore include the Ballerina runtime, along with the runtime type information to support type checks, panic-time stack traces, observability metrics. A simple Ballerina 'hello, world' program compiled and linked statically is around 600 kB. What is the concurrency/threading model? Ballerina's runtime implements a virtual machine that executes the Ballerina bytecode, which is called the BVM. The BVM's execution model is made up of lightweight parallel execution units known as \"workers\". A worker is a lightweight parallel execution unit. Every function or network action defines one or more workers to execute its logic, and each has its own lifecycle consisting of worker states such as READY, RUNNING, and WAITING_FOR_RESPONSE. A worker is not bound exclusively to a single operating system thread, but rather, it uses full non-blocking policy, where it will never block an executing thread if the worker is not actively using it. This is controlled by the scheduler in the BVM, which coordinates the worker executions with the physical threads. For example, I/O operations such as HTTP calls will release the physical threads and only after the I/O response is available will the worker resume. This behavior gives a more natural programming environment for the developer, so she does not have to explicitly consider non-blocking I/O handling semantics. Also, this style of physical thread allocation is efficient and lowers the number of context switches optimizing CPU allocations. Would you provide NLP, ML toolkits around Ballerina? We do not have any plans. The community can add their own modules through Ballerina Central, and we will work hard to delegate frameworks and projects to the community. Which enterprise patterns and microservices patterns does Ballerina support? Ballerina is a language that can be used to implement any pattern. We provide examples of patterns with Ballerina By Guide related to doing lifecycle integration development. Many enterprise patterns are demonstrated with Ballerina by Example . What is your support for Docker and Kubernetes? What is the plan for supporting other infrastructure environments like CloudFoundry and Mesosphere? We provide annotations that activate builder extensions which can generate Dockerfiles, Docker images, and Kubernetes manifests. This makes it simple to target a service for deployment in a cloud-native environment. These annotations and extensions are provided within modules. Modules are shareable units and we will work with the ecosystem to create and push modules to support other environments with custom annotations. "},{"page":"/learn/events","content":" layout: ballerina-inner-page title: Events permalink: /events/ redirect_from: /learn/events /learn/events/ Events November 5-7 Austin, TX DeveloperWeek Austin 2019 Pro Session: Microservices in Practice with Ballerina, Kubernetes and Istio Lakmal Warusawithana, Senior Director - Cloud Architecture, WSO2 More Info November 19-21 San Diego, CA KubeCon + CloudNativeCon North America 2019 Platinum Sponsor More Info Meetups December 12 Mountain View, California Cloud-Native and Kubernetes Meetup in Silicon Valley An Introduction to the Ballerina Programming Language Anjana Fernando, Director of Developer Relations - CTO Office, WSO2 Register Now "},{"page":"/learn/how-to-document-ballerina-code","content":" layout: ballerina-inner-page title: How to Document Ballerina Code permalink: /learn/how-to-document-ballerina-code/ How to Document Ballerina Code Ballerina has a built-in Ballerina Flavored Markdown (BFM) documentation framework named Docerina. The documentation framework allows you to write unstructured documents with a bit of structure to enable generating HTML content as API documentation. Developers can write the documentation inline with the Ballerina source code using the lightweight markdown markup language. They can document special constructs such as parameters, return values, fields, etc. within the code using documentation attributes. Once the code is documented, developers can generate a basic HTML version of their Ballerina modules using the ballerina doc command. Developers are encouraged to have their custom themes and styles, to have a standard presentation of their Ballerina documentation. Ballerina documentation design and usage is aligned with project and module semantics of Ballerina. You can generate documentation for modules using the ballerina doc command. Overview Ballerina programmers can place the documentation inline with the source code using the documentation syntax. Ballerina type definitions, global variables, annotations, listeners, etc. can be documented using the documentation syntax. Fields, parameters, return values, etc. can be marked using documentation attributes. HTML documents can be generated using the ballerina doc command for each Ballerina module and if you have custom handlebars templates, you can use them to generate the HTMLs. Writing Ballerina Documentation Ballerina Flavored Markdown documentation is a first class syntax in the Ballerina language. The # at the beginning of a line denotes a line of documentation. If necessary, you can have multiple lines of documentation, which you can group together. # <documentation line 1> # <documentation line 2> # ... When you write documentation, you can use the markdown documentation syntax given above. For example: # Provides the HTTP actions for interacting with an HTTP server. Apart from the standard # HTTP methods, `forward()` and `execute()` functions are provided. # ... The supported structure of documentation syntax is as follows: # <description_line_1> # <description_line_2> # ... # + <parameter_name/field_name> - <description_line_1> # <description_line_2> # ... # + <parameter_name/field_name> - <description_line_1> # <description_line_2> # ... # + return - <return_parameter_description_line_1> # <return_parameter_description_line_2> Sample Usage # Submits an HTTP request to a service with the specified HTTP verb. # The `submit()` function does not give out a `Response` as the result, # rather it returns an `HttpFuture`, which can be used to do further # interactions with the endpoint. # # Example: # ```ballerina # HttpFuture future = myMsg.submit(\"GET\", \"/test\", req); # ``` # # + httpVerb - The HTTP verb value # + path - The resource path # + request - An HTTP outbound request message # + return - An `HttpFuture` that represents an asynchronous service invocation, # or an `error` if the submission fails public function submit(@sensitive string httpVerb, string path, Request request) returns HttpFuture\"error; Documenting A Module A Ballerina module can have a Module.md file which describes the module and its usage. A typical project structure of a Ballerina project is like this: / Ballerina.toml # Configuration that defines project intent src module1/ # The source in this directory will be named \"<org-name>/module1\" Module.md # Optional, contains descriptive metadata for display at # Ballerina Central *.bal [tests/] # Module-specific unit and integration tests [resources/] # Module-specific resources modules.can.include.dots.in.dir.name/ Module.md *.bal [tests/] [resources/] [resources/] # Resources included with every module in the project target/ # Compiled executables and other artifacts end up here ballerina doc command will read the Module.md and prepend it to the generated HTML file. Check HTTP module documentation for sample HTML that has Module.md content at the top, followed by the other module constructs. Generating Ballerina Documentation Ballerina provides a doc command which can be executed against a given Ballerina project. This command will result in generating the Ballerina documentation as HTML files, for all the modules in the project. First, let's create a new Ballerina project: $ ballerina new myproject $ cd myproject/ Next: Use `ballerina add` to add a Ballerina module. $ ballerina add math -t service Added new ballerina module at 'src/math' $ ballerina add time -t service Added new ballerina module at 'src/time' Now, let's generate documentation of the project: $ ballerina doc -a Output: Compiling source foo/time:0.1.0 foo/math:0.1.0 Generating API Documentation target/apidocs target/apidocs/ folder would contain following; $ ls target/apidocs/ index.html math time ... index.html - contains an index page of all the modules in the Ballerina project math - contains the documentation of the module named math time - contains the documentation of the module named time If you want to generate documentation for a selected Ballerina module, then you can execute the following command from the Ballerina project root directory: $ ballerina doc <module_name> For other options, run ballerina doc --help. "},{"page":"/learn/how-to-deploy-and-run-ballerina-programs","content":" layout: ballerina-inner-page title: How to Run and Deploy Ballerina Programs permalink: /learn/how-to-deploy-and-run-ballerina-programs/ How to Run and Deploy Ballerina Programs Running Ballerina Programs and Services A Ballerina application can have: A main() function that runs as a terminating process. A service , which is a hosted non-terminating process. Both of these are considered as entry points for program execution. These applications can be structured into a single program file or a Ballerina module. A collection of modules can be managed together with versioning and dependency management as part of a Ballerina project. Source files and modules can contain zero or more entrypoints, and the runtime engine has precedence and sequence rules for choosing which entrypoint to execute. Running Standalone Source Code A single Ballerina source code file can be placed into any folder. If the source file contains at least one entry point, it can be executed using the run command. $ ballerina run foo.bal You can compile a source file with an entry point into an executable jar. $ ballerina build [-o outputfilename.jar] foo.bal And you can run .jar files directly: $ ballerina run filename.jar Running a Project A project is a folder that manages modules as part of a common versioning, dependency management, build, and execution. You can build and run items collectively or individually as modules. See How To Structure Ballerina Code for in-depth structuring of projects. Build all modules of a project: $ ballerina build Build a single module in a project: $ ballerina build <module-name> Options for running programs with entrypoints in a project: $ ballerina run main.bal $ ballerina run main.jar Configuring Your Ballerina Runtimes Ballerina Runtime Configuration Files A Ballerina runtime can be configured using configuration parameters, which are arbitrary key/value pairs with structure. The ballerina/config module provides an API for sourcing configuration parameters and using them within your source code. See Config API Documentation for details. The configuration APIs accept a key and an optional default value. If a mapping does not exist for the specified key, the default value is returned as the configuration value. The default values of these optional configurations are the default values of the return types of the functions. Sourcing Parameters Into Ballerina Programs Configuration parameters for your programs and apps can be defined on the CLI, as an environment variable, or from a configuration file, with loading and override precedence in the same order. Sourcing CLI Parameters Consider the following example, which reads a Ballerina config value and prints it. import ballerina/io; import ballerina/config; public function main() { string name = config:getAsString(\"hello.user.name\"); io:println(\"Hello, \" + name + \" !\"); } The config key is hello.user.name. To pass a value to this config from the CLI, we can use --key=value format as the following command. $ ballerina run main.bal --hello.user.name=Ballerina Hello, Ballerina ! Sourcing Configuration Values The value can be passed as a config file as well. A configuration file should conform to the TOML format. Ballerina only supports the following features of TOML: value types (string, int, float, and boolean), tables, and nested tables. Given below is a sample ballerina.conf: [hello.user] name=\"Ballerina\" When running a program with config API lookups, Ballerina looks for a ballerina.conf file in the directory where the source files are located. If ballerina.conf resides in the same directory as main.bal, balllerina run can be used without any argument. $ ballerina run main.bal Hello, Ballerina ! To explicitly specify a configuration file, use the --b7a.config.file property. The path to the configuration file can be either an absolute or a relative path. $ ballerina run main.bal --b7a.config.file=path/to/conf/file/custom-config-file-name.conf Hello, Ballerina ! Configure Secrets as Configuration Items Ballerina provides support for encrypting sensitive data such as passwords and allows access to them securely through the configuration API in the code. Creating a Secured Value The ballerina encrypt command will encrypt parameters that can be securely sourced from your code files. For example, let's create a secure parameter named Ballerina with the value 12345 as the secret. $ ballerina encrypt Enter value: Enter secret: Re-enter secret to verify: Add the following to the runtime config: <key>=\"@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=}\" Or add to the runtime command line: --<key>=@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=} Using the Secured Value at Runtime The secured value can be placed in a config file as a value or passed on the command line. [hello.user] name=\"@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=}\" or (Enter secret 12345 when prompted.): $ ballerina run main.bal --hello.user.name=@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=} ballerina: enter secret for config value decryption: Hello, Ballerina ! Decrypting the Value If a configuration contains an encrypted value, Ballerina looks for a secret.txt file in the directory where the source files are located. The secret.txt should contain the secret used to encrypt the value. The secret.txt file will be deleted after it is read. $ echo 12345 > secret.txt $ ballerina run main.bal --b7a.config.file=ballerina.conf Hello, Ballerina ! If the secret.txt file is not present, then CLI prompts the user for the secret. Enter secret 12345 when prompted. $ ballerina run main.bal --b7a.config.file=ballerina.conf ballerina: enter secret for config value decryption: Hello, Ballerina ! Deploying Ballerina Programs and Services Deploying a Ballerina program or service is the process of creating assets that ready the program and services(s) for activation in another runtime, such as Docker Engine, Moby, Kubernetes, or Cloud Foundry. The Ballerina compiler is able to generate the necessary artifacts for different deployment annotations based upon annotations that decorate the source code, which provide compiler instructions for artifact generation. How Deployment Works Ballerina has builder extensions that run after the compilation phase. These extensions analyze code to generate deployment artifacts and utilities to make deployment of your apps and services easier. When you start building a project, the system starts parsing. This is followed by dependency analysis, compilation, and a phase at which deployment artifact generation can take place. These deployment artifacts can be a form of simple files or complex types, like container images, virtual images, etc. The Ballerina builder extension supports the following list of deployment artifacts. Dockerfiles Docker images Kubernetes artifacts It is possible for third parties and the ecosystem to create their own annotations and builder extensions that generate different kinds of deployment artifacts. You can publish these extensions within Ballerina Central for others to use. How to Enable Deployment A developer enables deployment artifact generation by adding annotations to their Ballerina code: Import the relevant extension module in the code. Add relevant annotations within the code. Build the Ballerina project. Docker-Based Deployment See the following example on how a developer can add Docker support in the code. Add the following code to the hello_world_docker.bal file. import ballerina/http; import ballerina/docker; @http:ServiceConfig { basePath:\"/helloWorld\" } @docker:Config { registry:\"docker.abc.com\", name:\"helloworld\", tag:\"v1.0\" } service helloWorld on new http:Listener(9090) { resource function sayHello (http:Caller caller, http:Request request) { http:Response response = new; response.setTextPayload(\"Hello, World! \\n\"); var result = caller -> respond(response); if (result is error) { log:printError(\"Error sending response\", result); } } } Now your code is ready to generate deployment artifacts. In this case it is a Docker image. $ ballerina build hello_world_docker.bal Compiling source hello_world_docker.bal Generating executables hello_world_docker.jar Generating docker artifacts... @docker - complete 2/2 Run the following command to start a Docker container: docker run -d -p 9090:9090 docker.abc.com/helloworld:v1.0 $ tree . docker Dockerfile hello_world_docker.bal hello_world_docker.jar 1 directory, 3 files $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.abc.com/helloworld v1.0 154053b4e4cd About a minute ago 108MB You can run a Docker container by copying and pasting the Docker run command that displays as output of the Ballerina build command. $ docker run -d -p 9090:9090 docker.abc.com/helloworld:v1.0 938761fa222fde551c5092b7f5fda2a72c3cd43178c7fd86f43f678ec5227d35 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 938761fa222f docker.abc.com/helloworld:v1.0 \"/bin/sh -c 'java -j\" 18 seconds ago Up 17 seconds 0.0.0.0:9090->9090/tcp brave_hamilton Invoke the hello world service with a cURL command: $ curl http://localhost:9090/helloWorld/sayHello Hello, World! The following features are supported by the Docker builder extension. Dockerfile generation Docker image generation Docker push support with Docker registry Docker-based Ballerina debug support Copy file support Supported Docker Annotations @docker:Config{} Supported with Ballerina services or endpoints. Annotation Name Description Default value name Name of the Docker image output .jar file name registry Docker registry None tag Docker image tag latest buildImage Whether to build Docker image true dockerHost Docker host IP and Docker PORT (e.g., minikube IP and Docker PORT) unix:///var/run/docker.sock dockerCertPath Docker cert path null baseImage Base image to create the Docker image ballerina/ballerina:latest enableDebug Enable debug for Ballerina false debugPort Remote debug port 5005 push Push to remote registry false username Username for Docker registry None password Password for Docker registry None @docker:CopyFiles{} Supported with Ballerina services or endpoints. Annotation Name Description Default value sourceFile Source path of the file (on your machine) None target Target path (inside container) None isBallerinaConf Whether the file is a Ballerina config file false @docker:Expose{} Supported with Ballerina endpoints. For more information, see the Docker build extension GitHub repo . Kubernetes-Based Deployment The Kubernetes builder extension offers native support for running Ballerina programs on Kubernetes with the use of annotations that you can include as part of your service code. Also, it will take care of the creation of the Docker images, so you don't need to explicitly create Docker images prior to deployment on Kubernetes. The following Kubernetes configurations are supported: Kubernetes deployment support Kubernetes service support Kubernetes liveness probe support Kubernetes ingress support Kubernetes horizontal pod autoscaler support Docker image generation Docker push support with remote Docker registry Kubernetes secret support Kubernetes config map support Kubernetes persistent volume claim support The following Ballerina code section explains how you can use some of these Kubernetes capabilities by using Kubernetes annotation support in Ballerina. import ballerina/config; import ballerina/http; import ballerina/jdbc; import ballerina/kubernetes; // Create SQL endpoint to MySQL database jdbc:Client employeeDB = new ({ url:config:getAsString(\"db-url\"), username:config:getAsString(\"db-username\"), password:config:getAsString(\"db-password\") }); @kubernetes:Ingress { hostname:\"ballerina.guides.io\", name:\"ballerina-guides-employee-database-service\", path:\"/\" } @kubernetes:Service { serviceType:\"NodePort\", name:\"ballerina-guides-employee-database-service\" } listener http:Listener ep = new (9090, config = { secureSocket:{ keyStore:{ path:\"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password:config:getAsString(\"key-store-password\") }, trustStore:{ path:\"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password:config:getAsString(\"trust-store-password\") } } }); @kubernetes:ConfigMap { ballerinaConf:\"conf/data-service.conf\" } @kubernetes:Deployment { image:\"ballerina.guides.io/employee_database_service:v1.0\", name:\"ballerina-guides-employee-database-service\", copyFiles:[{target:\"/ballerina/runtime/bre/lib\", sourceFile:\"conf/mysql-connector-java-8.0.11.jar\"}] } @http:ServiceConfig { basePath:\"/records\" } service employee_data_service on ep { Sample content of data-service.conf: # Ballerina database config file db-url = \"jdbc:mysql://mysql-server:3306/EMPLOYEE_RECORDS\" db-username = \"root\" db-password = \"root\" key-store-password = \"abc123\" trust-store-password = \"xyz123\" Here we have used @kubernetes:Deployment to specify the Docker image name that will be created as part of building this service. The CopyFiles field is used to copy the MySQL JAR file into the Ballerina bre/lib folder. The @kubernetes:Service {} annotation will create a Kubernetes service that will expose the Ballerina service running on a Pod. In addition, you can use @kubernetes:Ingress, which is the external interface to access your service (with path / and host name ballerina.guides.io). Minikube users please see the Kubernetes Extension samples for additional configurations required for Minikube. Now you can use the following command to build the Ballerina service that we developed above. This will also create the corresponding Docker image and the Kubernetes artifacts using the Kubernetes annotations that you have configured above. $ ballerina build data_backed_service.bal Compiling source data_backed_service.bal Generating executables data_backed_service.jar Generating artifacts... @kubernetes:Service - complete 1/1 @kubernetes:Ingress - complete 1/1 @kubernetes:Secret - complete 1/1 @kubernetes:ConfigMap - complete 1/1 @kubernetes:Docker - complete 3/3 @kubernetes:Deployment - complete 1/1 Run the following command to deploy the Kubernetes artifacts: kubectl apply -f ./kubernetes/ You can use the docker images command to verify that the Docker image that we specified in @kubernetes:Deployment was created. The Kubernetes artifacts related to your service will be generated in addition to the .balx file. $ tree conf ballerina.conf mysql-connector-java-8.0.11.jar data_backed_service.bal data_backed_service.jar kubernetes data_backed_service_config_map.yaml data_backed_service_deployment.yaml data_backed_service_ingress.yaml data_backed_service_secret.yaml data_backed_service_svc.yaml docker Dockerfile mysql-connector-java-8.0.11.jar Now you can create the Kubernetes deployment using: $ kubectl apply -f ./kubernetes configmap \"employee-data-service-ballerina-conf-config-map\" created deployment \"ballerina-guides-employee-database-service\" created ingress \"ballerina-guides-employee-database-service\" created secret \"listener-secure-socket\" created service \"ballerina-guides-employee-database-service\" created You can verify Kubernetes deployment, service, and ingress are running properly by using the following Kubernetes commands. $ kubectl get pods NAME READY STATUS RESTARTS AGE ballerina-guides-employee-database-service-57479b7c67-l5v9k 1/1 Running 0 26s This is the container based on the deployment annotation. This container has the .jar file, secrets, config-maps, and dependencies wrapped within. $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ballerina-guides-employee-database-service NodePort 10.96.24.77 <none> 9090:30281/TCP 51s This is the Kubernetes service that exposes the listener endpoint. $ kubectl get ingress NAME HOSTS ADDRESS PORTS AGE ballerina-guides-employee-database-service ballerina.guides.io 80, 443 1m This is the Kubernetes nginx rule that exposes the hostname to the outside world. $ kubectl get secrets NAME TYPE DATA AGE listener-secure-socket Opaque 2 1m The secrets are generated automatically for endpoint keystores and truststores. This secret is mounted to ${ballerina_home} of the container. $ kubectl get configmap NAME DATA AGE employee-data-service-ballerina-conf-config-map 1 2m This is the config-map created for the ballerina.conf file, as the ballerinaConf:\"./conf/data-service.conf\" attribute is used. At run time, it is equivalent to: $ ballerina run <source>.jar --b7a.config.file=./conf/data-service.conf The Kubernetes extension automatically passes the config file to the Ballerina program. If everything is successfully deployed, you can invoke the service either via Node port or ingress. Access via Node Port: $ curl -v -X POST -d '{\"name\":\"Alice\", \"age\":20,\"ssn\":123456789,\"employeeId\":1}' \\ \"http://localhost:<Node_Port>/records/employee\" -H \"Content-Type:application/json\" Access via Ingress: Add an /etc/hosts entry to match hostname. 127.0.0.1 ballerina.guides.io Access the service: $ curl -v -X POST -d '{\"name\":\"Alice\", \"age\":20,\"ssn\":123456789,\"employeeId\":1}' \\ \"http://ballerina.guides.io/records/employee\" -H \"Content-Type:application/json\" Supported Kubernetes Annotations @kubernetes:Deployment{} Supported with Ballerina services or endpoints. Annotation Name Description Default value name Name of the deployment <outputfilename>-deployment labels Labels for deployment \"app: <outputfilename>\" replicas Number of replicas 1 enableLiveness Enable or disable liveness probe disable initialDelaySeconds Initial delay in seconds before performing the first probe 10s periodSeconds Liveness probe interval 5s livenessPort Port that the liveness probe checks <ServicePort> imagePullPolicy Docker image pull policy IfNotPresent image Docker image with tag :latest env List of environment variables null buildImage Building Docker image true copyFiles Copy external files for Docker image null dockerHost Docker host IP and Docker PORT (e.g., \"tcp://192.168.99.100:2376\") null dockerCertPath Docker cert path null push Push Docker image to registry. This can only be true if image build is true. false username Username for the Docker registry null password Password for the Docker registry null baseImage Base image to create the Docker image ballerina/ballerina:latest singleYAML Generate a single yaml file for all k8s resources false @kubernetes:Service{} Supported with Ballerina endpoints. Annotation Name Description Default value name Name of the service <ballerina service name>-service labels Labels for the service \"app: <outputfilename>\" serviceType Service type of the service ClusterIP port Service port Port of the Ballerina service @kubernetes:Ingress{} Supported with Ballerina endpoints. Annotation Name Description Default value name Name of Ingress <ballerina service name>-ingress labels Labels for service \"app: <outputfilename>\" hostname Host name of Ingress <ballerina service name>.com path Resource path. / targetPath This is used for URL rewrite. null ingressClass Ingress class nginx enableTLS Enable ingress TLS false @kubernetes:HPA{} Supported with Ballerina services. Annotation Name Description Default value name Name of the Horizontal Pod Autoscaler <ballerina service name>-hpa labels Labels for service \"app: <outputfilename>\" minReplicas Minimum number of replicas No of replicas in deployment maxReplicas Maximum number of replicas minReplicas+1 cpuPrecentage CPU percentage to start scaling 50 @kubernetes:Secret{} Supported with Ballerina services. Annotation Name Description Default value name Name of the secret volume mount <service_name>-secret mountPath Path to mount on container null readOnly Is mount read only true data Paths to data files null @kubernetes:ConfigMap{} Supported with Ballerina services. Annotation Name Description Default value name Name of the configmap volume mount <service_name>-config-map mountPath Path to mount on container null readOnly Is mount read only true ballerinaConf Ballerina conf file location null data Paths to data files null @kubernetes:PersistentVolumeClaim{} Supported with Ballerina services. Annotation Name Description Default value name Name of the volume mount null mountPath Path to mount on container null readOnly Is mount read only false accessMode Access mode ReadWriteOnce volumeClaimSize Size of the volume claim null @kubernetes:Job{} Supported with the Ballerina main() function. Annotation Name Description Default value name Name of the job <output file name>-job labels Labels for job \"app: <outputfilename>\" restartPolicy Restart policy Never backoffLimit Restart tries before termination 3 activeDeadlineSeconds Active deadline seconds 20 schedule Schedule for cron jobs none imagePullPolicy Docker image pull policy IfNotPresent image Docker image with tag <output file name>:latest env List of environment variables null buildImage Building Docker image true dockerHost Docker host IP and Docker PORT (e.g., \"tcp://192.168.99.100:2376\") null dockerCertPath Docker cert path null push Push Docker image to registry. This can only be true if image build is true. false username Username for the Docker registry null password Password for the Docker registry null baseImage Base image to create the Docker image ballerina/ballerina:latest Extend Ballerina Deployment and Annotations Ballerina can be augmented with your own annotations that represent your own unique deployment artifacts. You can also write builder extensions that generate these files during compilation. "},{"page":"/learn/how-to-extend-ballerina","content":" layout: ballerina-inner-page title: How to Extend Ballerina permalink: /learn/how-to-extend-ballerina/ How to Extend Ballerina Annotations can be used to provide structured metadata about a particular construct. Annotations are not executable. However, they can be used to alter the behavior of constructs they are attached to. Annotations can be attached to: services and resources type definitions function definitions function parameters function return module-level variables and constants annotations listeners workers type cast expressions The Ballerina compiler can be extended using compiler extensions (if required) for additional verification or processing (e.g. modifications, artifact generation etc.). Such custom extensions provided will be executed at the end of the compilation phase before generating the Ballerina Intermediate Representation (BIR). A compiler extension can make use of the metadata provided via annotations to introduce additional behavior to the compilation process. The ballerina/docker and ballerina/kubernetes modules make use of custom annotations. They introduce new annotations such as @docker:Config and @kubernetes:Deployment that can be attached to certain constructs in a Ballerina source file. The respective compiler extensions then run a post-compilation process that reads these annotations and generates the Docker and Kubernetes deployment artifacts. Note: Currently, there are two caveats when writing compiler extensions: The Ballerina Compiler is written in Java 8. Therefore, you will need JDK 1.8. End users will have to install the extension manually. Hello World: The Annotation Way In this guide, we will take a look at how to create a custom annotation and how to write a compiler extension to read and act upon our custom annotation. The custom annotation (i.e. @hello:Greeting) is attachable to functions. It has an attribute called salutation, which will be read by the compiler extension and written to a file when building the program. The annotation can be shared with others by publishing it to Ballerina Central . Currently, there isn't a mechanism for sharing compiler extensions. The compiler extension has to be copied to the <BALLERINA_HOME>/bre/lib directory. The end user would be able to write a program such as the following: import foo/hello; @hello:Greeting { salutation: \"Guten Tag!\" } function add(int x, int y) returns int { return x + y; } public function main() { var sum = add(10, 20); } At the end of the build, the user should be able to see a <module_name>.txt file in the target/greetings/ directory. Defining a Custom Annotation Creating the Annotation Create a new Ballerina project and add a module named hello. For this instance, add a single source file named annotation.bal and remove other boilerplate code and files. Your project structure should look similar to the following: . Ballerina.toml src hello annotation.bal Add the following code to define the @hello:Greeting annotation in the annotation.bal file. # This record defines the fields of the @hello:Greeting annotation. # # + salutation - The greeting message public type HelloConfiguration record {\" string salutation = \"Hello!\"; \"}; # Define an annotation named `Greeting`. Its type is `HelloConfiguration` and it can be # attached to services. public annotation HelloConfiguration Greeting on service; Now, build this annotation. The -c flag is used since this module will only be used as a library. $ ballerina build -c hello If all went well, a /target directory should be created with the built artifacts. target/ balo hello-2019r3-any-0.1.0.balo caches bir_cache foo hello 0.1.0 hello.bir jar_cache foo hello 0.1.0 foo-hello-0.1.0.jar tmp foo-hello-0.1.0.jar Verifying the Annotation At this stage, you can use the annotation in a program to verify the correctness of what was done so far. To do so, create a demo project, add our hello module as a dependency, and attach it to a function. Your program should compile without any errors. The demo project structure looks like the following: . Ballerina.toml src greet greeting.bal Add the foo/hello module as a path dependency in the Ballerina.toml file. [project] org-name= \"bar\" version= \"0.1.0\" [dependencies] \"foo/hello\" = {path = \"<path_to_annotation_project_dir>/hello-annot/target/balo/hello-2019r3-any-0.1.0.balo\"} Add a function to the greeting.bal file. Note that the function is annotated using the @hello:Greeting annotation. import foo/hello; @hello:Greeting { salutation: \"Guten Tag!\" } function add(int x, int y) returns int { return x + y; } public function main() { var sum = add(10, 20); } Building the greet module should produce an executable named greet.jar in the /target/bin directory. Writing the Compiler Extension The Ballerina compiler can be extended through compiler extensions if there are additional verifications or tasks you would like to perform. Such custom extensions will be executed towards the end of the compilation phase. A compiler extension can be created by implementing the CompilerPlugin interface provided by the org.ballerinalang.compiler.plugins package. It defines the following methods, which the user can implement to add additional verifications. void process(PackageNode packageNode) void process(BLangTestablePackage testablePackageNode) void process(ServiceNode serviceNode, List<AnnotationAttachmentNode> annotations) void process(TypeDefinition typeDefinition, List<AnnotationAttachmentNode> annotations) void process(FunctionNode functionNode, List<AnnotationAttachmentNode> annotations) void process(SimpleVariableNode variableNode, List<AnnotationAttachmentNode> annotations) void process(AnnotationNode annotationNode, List<AnnotationAttachmentNode> annotations) void codeGenerated(PackageID packageID, Path binaryPath) Each of the process() methods correspond to annotable constructs of the language. The codegenerated() method gets invoked once the code generation phase is completed. The org.ballerinalang.compiler.plugins package also provides a convenience class named AbstractCompilerPlugin with empty implementations for the above methods. The extension will read the salutation field of the @hello:Greeting annotation and write its value to a file in the /target directory. Setting up the Project Start by creating a Java project for the extension. It needs two classes: HelloPlugin and HelloModel. Also, create a resource file named org.ballerinalang.compiler.plugins.CompilerPlugin in the resources/META-INF/services directory. This file should contain the fully-qualified class name of the extension class (which in this case, is xyz.foo.hello.HelloPlugin). src/ main java xyz foo hello HelloModel.java HelloPlugin.java resources META-INF services org.ballerinalang.compiler.plugins.CompilerPlugin The only dependency you will need for this extension is the ballerina-lang project. Add the following Maven repository to your project to get the ballerina-lang dependency. http://maven.wso2.org/nexus/content/repositories/releases/ Given below is a sample build.gradle file for the project. plugins { id 'java' } group 'xyz.foo' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 repositories { maven { url \"http://maven.wso2.org/nexus/content/repositories/releases/\" } } dependencies { implementation group: 'org.ballerinalang', name: 'ballerina-lang', version: '1.0.0' } Adding the Code for the Extension Add the following code to the HelloPlugin.java file. import org.ballerinalang.compiler.plugins.AbstractCompilerPlugin; import org.ballerinalang.compiler.plugins.SupportedAnnotationPackages; import org.ballerinalang.model.elements.PackageID; import org.ballerinalang.model.tree.AnnotationAttachmentNode; import org.ballerinalang.model.tree.FunctionNode; import org.ballerinalang.util.diagnostic.Diagnostic; import org.ballerinalang.util.diagnostic.DiagnosticLog; import org.wso2.ballerinalang.compiler.tree.BLangAnnotationAttachment; import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral; import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral; import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral.BLangRecordKeyValue; import java.io.File; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardOpenOption; import java.util.List; /** * Compiler extension to generate greetings. */ // This annotation specifies that this compiler extension should only be enabled when the mentioned module is used. @SupportedAnnotationPackages( value = \"foo/hello:0.1.0\" ) public class HelloPlugin extends AbstractCompilerPlugin { private DiagnosticLog dlog; @Override public void init(DiagnosticLog diagnosticLog) { this.dlog = diagnosticLog; } // The annotation is attached to functions. Therefore, the process() method is overridden for functions. @Override public void process(FunctionNode functionNode, List<AnnotationAttachmentNode> annotations) { // Iterate through the annotations attached to the service. for (AnnotationAttachmentNode annotation : annotations) { // The `annotations` list contains all the annotations attached to the service. // Since only the `@hello:Greeting` annotation is considered, skip the other annotations. if (!\"Greeting\".equals(annotation.getAnnotationName().getValue())) { continue; } // Retrieve the fields of the annotation value. List<BLangRecordKeyValue> annotFields = ((BLangRecordLiteral) ((BLangAnnotationAttachment) annotation).expr).getKeyValuePairs(); // In this particular case, there is no need to iterate through the list since the `@hello:Greeting` annotation only has // one field. Therefore, take the first element of the fields list. BLangRecordKeyValue salutationField = annotFields.get(0); String annotFieldValue = ((BLangLiteral) salutationField.getValue()).getValue().toString(); String greeting = String.format(\"%s from %s()\\n\", annotFieldValue, functionNode.getName().getValue()); HelloModel.getInstance().setGreeting(greeting); } } // The `codeGenerated()` method gets invoked once the executable is built. The greeting is written to a text file // with the same name as the executable and in the same directory as the executable. @Override public void codeGenerated(PackageID packageID, Path binaryPath) { String fileName = binaryPath.getFileName().toString().replace(\".jar\", \".txt\"); Path greetingsPath = Paths.get(\"target\", \"greetings\", fileName); String greeting = HelloModel.getInstance().getGreetings(); try { System.out.println(\"\\nGenerating greetings\"); System.out.println(\"\\t\" + greetingsPath.toString()); writeToFile(greeting, greetingsPath); } catch (IOException e) { dlog.logDiagnostic(Diagnostic.Kind.ERROR, null, e.getMessage()); } } private void writeToFile(String greetings, Path targetFilePath) throws IOException { File newFile = targetFilePath.toFile(); if (newFile.exists()) { Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND); return; } if (newFile.getParentFile().mkdirs()) { Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8)); return; } Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8)); } } Add the following code to the HelloModel.java file. class HelloModel { private static HelloModel instance = new HelloModel(); private String greeting; private HelloModel() { } static HelloModel getInstance() { return instance; } String getGreetings() { return greeting; } void setGreeting(String greeting) { this.greeting = greeting; } } Finally, build the extension and place the resulting JAR file inside the <BALLERINA_HOME>/distributions/jballerina-1.0.2/bre/lib/ directory. Putting It All Together Now, build your hello world project again. You should see an additional step logged in the console for generating the greeting. $ ballerina build greet Compiling source bar/greet:0.1.0 Creating balos target/balo/greet-2019r3-any-0.1.0.balo Running tests bar/greet:0.1.0 No tests found Generating executables target/bin/greet.jar Generating greetings target/greetings/greet.txt The target/greetings/greet.txt file should contain the following text: Guten Tag! from add() Learning More About Writing Compiler Extensions The example considered in this how-to guide is a basic compiler extension. If you are looking for something which goes beyond this, take a look at the compiler extensions written for generating Docker and Kubernetes artifacts. "},{"page":"/learn/how-to-observe-ballerina-code","content":" layout: ballerina-inner-page title: How to Observe Ballerina Services permalink: /learn/how-to-observe-ballerina-code/ How to Observe Ballerina Services Introduction Observability is a measure of how well internal states of a system can be inferred from knowledge of its external outputs. Monitoring, logging, and distributed tracing are key methods that reveal the internal state of the system to provide the observability. Ballerina becomes fully observable by exposing itself via these three methods to various external systems allowing to monitor metrics such as request count and response time statistics, analyze logs, and perform distributed tracing. HTTP/HTTPS based Ballerina services and any client connectors are observable by default. HTTP/HTTPS and SQL client connectors use semantic tags to make tracing and metrics monitoring more informative. Getting Started This section focuses on enabling Ballerina service observability with some of its default supported systems. Prometheus and Grafana are used for metrics monitoring, and Jaeger is used for distributed tracing. Ballerina logs can be fed to any external log monitoring system like Elastic Stack to perform log monitoring and analysis. Prerequisites Make sure you have already installed Docker to setup external products such as Jaeger, Prometheus, etc. You can follow official documentation to install Docker. Steps Step 1: Install and configure Prometheus, Grafana, Jeager and Elastic Stack to Observe Ballerina. Setup Prometheus for collecting metrics information by following section on Setting up Prometheus Setup Grafana to visualize metrics by following section on Setting up Grafana Setup Jaeger analyze tracing as mentioned in section Setting up Jaeger Setup Elastic Stack only if you are interested in analysing logs by following section on Setting up Elastic Stack Step 2: Create Hello World Ballerina service. Create a Service as shown below and save it as hello_world_service.bal. import ballerina/http; import ballerina/log; service hello on new http:Listener(9090) { resource function sayHello (http:Caller caller, http:Request req) returns error? { log:printInfo(\"This is a test Info log\"); log:printError(\"This is a test Error log\"); log:printWarn(\"This is a test Warn log\"); http:Response res = new; res.setPayload(\"Hello, World!\"); check caller->respond(res); } } Step 3: Observe Hello World Ballerina service Observability is disabled by default and can be enabled by using the --b7a.observability.enabled=true flag or updating the configurations. When Ballerina observability is enabled, Ballerina runtime exposes internal metrics via an HTTP endpoint for metrics monitoring and tracers will be published to Jaeger. Prometheus should be configured to scrape metrics from the metrics HTTP endpoint in Ballerina. Ballerina logs are logged on to the console. Therefore, the logs need to be redirected to a file, which can then be pushed to Elastic Stack to perform the log analysis. Start the service using --b7a.observability.enabled=true flag: The Ballerina service is observable with default settings when the --b7a.observability.enabled=true flag is used along with the Ballerina run command to start the service. This lets you to collect the distributed tracing information with Jaeger and metrics information with Prometheus. $ ballerina run hello_world_service.bal --b7a.observability.enabled=true [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 Redirect the standard output to a file if you want to monitor logs. For example: $ nohup ballerina run hello_world_service.bal --b7a.observability.enabled=true > ballerina.log & Start the service using a configuration file: Observability of Ballerina service can also be enabled from the configuration. Create a configuration file such as ballerina.conf and add the below configuration that starts metrics monitoring and distributed tracing with default settings. [b7a.observability.metrics] # Flag to enable Metrics enabled=true [b7a.observability.tracing] # Flag to enable Tracing enabled=true The created configuration file can be passed to the Ballerina program with --b7a.config.file option along with the path of the configuration file. $ ballerina run hello_world_service.bal --b7a.config.file=<path-to-conf>/ballerina.conf [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 Redirect the standard output to a file if you want to monitor logs. For example: $ nohup ballerina run hello_world_service.bal --b7a.config.file=<path-to-conf>/ballerina.conf > ballerina.log & Step 4: Send few requests. Send few requests to http://localhost:9090/hello/sayHello Example cURL command: $ curl http://localhost:9090/hello/sayHello Step 5: View tracing and metrics in dashboard. View the tracing information on Jaeger via http://localhost:16686/ and view metrics information from Grafana dashboard on http://localhost:3000/ . Sample view of Jaeger dashboard for hello_world_service.bal is shown below. Sample view of Grafana dashboard for hello_world_service.bal is shown below. Step 6: Visualize the logs. If you have configured log analytics, view the logs in Kibana via http://localhost:5601 Monitoring Metrics Metrics help to monitor the runtime behaviour of a service. Therefore, metrics is a vital part of monitoring Ballerina services. However, metrics is not the same as analytics. For example, you should not use metrics to do something like per-request billing. Metrics are used to measure what Ballerina service does at runtime to make better decisions using the numbers. The code generates business value when it continuously run in production. Therefore, it is imperative to continuously measure the code in production. Metrics, by default, supports Prometheus. In order to support Prometheus, an HTTP endpoint starts with the context of /metrics in default port 9797 when starting the Ballerina service. Advanced Metrics Configuration for Ballerina This section focuses on the Ballerina configurations that are available for metrics monitoring with Prometheus, and the sample configuration is provided below. [b7a.observability.metrics] enabled=true reporter=\"prometheus\" [b7a.observability.metrics.prometheus] port=9797 host=\"0.0.0.0\" The descriptions of each configuration above are provided below with possible alternate options. Configuration Key Description Default Value Possible Values b7a.observability.metrics. enabled Whether metrics monitoring is enabled (true) or disabled (false) false true or false b7a.observability.metrics. reporter Reporter name that reports the collected Metrics to the remote metrics server. This is only required to be modified if a custom reporter is implemented and needs to be used. prometheus prometheus or if any custom implementation, then name of the reporter. b7a.observability.metrics. prometheus.port The value of the port in which the service '/metrics' will bind to. This service will be used by Prometheus to scrape the information of the Ballerina service. 9797 Any suitable value for port 0 - 0 - 65535. However, within that range, ports 0 - 1023 are generally reserved for specific purposes, therefore it is advisable to select a port without that range. b7a.observability.metrics. prometheus.host The name of the host in which the service '/metrics' will bind to. This service will be used by Prometheus to scrape the information of the Ballerina service. 0.0.0.0 IP or Hostname or 0.0.0.0 of the node in which the Ballerina service is running. Setup External Systems for Metrics There are mainly two systems involved in collecting and visualizing the metrics. Prometheus is used to collect the metrics from the Ballerina service and Grafana can connect to Prometheus and visualize the metrics in the dashboard. Prometheus Prometheus is used as the monitoring system, which pulls out the metrics collected from the Ballerina service '/metrics'. This section focuses on the quick installation of Prometheus with Docker, and configure it to collect metrics from Ballerina service with default configurations. Below provided steps needs to be followed to configure Prometheus. There are many other ways to install the Prometheus and you can find possible options from installation guide . Step 1: Create a prometheus.yml file in /tmp/ directory. Step 2: Add the following content to /tmp/prometheus.yml. global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: 'prometheus' static_configs: - targets: ['a.b.c.d:9797'] Here the targets 'a.b.c.d:9797' should contain the host and port of the /metrics service that's exposed from Ballerina for metrics collection. Add the IP of the host in which the Ballerina service is running as a.b.c.d and its port (default 9797). If you need more information refer official documentation of Prometheus . Step 3: Start the Prometheus server in a Docker container with below command. $ docker run -p 19090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus Step 4: Go to http://localhost:19090/ and check whether you can see the Prometheus graph. Ballerina metrics should appear in Prometheus graph's metrics list when Ballerina service is started. Grafana Let's use Grafana to visualize metrics in a dashboard. For this, we need to install Grafana, and configure Prometheus as a datasource. Follow the below provided steps and configure Grafana. Step 1: Start Grafana as Docker container with below command. $ docker run -d --name=grafana -p 3000:3000 grafana/grafana For more information refer Grafana in Docker Hub . Step 2: Go to http://localhost:3000/ to access the Grafana dashboard running on Docker. Step 3: Login to the dashboard with default user, username: admin and password: admin Step 4: Add Prometheus as datasource with Browser access configuration as provided below. Step 5: Import the Grafana dashboard designed to visualize Ballerina metrics from https://grafana.com/dashboards/5841 . This dashboard consists of service and client invocation level metrics in near real-time view. Ballerina HTTP Service Metrics Dashboard Panel will be as below. Ballerina HTTP Client Metrics Dashboard Panel will be as below. Ballerina SQL Client Metrics Dashboard Panel will be as below. Distributed Tracing Tracing provides information regarding the roundtrip of a service invocation based on the concept of spans, which are structured in a hierarchy based on the cause and effect concept. Tracers propagate across several services that can be deployed in several nodes, depicting a high-level view of interconnections among services as well, hence coining the term distributed tracing. A span is a logical unit of work, which encapsulates a start and end time as well as metadata to give more meaning to the unit of work being completed. For example, a span representing a client call to an HTTP endpoint would give the user the latency of the client call and metadata like the HTTP URL being called and HTTP method used. If the span represents an SQL client call, the metadata would include the query being executed. Tracing gives the user a high-level view of how a single service invocation is processed across several distributed microservices. Identify service bottlenecks - The user can monitor the latencies and identify when a service invocation slows down, pinpoint where the slowing down happens (by looking at the span latencies) and take action to improve the latency. Error identification - If an error occurs during the service invocation, it will show up in the list of tracers. The user can easily identify where the error occurred and information of the error will be attached to the relevant span as metadata. Ballerina supports OpenTracing standards by default. This means that Ballerina services can be traced using OpenTracing implementations like Jaeger , and Zipkin . Jaeger is the default tracer of Ballerina. Semantic tags used by Ballerina also follow the semantic conventions defined in OpenTracing specification. Advanced Tracing Configuration for Ballerina Tracing can be enabled in Ballerina with --b7a.observability.enabled=true flag as mentioned in the Getting Started section, as well as configuration option. This section mainly focuses on the configuration options with description and possible values. The sample configuration that enables tracing, and uses Jaeger as the sample tracer as provided below. [b7a.observability.tracing] enabled=true name=\"jaeger\" The below table provides the descriptions of each configuration option and possible values that can be assigned. Configuration Key Description Default Value Possible Values b7a.observability.tracing.enabled Whether tracing is enabled (true) or disabled (false) false true or false b7a.observability.tracing.name Tracer name which implements tracer interface. jaeger jaeger or zipkin Jaeger Client Jaeger is the default tracer supported by Ballerina. Below is the sample configuration options that are available in the Jaeger. [b7a.observability.tracing] enabled=true name=\"jaeger\" [b7a.observability.tracing.jaeger.sampler] type=\"const\" param=1.0 [b7a.observability.tracing.jaeger.reporter] hostname=\"localhost\" port=5775 [b7a.observability.tracing.jaeger.reporter.flush.interval] ms=2000 [b7a.observability.tracing.jaeger.reporter.max.buffer] spans=1000 The below table provides the descriptions of each configuration option and possible values that can be assigned. Configuration Key Description Default Value Possible Values b7a.observability.tracing. jaeger.reporter.hostname Hostname of the Jaeger server localhost IP or hostname of the Jaeger server. If it is running on the same node as Ballerina, it can be localhost. b7a.observability.tracing. jaeger.reporter.port Port of the Jaeger server 5775 The port which the Jaeger server is listening to. b7a.observability.tracing. jaeger.sampler.type Type of the sampling methods used in the Jaeger tracer. const const, probabilistic, or ratelimiting. b7a.observability.tracing. jaeger.sampler.param It is a floating value. Based on the sampler type, the effect of the sampler param varies 1.0 For const 0 (no sampling) or 1 (sample all spans), for probabilistic 0.0 to 1.0, for ratelimiting any positive integer (rate per second). b7a.observability.tracing. jaeger.reporter.flush.interval.ms Jaeger client will be sending the spans to the server at this interval. 2000 Any positive integer value. b7a.observability.tracing. jaeger.reporter.max.buffer.spans Queue size of the Jaeger client. 2000 Any positive integer value. Zipkin Client The tracing of Ballerina service can be done via Zipkin as well, but the required dependencies are not included in default Ballerina distribution. Follow the below steps to add the required dependencies to the Ballerina distribution. Step 1: Go to ballerina-observability and clone the GitHub repository in any preferred location. Step 2: Make sure you have installed Apache Maven . Step 3: Open the command line and build the repository by using Apache Maven with below command, while being in the root project directory ballerina-observability. $ mvn clean install Step 4: Go to the path - ballerina-observability/tracing-extensions/modules/ballerina-zipkin-extension/target/ and extract distribution.zip. Step 5: Copy all the JAR files inside the distribution.zip to 'bre/lib' directory in the Ballerina distribution. Step 6: Add following configuration to the Ballerina.toml of your module. [platform] target = \"java8\" [[platform.libraries]] artifactId = \"ballerina-zipkin-extension\" version = \"1.0.0-rc1-SNAPSHOT\" path = \"/<absolute_path_to>/ballerina-zipkin-extension-1.0.0-rc1-SNAPSHOT.jar\" groupId = \"org.ballerinalang\" modules = [\"yourModuleName\"] [[platform.libraries]] artifactId = \"brave-opentracing\" version = \"4.17.1\" path = \"/<absolute_path_to>/brave-4.17.1.jar\" groupId = \"io.opentracing.brave\" modules = [\"yourModuleName\"] [[platform.libraries]] artifactId = \"brave\" version = \"0.29.0\" path = \"/<absolute_path_to>/brave-opentracing-0.29.0.jar\" groupId = \"io.zipkin.brave\" modules = [\"yourModuleName\"] [[platform.libraries]] artifactId = \"zipkin-reporter\" version = \"2.6.1\" path = \"/<absolute_path_to>/zipkin-2.6.1.jar\" groupId = \"io.zipkin.reporter2\" modules = [\"yourModuleName\"] [[platform.libraries]] artifactId = \"zipkin\" version = \"2.5.0\" path = \"/<absolute_path_to>/zipkin-reporter-2.5.0.jar\" groupId = \"io.zipkin.zipkin2\" modules = [\"yourModuleName\"] [[platform.libraries]] artifactId = \"zipkin-sender-okhttp3\" version = \"2.5.0\" path = \"/<absolute_path_to>/zipkin-sender-okhttp3-2.5.0.jar\" groupId = \"io.zipkin.reporter2\" modules = [\"yourModuleName\"] [[platform.libraries]] artifactId = \"zipkin-sender-urlconnection\" version = \"2.5.0\" path = \"/<absolute_path_to>/zipkin-sender-urlconnection-2.5.0.jar\" groupId = \"io.zipkin.reporter2\" modules = [\"yourModuleName\"] [[platform.libraries]] artifactId = \"kotlin-stdlib\" version = \"1.3.31\" path = \"/<absolute_path_to>/kotlin-stdlib-1.3.31.jar\" groupId = \"org.jetbrains.kotlin\" modules = [\"yourModuleName\"] Step 7: Change the following configuration name to Zipkin. This ensures that all tracers are sent to Zipkin instead of the default Jaeger tracer. [b7a.observability.tracing] name=\"zipkin\" Step 8: The following configuration is a sample configuration option available for Zipkin tracer. [b7a.observability.tracing.zipkin.reporter] hostname=\"localhost\" port=9411 [b7a.observability.tracing.zipkin.reporter.api] context=\"/api/v2/spans\" version=\"v2\" [b7a.observability.tracing.zipkin.reporter.compression] enabled=true The below table provides the descriptions of each configuration option and possible values that can be assigned. Configuration Key Description Default Value Possible Values b7a.observability.tracing.zipkin. reporter.hostname Hostname of the Zipkin server localhost IP or hostname of the Zipkin server. If it is running on the same node as Ballerina, it can be localhost. b7a.observability.tracing.zipkin. reporter.port Port of the Zipkin server 9411 The port that the Zipkin server is listening to. b7a.observability.tracing.zipkin. reporter.api.context API context of the Zipkin server /api/v2/spans The API context of the Zipkin API. For V1 API, the context will be /api/v1/spans, and for V2 API, the context will be /api/v2/spans for default Zipkin server. b7a.observability.tracing.zipkin. reporter.api.version API version of the Zipkin API v2 v1 or v2. b7a.observability.tracing.zipkin. reporter.compression.enabled Enable the compression for the spans request true true or false. Setup External Systems for Tracing Ballerina by default supports Jaerger and Zipkin for distributed tracing. This section focuses on configuring the Jaeger and Zipkin with Dockers as a quick installation. Jaeger Server Jaeger is the default distributed tracing system that is supported. There are many possible ways to deploy Jaeger and you can find more information on this link . Here we focus on all in one deployment with Docker. Step 1: Install Jaeger via Docker and start the Docker container by executing below command. $ docker run -d -p5775:5775/udp -p6831:6831/udp -p6832:6832/udp -p5778:5778 -p16686:16686 -p14268:14268 jaegertracing/all-in-one:latest Step 2: Go to http://localhost:16686 and load the web UI of the Jaeger to make sure it is functioning properly. The below image is the sample tracing information you can see from Jaeger. Zipkin Server Similar to Jaeger, Zipkin is another distributed tracing system that is supported by the Ballerina. There are many different configurations and deployment exist for Zipkin, please go to link for more information. Here we focus on all in one deployment with Docker. Step 1: Install Zipkin via Docker and start the Docker container by executing following command. $ docker run -d -p 9411:9411 openzipkin/zipkin Step 2: Go to http://localhost:9411/zipkin/ and load the web UI of the Zipkin to make sure it is functioning properly. The below shown is the sample Zipkin dashboard for the hello world sample in the Quick Start Distributed Logging Ballerina distributed logging and analysis is supported by Elastic Stack. Ballerina has a log module for logging in to the console. In order to monitor the logs, the Ballerina standard output needs to be redirected to a file. This can be done by running the Ballerina service as below. $ nohup ballerina run hello_world_service.bal > ballerina.log & You can view the logs with below command. $ tail -f ~/wso2-ballerina/workspace/ballerina.log Setup External Systems for Log Analytics Elastic Stack The elastic stack comprises of the following components. Beats - Multiple agents that ship data to Logstash or Elasticsearch. In our context, Filebeat will ship the Ballerina logs to Logstash. Filebeat should be a container running on the same host as the Ballerina service. This is so that the log file (ballerina.log) can be mounted to the Filebeat container. Logstash - Used to process and structure the log files received from Filebeat and send to Elasticsearch. Elasticsearch - Storage and indexing of the logs received by Logstash. Kibana - Visualizes the data stored in Elasticsearch Elasticsearch and Kibana are provided as Cloud Services Alternatively, Docker containers can be used to set up Elasticsearch and Kibana as well. Step 1: Download the Docker images using the following commands. # Elasticsearch Image $ docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.1 # Kibana Image $ docker pull docker.elastic.co/kibana/kibana:6.5.1 # Filebeat Image $ docker pull docker.elastic.co/beats/filebeat:6.5.1 # Logstash Image $ docker pull docker.elastic.co/logstash/logstash:6.5.1 Step 2: Start Elasticsearch and Kibana containers by executing the following commands. $ docker run -p 9200:9200 -p 9300:9300 -it -h elasticsearch --name elasticsearch docker.elastic.co/elasticsearch/elasticsearch:6.5.1 $ docker run -p 5601:5601 -h kibana --name kibana --link elasticsearch:elasticsearch docker.elastic.co/kibana/kibana:6.5.1 If you run on Linux you may have to increase the vm.max_map_count for the Elasticsearch container to start. Execute the following command to do that. $ sudo sysctl -w vm.max_map_count=262144 Step 3: Create a logstash.conf file in the /tmp/pipeline/ directory and include the following content in the file. input { beats { port => 5044 } } filter { grok { match => { \"message\" => \"%{TIMESTAMP_ISO8601:date}%{SPACE}%{WORD:logLevel}%{SPACE}\\[%{GREEDYDATA:module}\\]%{SPACE}\\-%{SPACE}%{GREEDYDATA:logMessage}\"} } } output { elasticsearch { hosts => \"elasticsearch:9200\" index => \"ballerina\" document_type => \"ballerina_logs\" } } Here the 3 stages are specified in the pipeline. Input is specified as beats and listens to port 5044. A grok filter is used to structure the Ballerina logs and the output is specified to push to Elasticsearch on elasticsearch:9200. Step 4: Start the Logstash container by the following command. $ docker run -h logstash --name logstash --link elasticsearch:elasticsearch -it --rm -v /tmp/pipeline:/usr/share/logstash/pipeline/ -p 5044:5044 docker.elastic.co/logstash/logstash:6.5.1 Step 5: Configure Filebeat to ship the Ballerina logs. Create a filebeat.yml file in the /tmp/ directory and include the following content in the file. filebeat.prospectors: - type: log paths: - /usr/share/filebeat/ballerina.log output.logstash: hosts: [\"logstash:5044\"] Step 6: Start the Filebeat container with the following command. The -v flag is used for bind mounting, where the container will read the file from the host machine. Provide the path to the ballerina.log file, to be bind mounted to the filebeat container. $ docker run -v /tmp/filebeat.yml:/usr/share/filebeat/filebeat.yml -v /<path-to-ballerina.log>/ballerina.log:/usr/share/filebeat/ballerina.log --link logstash:logstash docker.elastic.co/beats/filebeat:6.5.1 Step 7: Access Kibana to visualize the logs at http://localhost:5601 . Add an index named ballerina and click on Discover to visualize the logs. "},{"page":"/learn/how-to-publish-modules","content":" layout: ballerina-inner-page title: How to Publish a Module permalink: /learn/how-to-publish-modules/ How to Publish a Module CLI Command Pushing a module uploads it to Ballerina Central . ballerina push <module-name> Setting up Before you push your module, you must enter your Ballerina Central access token in Settings.toml in your home repository ( <USER_HOME>/.ballerina/). To get your token, register on Ballerina Central and visit the user dashboard at https://central.ballerina.io/dashboard . If you are connected to the internet via an HTTP proxy, add the following section to Settings.toml and change accordingly. [proxy] host = \"localhost\" port = \"3128\" username = \"\" password = \"\" Organizations When you push a module to Ballerina Central, the runtime validates organizations for the user against the org-name defined in your module's Ballerina.toml file. Therefore, when you have more than one organization in Ballerina Central, be sure to pick the organization name that you intend to push the module into and set that as the org-name in the Ballerina.toml file inside the project directory. "},{"page":"/learn/how-to-generate-code-for-protocol-buffers","content":" layout: ballerina-inner-page title: How to generate Ballerina code for Protocol Buffer Definition permalink: /learn/how-to-generate-code-for-protocol-buffers/ How to generate Ballerina code for Protocol Buffer Definition The Protocol Buffers to Ballerina tool provides capabilities to generate Ballerina source code for the Protocol Buffer definition. The code generation tool can produce ballerina stub and ballerina service/client template files. In Ballerina, Protocol Buffers serialization is only supported in the gRPC module. Therefore, you can only use this tool to generate Ballerina source code for gRPC service definitions. CLI Command You can generate Ballerina source code using the following command: ./ballerina grpc --input <proto-file-path> [--output <path>] [--mode client \" server] Options --input - Path of the input .proto file. This is a mandatory field. You need to provide the path of the definition file. --output - Location of the generated Ballerina source files. This is an optional field. If output path is not specified, output will be written to a directory corresponding to the package in the Protocol Buffers definition. If package is not specified, output will be written to a 'temp' directory in the current location. --mode - Set the mode (client or server) to generate code samples. If not specified, only the stub file is generated. Sample The below example shows how you can generate Ballerina source code from the following Protocol Buffers definition (in the helloworld_service.proto file). syntax = \"proto3\"; service helloWorld { rpc sayHello(HelloRequest) returns (HelloResponse); } message HelloRequest { string name = 1; } message HelloResponse { string message = 1; } You can run the following command to generate the client/service stub and service template. $ ballerina grpc --input helloworld_service.proto --mode service --output service Once you execute the command, the stub file( helloworld_service_pb.bal) and the service template file ( helloWorld_sample_service.bal) are generated inside the service directory. You can run the following command to generate the client/service stub and client template. $ ballerina grpc --input helloworld_service.proto --mode client --output client Once you execute the command, the stub file( helloworld_service_pb.bal) and the service template file ( helloWorld_sample_client.bal) are generated inside the client directory. You can run the following command to generate only the client/service stub. $ ballerina grpc --input helloworld_service.proto --output stubs Once you execute the command, only the stub file ( helloworld_service_pb.bal) is generated inside the stubs directory. "},{"page":"/learn/how-to-structure-ballerina-code","content":" layout: ballerina-inner-page title: How to Structure Ballerina Code permalink: /learn/how-to-structure-ballerina-code/ How to Structure Ballerina Code This document demonstrates the development of a Ballerina project and shows how to use the Ballerina Tool to fetch, build, and install Ballerina modules. These commands work with repositories that are both local and remote. Ballerina Central is a globally hosted module management system that is used to discover, download, and publish modules. The Ballerina Tool requires you to organize your code in a specific way. This document explains the simplest way to get it up and running with a Ballerina installation. Overview Ballerina progammers can either place their code into a single source code file or in a project directory. A Ballerina program residing in a single source code file should have a .bal extension and an entry point (i.e., either a main method or a service). A Ballerina program is a compiled and linked binary. A module is a directory that contains Ballerina source code files. A repository is a versioned collection of compiled or source code modules. A project atomically manages a collection of modules. Programs A program is a runtime executable ending with a .jar extension. A program is the transitive closure of one Ballerina module without including ballerina/* modules, since those are dynamically linked within Ballerina's runtime engine during execution. A module, which is a program compiles into a file with a .jar extension. Otherwise, it is treated as a to-be-linked library that ends with a .balo extension. To generate an executable .jar file, the program's module must contain either a main() function (a process entry point) or a service (a network-accessible API). A program can import dependent modules that are stored within a repository. Suppose you have the following structure: /local/ballerina/src sample.bal The sample.bal file contains both a main() entry point and a service: import ballerina/http; import ballerina/io; import ballerina/log; public function main() { io:println(\"Hello, World!\"); } service hello on new http:Listener(9090) { resource function sayHello (http:Caller caller, http:Request req) { http:Response res = new; res.setPayload(\"Hello, World!\"); var respondResult = caller->respond(res); if (respondResult is error) { log:printError(\"Error sending response\", err = respondResult); } } } Build and Run Programs To generate an executable .jar, you can build a Ballerina program, which contains a main() function or a service(s): $ cd /local/ballerina/src $ ballerina build sample.bal # This generates 'sample.jar'. You can use the following command to run the main() function or services in a generated .jar file: $ ballerina run sample.jar Modules A module is a directory, which contains Ballerina source code files and is part of a namespace. Modules facilitate collaboration, sharing, and reuse. Modules can include functions, clients, constants, annotations, services, and objects. To share a module among programs, projects, and users, you need to push the module into a repository. Modules: May or may not have a version However, modules cannot be pushed into a registry for sharing without a version Are referenced by <org-name>/<module-name> where <org-name> is a namespace from within a repository. Module names can contain alphanumeric characters including dots ( .). Dots in a module name has no meaning other than the last segment after the final dot being used as a default alias within your source code. Importing Modules Your Ballerina source files can import modules: import [<org-name>]/<module-name> [as <identifier>]; When you import a module, you can use its functions, annotations, and other objects in your code. You can also reference the objects with a qualified identifier followed by a colon ( :). For example, <identifier>:<module-object>. Identifiers are either derived or explicit. The default identifier is either the module name or if the module name has dots ( .) included, then the last word after the last dot. For example, import ballerina/http; will have http:as the derived identifer and the module import ballerinax/java.jdbc would have jdbc: as the default identifier. You can have an explicit identifier by using the as <identifier> syntax. import ballerina/http; // The listener comes from the imported module. service hello on new http:Listener(9090) { // The 'Request' object comes from the imported module. resource function sayHello (http:Caller caller, http:Request req) { ... } } Or you can override the default identifier: import ballerina/http as network; service hello on new network:Listener(9090) { // The 'Request' object comes from the imported module. resource function sayHello (network:Caller caller, network:Request req) { ... } } Module Version Dependency If your source file or module is a part of a project, then you can explicitly manage version dependencies of imported modules within the project by defining it in the Ballerina.toml file: [dependencies] \"wso2/twitter\" = \"2.3.4\" \"wso2/github\" = { path = \"path/to/github.balo\", version = \"1.2.3\"} Often, you would want to depend on a module of another project, which you have not pushed to the Ballerina Central. This can be achieved using a path dependency as shown above with the wso2/github dependency. If an import version is not specified in Ballerina.toml, the compiler will use the latest module version from a repository, if one exists. import foo/http; public function main() { http:Person x = http:getPerson(); } Compiled Modules A compiled module is the compiled representation of a single module of Ballerina code, which includes transitive dependencies into the compiled unit. Modules can only be created, versioned, and pushed into a repository as part of a project. Running Compiled Modules An entrypoint such as a main() or a service that is compiled as part of a named module is automatically linked into a .jar. You can run the compiled module .jar: ballerina run module.jar Projects A project is a directory, which atomically manages a collection of modules. It has: A user-managed manifest file, Ballerina.toml An src folder with module source code Projects are managed atomically. Therefore, dependency management, compilation, unit tests, and artifact generation are done collectively across the source code files and modules defined within a project. Create a Project You can create a project using the ballerina new command: ballerina new <project-name> The new command will create a project directory with the given name. A Ballerina project cannot reside in another ballerina project. If you run ballerina new from inside a Ballerina project directory or from inside a sub directory of a Ballerina project, it will give an error. It will create the Ballerina.toml file, and src folder. Add a Module Once the project is initialized, a module can be created inside the project using the ballerina add command. Each subdirectory of the project src folder defines a single module. The subdirectory's name will be used to name the module. ballerina add <module-name> The folders tests/ and resources/ are reserved folder names within the module. The tests/ folder contains unit test files of the module and the resources/ folder contains the resources of the module that will be available at runtime. Any additional subdirectories within the module have no semantic meaning and can be used by the developer for organizing files. The module subdirectories can have as many Ballerina source files and all will be included within the module when it is built. Project Structure / project-name/ .gitignore Balleirna.lock # Generated during the build and used to rebuild identical binary Ballerina.toml # Configuration, which defines project intent src/ module1/ # The source in this directory will be named \"<org-name>/module1\" Module.md # Contains descriptive metadata for display at Ballerina Central main.bal # Contains the default main method *.bal # In this dir and recursively in subdirs except tests/ and resources/ [tests/] # Module-specific unit and integration tests main_test.bal # The test file for main [resources] # Resources for the tests [resources/] # Module-specific resources module2/ Module.md *.bal [tests/] [resources/] target/ # Compiled executables and other artifacts end up here balo/ # BALO files, one per each module, will be created here bin/ # Executables will be created here caches/ bir_cache/ jar_cache/ Build a Project A project should be built if it is required to generate the executable JAR files from the modules in the project. The executable JAR files will be generated only if there are entry points (main method or a service) in the module. Building a project will build all modules found in the project's root folder. Building a project runs through phases including dependency resolution, compilation, artifact generation, and unit test execution. ballerina build -a Build a Module You can build a single module contained within a project: ballerina build <module-name> Use the --skip-tests flag with the ballerina build command to skip running the tests during the build process. ballerina build --skip-tests <module-name> Compile a Project A project should be compiled if it is required to generate the libraries (i.e., BALOs) from the modules in the project. Compiling a project will compile all the modules found in the project's root folder. Building a project runs through phases including dependency resolution, compilation, artifact generation, and unit test execution. ballerina build -c -a Compile a Module You can build a single module contained within a project: ballerina build -c <module-name> Use the --skip-tests flag with the ballerina compile command to skip running the tests during the compile process. ballerina build -c --skip-tests <module-name> Version a Module Modules in a project are assigned their version from within the Ballerina.toml file: # The current version, obeying [semver](https://semver.org/) version = \"string\" All modules built in a project are assigned the same version. If you need two modules to have different versions, then those modules should be placed into different projects. Version labels must follow Semantic Versioning 2.0 rules . Assign an Organization Name to a Module A module is assigned an <org-name> when it is pushed into a repository. The <org-name> is defined in the Ballerina.toml and all modules in the same project are assigned the same organization name: # Org name assigned to modules when installed into a repository org-name = \"foo\" Module Caches Caches Ballerina will maintain several caches to speed up the compile and build process. Following artifacts will be cached by Ballerina. BALO files fetched from Central. BIR files generated during the compilation. JAR file generated during the compilation Here, the BALO cache will be common across any version of Ballerina and the BIR and JAR caches will be specific to the Ballerina version. BALO Cache BALO cache is responsible for keeping BALOs of dependent modules. There is a BALO cache inside the Ballerina distribution, which contains the BALOs of libraries that will get packed into the distribution. There is another cache at the user's home repository, which is used to cache the BALOs fetched from Central. BIR Cache BIR files of the standard library that gets packed into a distribution are generated during the distribution build time. The BIR files of the other dependencies will be kept inside the target directory when compiling a Ballerina project. JAR Cache The JAR files generated during the build will be kept inside the target directory when building a Ballerina project. The JAR file will be generated only if there is an entry point (main funtion or service) within the module. Module Repository - Ballerina Central A repository is a collection of compiled Ballerina modules. A repository helps to organize modules used by multiple programs by managing their versions and assets in a central location. [Ballerina Central] ( http://central.ballerina.io ) is the only module repository for Ballerina developers. Organizations An organization is a logical name used for grouping modules together under a common namespace within a repository. All modules installed into a repository must have an organization name. Any installation or pushing of a module into a repository will fail without an organization name. Organization names can contain lowercase alphanumeric characters and underscores. None of the characters in an organization name have any semantic meaning. The organization names ballerina and ballerinax are reserved for system use. Modules in ballerina and ballerinax are included within the system distribution. At Ballerina Central, every account is assigned a personal organization name, which is chosen by a user when creating their account initially or is derived from the email address of the user. When pushing a module from a local computer into Ballerina Central, the user's organization name in the Ballerina Central MUST match the <org-name> assigned in the Ballerina.toml file. If the names do not match, then the push operation will fail. This enforcement may seem arbitrary. However, it is a simple way to ensure organization naming consistency across remote and local development environments. Pulling Remote Modules You can install modules that exist in Ballerina Central into your BALO cache in the home directory via \"pulling\" them. Pulling a module discovers and downloads the module source and binaries from Ballerina Central and installs them into the BALO cache. ballerina pull <org-name>/<module-name>[:<version>] If a version is not specified for the module to be pulled, the latest version of the module will be pulled from the Ballerina Central. Projects that perform dependency analysis will automatically pull modules into the BALO cache in the home directory. Pushing Modules \"Pushing\" a module uploads the associated module files and installs the module into Ballerina Central. The org-name and the version of the module will be read from the manifest file Ballerina.toml inside the project. It is required to build the module before pushing it to Ballerina Central. # Push a single module ballerina push <module-name> Configure Ballerina Central Access Ballerina Central requires an account in order to push modules. Your account is represented by a CLI token that is installed into your local Ballerina configuration file, i.e., ~/.ballerina/Settings.toml. The CLI token is automatically installed into this file the first time you perform a ballerina push as Ballerina redirects to an OAuth authorization screen, configures your account, and then copies your CLI token from Ballerina Central into your local CLI configuration. To get your token, register on Ballerina Central and visit the Ballerina Central Dashboard . Every push of the same module into Ballerina Central REQUIRES a new version even for minor text updates. This policy is enforced to ensure that projects, which make use of dependencies cannot experience accidental behavior drift across two versions of the same module given the same version. Essentially, there is no way to \"update\" a module for a specific version in Ballerina Central. "},{"page":"/learn/intellij-plugin-doc","content":" layout: ballerina-inner-page title: The IntelliJ IDEA Ballerina Plugin permalink: /learn/intellij-plugin-doc/ The IntelliJ IDEA Ballerina Plugin The IntelliJ Ballerina plugin provides the Ballerina development capabilities in IntelliJ IDEA. Click on the below links for instructions on how to download, install and use the features of the IntelliJ plugin. Downloading IntelliJ IDEA Installing the plugin Setting up Ballerina SDK Using the plugin Using the features of the plugin Downloading IntelliJ IDEA Download the IntelliJ IDEA editor . Installing the plugin Use either of the below approaches to install the IntelliJ Ballerina plugin. Installing via the IntelliJ IDEA editor Installing using the ZIP file Installing via the IntelliJ IDEA editor Open the editor, click IntelliJ IDEA in the top menu, click Preferences, and then click Plugins. Tip: If you are using Ubuntu/Windows, click File, click Settings, and then click Plugins. In the search bar, type \"Ballerina\", press the Enter key, Click Install, and then click Accept. Click Restart IDE, and then click Restart. This downloads the plugin and installs it. Installing using the ZIP file Follow the steps below to install the plugin using its ZIP file. Obtaing the ZIP file Installing the ZIP file via the editor Obtaing the ZIP file Follow either of the below approaches to obtain the ZIP file of the Ballerina plugin. Downloading from the JetBrains Plugin Repository Building from the source Downloading from the JetBrains Plugin Repository Download the IntelliJ Ballerina plugin . Building from the source Follow the steps below to obtain the ZIP file by building it from its source. Clone the ballerina-lang GIT repo. In a new Command Line tab, navigate to the source directory of the plugin (i.e., the <CLONED_BALLERINA_DIRECTORY>/tool-plugins/intellij directory), and execute the below command. Info: In the above step, <CLONED_BALLERINA_DIRECTORY> refers to the path of the ballerina-lang Git repository, which you cloned locally. Tip: You need to install Gradle Build Tool to execute the below command. ./gradlew buildPlugin Tip: If you are using Ubuntu/Windows, execute the below command: gradlew buildPlugin Info: This creates the /build/distributions/ballerina-intellij-idea-plugin-[VERSION].zip file locally in the ballerina-platform/ballerina-lang/tree/master/tool-plugins/intellij/tree/master/tool-plugins/intellij directory. Installing the ZIP file via the editor After obtaining the ZIP file using either of the above approaches follow the steps below to install it using the IntelliJ IDEA Editor. Open the editor, click IntelliJ IDEA in the top menu, click Preferences, and then click Plugins. Tip: If you are using Ubuntu/Windows, click File, click Settings, and then click Plugins. Click the cogwheel icon, and then click Install plugin from disk.... Browse and select the ZIP file of the plugin you downloaded. Important: Make sure you install the ZIP file and not the extracted JAR files. This is because the ZIP file contains of an additional library that is required by the plugin to function as expected. Click the Installed tab, click Restart IDE, and then click Restart. Setting up Ballerina SDK After installing the IntelliJ Ballerina plugin, you need to set up Ballerina SDK for your ballerina projects to activate all capabilities of the plugin. Using the plugin For information on using the IntelliJ Ballerina plugin to write Ballerina programs, see Using the IntelliJ Ballerina plugin . Using the features of the plugin Click on the below links to find information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process. Running Ballerina programs Debugging Ballerina programs Viewing the sequence diagram Importing modules on the fly Importing unambiguous modules Finding usage Formatting Ballerina codes Viewing details of parameters Viewing documentation Adding annotation fields via suggestions Using file templates Using code snippet templates Checking spellings Analyzing semantics "},{"page":"/learn/how-to-use-openapi-tools","content":" layout: ballerina-inner-page title: Ballerina OpenAPI Tools permalink: /learn/how-to-use-openapi-tools/ Ballerina OpenAPI Tools OpenAPI Specification is a specification that creates RESTFUL contract for APIs, detailing all of its resources and operations in a human and machine-readable format for easy development, discovery, and integration. Ballerina OpenAPI tooling will make it easy for user to start development of a service, documented in OpenAPI contract, in Ballerina by generating Ballerina service and client skeletons. The OpenAPI tools provides following capabilities. Generate the Ballerina Service or Client code for a given OpenAPI definition. Generate the client stub for an existing Ballerina service at build time. Export the OpenAPI definition of a Ballerina service. The openapi command in Ballerina is used for OpenAPI to Ballerina and Ballerina to OpenAPI code generation. Code generation from OpenAPI to Ballerina can produce ballerina mock services and ballerina client stubs. For build time client stub generation, annotation support is provided. Mock service from OpenAPI ballerina openapi gen-service <moduleName>:<serivceName> <openapi_contract> [-c: copy-contract] [-o: outputFile] Generates a Ballerina service for the OpenAPI file. This generated service is a mock version of the actual Ballerina service. Generated sources contain the service definition in src/<module-name>/ and the OpenAPI contract that used to generate will be copied to src/<module-name>/resources. Client stub from OpenAPI ballerina openapi gen-client [<moduleName>]:<clientName> <openapi-contract> [-o <dir-path> \" --output <dir-path>] Generates a Ballerina client stub for the service defined in a OpenAPI file. This client can be used in client applications to call the service defined in the OpenAPI file. Service to OpenAPI export ballerina openapi gen-contract [<moduleName>:]<serviceName> [-i: <ballerinaFile> \" --ballerina-file <ballerina-file>] [-o: <openapi-contract> \" --output <openapi-contract>] [-s \" --skip-bind] Export the Ballerina service to a definition of OpenApi Specification 3.0. For the export to work properly, the input Ballerina service should be defined using basic service and resource level HTTP annotations. Client stub for service Generates a Ballerina client stub to communicate with a Ballerina service. All endpoint(s) that are used for client stub generation should be marked with the @openapi:ClientEndpoint annotation. If not, there might be errors during client stub generation. Endpoints that are not marked with this annotation are not picked for client stub generation. The @openapi:ClientConfig { generate: true } annotation is used to enable or disable client stub generation per service. Samples Mock service from OpenAPI ballerinna openapi gen-service helloworld:helloService hello_service.yaml This will generate a Ballerina service, for hello_service.yaml OpenAPI contract, named helloService in the module named helloworld. This command should be executed inside a Ballerina project. Client stub from OpenAPI ballerina openapi gen-client hello_client hello_service.yaml This will generate a Client named hello_client in a module named client for the service documented in hello_service.yaml. This command should be executed inside a Ballerina project. OpenAPI from service ballerina openapi gen-contract hello -i src/helloS/hello.bal This will generate the OpenAPI contract for the Ballerina service hello which is in hello.bal Ballerina file. Client stub from service Apply annotation to say that client generation is enabled by adding @openapi:ClientConfig { generate: true } and point the client endpoint to be applied on generation by adding @openapi:ClientEndpoint annotation to the client endpoint. import ballerina/http; import ballerina/log; import ballerina/openapi; // Define this endpoint as a selected endpoint for client generation. @openapi:ClientEndpoint listener http:Listener helloEp = new(9090); // Enable client code generation for this service. @openapi:ClientConfig { generate: true } @http:ServiceConfig { basePath: \"/sample\" } service Hello on helloEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/hello\" } resource function hello(http:Caller caller, http:Request req) { http:Response res = new; res.setPayload(\"Hello\"); var result = caller->respond(res); if (result is error) { log:printError(\"Error when responding\", err = result); } } } "},{"page":"/learn/quick-tour","content":" layout: ballerina-inner-page title: Quick Tour permalink: /learn/quick-tour/ Quick Tour Now, that you know a little bit of Ballerina, let's take it for a spin! Install Ballerina Download Ballerina based on the Operating System you are using. Follow the instructions given on the Getting Started page to set it up. Follow the instructions given on the The Visual Studio Code Plugin page or The IntelliJ IDEA Ballerina Plugin page to set up your preferred editor for Ballerina. Write a Service, Run It, and Invoke It Write a simple Hello World service in a file with the .bal extension. import ballerina/http; import ballerina/io; # A service representing a network-accessible API # bound to port `9090`. service hello on new http:Listener(9090) { # A resource respresenting an invokable API method # accessible at `/hello/sayHello`. # # + caller - the client invoking this resource # + request - the inbound request resource function sayHello(http:Caller caller, http:Request request) { // Sends a response back to the caller. error? result = caller->respond(\"Hello Ballerina!\"); if (result is error) { io:println(\"Error in responding: \", result); } } } Now, you can run the service by running the following command. $ ballerina run hello_world.bal You get the following output. [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 This means your service is up and running. You can invoke the service using an HTTP client. In this case, we use cURL. $ curl http://localhost:9090/hello/sayHello Tip: If you do not have cURL installed, you can download it from https://curl.haxx.se/download.html . You get the following response. Hello Ballerina! Alternatively, you can use a Ballerina HTTP client to invoke the service. Use a Client to Interact with a Network Accessible Service A Ballerina client is a component, which interacts with a network-accessible service. It aggregates one or more actions that can be executed on the network-accessible service and accepts configuration parameters related to the network-accessible service. There are two kinds of clients in Ballerina, inbound (or ingress) and outbound (or egress) clients. An outbound client object can be used to send messages to a network service. Having said that, let's see how you can use a Ballerina client to invoke the Hello World service. First, you need to create the client with the relevant endpoint URL as follows. We will use a Ballerina program with a 'main' function, which will perform the invocation. Note: returning error? allows you to use the check keyword to avoid handling errors explicitly. This is only done to keep the code simple. However, in real production code, you may have to handle those errors explicitly. http:Client helloClient = new(\"http://localhost:9090/hello\"); As the next step, add the below code to do a GET request to the Hello World service. http:Response helloResp = check helloClient->get(\"/sayHello\"); The remote call would return an http:Response if successful, or an error on failure. If successful, attempt retrieving the payload as a string and print the payload. io:println(check helloResp.getTextPayload()); The complete source code should look similar to the following: import ballerina/http; import ballerina/io; public function main() returns error? { http:Client helloClient = new(\"http://localhost:9090/hello\"); http:Response helloResp = check helloClient->get(\"/sayHello\"); io:println(check helloResp.getTextPayload()); } Make sure the service is up and running. Now, you can run the .bal file containing the main function that invokes the service. $ ballerina run hello_client.bal This would produce the following output. Hello Ballerina! Similarly, you can use a Ballerina HTTP client to interact with any HTTP service. Now, let's look at a simple HTTP client that retrieves sunrise/sunset time details for Colombo. Create a client with the relevant endpoint URL as follows. http:Client sunriseApi = new(\"http://api.sunrise-sunset.org\"); As the next step, add the below code to do a GET request to the sunrise-sunset backend. http:Response sunriseResp = check sunriseApi->get(\"/json?lat=6.9349969&lng=79.8538463\"); Now, add the below code snippet to retrieve the payload and print it. json sunrisePayload = check sunriseResp.getJsonPayload(); io:println(sunrisePayload); The complete source code should look similar to the following: import ballerina/http; import ballerina/io; public function main() returns error? { http:Client sunriseApi = new(\"http://api.sunrise-sunset.org\"); http:Response sunriseResp = check sunriseApi->get(\"/json?lat=6.9349969&lng=79.8538463\"); json sunrisePayload = check sunriseResp.getJsonPayload(); io:println(sunrisePayload); } Now, you can invoke the service using this client by running the following command. $ ballerina run sunrise_client.bal This should print out the sunrise/sunset details. Follow the Repo \"Star\" \"Watch\" Star GitHub repo and show appreciation to Ballerina maintainers for their work. Watch the repo to keep track of Ballerina issues. What's Next Now, that you have taken Ballerina around for a quick tour, you can explore Ballerina more. Go through Ballerina by Example to learn Ballerina incrementally with commented examples that cover every nuance of the syntax. "},{"page":"/learn/how-to-write-secure-ballerina-code","content":" layout: ballerina-inner-page title: How to Write Secure Ballerina Programs permalink: /learn/how-to-write-secure-ballerina-code/ How to Write Secure Ballerina Programs This document demonstrates different security features and controls available within Ballerina, and serves the purpose of providing guidelines on writing secure Ballerina programs. Table of Contents Secure by Design Ensuring security of Ballerina standard libraries Securely using tainted data with security-sensitive parameters Securing Passwords and Secrets Authentication and Authorization Inbound Authentication & Authorization Inbound Advanced Use Cases Using Multiple Auth Handlers Using Multiple Scopes Per-Resource and Per-Service Customization Implementing Inbound Custom Authentication Mechanism Disable HTTPS Enforcement Modify Authn or Authz Filter Index JWT Inbound Authentication and Authorization OAuth2 Inbound Authentication and Authorization LDAP Inbound Authentication and Authorization Basic Auth Inbound Authentication and Authorization Outbound Authentication & Authorization Outbound Advanced Use Cases Implementing Outbound Custom Authentication Mechanism JWT Outbound Authentication OAuth2 Outbound Authentication Client Credentials Grant Type Password Grant Type Direct Token Mode Basic Auth Outbound Authentication Token Propagation for Outbound Authentication Example - 1 Example - 2 Secure by Design This approach makes it unnecessary for developers to review best practice coding lists that itemize how to avoid security vulnerabilities. The Ballerina compiler ensures that Ballerina programs do not introduce security vulnerabilities. A taint analysis mechanism is used to achieve this. Parameters in function calls can be designated as security-sensitive. The compiler will generate an error if you pass untrusted data (tainted data) into a security-sensitive parameter: tainted value passed to sensitive parameter 'sqlQuery' We require developers to explicitly mark all values passed into security-sensitive parameters as 'trusted'. This explicit check forces developers and code reviewers to verify that the values being passed into the parameter are not vulnerable to a security violation. Ballerina standard library makes sure untrusted data cannot be used with security sensitive parameters such as SQL queries, file paths, file name, permission flags, request URLs and configuration keys, preventing vulnerabilities, including: SQL Injection Path Manipulation File Manipulation Unauthorized File Access Unvalidated Redirect (Open Redirect) Ensuring security of Ballerina standard libraries Security-sensitive functions and remote methods of Ballerina standard libraries are annotated with the @untainted parameter annotation. This denotes that untrusted (tainted) data should not be passed to the parameter. For example, the sqlQuery parameter of the ballerinax/java.jdbc select remote method is annotated as @untainted. public remote function select(@untainted string sqlQuery, typedesc<record{}>? recordType, Param... parameters) returns @tainted table<record {}>\"Error The following example constructs an SQL query with a tainted argument: import ballerinax/java.jdbc; type ResultStudent record { string name; }; public function main() { jdbc:Client testDB = new({ url: \"jdbc:mysql://localhost:3306/testdb\", username: \"test\", password: \"test\", poolOptions: { maximumPoolSize: 5 }, dbOptions: { useSSL: false } }); // Construct student ID based on user input. string studentId = \"S_\" + args[0]; // Execute select query using the untrusted (tainted) student ID var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = \" + studentId, ResultStudent); testDB.stop(); } The Ballerina compiler will generate an error: tainted value passed to sensitive parameter 'sqlQuery' In order to compile, the program is modified to use query parameters: sql:Parameter paramId = {sqlType:sql:TYPE_VARCHAR, value:studentId}; var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = ?\", ResultStudent, paramId); Command-line arguments passed to Ballerina programs and inputs received through service resources are considered as tainted. Additionally, return values of certain functions are marked with the @tainted annotation to denote that the resulting value should be considered as untrusted data. For example, the select remote method of the java:jdbc client highlighted above returns a @tainted table<record {}>\"Error. This means that any value read from a database is considered as untrusted. When the Ballerina compiler can determine that a function is returning tainted data without tainted data being passed in as parameters to that function, it is required to annotate the function's return type as @tainted. If not, the function author has to clean up the data before returning. For instance, if you are to read from the database and return that result, you either need to annotate that function's return type as @tainted or you have to clean up and make sure the returned data is not tainted. Securely using tainted data with security-sensitive parameters There can be certain situations where a tainted value must be passed into a security-sensitive parameter. In such situations, it is essential to do proper data validation or data sanitization to make sure the input does not result in a security threat. Once proper controls are in place, the @untainted annotation can be used with a type cast operator to denote that the value is trusted: // Execute select query using the untrusted (tainted) student ID boolean isValid = isNumeric(studentId); if (isValid) { var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = \" + <@untainted> studentId, ResultStudent); } // ... Additionally, return values can be annotated with @untainted. This denotes that the return value should be trusted (even if the return value is derived from tainted data): // Execute the select query using the untrusted (tainted) student ID function sanitizeSortColumn (string columnName) returns @untainted string { string sanitizedSortColumn = columnName; // Insert sanitization logic to ensure that the return value is safe. return sanitizedSortColumn; } // ... Securing Passwords and Secrets Ballerina provides an API to access configuration values from different sources. For more information, see Config Ballerina by Example . Configuration values containing passwords or secrets should be encrypted. The Ballerina Config API will decrypt such configuration values when being accessed. Use the following command to encrypt a configuration value: $ ballerina encrypt The encrypt command will prompt for the plain-text value to be encrypted and an encryption secret. $ ballerina encrypt Enter value: Enter secret: Re-enter secret to verify: Add the following to the configuration file: <key>=\"@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=}\" Or provide it as a command line argument: --<key>=@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=} Ballerina uses AES, CBC mode with PKCS#5 padding for encryption. The generated encrypted value should be used in place of the plain-text configuration value. For example, contents of a configuration file that includes a secret value should look as follows: api.secret=\"@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=}\" api.provider=\"not-a-security-sensitive-value\" When running a Ballerina program that uses encrypted configuration values, Ballerina will require the secret used during the encryption process to perform the decryption. Ballerina will first look for a file named secret.txt. If such file exists, Ballerina will read the decryption secret from the file and immediately remove the file to make sure secret cannot be accessed afterwards. If the secret file is not present, the Ballerina program will prompt for the decryption secret. The file based approach is useful in automated deployments. The file containing the decryption secret can be deployed along with the Ballerina program. The name and the path of the secret file can be configured using the ballerina.config.secret runtime parameter: $ ballerina run --b7a.config.secret=path/to/secret/file securing_configuration_values.bal Authentication and Authorization Inbound Authentication & Authorization Ballerina HTTP services can be configured to enforce authentication and authorization. Ballerina has built-in support for the following inbound authentication mechanisms whereas it is possible to add custom mechanisms: Basic authentication JWT authentication OAuth2 authentication LDAP authentication Ballerina inbound authentication is abstracted out into 2 layers called http:InboundAuthHandler and auth:InboundAuthProvider. The auth:InboundAuthProvider is a protocol-independent entity that only knows how to authenticate a user when the necessary information is provided. The http:InboundAuthHandler can be protocol dependent. Even-though the current focus is on HTTP, the ballerina/auth module can operate with other protocols as well. The http:InboundAuthHandler is used to perform HTTP-level actions, which are extracting the required HTTP header or body, extracting the credentials out of it, passing them into the associated auth:InboundAuthProvider, and getting the credentials validated. The auth:InboundAuthProvider is used to validate the credentials passed by the http:InboundAuthHandler. In a particular authentication scheme, the implemented instance of the auth:InboundAuthProvider is initialized with the required configurations and it is passed to the implemented instance of the http:InboundAuthHandler. Next, the implemented instance of the http:InboundAuthHandler is passed to the http:Listener configuration as follows and the listener is initialized with authentication. The following example represents how a listener is secured with Basic Auth with the above-mentioned configurations. import ballerina/auth; import ballerina/http; auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider); listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [basicAuthHandler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); service helloWorld on secureHelloWorldEp { // .... } Note: It is a must to use HTTPS when enforcing authentication and authorization checks, to ensure the confidentiality of sensitive authentication data. Optionally, the scopes attribute is configured for the authorization as follows. If it is not specified, that means the service is authorized for any authenticated user. listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [authHandler], scopes: [\"test-scope\"] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); service helloWorld on secureHelloWorldEp { // .... } Inbound Advanced Use Cases Using Multiple Auth Handlers The authHandlers can be configured for advanced use cases, which use multiple auth handlers as follows: Case 1: Auth should be successful for authHandler1 OR authHandler1. authHandlers: [authHandler1, authHandler2] Case 2: Auth should be successful for authHandler1 AND authHandler12. authHandlers: [[authHandler1], [authHandler2]] Case 3: Auth should be successful for (( authHandler1 OR authHandler2) AND ( authHandler3 OR authHandler4)). authHandlers: [[authHandler1, authHandler2], [authHandler3, authHandler4]] listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [authHandler1, authHandler2] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); service helloWorld on secureHelloWorldEp { // .... } Using Multiple Scopes The scopes can be configured for advanced use cases as follows: Case 1: Auth should be successful for scope-1 OR scope-2. scopes: [\"scopes-1\", \"scopes-2\"] Case 2: Auth should be successful for scope-1 AND scope-2. scopes: [[\"scopes-1\"], [\"scopes-2\"]] Case 3: Auth should be successful for (( scope-1 OR scope-2) AND ( scope-3 OR scope-4)). scopes: [[\"scopes-1\", \"scopes-2\"], [\"scopes-3\", \"scopes-4\"]] listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [authHandler], scopes: [\"scopes-1\", \"scopes-2\"] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); service helloWorld on secureHelloWorldEp { // .... } Per-Resource and Per-Service Customization The security enforcements can be customized by the @http:ServiceConfig annotation and the @http:ResourceConfig annotation. For example, authentication and authorization can be modified for a particular service as follows by configuring the auth attribute of the @http:ServiceConfig. Authentication can be disabled only for a particular service by using the enabled attribute The authentication mechanism can be changed for a particular service by using the authHandlers attribute Authorization scopes can be changed for a particular service by using the scopes attribute @http:ServiceConfig { basePath: \"/hello\", auth: { enabled: false, authHandlers: [authHandlerA], scopes: [\"scope-A\"] } } service helloWorld on secureHelloWorldEp { // ... } Further, authentication and authorization can be modified for a particular resource as follows by configuring the auth attribute of the @http:ResourceConfig: @http:ResourceConfig { basePath: \"/\", auth: { enabled: false, authHandlers: [authHandlerA], scopes: [\"scope-A\"] } } resource function sayHello (http:Caller caller, http:Request req) { // ... } The same configuration patterns used for the listener-level configurations are applied for authHandlers and the scopes attributes in service-level configurations and resource-level configurations. Implementing Inbound Custom Authentication Mechanism The user can implement a custom version of AuthHandler and AuthProvider with the use of the object-equivalency pattern as follows. With that, the http:Listener can be enforced with custom authentication and authorization mechanisms. public type InboundCustomAuthHandler object { *http:InboundAuthHandler; public function canProcess(http:Request req) returns @tainted boolean { // Custom logic to check whether the request can be processed. } public function process(http:Request req) returns boolean\"http:AuthenticationError { // Custom logic to process the request, extract the credentials, and get them validated from the AuthProvider. } }; public type InboundCustomAuthProvider object { *auth:InboundAuthProvider; public function authenticate(string credential) returns boolean\"auth:Error { // Custom logic to authenticate the given credentials. } }; Disable HTTPS Enforcement The enforcement of HTTPS can be disabled by configuring the value mandateSecureSocket into false as follows: listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [authHandler], mandateSecureSocket: false } }); service helloWorld on secureHelloWorldEp { // .... } Modify Authn or Authz Filter Index The authn/authz filters are engaged as the top most filters of the filter array, which is configured in the HTTP listener configuration. The uer can configure the index of the authn/authz filters if it is needed to engage a custom filter before the authn/authz filters. The position attribute represents the authn/authz filter position of the filter array. The position values starts from 0 and it is set to 0 implicitly. The following example engages the authn/authz filters in between the customFilter1 and customFilter2. Then, the internally-updated filter chain would be [customFilter1, authnFilter, authzFilter, customFilter2]. listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [authHandler], position: 1 }, filters: [customFilter1, customFilter2], secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); service helloWorld on secureHelloWorldEp { // .... } JWT Inbound Authentication and Authorization Ballerina supports JWT Authentication and Authorizations for services. The http:BearerAuthHandler is used to extract the HTTP Authorization header from the request and extract the credential from the header value which is Bearer <token>. Then the extracted credential will be passed to the initialized AuthProvider and get validated. The jwt:InboundJwtAuthProvider is used to validate the credentials (JWT) passed by the AuthHandler against the jwt:JwtValidatorConfig provided by the user. JWT validation requires several additional configurations for the jwt:JwtValidatorConfig including: issuer - The issuer of the JWT audience - The audience value for the current service clockSkewInSeconds - Clock skew in seconds that can be used to avoid token validation failures due to clock synchronization problems trustStoreConfig - JWT trust store configurations trustStore - Trust store used for signature verification certificateAlias - Token-signed public key certificate alias jwtCache - Cache used to store parsed JWT information as CachedJwt The jwt:JwtValidatorConfig record should be provided into the jwt:InboundJwtAuthProvider when initializing. The initialized jwt:InboundJwtAuthProvider is passed to the `http:BearerAuthHandler. Note: For demonstration purposes, the ballerinaTruststore.p12 included with Ballerina runtime is used. In a production deployment, the truststore should only contain the public key certificates of the trusted JWT issuers. import ballerina/http; import ballerina/jwt; jwt:InboundJwtAuthProvider jwtAuthProvider = new({ issuer: \"ballerina\", audience: [\"ballerina.io\"], trustStoreConfig: { certificateAlias: \"ballerina\", trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); http:BearerAuthHandler jwtAuthHandler = new(jwtAuthProvider); listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [jwtAuthHandler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); @http:ServiceConfig { basePath: \"/hello\" } service helloWorld on secureHelloWorldEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/\" } resource function sayHello(http:Caller caller, http:Request req) { http:Response resp = new; resp.setTextPayload(\"Hello, World!\"); checkpanic caller->respond(resp); } } When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur: curl -k -v https://localhost:9091/hello > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure Once a request is made with a valid, signed JWT, but without the expected \"scope\", an authorization failure will occur. An example of a JWT without \"scope\" attribute is as follows. { \"sub\": \"ballerina\", \"iss\": \"ballerina\", \"exp\": 2818415019, \"iat\": 1524575019, \"jti\": \"f5aded50585c46f2b8ca233d0c2a3c9d\", \"aud\": [ \"ballerina\", \"Ballerina.org\", \"ballerina.io\" ] } curl -k -v https://localhost:9091/hello -H \"Authorization:Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwianRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiYmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdfQ.X2mHWCr8A5UaJFvjSPUammACnTzFsTdre-P5yWQgrwLBmfcpr9JaUuq4sEwp6to3xSKN7u9QKqRLuWH1SlcphDQn6kdF1ZrCgXRQ0HQTilZQU1hllZ4c7yMNtMgMIaPgEBrStLX1Ufr6LpDkTA4VeaPCSqstHt9WbRzIoPQ1fCxjvHBP17ShiGPRza9p_Z4t897s40aQMKbKLqLQ8rEaYAcsoRBXYyUhb_PRS-YZtIdo7iVmkMVFjYjHvmYbpYhNo57Z1Y5dNa8h8-4ON4CXzcJ1RzuyuFVz1a3YL3gWTsiliVmno7vKyRo8utirDRIPi0dPJPuWi2uMtJkqdkpzJQ\" > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJ pbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwian RpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiY mFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdfQ.X2mHWCr8A5UaJFvjSPUammACnTzFsTdre-P5y WQgrwLBmfcpr9JaUuq4sEwp6to3xSKN7u9QKqRLuWH1SlcphDQn6kdF1ZrCgXRQ0HQTilZQU1hllZ4c 7yMNtMgMIaPgEBrStLX1Ufr6LpDkTA4VeaPCSqstHt9WbRzIoPQ1fCxjvHBP17ShiGPRza9p_Z4t897 s40aQMKbKLqLQ8rEaYAcsoRBXYyUhb_PRS-YZtIdo7iVmkMVFjYjHvmYbpYhNo57Z1Y5dNa8h8-4ON4 CXzcJ1RzuyuFVz1a3YL3gWTsiliVmno7vKyRo8utirDRIPi0dPJPuWi2uMtJkqdkpzJQ > < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure A request with a correct \"scope\" attribute will result in a successful invocation. An example of a JWT that has the correct \"scope\" attribute is as follows. { \"sub\": \"ballerina\", \"iss\": \"ballerina\", \"exp\": 2818415019, \"iat\": 1524575019, \"jti\": \"f5aded50585c46f2b8ca233d0c2a3c9d\", \"aud\": [ \"ballerina\", \"ballerina.org\", \"ballerina.io\" ], \"scope\": \"hello\" } curl -k -v https://localhost:9091/hello -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwianRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiYmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdLCJzY29wZSI6ImhlbGxvIn0.bNoqz9_DzgeKSK6ru3DnKL7NiNbY32ksXPYrh6Jp0_O3ST7WfXMs9WVkx6Q2TiYukMAGrnMUFrJnrJvZwC3glAmRBrl4BYCbQ0c5mCbgM9qhhCjC1tBA50rjtLAtRW-JTRpCKS0B9_EmlVKfvXPKDLIpM5hnfhOin1R3lJCPspJ2ey_Ho6fDhsKE3DZgssvgPgI9PBItnkipQ3CqqXWhV-RFBkVBEGPDYXTUVGbXhdNOBSwKw5ZoVJrCUiNG5XD0K4sgN9udVTi3EMKNMnVQaq399k6RYPAy3vIhByS6QZtRjOG8X93WJw-9GLiHvcabuid80lnrs2-mAEcstgiHVw' > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZX JpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwia nRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwi YmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdLCJzY29wZSI6ImhlbGxvIn0.bNoqz9_DzgeKSK6 ru3DnKL7NiNbY32ksXPYrh6Jp0_O3ST7WfXMs9WVkx6Q2TiYukMAGrnMUFrJnrJvZwC3glAmRBrl4BY CbQ0c5mCbgM9qhhCjC1tBA50rjtLAtRW-JTRpCKS0B9_EmlVKfvXPKDLIpM5hnfhOin1R3lJCPspJ2e y_Ho6fDhsKE3DZgssvgPgI9PBItnkipQ3CqqXWhV-RFBkVBEGPDYXTUVGbXhdNOBSwKw5ZoVJrCUiNG 5XD0K4sgN9udVTi3EMKNMnVQaq399k6RYPAy3vIhByS6QZtRjOG8X93WJw-9GLiHvcabuid80lnrs2- mAEcstgiHVw > < HTTP/1.1 200 OK < content-type: text/plain < Hello, World! OAuth2 Inbound Authentication and Authorization Ballerina supports OAuth2 Authentication and Authorization for services. The http:BearerAuthHandler is used to extract the HTTP Authorization header from the request and extract the credentials from the header value, which is the Bearer <token>. Then, the extracted credentials will be passed to the initialized AuthProvider to get them validated. The oauth2:InboundOAuth2Provider is used to validate the credentials passed by the AuthHandler against the introspection endpoint configured at oauth2:IntrospectionServerConfig, which is provided by the user. OAuth2 token validation requires several additional configurations for the oauth2:IntrospectionServerConfig including: url - URL of the introspection server tokenTypeHint - A hint about the type of the token submitted for introspection clientConfig - HTTP client configurations, which calls the introspection server The oauth2:IntrospectionServerConfig record should be provided into the oauth2:InboundOAuth2Provider when initializing and the initialized oauth2:InboundOAuth2Provider is passed to the http:BearerAuthHandler. import ballerina/http; import ballerina/oauth2; oauth2:InboundOAuth2Provider oauth2Provider = new({ url: \"https://localhost:9196/oauth2/token/introspect\", tokenTypeHint: \"access_token\" }); http:BearerAuthHandler oauth2Handler = new(oauth2Provider); listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [oAuth2Handler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); @http:ServiceConfig { basePath: \"/hello\" } service helloWorld on secureHelloWorldEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/\" } resource function sayHello(http:Caller caller, http:Request req) { http:Response resp = new; resp.setTextPayload(\"Hello, World!\"); checkpanic caller->respond(resp); } } When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur: curl -k -v https://localhost:9091/hello > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure Once a request is made with a valid, authentication information, but if the introspection endpoint does not respond with the \"scope\" attribute of the response JSON payload or respond with the \"scope\" attribute, which are not the expected scopes, an authorization failure will occur. curl -k -v https://localhost:9091/hello -H \"Authorization:Bearer <token>\" > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer <token> > < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure A request, which gets a successful response from the introspection endpoint with a correct \"scope\" attribute will result in a successful invocation. curl -k -v https://localhost:9091/hello -H 'Authorization: Bearer <token>' > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> > < HTTP/1.1 200 OK < content-type: text/plain < Hello, World! LDAP Inbound Authentication and Authorization Ballerina supports LDAP Authentication and Authorizations for services. The http:BasicAuthHandler is used to extract the HTTP Authorization header from the request and extract the credentials from the header value, which is Basic <token>. Then, the extracted credentials will be passed to the initialized AuthProvider to get validated. The ldap:InboundLdapAuthProvider is used to validate the credentials passed by the AuthHandler against the LDAP server configured at ldap:LdapConnectionConfig, which is provided by the user. LDAP token validation requires several additional configurations for the ldap:LdapConnectionConfig including: domainName - Unique name to identify the user store connectionURL - Connection URL to the LDAP server connectionName - The username to connect to the LDAP server connectionPassword - Password for the ConnectionName user userSearchBase - DN of the context or object under which the user entries are stored in the LDAP server userEntryObjectClass - Object class used to construct user entries userNameAttribute - The attribute used for uniquely identifying a user entry userNameSearchFilter - Filtering criteria used to search for a particular user entry userNameListFilter - Filtering criteria for searching user entries in the LDAP server groupSearchBase - DN of the context or object under which the group entries are stored in the LDAP server groupEntryObjectClass - Object class used to construct group entries groupNameAttribute - The attribute used for uniquely identifying a group entry groupNameSearchFilter - Filtering criteria used to search for a particular group entry groupNameListFilter - Filtering criteria for searching group entries in the LDAP server membershipAttribute - Define the attribute that contains the distinguished names (DN) of user objects that are in a group userRolesCacheEnabled - To indicate whether to cache the role list of a user connectionPoolingEnabled - Define whether LDAP connection pooling is enabled connectionTimeoutInMillis - Timeout in making the initial LDAP connection readTimeoutInMillis - Read timeout in milliseconds for LDAP operations retryAttempts - Retry the authentication request if a timeout happened secureClientSocket - The SSL configurations for the LDAP client socket. This needs to be configured in order to communicate through LDAPs The ldap:LdapConnectionConfig record should be provided into the ldap:InboundLdapAuthProvider when initializing and the initialized ldap:InboundLdapAuthProvider is passed to the http:BasicAuthHandler. import ballerina/http; import ballerina/ldap; ldap:LdapConnectionConfig ldapConfig = { domainName: \"ballerina.io\", connectionURL: \"ldap://localhost:20100\", connectionName: \"uid=admin,ou=system\", connectionPassword: \"secret\", userSearchBase: \"ou=Users,dc=ballerina,dc=io\", userEntryObjectClass: \"identityPerson\", userNameAttribute: \"uid\", userNameSearchFilter: \"(&(objectClass=person)(uid=?))\", userNameListFilter: \"(objectClass=person)\", groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"], groupEntryObjectClass: \"groupOfNames\", groupNameAttribute: \"cn\", groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\", groupNameListFilter: \"(objectClass=groupOfNames)\", membershipAttribute: \"member\", userRolesCacheEnabled: true, connectionPoolingEnabled: false, connectionTimeoutInMillis: 5000, readTimeoutInMillis: 60000, retryAttempts: 3 }; ldap:InboundLdapAuthProvider ldapAuthProvider = new(ldapConfig, \"ldap01\"); http:BasicAuthHandler ldapAuthHandler = new(ldapAuthProvider); listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [ldapAuthHandler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); @http:ServiceConfig { basePath: \"/hello\", auth: { scopes: [\"hello\"] } } service helloWorld on secureHelloWorldEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/\" } resource function sayHello(http:Caller caller, http:Request req) { http:Response resp = new; resp.setTextPayload(\"Hello, World!\"); checkpanic caller->respond(resp); } } When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur: curl -k -v https://localhost:9091/hello > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure Once a request is made with a valid, authentication information, but if the LDAP server responds with an empty group list or unexpected scopes, an authorization failure will occur. curl -k -v https://localhost:9091/hello -H \"Authorization: Basic <token>\" > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer <token> > < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure A request, which gets a successful response from the LDAP server for the \"scope\" request will result in a successful invocation. curl -k -v https://localhost:9091/hello -H 'Authorization: Basic <token>' > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> > < HTTP/1.1 200 OK < content-type: text/plain < Hello, World! Basic Auth Inbound Authentication and Authorization Ballerina supports Basic Authentication and Authorizations for services. The http:BasicAuthHandler is used to extract the HTTP Authorization header from the request and extract the credential from the header value, which is the Basic <token>. Then, the extracted credentials will be passed to the initialized AuthProvider and gets validated. The jwt:InboundBasicAuthProvider is used to read the user information from the configuration file and authenticate the credentials passed by the AuthHandler. import ballerina/auth; import ballerina/http; auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider); listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [basicAuthHandler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); @http:ServiceConfig { basePath: \"/hello\", auth: { scopes: [\"hello\"] } } service helloWorld on secureHelloWorldEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/\" } resource function sayHello(http:Caller caller, http:Request req) { http:Response resp = new; resp.setTextPayload(\"Hello, World!\"); checkpanic caller->respond(resp); } } To enforce Basic Authentication, users and scopes should be configured through a configuration file. The following example file introduces two users. The 'generalUser` has no scopes and the 'admin' user has the 'hello' scope. sample-users.toml [b7a.users] [b7a.users.generalUser] password=\"@encrypted:{pIQrB9YfCQK1eIWH5d6UaZXA3zr+60JxSBcpa2PY7a8=}\" [b7a.users.admin] password=\"@encrypted:{pIQrB9YfCQK1eIWH5d6UaZXA3zr+60JxSBcpa2PY7a8=}\" scopes=\"hello\" Restart the service using the following command. ballerina run --config sample-users.toml basic_auth_sample.bal Since passwords are encrypted, the Config API will request for the decryption key. Use 'ballerina' as the decryption key in this sample. Also, the passwords can be hashed and provided with the configuration file. The following example file introduces three users along with the passwords hashed with sha256, sha384, and sha512 hashing algorithms. sample-users.toml [b7a.users] [b7a.users.userA] password=\"@sha256:{cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860}\" [b7a.users.userB] password=\"@sha384:{1249e15f035ed34786a328d9fdb2689ab24f7c7b253d1b7f66ed92a679d663dd502d7beda59973e8c91a728b929fc8cd}\" [b7a.users.userC] password=\"@sha512:{9057ff1aa9509b2a0af624d687461d2bbeb07e2f37d953b1ce4a9dc921a7f19c45dc35d7c5363b373792add57d0d7dc41596e1c585d6ef7844cdf8ae87af443f}\" Once the service is restarted with the first configuration file in place, the 'generalUser' will not be able to invoke the service due to authorization failure: curl -k -v -u generalUser:password https://localhost:9091/hello > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure 'Admin' users will be able to invoke the service: curl -k -v -u admin:password https://localhost:9091/hello > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* < HTTP/1.1 200 OK < content-type: text/plain < Hello, World! Outbound Authentication & Authorization The Ballerina HTTP client can be configured to send authentication and authorization information to the endpoint being invoked. Ballerina has built-in support for the following outbound authentication mechanisms, whereas it is possible to add custom mechanisms: Basic authentication JWT authentication OAuth2 authentication Ballerina outbound authentication is also abstracted out into 2 layers called http:OutboundAuthHandler and auth:OutboundAuthProvider. The auth:OutboundAuthProvider is a protocol-independent entity, which only knows how to generate credentials with the necessary information provided by the user. The http:OutboundAuthHandler can be protocol dependent. Even-though the current focus is on HTTP, the ballerina/auth module can operate with other protocols as well. The auth:OutboundAuthProvider is used to create the credentials according to the provided configurations. The http:OutboundAuthHandler is used to get the created credentials from the auth:OutboundAuthProvider and perform HTTP-level actions, which are adding the required HTTP headers or body using the received credentials. In a particular authentication scheme, the implemented instance of the auth:OutboundAuthProvider is initialized with required configurations and it is passed to the implemented instance of the http:OutboundAuthHandler. Next, the implemented instance of the http:OutboundAuthHandler is passed to the http:Client configuration as follows and the client is initialized with authentication. The following example represents how a client is secured with Basic Auth with the above-mentioned configurations. import ballerina/auth; import ballerina/http; auth:OutboundBasicProvider basicAuthProvider = new({ username: \"user\", password: \"ballerina\" }); http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider); http:Client secureHelloWorldClient = new(\"https://localhost:9092\", { auth: { authHandler: basicAuthHandler }, secureSocket: { trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); Note: It is better to use HTTPS when enforcing authentication and authorization checks to ensure the confidentiality of sensitive authentication data. Outbound Advanced Use Cases Implementing Outbound Custom Authentication Mechanism The user can implement a custom version of the AuthHandler and AuthProvider with the use of the object equivalency pattern as follows. With that, the http:Client can be enforced with custom authentication and authorization mechanisms. public type OutboundCustomAuthHandler object { *http:OutboundAuthHandler; public function prepare(http:Request req) returns http:Request\"http:AuthenticationError { // Custom logic to prepare the request. } public function inspect(http:Request req, http:Response resp) returns http:Request\"http:AuthenticationError? { // Custom logic to inspect the request after the initial outbound call. } }; public type OutboundCustomAuthProvider object { *auth:OutboundAuthProvider; public function generateToken() returns string\"auth:Error { // Custom logic to generate the token. } public function inspect(map<anydata> data) returns string\"auth:Error? { // Custom logic to inspect the data map received from the AuthHandler. } }; JWT Outbound Authentication Ballerina supports JWT Authentication for clients. The jwt:OutboundJwtAuthProvider is used to issue a JWT against the jwt:JwtIssuerConfig provided by the user. The http:BearerAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Bearer <token>. JWT issuing requires several additional configurations for the jwt:JwtIssuerConfig including: username - JWT token username issuer - JWT token issuer audience - JWT token audience customClaims - Map of custom claims expTime - JWT token expiry time keyStoreConfig - JWT key store configurations keyStore - Keystore to be used in JWT signing keyAlias - Signing key alias keyPassword - Signing key password signingAlg - JWT signing algorithm jwt:RS256 - The RSA-SHA256 algorithm jwt:RS384 - The RSA-SHA384 algorithm jwt:RS512 - The RSA-SHA512 algorithm jwt:NONE - Unsecured JWTs (no signing) The jwt:JwtIssuerConfig record should be provided into the jwt:OutboundJwtAuthProvider when initializing and the initialized jwt:OutboundJwtAuthProvider is passed to the http:BearerAuthHandler. import ballerina/http; import ballerina/jwt; jwt:OutboundJwtAuthProvider jwtAuthProvider = new({ username: \"ballerinaUser\", issuer: \"ballerina\", audience: [\"ballerina.io\"], keyStoreConfig: { keyAlias: \"ballerina\", keyPassword: \"ballerina\", keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); http:BearerAuthHandler jwtAuthHandler = new(jwtAuthProvider); http:Client downstreamServiceEP = new(\"https://localhost:9091\", { auth: { authHandler: jwtAuthHandler }, secureSocket: { trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); The http:Client defined in the program calls the the http:Listener, which is secured with JWT authentication (For more information, see the example added under JWT inbound authentication). OAuth2 Outbound Authentication Ballerina supports OAuth2 Authentication for clients. It supports the Client Credentials grant type, Password grant type, and Direct Token mode, in which, the credentials can be provided manually and after that refreshing is handled internally. The oauth2:OutboundOAuth2Provider is used to create a token against the configuration provided by the user. It can be the oauth2:ClientCredentialsGrantConfig, oauth2:PasswordGrantConfig, or oauth2:DirectTokenConfig according to the grant type that is required by the user. The http:BearerAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Bearer <token>. Client Credentials Grant Type OAuth2 token issuing requires several additional configurations for the oauth2:ClientCredentialsGrantConfig including: tokenUrl - Token URL for the authorization endpoint clientId - Client ID for the client credentials grant authentication clientSecret - Client secret for the client credentials grant authentication scopes - Scope of the access request clockSkewInSeconds - Clock skew in seconds retryRequest - Retry the request if the initial request returns a 401 response credentialBearer - How authentication credentials are sent to the authorization endpoint http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header http:POST_BODY_BEARER \" NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request clientConfig - HTTP client configurations,which calls the authorization endpoint The oauth2:ClientCredentialsGrantConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler. import ballerina/http; import ballerina/oauth2; oauth2:OutboundOAuth2Provider oauth2Provider = new({ tokenUrl: \"https://localhost:9196/oauth2/token/authorize\", clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68\", clientSecret: \"9205371918321623741\", scopes: [\"token-scope1\", \"token-scope2\"] }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider); http:Client downstreamServiceEP = new(\"https://localhost:9091\", { auth: { authHandler: oauth2AuthHandler }, secureSocket: { trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); Password Grant Type OAuth2 token issuing requires several additional configurations for the oauth2:PasswordGrantConfig including: tokenUrl - Token URL for the authorization endpoint username - Username for password grant authentication password - Password for password grant authentication clientId - Client ID for password grant authentication clientSecret - Client secret for password grant authentication scopes - Scope of the access request refreshConfig - Configurations for refreshing the access token refreshUrl - Refresh token URL for the refresh token server scopes - Scope of the access request credentialBearer - How authentication credentials are sent to the authorization endpoint clientConfig - HTTP client configurations, which calls the authorization endpoint clockSkewInSeconds - Clock skew in seconds retryRequest - Retry the request if the initial request returns a 401 response credentialBearer - How authentication credentials are sent to the authorization endpoint http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header http:POST_BODY_BEARER\"NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request clientConfig - HTTP client configurations, which calls the authorization endpoint The oauth2:PasswordGrantConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler. import ballerina/http; import ballerina/oauth2; oauth2:OutboundOAuth2Provider oauth2Provider = new({ tokenUrl: \"https://localhost:9196/oauth2/token/authorize\", username: \"johndoe\", password: \"A3ddj3w\", clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68\", clientSecret: \"9205371918321623741\", scopes: [\"token-scope1\", \"token-scope2\"], refreshConfig: { refreshUrl: \"https://localhost:9196/oauth2/token/refresh\", scopes: [\"token-scope1\", \"token-scope2\"] } }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider); http:Client downstreamServiceEP = new(\"https://localhost:9091\", { auth: { authHandler: oauth2AuthHandler }, secureSocket: { trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); Direct Token Mode OAuth2 token issuing requires several additional configurations for the oauth2:DirectTokenConfig including: accessToken - Access token for the authorization endpoint refreshConfig - Configurations for refreshing the access token refreshUrl - Refresh token URL for the refresh token server refreshToken - Refresh token for the refresh token server clientId - Client ID for authentication with the authorization endpoint clientSecret - Client secret for authentication with the authorization endpoint scopes - Scope of the access request credentialBearer - How authentication credentials are sent to the authorization endpoint clientConfig - HTTP client configurations, which calls the authorization endpoint clockSkewInSeconds - Clock skew in seconds retryRequest - Retry the request if the initial request returns a 401 response credentialBearer - How authentication credentials are sent to the authorization endpoint http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header http:POST_BODY_BEARER\"NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request The oauth2:DirectTokenConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler. import ballerina/http; import ballerina/oauth2; oauth2:OutboundOAuth2Provider oauth2Provider = new({ accessToken: \"34060588-dd4e-36a5-ad93-440cc77a1cfb\", refreshConfig: { refreshToken: \"15160398-ae07-71b1-aea1-411ece712e59\", refreshUrl: \"https://ballerina.io/sample/refresh\", clientId: \"rgfKVdnMQnJSSr_pKFTxj3apiwYa\", clientSecret: \"BRebJ0aqfclQB9v7yZwhj0JfW0ga\" } }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider); http:Client downstreamServiceEP = new(\"https://localhost:9091\", { auth: { authHandler: oauth2AuthHandler }, secureSocket: { trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); Basic Auth Outbound Authentication Ballerina supports Basic Authentication for clients. The auth:OutboundBasicAuthProvider is used to create a token against the auth:Credential provided by the user. The http:BasicAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Basic <token>. Token issuing requires several additional configurations for the auth:Credential config including: username - The username for Basic authentication password - The password for Basic authentication The auth:Credential record should be provided into the auth:OutboundBasicAuthProvider when initializing and the initialized auth:OutboundBasicAuthProvider is passed to the http:BasicAuthHandler. import ballerina/auth; import ballerina/http; auth:OutboundBasicProvider basicAuthProvider = new({ username: \"user\", password: \"ballerina\" }); http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider); http:Client downstreamServiceEP = new(\"https://localhost:9091\", { auth: { authHandler: basicAuthHandler }, secureSocket: { trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); Token Propagation for Outbound Authentication Ballerina supports token propagation for outbound authentication. The token propagation happens if the user does not provide any configuration when initializing the auth:OutboundAuthProvider. The auth:OutboundAuthProvider reads the token/username from the runtime:InvocationContext according to the outbound authentication scheme and uses that for the outbound request. The runtime:InvocationContext is initialized based on the authentication information from the inbound request. Example - 1 The following program has an http:Client secured with Basic authentication and it is configured inside an http:Listener secured with Basic authentication. The auth:OutboundBasicAuthProvider is initialized without providing any configurations. Therefore, the program gets the token from the runtime:InvocationContext and uses it for the outbound request. If the downstream service is also secured with Basic authentication and as same as the upstream service, the user does not need to configure the client. NOTE: This scenario is the same for all the scenarios where both the upstream and downstream services are secured using the same authentication scheme and clients are also configured using the same authentication scheme but without any configurations. The token propagation happens internally. import ballerina/auth; import ballerina/http; auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new(inboundBasicAuthProvider); listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [inboundBasicAuthHandler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); auth:OutboundBasicAuthProvider outboundBasicAuthProvider = new; http:BasicAuthHandler outboundBasicAuthHandler = new(outboundBasicAuthProvider); http:Client downstreamClientEP = new(\"https://localhost:9092\", { auth: { authHandler: outboundBasicAuthHandler }, secureSocket: { trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); @http:ServiceConfig { basePath: \"/hello\", auth: { scopes: [\"hello\"] } } service helloWorld on secureHelloWorldEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/\" } resource function sayHello(http:Caller caller, http:Request req) returns error? { // http:Request req = new; http:Response response = check downstreamClientEP->get(\"/downstream\"); checkpanic caller->respond(response); } } // ---------------------------------------------- // Following code creates the downstream service // ---------------------------------------------- listener http:Listener downstreamServiceEp = new(9092, { auth: { authHandlers: [inboundBasicAuthHandler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); @http:ServiceConfig { basePath: \"/downstream\" } service downStreamService on downstreamServiceEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/\" } resource function downStreamResource(http:Caller caller, http:Request req) { http:Response resp = new; resp.setTextPayload(\"Downstream service received authenticated request with the token: \" + req.getHeader(\"Authorization\")); checkpanic caller->respond(resp); } } To enforce Basic Authentication, create a configuration file as follows: sample-users.toml [b7a.users] [b7a.users.tom] password=\"123\" scopes=\"hello\" Start the service using the following command after creating the sample-users.toml file. ballerina run --config sample-users.toml example.bal The 'Tom' user will be able to invoke the /hello resource and invoke the Basic Auth protected downstream service. curl -k -v -u tom:123 https://localhost:9091/hello > GET /hello HTTP/1.1 > Host: localhost:9091 > Authorization: Basic dG9tOjEyMw== > User-Agent: curl/7.60.0 > Accept: */* < HTTP/1.1 200 OK < content-type: text/plain < content-length: 602 < Downstream service received authenticated request with the token: Basic dG9tOjEyMw== Example - 2 The following program has an http:Client secured with JWT authentication and it is configured inside an http:Listener secured with Basic Authentication. The jwt:OutboundJwtAuthProvider is initialized using the provides configurations but without the username. Therefore, the program gets the username from the runtime:InvocationContext, which is set based on the inbound authentication information and uses it for the outbound request. In this example, the downstream service is secured using JWT authentication and expects a JWT issued against the user authenticating by the upstream service (protected by Basic authentication). Ballerina can dynamically issue such JWT while propagating the user information internally. import ballerina/auth; import ballerina/http; import ballerina/jwt; auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new(inboundBasicAuthProvider); listener http:Listener secureHelloWorldEp = new(9091, { auth: { authHandlers: [inboundBasicAuthHandler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); jwt:OutboundJwtAuthProvider outboundJwtAuthProvider = new({ issuer: \"ballerina\", audience: [\"ballerina.io\"], keyStoreConfig: { keyAlias: \"ballerina\", keyPassword: \"ballerina\", keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); http:BearerAuthHandler outboundJwtAuthHandler = new(outboundJwtAuthProvider); http:Client downstreamClientEP = new(\"https://localhost:9092\", { auth: { authHandler: outboundJwtAuthHandler }, secureSocket: { trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } } }); @http:ServiceConfig { basePath: \"/hello\", auth: { scopes: [\"hello\"] } } service helloWorld on secureHelloWorldEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/\" } resource function sayHello(http:Caller caller, http:Request req) returns error? { // http:Request req = new; http:Response response = check downstreamClientEP->get(\"/downstream\"); checkpanic caller->respond(response); } } // ---------------------------------------------- // Following code creates the downstream service // ---------------------------------------------- jwt:InboundJwtAuthProvider inboundJwtAuthProvider = new({ issuer: \"ballerina\", audience: [\"ballerina.io\"], certificateAlias: \"ballerina\", trustStore: { path: \"${ballerina.home}/bre/security/ballerinaTruststore.p12\", password: \"ballerina\" } }); http:BearerAuthHandler inboundJwtAuthHandler = new(inboundJwtAuthProvider); listener http:Listener downstreamServiceEp = new(9092, { auth: { authHandlers: [inboundJwtAuthHandler] }, secureSocket: { keyStore: { path: \"${ballerina.home}/bre/security/ballerinaKeystore.p12\", password: \"ballerina\" } } }); @http:ServiceConfig { basePath: \"/downstream\" } service downStreamService on downstreamServiceEp { @http:ResourceConfig { methods: [\"GET\"], path: \"/\" } resource function downStreamResource(http:Caller caller, http:Request req) { http:Response resp = new; resp.setTextPayload(\"Downstream service received authenticated request with the token: \" + req.getHeader(\"Authorization\")); checkpanic caller->respond(resp); } } To enforce Basic Authentication, create a configuration file as follows: sample-users.toml [b7a.users] [b7a.users.tom] password=\"123\" scopes=\"hello\" Start the service using the following command after creating the sample-users.toml file. ballerina run --config sample-users.toml example.bal The 'Tom' user will be able to invoke the /hello resource and invoke the Basic Auth protected downstream service. curl -k -v -u tom:123 https://localhost:9091/hello > GET /hello HTTP/1.1 > Host: localhost:9091 > Authorization: Basic dG9tOjEyMw== > User-Agent: curl/7.60.0 > Accept: */* < HTTP/1.1 200 OK < content-type: text/plain < content-length: 602 < Downstream service received authenticated request with the token: Bearer eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QifQ==.eyJzdWIiOiJ0b20iLCAiaXNzIjoiYmFsbGVyaW5hIiwgImV4cCI6MTU2NTUwMzUzNywgImlhdCI6MTU2NTUwMzIzNywgImp0aSI6ImJhMjczNTM5LTcxZWItNDExOC04MzNiLTQyNDlhMjY0MmZmNCIsICJhdWQiOlsiYmFsbGVyaW5hLmlvIl19.OwMHPrQfjpIujHSAIq3ycKsP4SYTR2nW9lBHXBOgIZV6-FcM1Lxz8xtjY1AwcIAd_L4XmiODN_5HYUluZb3jDj1F6ZeI4FQeTKygiGgJs_nTww56bHFQXPe9_IW1zxRGM8G51cJBKxTH6YsOTXgNVhcGoe5f-kaESmGze-XLCnCXgj0GYnG2ECnejSHRh89gjWMyfyMFRDhioPi9IYZEQGIFBQzrModFWXNKQZh5vxaF5KW4KWXLTRgrBX8uY2IIS6S80nf83oaUlrrApieaGf88cwSqOjGjaPpxj3I810qGa996ZVE3P5DkzgxrJYHrJMwcVgBX7sgDFUUcD3RrEA=="},{"page":"/learn/how-to-test-ballerina-code","content":" layout: ballerina-inner-page title: How to Test Ballerina Code permalink: /learn/how-to-test-ballerina-code/ How to Test Ballerina Code Ballerina has a built-in test framework named Testerina. Testerina enables developers to write testable code. The test framework provides a set of building blocks to help write tests and a set of tools to help test. Developers and testers can cover multiple levels of the test pyramid including unit testing, integration testing and end to end testing with the building blocks the framework provides. It provides the flexibility to programmers and testers to build intelligent tests that suit the domain and application needs. Testerina design and usage is aligned with project and module semantics of Ballerina. You can test the project modules while you are building the project in a seamless manner using the test constructs. Overview Ballerina programmers can place their test code in a tests folder in a module Ballerina tests are defined using a set of annotations Test assertions can be used to verify the set of program behaviour expectations Data providers can be used to feed in the test data sets Service calls can be tested using service skeletons in the test phase of the project until the system is connected to the real service Function mocks can be used to mimic third party function calls to enable testing a project module in isolation Writing and Running Tests To write tests, you need to import the test module in all Ballerina test source files. import ballerina/test; For structured projects, it is recommended to use a structured test model that is aligned with standard module semantics. Structured test model consists of a seperate tests directory in a Ballerina module, which allows you to isolate the source from the tests. In a standard Ballerina project, a module is mapped to a test suite. Unit and integration tests bound to a module need to be placed in a subfolder called tests/ within the module. All tests within a module's tests/ subfolder are considered to be part of the same test suite. Project Structure project-name/ - Ballerina.toml - src/ -- mymodule/ --- Module.md <- module level documentation --- main.bal <- Contains default main method. --- resources/ <- resources for the module (available at runtime) --- tests/ <- tests for this module (e.g. unit tests) ---- testmain.bal <- test file for main ---- resources/ <- resources for these tests The test source files could have any name. The test functions are just Ballerina functions that use a special annotation to mark the function as a test. Test functions must be specified with the @test:Config { } annotation and there is no restriction on the test function name. The ballerina test command can be used to execute tests. Execute tests within the specified module with the following command. ballerina test <module_name> Execute tests in the entire project, using the --all option. ballerina test --all For more information on the test command, run the following. ballerina help test Annotations Testerina defines the following test annotations. @test:BeforeSuite {} The function specified following the annotation will be run once before any of the tests in the test suite is run. This can be used for initializing test suite level aspects. @test:BeforeSuite {} function testSuiteInitialize() { // module level test initialization logic here } Sample : import ballerina/io; import ballerina/test; // The `BeforeSuite` function is executed before all test functions in this module. @test:BeforeSuite function beforeFunc() { io:println(\"I'm the before suite function!\"); } // Test function. @test:Config {} function testFunction1() { io:println(\"I'm in test function 1!\"); test:assertTrue(true, msg = \"Failed\"); } // Test function. @test:Config {} function testFunction2() { io:println(\"I'm in test function 2!\"); test:assertTrue(true, msg = \"Failed\"); } @test:BeforeEach {} The function specified following the annotation will be run before every test within the test suite is run. This can be used for repeatedly initializing test level aspects before every test function. @test:BeforeEach {} function beforeEachTest() { // test initialization logic here to be // executed before each test being run } Sample : import ballerina/io; import ballerina/test; // Before each function, which is executed before each test function @test:BeforeEach function beforeFunc() { io:println(\"I'm the before function!\"); } // Test function @test:Config {} function testFunction1() { io:println(\"I'm in test function 1!\"); test:assertTrue(true, msg = \"Failed!\"); } // Test function @test:Config {} function testFunction2() { io:println(\"I'm in test function 2!\"); test:assertTrue(true, msg = \"Failed!\"); } // Test function @test:Config {} function testFunction3() { io:println(\"I'm in test function 3!\"); test:assertTrue(true, msg = \"Failed!\"); } @test:Config {} The function specified following the annotation is a test function. This annotation supports the following parameters. Annotation Value Fields: enable: {true \" false}: Enable/disable the test. Default: true before: \"<function name>\": Name of the function to be run just before the test is run. Default: none after: \"<function name>\": Name of the function to be run just after the test is run. dependsOn: [\"<function names>\", ]: A list of function names the test function depends on, and will be run before the test. The list of functions provided has no order of execution. The current test function will depend on the list provided and that list will run in whatever order, the order in which the comma separated list appears has no prominence. In case there needs to be an order, the way to do that is to define a sequence of test functions with one point to another based on dependency using dependsOn parameter in each one's config. dataProvider: \"<function name>\": Specifies the name of the function that will be used to provide the value sets to execute the test against. The given Ballerina function should return an array of arrays (e.g., string[][] for a test function that accepts string parameters). Each array of the returned array of arrays should have a length similar to the number of arguments of the function (e.g., function testSuffixC(string input, string expected) could have a dataProvider function that returns a string[][] like [ [\"ab\", \"abc\"], [\"de\", \"dec\"] ] ). The length of the array of arrays represents the number of time the same test case would run (e.g., in the above example the test function testSuffixC would run 2 times with input parameters \"ab\", \"abc\" and \"de\", \"dec\" respectively). groups: [\"<test group name\", ]: List of test group names (one or more) that this test belongs to. You can group a given test to a list of named test groups using this configuration. @test:Config { before: \"beforeTestBar\", after: \"afterTestBar\", dependsOn: [\"testFunctionPre1\", \"testFuncctionPre2\"], groups: [\"group1\"] } function testBar() { // test logic for function bar() } Sample : import ballerina/io; import ballerina/test; function beforeFunc() { // This is the before Test Function } function afterFunc() { // This is the before Test Function } // This test function depends on `testFunction3`. @test:Config { before: \"beforeFunc\", // You can provide a list of depends on functions here. dependsOn: [\"testFunction3\"], groups:[\"group1\"], after:\"afterFunc\" } function testFunction1() { io:println(\"I'm in test function 1!\"); test:assertTrue(true, msg = \"Failed!\"); } // This is a random test function, this will randomly execute without depending on other functions. // But note that other function do depend on this. @test:Config {} function testFunction3() { io:println(\"I'm in test function 3!\"); test:assertTrue(true, msg = \"Failed!\"); } @test:AfterSuite {} The function specified following the annotation will be run once after all of the tests in the test suite is run. This can be used for cleaning up test suite level aspects. The test suite covers tests related to a module. @test:AfterSuite {} function testSuiteCleanup() { // module level test cleanup logic here } Sample : import ballerina/io; import ballerina/test; // Test function. @test:Config {} function testFunction1() { io:println(\"I'm in test function 1!\"); test:assertTrue(true, msg = \"Failed\"); } // The `AfterSuite` function is executed after all the test functions in this module. @test:AfterSuite function afterFunc() { io:println(\"I'm the after suite function!\"); } Assertions Testerina supports the following assertions. assertTrue(boolean expression, string message) Asserts that the expression is true with an optional message. import ballerina/test; @test:Config {} function testAssertTrue() { boolean value = false; test:assertTrue(value, msg = \"AssertTrue failed\"); } assertFalse(boolean expression, string message) Asserts that the expression is false with an optional message. import ballerina/test; @test:Config {} function testAssertFalse() { boolean value = false; test:assertFalse(value, msg = \"AssertFalse failed\"); } assertEquals(Any actual, Any expected, string message) Asserts that the actual is equal to the expected, with an optional message. import ballerina/test; @test:Config {} function testAssertIntEquals() { int answer = 0; int a = 5; int b = 3; answer = intAdd(a, b); test:assertEquals(answer, 8, msg = \"IntAdd function failed\"); } function intAdd(int a, int b) returns (int) { return (a + b); } assertNotEquals(Any actual, Any expected, string message) Asserts that the actual is not equal to the expected, with an optional message. import ballerina/test; @test:Config {} function testAssertIntEquals() { int answer = 0; int a = 5; int b = 3; answer = intAdd(a, b); test:assertNotEquals(answer, 8, msg = \"Matches\"); } function intAdd(int a, int b) returns (int) { return (a + b); } assertFail(string message) Fails the test. Useful when we want to fail a test while in execution based on a check for a condition. import ballerina/test; @test:Config {} function foo() { error? e = trap bar(); // Expecting `bar()` to panic if (e is error) { test:assertEquals(e.reason(), \"Invalid Operation\", msg = \"Invalid error reason\"); // Some other assertions } else { test:assertFail(msg = \"Expected an error\"); } } Service Skeleton Start/Stop Utility Testerina provides the functionality to start/stop service skeletons generated from OpenAPI definitions. test:startServiceSkeleton(string moduleName, string openApiFilePath) (boolean isSuccessful) Start a service skeleton from a given OpenAPI definition in the given Ballerina module. If it is successful, it returns true. Alternatively, it returns false or throws an exception. For example: boolean isSuccessful = test:startServiceSkeleton(\"petstore.service.skeleton\", \"/tmp/petstore.yaml\"); When the tests are executing service skeleton related to the Ballerina service definition will be generated and started. The host names and ports you have defined in the OpenAPI definition will be used when starting the services. You can then invoke this service skeleton using a HTTP client endpoint, just like a normal Ballerina service. test:stopServiceSkeleton (string moduleName) Stop a service skeleton and cleanup created directories of a given Ballerina module. This function would first try to stop the service that was created using test:startServiceSkeleton function and then would try to clean up the directories created. test:stopServiceSkeleton(\"petstore.service.skeleton\"); The following sample explains how you can start and stop a skeleton service based on an OpenAPI definition. import ballerina/config; import ballerina/http; import ballerina/test; string uri = \"http://0.0.0.0:9095/v1\"; boolean isServiceSkeletonStarted = false; function init() { // Starting the OpenAPI based service isServiceSkeletonStarted = test:startServiceSkeleton(\"mymodule\", \"<PATH_TO_OPENAPI_DEFINITION>/petstore.yaml\"); } function clean() { // Stopping the swager based service test:stopServiceSkeleton(\"mymodule\"); } @test:Config { before: \"init\", after: \"clean\" } function testService() { http:Client clientEndpoint = new(uri); test:assertTrue(isServiceSkeletonStarted, msg = \"Service skeleton failed to start\"); // Send a GET request to the specified endpoint var response = httpEndpoint->get(\"/pets\"); if (response is http:Response) { var strRes = response.getTextPayload(); string expected = \"Sample listPets Response\"; test:assertEquals(strRes, expected); } else { test:assertFail(msg = \"Failed to call the endpoint: \" + uri); } } Function Mocks Testerina provides the functionality to mock a function in a different third-party module with your own Ballerina function, which will help you test your module independently. @test:Mock {} The function specified following the annotation will be a mock function that gets triggered every time the original function is called. The original function that will be mocked should be defined using the annotation parameters. Parameters: moduleName: \"<module_name>\": Name of the module where the function to be mocked resides in. Default: \".\" (No Module) functionName: \"<function_name>\": Name of the function to be mocked. Default: none The following is an example for function mocking. import ballerina/test; import ballerina/io; // This is the mock function which will replace the real intAdd function. @test:Mock { // Since we do not have a module, `.` is the current module // We can include any module here e.g., `ballerina/io, foo/bar:0.0.1` etc. moduleName: \".\", functionName: \"intAdd\" } // The mock function signature should match the actual function signature. public function mockIntAdd(int a, int b) returns (int) { io:println(\"I'm the mock function!\"); return (a - b); } // This is the test function. @test:Config {} function testAssertIntEquals() { int answer = 0; answer = intAdd(5, 3); io:println(\"Function mocking test\"); test:assertEquals(answer, 2, msg = \"function mocking failed\"); } // The real function which is mocked above. public function intAdd(int a, int b) returns (int) { return (a + b); } "},{"page":"/learn/style-guide","content":" layout: ballerina-inner-page title: Ballerina Style Guide permalink: /learn/style-guide/ Ballerina Style Guide The Ballerina Style Guide aims at maintaining a standard coding style among the Ballerina community. Therefore, the Ballerina code formatting tools are based on this guide. You can follow your own coding style when writing Ballerina source code. Also, plugins and tools can be configured to match your coding style. Indentation and line length Use four spaces (not tabs) for each level of indentation. Keep the maximum length of a line to 120 characters. Note: You can configure tools and plugins to use tabs when indenting and to change the number of maximum characters of the line length. Line spacing Use only a single space to separate keywords, types, and identifiers. Do's public function getFullName() returns string { string fullName = \"john doe\"; return fullName; } Don'ts public function getFullName() returns string { string fullName = \"john doe\"; return fullName; } Few exceptions for this rule are: Do not keep spaces around a type when it is enclosed using angle brackets <string>. Example, map<string> names = {}; Do not keep spaces between the type and the opening bracket in the array definition string[]. Example, string[] names = []; If it is a list of values separated by commas, add only a single space after each comma and don't add spaces before the comma. Example, [string, int, boolean] tupleVar = [\"\", 0, false]; int[] arrayOfString = [1, 2, 3, 4] map<string> stringMap = {one: st1, two: st2, three: st3}; Person personRecord = {name:\"marcus\", id: 0}; function foo(string name, int id) {} service hello on ep1, ep2 {...} Blank lines Separate both statements and top level definitions by zero or one blank lines. Example, import ballerina/http; import ballerina/io; const string CITY = \"Colombo\"; const int CITY_NO = 1; function getName() returns string { string firstName = \"john\"; string lastName = \"doe\"; return firstName + lastName; } function setName(string name) {} function setAge(int age) {} Note: You can configure tools and plugins to change the number of minimum and maximum blank lines used when formatting. Blocks Opening curly braces of a block should be placed inline. Do's if (true) { } function setName(string name) { } Don'ts if (true) { } function setName(string name) { } Add a single space before the opening curly braces. Example, function func1() { if (true) {} } If a block is empty, do not keep spaces in between the opening and closing braces. Example, function func1() {} Indent all the statements inside a block to be at the same level. Indent the closing brace of a block to align it with the starting position of the block statement. Example, if (false) { ... } match a { ... } Parentheses and Brackets Do not have spaces after opening parentheses/bracket and before closing parentheses/bracket. Example, [string, int] tupleVar = [\"\", 0]; function setValue(string value) {...} setValue(\"value\"); To define an empty parentheses, do not keep spaces between the opening and closing parentheses (). Example, int \" () result = getResult(); Line breaks Have only one statement in a line. When splitting lines, which contains operator(s), split them right before an operator. Example, // Binary operations. string s = \"added \" + People.name + \" in to database.\"; // Function invocation. string s = person .getName(); // Binary operations in if condition if (isNameAvailable && (i == 1)) { } When splitting lines, which contains separator(s), split them right after a separator. Example, // Function parameters. function getName(int id, int age, string searchValue) returns string { ... } If there isn't any operator or separator to break the line from, move the whole expression to a new line. Example, // String literal. string s1 = \"My name is not in this description\"; // Function invocation. string s2 = getPersonNameWithUpperCaseLetters(); If a line exceeds the max line length, start from the end of the line and come towards the start of the line until you find a point, which matches the above rules to break the line. Indent split lines with relation to the starting position of the statement or definition. Example, if (isNameAvailable && (i == 1)) { } // Function parameters. function getName(int id, int age, string searchValue) returns string { ... } However, if you cannot add the type-casting expression or statement with the constrained type in a single line due to it exceeding the max line length, move the casting type with the operators to a new line. Example, string name = <string>json.name; keep the constrained type on the same line by splitting the statement from a point before the constraint type. Example, map<int \" string> registry = { name: \"marcus\" }; table<Employee> employee = table { {key id, name, address} }; Top Level Definitions For style guidelines on imports, service definition, object definiiton, record definition, referencing record or abstract object, etc., see Top Level Definitions . Operators, Keywords, and Types For style guidelines on operators, keywords, and types, see Operators, Keywords, and Types . Statements For style guidelines on statemnets such as if, match, transcation etc., see Statements . Expressions For style guidelines on function invocation, literals, tuple, type casting etc. see Expressions . Annotations, Documentation, and Comments For style guidelines on annotations, documentation, and comments, see Annotations, Documentation, and Comments . "},{"page":"/learn/set-up-ballerina-sdk","content":" layout: ballerina-inner-page title: Setting up Ballerina SDK permalink: /learn/set-up-ballerina-sdk Setting up Ballerina SDK After installing the IntelliJ Ballerina plugin , you need to set up Ballerina SDK for your Ballerina projects to activate all the capabilities of the plugin. Click on the below links for instructions on how to set up Ballerina SDK. Setting up for a new project Setting up for an existing project Setting up for a new project Follow the steps below to set up Ballerina SDK when creating a new Ballerina project. In the editor, click File in the top menu, click New, and then click Project. Click Ballerina and then click Next. If you do not have an already-configured Ballerina SDK, click Configure to add a new Ballerina SDK. Tip: If you have already-configured Ballerina SDKs, you can select one of them and click Next to continue with the project creation. Select the location of the Ballerina distribution and click Open. Now, you have successfully added the Ballerina SDK. Click Next and continue with the project creation. Setting up for an existing project Follow the steps below to set up Ballerina SDK for an exisitng Ballerina project. Open the Project to which you want to set up a Ballerina SDK. In the editor, click File in the top menu, click Project Structure. If you do not have an already-configured Ballerina SDK, in the Project tab, click New under Project SDK:, click Ballerina SDK, and then click OK. Tip: If you have already-configured Ballerina SDKs, select one under Project SDK: and click OK to continue. Select the location of the Ballerina distribution and click Open. Click Apply to save the changes. Tip This prompts a restart request. Click Restart to apply the changes. Now, you have successfully added the Ballerina SDK to this project. "},{"page":"/learn/tools-ides","content":" layout: ballerina-inner-page title: Tools and IDEs permalink: /learn/tools-ides/ Tools and IDEs Ballerina provides language servers, editors, IDEs, and graphical visualization tools to help you write, document, and test your code. The sections below introduce you to them. Editor and IDE support OpenAPI to Ballerina code generator API documentation generator Test framework Editor and IDE support You can use plugins to write Ballerina code in your favorite editor or IDE. Click on the below icons to learn about the plugins that are currently available. Visual Studio Code IntelliJ IDEA The graphical visualization tool is embedded in the Visual Studio Code plug-in. OpenAPI to Ballerina code generator You can use the existing OpenAPI/Swagger files to generate connectors and services in Ballerina code. For details, see the OpenAPI to Ballerina Code Generator . API documentation generator As you develop new connectors, remote functions in connectors and other functions that you want to share with others, it's important to add API documentation that describes each entity and how it's used. Ballerina provides a framework called Docerina that generates API documentation from the annotations in your Ballerina files. You can check it out here . You can generate docs for a Ballerina file or module using the following command: ./ballerina doc [<ballerina-file>\"<module-name>] Test framework Ballerina provides a testing framework called Testerina that you can use to test your programs. You can check it out here . You can test a Ballerina file or module using the following command: ./ballerina test [<ballerina-file>\"<module-name>] Compatibility Ballerina Language Specification supports a set of experimental features such as transactions syntax. In order to be compatible with the experimental features and for supporting language intelligence in VSCode Plugin, enable the Allow Experimental option in user settings. "}];

let titleIndex = [{"page":"/learn/ballerina-streaming-reference","content":"ballerina streaming reference"},{"page":"/learn/cli-commands","content":"cli commands"},{"page":"/learn/events","content":"events"},{"page":"/learn/faq","content":"faq"},{"page":"/learn/getting-started","content":"getting started"},{"page":"/learn/how-to-deploy-and-run-ballerina-programs","content":"how to deploy and run ballerina programs"},{"page":"/learn/how-to-document-ballerina-code","content":"how to document ballerina code"},{"page":"/learn/how-to-extend-ballerina","content":"how to extend ballerina"},{"page":"/learn/how-to-generate-code-for-protocol-buffers","content":"how to generate code for protocol buffers"},{"page":"/learn/how-to-observe-ballerina-code","content":"how to observe ballerina code"},{"page":"/learn/how-to-publish-modules","content":"how to publish modules"},{"page":"/learn/how-to-structure-ballerina-code","content":"how to structure ballerina code"},{"page":"/learn/how-to-test-ballerina-code","content":"how to test ballerina code"},{"page":"/learn/how-to-use-openapi-tools","content":"how to use openapi tools"},{"page":"/learn/how-to-write-secure-ballerina-code","content":"how to write secure ballerina code"},{"page":"/learn/intellij-plugin-doc","content":"intellij plugin doc"},{"page":"/learn/quick-tour","content":"quick tour"},{"page":"/learn/set-up-ballerina-sdk","content":"set up ballerina sdk"},{"page":"/learn/style-guide","content":"style guide"},{"page":"/learn/tools-ides","content":"tools ides"},{"page":"/learn/api-docs/ballerina/index.html","content":"Modules"},{"page":"/learn/api-docs/ballerina/cache/index.html","content":"Module : cache"},{"page":"/learn/api-docs/ballerina/config/index.html","content":"Module : config"},{"page":"/learn/api-docs/ballerina/docker/index.html","content":"Module : docker"},{"page":"/learn/api-docs/ballerina/auth/index.html","content":"Module : auth"},{"page":"/learn/api-docs/ballerina/encoding/index.html","content":"Module : encoding"},{"page":"/learn/api-docs/ballerina/file/index.html","content":"Module : file"},{"page":"/learn/api-docs/ballerina/crypto/index.html","content":"Module : crypto"},{"page":"/learn/api-docs/ballerina/filepath/index.html","content":"Module : filepath"},{"page":"/learn/api-docs/ballerina/grpc/index.html","content":"Module : grpc"},{"page":"/learn/api-docs/ballerina/http/index.html","content":"Module : http"},{"page":"/learn/api-docs/ballerina/java.arrays/index.html","content":"Module : java.arrays"},{"page":"/learn/api-docs/ballerina/java.jdbc/index.html","content":"Module : java.jdbc"},{"page":"/learn/api-docs/ballerina/java/index.html","content":"Module : java"},{"page":"/learn/api-docs/ballerina/io/index.html","content":"Module : io"},{"page":"/learn/api-docs/ballerina/istio/index.html","content":"Module : istio"},{"page":"/learn/api-docs/ballerina/jsonutils/index.html","content":"Module : jsonutils"},{"page":"/learn/api-docs/ballerina/jwt/index.html","content":"Module : jwt"},{"page":"/learn/api-docs/ballerina/kafka/index.html","content":"Module : kafka"},{"page":"/learn/api-docs/ballerina/lang.decimal/index.html","content":"Module : lang.decimal"},{"page":"/learn/api-docs/ballerina/lang.array/index.html","content":"Module : lang.array"},{"page":"/learn/api-docs/ballerina/lang.error/index.html","content":"Module : lang.error"},{"page":"/learn/api-docs/ballerina/lang.future/index.html","content":"Module : lang.future"},{"page":"/learn/api-docs/ballerina/lang.float/index.html","content":"Module : lang.float"},{"page":"/learn/api-docs/ballerina/lang.int/index.html","content":"Module : lang.int"},{"page":"/learn/api-docs/ballerina/kubernetes/index.html","content":"Module : kubernetes"},{"page":"/learn/api-docs/ballerina/lang.object/index.html","content":"Module : lang.object"},{"page":"/learn/api-docs/ballerina/lang.stream/index.html","content":"Module : lang.stream"},{"page":"/learn/api-docs/ballerina/lang.map/index.html","content":"Module : lang.map"},{"page":"/learn/api-docs/ballerina/lang.string/index.html","content":"Module : lang.string"},{"page":"/learn/api-docs/ballerina/lang.table/index.html","content":"Module : lang.table"},{"page":"/learn/api-docs/ballerina/lang.typedesc/index.html","content":"Module : lang.typedesc"},{"page":"/learn/api-docs/ballerina/math/index.html","content":"Module : math"},{"page":"/learn/api-docs/ballerina/lang.xml/index.html","content":"Module : lang.xml"},{"page":"/learn/api-docs/ballerina/lang.value/index.html","content":"Module : lang.value"},{"page":"/learn/api-docs/ballerina/log/index.html","content":"Module : log"},{"page":"/learn/api-docs/ballerina/mime/index.html","content":"Module : mime"},{"page":"/learn/api-docs/ballerina/observe/index.html","content":"Module : observe"},{"page":"/learn/api-docs/ballerina/oauth2/index.html","content":"Module : oauth2"},{"page":"/learn/api-docs/ballerina/openapi/index.html","content":"Module : openapi"},{"page":"/learn/api-docs/ballerina/nats/index.html","content":"Module : nats"},{"page":"/learn/api-docs/ballerina/openshift/index.html","content":"Module : openshift"},{"page":"/learn/api-docs/ballerina/rabbitmq/index.html","content":"Module : rabbitmq"},{"page":"/learn/api-docs/ballerina/runtime/index.html","content":"Module : runtime"},{"page":"/learn/api-docs/ballerina/socket/index.html","content":"Module : socket"},{"page":"/learn/api-docs/ballerina/streams/index.html","content":"Module : streams"},{"page":"/learn/api-docs/ballerina/reflect/index.html","content":"Module : reflect"},{"page":"/learn/api-docs/ballerina/stringutils/index.html","content":"Module : stringutils"},{"page":"/learn/api-docs/ballerina/system/index.html","content":"Module : system"},{"page":"/learn/api-docs/ballerina/task/index.html","content":"Module : task"},{"page":"/learn/api-docs/ballerina/test/index.html","content":"Module : test"},{"page":"/learn/api-docs/ballerina/time/index.html","content":"Module : time"},{"page":"/learn/api-docs/ballerina/transactions/index.html","content":"Module : transactions"},{"page":"/learn/api-docs/ballerina/xslt/index.html","content":"Module : xslt"},{"page":"/learn/api-docs/ballerina/xmlutils/index.html","content":"Module : xmlutils"},{"page":"/learn/api-docs/ballerina/websub/index.html","content":"Module : websub"}];
