<!DOCTYPE html>
<html lang="en">
<head>
  <title>Ballerina Language Specification, 2020R2-pre1</title>
  <meta charset="utf-8">
  <style type="text/css">
    body { font-family: sans-serif; line-height: 1.38;  }
    pre.grammar code, code.grammar { background-color: #D0D0D0; }
    pre, code { font-family: Consolas, monospace; }
    table { border: solid thin; border-collapse: collapse; }
    td, th { border: solid thin; padding: 0.5em; }
    p.status { font-size: large; font-weight: bold; }
  </style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i&amp;display=swap">
<link rel="stylesheet" href="style/ballerina-language-specification.css">
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script><script src="style/ballerina-language-specification.js"></script>
</head>
<body>
<h1>Ballerina Language Specification, 2020R2-pre1</h1>
<p>
Primary contributors:
</p>
<ul>
<li>James Clark, <a href="mailto:jjc@jclark.com">jjc@jclark.com</a>
</li>
<li>Sanjiva Weerawarana, <a href="mailto:sanjiva@weerawarana.org">sanjiva@weerawarana.org</a>
</li>
<li>Sameera Jayasoma, <a href="mailto:sameera@wso2.com">sameera@wso2.com</a>
</li>
<li>Hasitha Aravinda, <a href="mailto:hasitha@wso2.com">hasitha@wso2.com</a>
</li>
</ul>
<p>
(Other contributors are listed in <a href="#contributors">Appendix D</a>.)
</p>
<p>
Copyright Â© 2018, 2019, 2020 <a href="https://wso2.com/">WSO2</a>
</p>
<p>
Licensed under the <a href="https://creativecommons.org/licenses/by-nd/4.0/">Creative Commons
Attribution-NoDerivatives 4.0 International</a> license
</p>
<p class="status">
Language and document status
</p>
<p>
The language described in this specification is now stable, with the exception
of features that are explicitly marked as having <em>Preview</em> status. We
expect the final design of these features to be close enough to the current
design that it will be straightforward for code that makes uses the current
design to be updated to the final design.
</p>
<p>
Comments on this document are welcome and should be made by creating an issue in
<code><a href="https://github.com/ballerina-platform/ballerina-spec">https://github.com/ballerina-platform/ballerina-spec</a></code>, which is the
GitHub repository where this specification is maintained. The design of the
language may also be discussed in the <a href="mailto:ballerina-dec@googlegroups.com">ballerina-dev@googlegroups.com</a>
mailing list.
</p>
<section class="toc"><h2>Table of contents</h2>
<ul>
<li>1. <a href="#introduction">Introduction</a>
</li>
<li>2. <a href="#notation">Notation</a>
</li>
<li>3. <a href="#program_structure">Program structure</a>
</li>
<li>4. <a href="#lexical_structure">Lexical structure</a>
</li>
<li>5. <a href="#values_types">Values, types and variables</a><ul>
<li>5.1 <a href="#section_5.1">Overview</a><ul>
<li>5.1.1 <a href="#section_5.1.1">Type system fundamentals</a>
</li>
<li>5.1.2 <a href="#section_5.1.2">Type descriptors</a>
</li>
<li>5.1.3 <a href="#section_5.1.3">Type-ids</a>
</li>
<li>5.1.4 <a href="#section_5.1.4">Iterability</a>
</li>
</ul>
</li>
<li>5.2 <a href="#section_5.2">Simple values</a><ul>
<li>5.2.1 <a href="#section_5.2.1">Nil</a>
</li>
<li>5.2.2 <a href="#section_5.2.2">Boolean</a>
</li>
<li>5.2.3 <a href="#section_5.2.3">Int</a>
</li>
<li>5.2.4 <a href="#section_5.2.4">Floating point types</a><ul>
<li>5.2.4.1 <a href="#section_5.2.4.1">Float</a>
</li>
<li>5.2.4.2 <a href="#section_5.2.4.2">Decimal</a>
</li>
</ul>
</li>
</ul>
</li>
<li>5.3 <a href="#section_5.3">Sequence values</a><ul>
<li>5.3.1 <a href="#section_5.3.1">Strings</a>
</li>
<li>5.3.2 <a href="#XML">XML</a><ul><li>5.3.2.1 <a href="#section_5.3.2.1">XML namespaces</a>
</li></ul>
</li>
</ul>
</li>
<li>5.4 <a href="#section_5.4">Structured values</a><ul>
<li>5.4.1 <a href="#section_5.4.1">Lists</a><ul>
<li>5.4.1.1 <a href="#section_5.4.1.1">Array types</a>
</li>
<li>5.4.1.2 <a href="#section_5.4.1.2">Tuple types</a>
</li>
</ul>
</li>
<li>5.4.2 <a href="#section_5.4.2">Mappings</a><ul>
<li>5.4.2.1 <a href="#section_5.4.2.1">Map types</a>
</li>
<li>5.4.2.2 <a href="#section_5.4.2.2">Record types</a>
</li>
</ul>
</li>
<li>5.4.3 <a href="#tables">Tables</a>
</li>
</ul>
</li>
<li>5.5 <a href="#section_5.5">Behavioral values</a><ul>
<li>5.5.1 <a href="#section_5.5.1">Errors</a>
</li>
<li>5.5.2 <a href="#functions">Functions</a>
</li>
<li>5.5.3 <a href="#section_5.5.3">Objects</a><ul>
<li>5.5.3.1 <a href="#section_5.5.3.1">Fields</a>
</li>
<li>5.5.3.2 <a href="#section_5.5.3.2">Methods</a>
</li>
<li>5.5.3.3 <a href="#section_5.5.3.3">Visibility</a>
</li>
<li>5.5.3.4 <a href="#section_5.5.3.4">Typing</a>
</li>
<li>5.5.3.5 <a href="#section_5.5.3.5">Initialization</a>
</li>
<li>5.5.3.6 <a href="#section_5.5.3.6">Inclusion and type-ids</a>
</li>
</ul>
</li>
<li>5.5.4 <a href="#section_5.5.4">Futures</a>
</li>
<li>5.5.5 <a href="#section_5.5.5">[Preview] Services</a>
</li>
<li>5.5.6 <a href="#section_5.5.6">Type descriptors</a>
</li>
<li>5.5.7 <a href="#section_5.5.7">Handles</a>
</li>
<li>5.5.8 <a href="#section_5.5.8">[Preview] Streams</a>
</li>
</ul>
</li>
<li>5.6 <a href="#section_5.6">Other type descriptors</a><ul>
<li>5.6.1 <a href="#section_5.6.1">Type reference</a>
</li>
<li>5.6.2 <a href="#section_5.6.2">Singleton types</a>
</li>
<li>5.6.3 <a href="#section_5.6.3">Any type</a>
</li>
<li>5.6.4 <a href="#section_5.6.4">Never type</a>
</li>
<li>5.6.5 <a href="#section_5.6.5">Readonly type</a>
</li>
<li>5.6.6 <a href="#distinct_types">Distinct types</a>
</li>
<li>5.6.7 <a href="#section_5.6.7">Union types</a>
</li>
<li>5.6.8 <a href="#section_5.6.8">Intersection types</a>
</li>
<li>5.6.9 <a href="#section_5.6.9">Optional types</a>
</li>
<li>5.6.10 <a href="#anydata">Anydata type</a>
</li>
<li>5.6.11 <a href="#section_5.6.11">JSON types</a>
</li>
<li>5.6.12 <a href="#byte_type">Byte type</a>
</li>
</ul>
</li>
<li>5.7 <a href="#built-in_abstract_object_types">Built-in abstract object types</a><ul>
<li>5.7.1 <a href="#section_5.7.1">Iterator</a>
</li>
<li>5.7.2 <a href="#section_5.7.2">Iterable</a>
</li>
<li>5.7.3 <a href="#StreamImplementor">StreamImplementor</a>
</li>
<li>5.7.4 <a href="#section_5.7.4">Listener</a>
</li>
</ul>
</li>
<li>5.8 <a href="#section_5.8">Abstract operations</a><ul>
<li>5.8.1 <a href="#FillMember">FillMember</a>
</li>
<li>5.8.2 <a href="#Clone">Clone</a>
</li>
<li>5.8.3 <a href="#ImmutableClone">ImmutableClone</a>
</li>
<li>5.8.4 <a href="#DeepEquals">DeepEquals</a>
</li>
<li>5.8.5 <a href="#section_5.8.5">NumericConvert</a>
</li>
</ul>
</li>
<li>5.9 <a href="#functionally_constructible_types">Functionally constructible types</a>
</li>
<li>5.10 <a href="#section_5.10">Binding patterns and variables</a><ul>
<li>5.10.1 <a href="#section_5.10.1">Binding patterns</a>
</li>
<li>5.10.2 <a href="#section_5.10.2">Typed binding patterns</a>
</li>
<li>5.10.3 <a href="#section_5.10.3">Variable and identifier scoping</a>
</li>
</ul>
</li>
</ul>
</li>
<li>6. <a href="#expressions">Expressions</a><ul>
<li>6.1 <a href="#section_6.1">Expression evaluation</a>
</li>
<li>6.2 <a href="#section_6.2">Static typing of expressions</a><ul>
<li>6.2.1 <a href="#lax_static_typing">Lax static typing</a>
</li>
<li>6.2.2 <a href="#section_6.2.2">Contextually expected type</a>
</li>
<li>6.2.3 <a href="#section_6.2.3">Precise and broad types</a>
</li>
</ul>
</li>
<li>6.3 <a href="#section_6.3">Casting and conversion</a>
</li>
<li>6.4 <a href="#section_6.4">Constant expressions</a>
</li>
<li>6.5 <a href="#section_6.5">Literals</a>
</li>
<li>6.6 <a href="#section_6.6">Template expressions</a><ul>
<li>6.6.1 <a href="#section_6.6.1">String template expression</a>
</li>
<li>6.6.2 <a href="#section_6.6.2">XML template expression</a>
</li>
</ul>
</li>
<li>6.7 <a href="#section_6.7">Structural constructors</a><ul>
<li>6.7.1 <a href="#section_6.7.1">List constructor</a>
</li>
<li>6.7.2 <a href="#section_6.7.2">Mapping constructor</a>
</li>
<li>6.7.3 <a href="#section_6.7.3">Table constructor</a>
</li>
</ul>
</li>
<li>6.8 <a href="#section_6.8">New expression</a>
</li>
<li>6.9 <a href="#section_6.9">Service constructor</a>
</li>
<li>6.10 <a href="#section_6.10">Variable reference expression</a>
</li>
<li>6.11 <a href="#section_6.11">Field access expression</a>
</li>
<li>6.12 <a href="#section_6.12">Optional field access expression</a>
</li>
<li>6.13 <a href="#section_6.13">XML attribute access expression</a>
</li>
<li>6.14 <a href="#section_6.14">Annotation access expression</a>
</li>
<li>6.15 <a href="#section_6.15">Member access expression</a>
</li>
<li>6.16 <a href="#function_call">Function call expression</a>
</li>
<li>6.17 <a href="#section_6.17">Method call expression</a>
</li>
<li>6.18 <a href="#section_6.18">Functional constructor</a>
</li>
<li>6.19 <a href="#section_6.19">Anonymous function expression</a>
</li>
<li>6.20 <a href="#section_6.20">Let expression</a>
</li>
<li>6.21 <a href="#section_6.21">Type cast expression</a>
</li>
<li>6.22 <a href="#section_6.22">Typeof expression</a>
</li>
<li>6.23 <a href="#section_6.23">Unary expression</a>
</li>
<li>6.24 <a href="#section_6.24">Multiplicative expression</a>
</li>
<li>6.25 <a href="#section_6.25">Additive expression</a>
</li>
<li>6.26 <a href="#section_6.26">Shift expression</a>
</li>
<li>6.27 <a href="#section_6.27">Range expression</a>
</li>
<li>6.28 <a href="#section_6.28">Numerical comparison expression</a>
</li>
<li>6.29 <a href="#section_6.29">Type test expression</a>
</li>
<li>6.30 <a href="#section_6.30">Equality expression</a>
</li>
<li>6.31 <a href="#section_6.31">Binary bitwise expression</a>
</li>
<li>6.32 <a href="#section_6.32">Logical expression</a>
</li>
<li>6.33 <a href="#section_6.33">Conditional expression</a>
</li>
<li>6.34 <a href="#section_6.34">Checking expression</a>
</li>
<li>6.35 <a href="#section_6.35">Trap expression</a>
</li>
<li>6.36 <a href="#section_6.36">Query expression</a><ul>
<li>6.36.1 <a href="#section_6.36.1">From clause</a>
</li>
<li>6.36.2 <a href="#section_6.36.2">Where clause</a>
</li>
<li>6.36.3 <a href="#section_6.36.3">Let clause</a>
</li>
<li>6.36.4 <a href="#section_6.36.4">Select clause</a>
</li>
</ul>
</li>
<li>6.37 <a href="#section_6.37">XML navigation expression</a><ul>
<li>6.37.1 <a href="#section_6.37.1">XML name pattern</a>
</li>
<li>6.37.2 <a href="#section_6.37.2">XML filter expression</a>
</li>
<li>6.37.3 <a href="#section_6.37.3">XML step expression</a>
</li>
</ul>
</li>
</ul>
</li>
<li>7. <a href="#actions_statements">Actions and statements</a><ul>
<li>7.1 <a href="#section_7.1">Actions</a>
</li>
<li>7.2 <a href="#section_7.2">Threads and strands</a>
</li>
<li>7.3 <a href="#section_7.3">Function and worker execution</a>
</li>
<li>7.4 <a href="#section_7.4">Statement execution</a>
</li>
<li>7.5 <a href="#section_7.5">Fork statement</a>
</li>
<li>7.6 <a href="#section_7.6">Start action</a>
</li>
<li>7.7 <a href="#section_7.7">Wait action</a><ul>
<li>7.7.1 <a href="#section_7.7.1">Single wait action</a>
</li>
<li>7.7.2 <a href="#section_7.7.2">Multiple wait action</a>
</li>
<li>7.7.3 <a href="#section_7.7.3">Alternate wait action </a>
</li>
</ul>
</li>
<li>7.8 <a href="#section_7.8">Worker message passing</a><ul>
<li>7.8.1 <a href="#section_7.8.1">Send action</a>
</li>
<li>7.8.2 <a href="#section_7.8.2">Receive action</a><ul>
<li>7.8.2.1 <a href="#section_7.8.2.1">Single receive action</a>
</li>
<li>7.8.2.2 <a href="#section_7.8.2.2">Multiple receive action</a>
</li>
</ul>
</li>
<li>7.8.3 <a href="#section_7.8.3">Flush action</a>
</li>
<li>7.8.4 <a href="#section_7.8.4">Send-receive correspondence</a>
</li>
</ul>
</li>
<li>7.9 <a href="#section_7.9">Remote interaction</a>
</li>
<li>7.10 <a href="#section_7.10">Query action</a>
</li>
<li>7.11 <a href="#section_7.11">Local variable declaration statements</a>
</li>
<li>7.12 <a href="#section_7.12">Implicit variable type narrowing</a>
</li>
<li>7.13 <a href="#section_7.13">Local type definition statement</a>
</li>
<li>7.14 <a href="#XML_namespace_declaration_statement">XML namespace declaration statement</a>
</li>
<li>7.15 <a href="#section_7.15">Assignment</a><ul>
<li>7.15.1 <a href="#section_7.15.1">Lvalues</a>
</li>
<li>7.15.2 <a href="#section_7.15.2">Assignment statement</a>
</li>
<li>7.15.3 <a href="#section_7.15.3">Compound assignment statement</a>
</li>
<li>7.15.4 <a href="#section_7.15.4">Destructuring assignment statement</a>
</li>
</ul>
</li>
<li>7.16 <a href="#section_7.16">Action statement</a>
</li>
<li>7.17 <a href="#section_7.17">Call statement</a>
</li>
<li>7.18 <a href="#section_7.18">Conditional statement</a>
</li>
<li>7.19 <a href="#section_7.19">Match statement</a>
</li>
<li>7.20 <a href="#section_7.20">Foreach statement</a>
</li>
<li>7.21 <a href="#section_7.21">While statement</a>
</li>
<li>7.22 <a href="#section_7.22">Continue statement</a>
</li>
<li>7.23 <a href="#section_7.23">Break statement</a>
</li>
<li>7.24 <a href="#section_7.24">Panic statement</a>
</li>
<li>7.25 <a href="#section_7.25">Return statement</a>
</li>
<li>7.26 <a href="#section_7.26">Lock statement</a>
</li>
</ul>
</li>
<li>8. <a href="#module_level">Module-level declarations</a><ul>
<li>8.1 <a href="#section_8.1">Import declaration</a>
</li>
<li>8.2 <a href="#section_8.2">Module and program execution</a>
</li>
<li>8.3 <a href="#section_8.3">Listeners and services</a><ul>
<li>8.3.1 <a href="#section_8.3.1">Listener declaration</a>
</li>
<li>8.3.2 <a href="#section_8.3.2">Service declaration</a>
</li>
</ul>
</li>
<li>8.4 <a href="#section_8.4">Function definition</a>
</li>
<li>8.5 <a href="#section_8.5">Module type definition</a>
</li>
<li>8.6 <a href="#section_8.6">Module variable declaration</a>
</li>
<li>8.7 <a href="#section_8.7">Module constant declaration</a>
</li>
<li>8.8 <a href="#section_8.8">Module enumeration declaration</a>
</li>
<li>8.9 <a href="#section_8.9">Module XML namespace declaration</a>
</li>
</ul>
</li>
<li>9. <a href="#metadata">Metadata</a><ul>
<li>9.1 <a href="#section_9.1">Annotations</a>
</li>
<li>9.2 <a href="#section_9.2">Documentation</a>
</li>
<li>9.3 <a href="#section_9.3">Ballerina Flavored Markdown</a>
</li>
</ul>
</li>
<li>10. <a href="#lang_library">Lang library</a><ul><li>10.1 <a href="#built-in_subtypes">Built-in subtypes</a>
</li></ul>
</li>
<li>A. <a href="#references">References</a>
</li>
<li>B. <a href="#changes">Changes since previous versions</a><ul>
<li>B.1 <a href="#section_B.1">Summary of changes from 2020R1 to 2020R2</a>
</li>
<li>B.2 <a href="#section_B.2">Summary of changes from 2019R3 to 2020R1</a>
</li>
<li>B.3 <a href="#section_B.3">Summary of changes from 2019R2 to 2019R3</a>
</li>
<li>B.4 <a href="#section_B.4">Summary of changes from 2019R1 to 2019R2</a>
</li>
<li>B.5 <a href="#section_B.5">Summary of changes from 0.990 to 2019R1</a>
</li>
<li>B.6 <a href="#section_B.6">Summary of changes from 0.980 to 0.990</a>
</li>
<li>B.7 <a href="#section_B.7">Summary of changes from 0.970 to 0.980</a>
</li>
</ul>
</li>
<li>C. <a href="#planned_future_functionality">Planned future functionality</a>
</li>
<li>D. <a href="#contributors">Other contributors</a>
</li>
</ul></section>
<section>
<h2 id="introduction">1. Introduction</h2>
<p>
Ballerina is a statically typed, concurrent programming language, focusing on
network interaction and structured data. It is intended to be the core of a
language-centric middleware platform. It has all the general-purpose
functionality expected of a modern programming language, but it also has several
unusual aspects that make it particularly suitable for its intended purpose.
</p>
<p>
First, it provides language constructs specifically for consuming and providing
network services. Future versions of Ballerina will add language constructs for
other middleware functionality such as event stream processing, distributed
transactions and reliable messaging; this is described in more detail in <a href="planned_future_functionality">Appendix C</a>.
</p>
<p>
Second, its abstractions and syntax for concurrency and network interaction have
been designed so that there is a close correspondence with sequence diagrams.
This enables a bidirectional mapping for any Ballerina function between its
textual representation in the syntax described in this specification and its
graphical representation as a sequence diagram, such that the sequence diagram
fully shows the aspects of the behavior of that function that relate to
concurrency and network interaction.
</p>
<p>
Third, it has a type system that is more flexible and allows for looser coupling
than traditional statically typed languages. The type system is structural:
instead of requiring the program to explicitly say which types are compatible
with each other, compatibility of types and values is determined automatically
based on their structure; this is particularly useful when combining data from
multiple, independently-designed systems. In addition, the type system provides
union types and open records. This flexibility allows the type system to be used
as a schema for the data that is exchanged in distributed applications.
Ballerina's data types are designed to work particularly well with JSON; any
JSON value has a direct, natural representation as a Ballerina value. Ballerina
also provides support for XML and tabular data.
</p>
<p>
Ballerina is not a research language. It is intended to be a pragmatic language
suitable for mass-market commercial adoption. It tries to feel familiar to
programmers who are used to popular, modern C-family languages, notably Java, C#
and JavaScript. It also gets ideas and inspiration from many other existing
programming languages including TypeScript, Go, Rust, D, Kotlin, Swift, Python
and Perl.
</p>
<p>
The Ballerina language has been designed in conjunction with the Ballerina
platform, which provides comprehensive support for a module-based software
development model, including versioning, dependency management, testing,
documentation, building and sharing. Modules are organized into repositories;
there is a globally-shared, central repository, but repositories can also be
local.
</p>
<p>
The Ballerina language includes a small library, the lang library, which
provides fundamental operations on the data types defined by the language; the
lang library is defined by this specification. The Ballerina platform includes
an extensive standard library, which includes not only the usual low-level,
general-purpose functionality, but also support for a wide variety of network
protocols, interface standards, data formats and authentication/authorization
standards, which make writing secure, resilient distributed applications
significantly easier than with other languages. The standard library is not
specified in this document.
</p>
</section>
<section>
<h2 id="notation">2. Notation</h2>
<p>
Productions are written in the form:
</p>

<pre>symbol := rhs
</pre>
<p>
where symbol is the name of a nonterminal, and <code>rhs</code> is as follows:
</p>
<ul>
<li>
<code>0xX</code> means the single character whose Unicode code point is
denoted by the hexadecimal numeral X</li>
<li>
<code>^x</code> means any single Unicode code point that does not match x
and is not a disallowed character;</li>
<li>
<code>x..y</code> means any single Unicode character whose code point is
greater than or equal to that of x and less than or equal to that of y</li>
<li>
<code class="grammar">str</code> means the characters <code>str</code> literally</li>
<li>
<code>symbol </code>means a reference to production for the nonterminal
<code>symbol</code>
</li>
<li>
<code>x|y</code> means x or y</li>
<li>
<code>x&amp;y</code> means x and y, interleaved in any order</li>
<li>
<code>[x]</code> means zero or one times</li>
<li>
<code>x?</code> means x zero or one times</li>
<li>
<code>x*</code> means x zero or more times</li>
<li>
<code>x+</code> means x one or more times</li>
<li>
<code>(x)</code> means x (grouping)</li>
</ul>
<p>
The <code>rhs</code> of a symbol that starts with a lower-case letter implicitly allows white
space and comments, as defined by the production <code>TokenWhiteSpace</code>,
between the terminals and nonterminals that it references.
</p>
</section>
<section>
<h2 id="program_structure">3. Program structure</h2>
<p>
A Ballerina program is divided into modules. A module has a source form and a
binary form. The module is the unit of compilation; a Ballerina compiler
translates the source form of a module into its binary form. A module may
reference other modules. When a compiler translates a source module into a
binary module, it needs access only to the binary form of other modules
referenced from the source module.
</p>
<p>
A binary module can only be referenced if it is placed in a module store. There
are two kinds of module store: a repository and a project. A module stored in a
repository can be referenced from any other module. A module stored in a project
can only be referenced from other modules stored in the same project.
</p>
<p>
A repository organizes binary modules into a 3-level hierarchy:
</p>
<ol>
<li>organization;</li>
<li>module name;</li>
<li>version.</li>
</ol>
<p>
Organizations are identified by Unicode strings, and are unique within a
repository. Any organization name starting with the string
<code>ballerina</code> is reserved for use by
the Ballerina platform. A module name is a Unicode string and is unique within a
repository organization. A particular module name can have one or more versions
each associated with a separate binary module. Versions are semantic, as
described in the SemVer specification.
</p>
<p>
A project stores modules using a simpler single-level hierarchy, in which the
module is associated directly with the module name.
</p>
<p>
A binary module is a sequence of octets. Its format is specified in the
Ballerina platform.
</p>
<p>
An abstract source module consists of:
</p>
<ul>
<li>an ordered collection of one or more source parts; each source part is a
sequence of octets that is the UTF-8 encoding of part of the source code for the
module</li>
<li>metadata containing the following
<ul>
<li>always required: module name</li>
<li>required only if the source module is to be compiled into a binary module
stored in a repository:
<ul>
<li>organization name</li>
<li>version</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>
An abstract source module can be stored in a variety of concrete forms. For
example, the Ballerina platform describes a method for storing an
abstract source module in a filesystem, where the source parts are files with a
<code>.bal </code>extension stored in a directory, the module name comes from
the name of that directory, and the version and organization name comes from a
configuration file <code>Ballerina.toml</code> in that directory.
</p>
</section>
<section>
<h2 id="lexical_structure">4. Lexical structure</h2>
<p>
The grammar in this document specifies how a sequence of Unicode code points is
interpreted as part of the source of a Ballerina module. A Ballerina module part
is a sequence of octets (8-bit bytes); this sequence of octets is interpreted as
the UTF-8 encoding of a sequence of code points and must comply with the
requirements of RFC 3629.
</p>
<p>
After the sequence of octets is decoded from UTF-8, the following two
transformations must be performed before it is parsed using the grammar in this
document:
</p>
<ul>
<li>if the sequence starts with a byte order mark (code point 0xFEFF), it must
be removed</li>
<li>newlines are normalized as follows:
<ul>
<li>the two character sequence 0xD 0xA is replaced by 0xA</li>
<li>a single 0xD character that is not followed by 0xD is replaced by 0xA</li>
</ul>
</li>
</ul>
<p>
The sequence of code points must not contain any of the following disallowed
code points:
</p>
<ul>
<li>surrogates (0xD800 to 0xDFFF)</li>
<li>non-characters (the 66 code points that Unicode designates as
non-characters)</li>
<li>C0 control characters (0x0 to 0x1F and 0x1F) other than whitespace (0x9,
0xA, 0xC, 0xD)</li>
<li>C1 control characters (0x80 to 0x9F)</li>
</ul>
<p>
Note that the grammar notation ^X does not allow the above disallowed code
points.
</p>

<pre class="grammar"><span class="ntdfn" id="identifier">identifier</span> := <a href="#UnquotedIdentifier"><span class="ntref">UnquotedIdentifier</span></a> | <a href="#QuotedIdentifier"><span class="ntref">QuotedIdentifier</span></a>
<span class="ntdfn" id="UnquotedIdentifier">UnquotedIdentifier</span> :=
   <a href="#IdentifierInitialChar"><span class="ntref">IdentifierInitialChar</span></a> <a href="#IdentifierFollowingChar"><span class="ntref">IdentifierFollowingChar</span></a>*
<span class="ntdfn" id="QuotedIdentifier">QuotedIdentifier</span> := <code>'</code> <a href="#QuotedIdentifierChar"><span class="ntref">QuotedIdentifierChar</span></a>+
<span class="ntdfn" id="QuotedIdentifierChar">QuotedIdentifierChar</span> :=
  <a href="#IdentifierFollowingChar"><span class="ntref">IdentifierFollowingChar</span></a>
  | <a href="#QuotedIdentifierEscape"><span class="ntref">QuotedIdentifierEscape</span></a>
  | <a href="#StringNumericEscape"><span class="ntref">StringNumericEscape</span></a>
<span class="ntdfn" id="IdentifierInitialChar">IdentifierInitialChar</span> :=  <a href="#AsciiLetter"><span class="ntref">AsciiLetter</span></a> | <code>_</code> | <a href="#UnicodeIdentifierChar"><span class="ntref">UnicodeIdentifierChar</span></a>
<span class="ntdfn" id="IdentifierFollowingChar">IdentifierFollowingChar</span> := <a href="#IdentifierInitialChar"><span class="ntref">IdentifierInitialChar</span></a> | <a href="#Digit"><span class="ntref">Digit</span></a>
<span class="ntdfn" id="QuotedIdentifierEscape">QuotedIdentifierEscape</span> := <code>\</code> ^ ( <a href="#AsciiLetter"><span class="ntref">AsciiLetter</span></a> | 0x9 | 0xA | 0xD | <a href="#UnicodePatternWhiteSpaceChar"><span class="ntref">UnicodePatternWhiteSpaceChar</span></a> )
<span class="ntdfn" id="AsciiLetter">AsciiLetter</span> := <code>A</code> .. <code>Z</code> | <code>a</code> .. <code>z</code>
<span class="ntdfn" id="UnicodeIdentifierChar">UnicodeIdentifierChar</span> := ^ ( <a href="#AsciiChar"><span class="ntref">AsciiChar</span></a> | <a href="#UnicodeNonIdentifierChar"><span class="ntref">UnicodeNonIdentifierChar</span></a> )
<span class="ntdfn" id="AsciiChar">AsciiChar</span> := 0x0 .. 0x7F
<span class="ntdfn" id="UnicodeNonIdentifierChar">UnicodeNonIdentifierChar</span> :=
   <a href="#UnicodePrivateUseChar"><span class="ntref">UnicodePrivateUseChar</span></a>
   | <a href="#UnicodePatternWhiteSpaceChar"><span class="ntref">UnicodePatternWhiteSpaceChar</span></a>
   | <a href="#UnicodePatternSyntaxChar"><span class="ntref">UnicodePatternSyntaxChar</span></a>
<span class="ntdfn" id="UnicodePrivateUseChar">UnicodePrivateUseChar</span> :=
   0xE000 .. 0xF8FF
   | 0xF0000 .. 0xFFFFD
   | 0x100000 .. 0x10FFFD
<span class="ntdfn" id="UnicodePatternWhiteSpaceChar">UnicodePatternWhiteSpaceChar</span> := 0x200E | 0x200F | 0x2028 | 0x2029
<span class="ntdfn" id="UnicodePatternSyntaxChar">UnicodePatternSyntaxChar</span> := <em>character with Unicode property Pattern_Syntax=True</em>
<span class="ntdfn" id="Digit">Digit</span> := <code>0</code> .. <code>9</code>
</pre>
<p>
Note that the set of characters allowed in identifiers follows the requirements
of Unicode TR31 for immutable identifiers; the set of characters is immutable in
the sense that it does not change between Unicode versions.
</p>
<p>
The QuotedIdentifier syntax allows an arbitrary non-empty string to be treated
as an identifier. In particular, a reserved keyword <code><var>K</var></code>
can be used as an identifier by preceding it with a single quote i.e.
<code>'<var>K</var></code>.
</p>

<pre class="grammar"><span class="ntdfn" id="TokenWhiteSpace">TokenWhiteSpace</span> := (<a href="#Comment"><span class="ntref">Comment</span></a> | <a href="#WhiteSpaceChar"><span class="ntref">WhiteSpaceChar</span></a>)*
<span class="ntdfn" id="Comment">Comment</span> := <code>//</code> <a href="#AnyCharButNewline"><span class="ntref">AnyCharButNewline</span></a>*
<span class="ntdfn" id="AnyCharButNewline">AnyCharButNewline</span> := ^ 0xA
<span class="ntdfn" id="WhiteSpaceChar">WhiteSpaceChar</span> := 0x9 | 0xA | 0xD | 0x20
</pre>
<p>
<code>TokenWhiteSpace</code> is implicitly allowed on the right hand side of
productions for non-terminals whose names start with a lower-case letter.
</p>
</section>
<section>
<h2 id="values_types">5. Values, types and variables</h2>

<section>
<h3 id="section_5.1">5.1 Overview</h3>

<section>
<h4 id="section_5.1.1">5.1.1 Type system fundamentals</h4>
<p>
Ballerina programs operate on a rich universe of values. This universe of values
is partitioned into a number of <em>basic types</em>; every value belongs to
exactly one basic type.
</p>
<p>
Values are of four kinds, each corresponding to a kind of basic type:
</p>
<ul>
<li>simple values, like booleans and floating point numbers, which are not
constructed from other values;</li>
<li>structured values, like mappings and lists, which contain other values;</li>
<li>sequence values, which combine aspects of simple values and structured
values;</li>
<li>behavioral values, like functions, which allow parts of Ballerina programs
to be handled in a uniform way with other values</li>
</ul>
<p>
There is a fundamental distinction between values that have a <em>storage
identity</em> and values that do not. A value that has storage identity has an
identity that comes from the location where the value is stored. All structural
and behavioural values have a storage identity, whereas all simple values do
not. Storage identity for sequence values is more complicated and will be
explained in the section on sequence values.
</p>
<p>
Values can be stored in variables or as members of structures. When a value has
no storage identity, it can be stored directly in the variable or structure.
However, when a value has storage identity, what is stored in the variable or
member is a reference to the location where the value is stored rather than the
value itself. Storage identity allows values in Ballerina to represent not just
trees but graphs.
</p>
<p>
Ballerina provides the ability to test whether two values have the same storage
identity, but does not expose the specific storage location of a value. For
values with storage identity, there is the concept of creating a <em>new</em>
value: this means creating a value that has a storage identity that is different
from any existing value. For values with storage identity, there is also the
concept of <em>copying</em>: it means to create a value that is the same, except
for having a new storage identity. The concept of having storage identity is
similar to the concept of a reference type in some other programming languages,
but also accomodates the concept of a sequence value.
</p>
<p>
Storage identity is tied to mutability. Mutation is only well-defined for values
with storage identity. When a value stored in some storage location is mutated,
the change will be visible through all variables referring to the value in that
location. But not all values with storage identity can be mutated: a value may
not support mutation even though it has a storage identity.
</p>
<p>
Ballerina programs use types to categorize values both at compile-time and
runtime. Types deal with an abstraction of values that does not consider storage
identity. This abstraction is called a <em>shape</em>. A type denotes a set of
shapes. Subtyping in Ballerina is <em>semantic</em>: a type S is a subtype of
type T if the set of shapes denoted by S is a subset of the set of shapes
denoted by T. Every value has a corresponding shape. A shape is specific to a
basic type: if two values have different basic types, then they have different
shapes. The shape of the values contained in a structured value are part of the
shape of the structured value. Since shapes do not deal with storage identity,
they represent trees rather graphs. For simple values, there is no difference
between a shape and a value, with the exception of floating point values where
the shape does not consider representation details that do not affect the
mathematical value being represented. There are two important relations between
a value and a type:
</p>
<ul>
<li>a value <em>looks like</em> a type at a particular point in the execution of
a program if its shape at that point is a member of the type;</li>
<li>a value <em>belongs to</em> a type if it looks like the type, and it will
necessarily continue to look like the type no matter how the value is mutated.</li>
</ul>
<p>
When a Ballerina program declares a variable to have a compile-time type, this
means that the Ballerina compiler together with the runtime system will ensure
that the variable will only ever contain a value that belongs to the type.
Ballerina also provides mechanisms that take a value that looks like a type and
use it to create a value that belongs to a type.
</p>
<p>
If a value cannot be mutated, looking like a type and belonging to a type are
the same thing.
</p>
<p>
Every value has a read-only bit. If the read-only bit is on, it means that the
value is not mutable. A value's read-only bit is fixed when the value is
constructed, and cannot be changed thereafter. Immutability is deep: the values
contained in a structured value that has its read-only bit on will all have
their read-only bits on. Some basic types are inherently immutable: the
read-only bit is always on for a value that belongs to an inherently immutable
basic type. All simple types are inherently immutable. Some basic types are
selectively immutable: a type is selectively immutable if it is possible to
construct both values of the type that have the read-only bit on and values
that do not have the read-only bit on. All structured types are selectively
immutable. Finally, some basic types are inherently mutable: the read-only bit
is never on for a value belonging to an inherently mutable basic type.
</p>
<p>
A shape is divided into two <em>aspects</em>: the <em>primary aspect</em> and
the <em>read-only aspect</em>. A value's read-only bit is a part of the
<em>read-only aspect</em> of the value's shape. The read-only bit of values
contained in a structured value is part of the read-only aspect of those values
and of the read-only aspect of the structured value. Everything about a shape
except the read-only bits constitutes the primary aspect of the shape.
</p>
<p>
A value is <em>plain data</em> if it is a simple value, a sequence value or a
structured value that does not contain a behavioral value at any depth.
More precisely, a value is defined to be <em>plain data</em> if it is
</p>
<ul>
<li>a simple value,</li>
<li>a sequence value, or</li>
<li>a structured value, all of whose members are also plain data.</li>
</ul>
<p>
Plain data values can in general contain cycles of references, but in some
contexts are restricted to be acyclic. Plain data values, including values with
cycles, can be compared for equality.
</p>

</section>
<section>
<h4 id="section_5.1.2">5.1.2 Type descriptors</h4>
<pre class="grammar"><span class="ntdfn" id="type-descriptor">type-descriptor</span> :=
   <a href="#simple-type-descriptor"><span class="ntref">simple-type-descriptor</span></a>
   | <a href="#sequence-type-descriptor"><span class="ntref">sequence-type-descriptor</span></a>
   | <a href="#structured-type-descriptor"><span class="ntref">structured-type-descriptor</span></a>
   | <a href="#behavioral-type-descriptor"><span class="ntref">behavioral-type-descriptor</span></a>
   | <a href="#other-type-descriptor"><span class="ntref">other-type-descriptor</span></a>
</pre>
<p>
Ballerina provides a rich variety of type descriptors, which programs use to
describe types. For example, there is a type descriptor for each simple basic
type; there is a type descriptor that describes a type as a union of two types;
there is a type descriptor that uses a single value to describe a type that
contains a single shape. This means that values can look like and belong to
arbitrarily many types, even though they look like or belong to exactly one
<em>basic</em> type.
</p>
<p>
The following table summarizes the type descriptors provided by Ballerina.
</p>
<table>
  <tr>
   <td><strong>Kind</strong></td>
   <td><strong>Name</strong></td>
   <td><strong>Set of values denoted by type descriptor</strong></td>
  </tr>
  <tr>
   <td rowspan="5">basic, simple</td>
   <td>nil</td>
   <td>()</td>
  </tr>
  <tr>
   <td>boolean</td>
   <td>true, false</td>
  </tr>
  <tr>
   <td>int</td>
   <td>64-bit signed integers</td>
  </tr>
  <tr>
   <td>float</td>
   <td>64-bit IEEE 754-2008 binary floating point numbers</td>
  </tr>
  <tr>
   <td>decimal</td>
   <td>decimal floating point numbers</td>
  </tr>
  <tr>
   <td rowspan="2">basic, sequence</td>
   <td>string</td>
   <td>a sequence of Unicode scalar values</td>
  </tr>
  <tr>
   <td>XML</td>
   <td>a sequence of zero or more elements, processing instructions, comments or
text items</td>
  </tr>
  <tr>
   <td rowspan="5">basic, structured</td>
   <td>array</td>
   <td>an ordered list of values, optionally with a specific length, where a
single type is specified for all members of the list</td>
  </tr>
  <tr>
   <td>tuple</td>
   <td>an ordered list of values, where a type is specified separately for each
member of the list</td>
  </tr>
  <tr>
   <td>map</td>
   <td>a mapping from keys, which are strings, to values; specifies mappings in
terms of a single type to which all keys are mapped</td>
  </tr>
  <tr>
   <td>record</td>
   <td>a mapping from keys, which are strings, to values; specifies maps in
terms of names of fields (required keys) and value for each field</td>
  </tr>
  <tr>
   <td>table</td>
   <td>a ordered collection of mappings, where a mapping is uniquely identified
within the table by a key derived from the mapping</td>
  </tr>
  <tr>
   <td rowspan="8">basic, behavioral</td>
   <td>error</td>
   <td>an indication that there has been an error, with a string identifying the
reason for the error, and a mapping giving additional details about the error</td>
  </tr>
  <tr>
   <td>function</td>
   <td>a function with 0 or more specified parameter types and a single return
type</td>
  </tr>
  <tr>
   <td>future</td>
   <td>a value to be returned by a function execution</td>
  </tr>
  <tr>
   <td>object</td>
   <td>a combination of named fields and named methods</td>
  </tr>
  <tr>
   <td>service</td>
   <td>a collection of named methods, including resource methods</td>
  </tr>
  <tr>
   <td>typedesc</td>
   <td>a type descriptor</td>
  </tr>
  <tr>
   <td>handle</td>
   <td>reference to externally managed storage</td>
  </tr>
  <tr>
   <td>stream</td>
   <td>a sequence of values that can be generated lazily</td>
  </tr>
  <tr>
   <td rowspan="11">other</td>
   <td>singleton</td>
   <td>a single value described by a literal</td>
  </tr>
  <tr>
   <td>readonly</td>
   <td>any value whose read-only bit is on</td>
  </tr>
  <tr>
   <td>any</td>
   <td>any value other than an error</td>
  </tr>
  <tr>
   <td>never</td>
   <td>no value</td>
  </tr>
  <tr>
   <td>optional</td>
   <td>a value that is either () or belongs to a type</td>
  </tr>
  <tr>
   <td>union</td>
   <td>a value that belongs to at least one of a number of types</td>
  </tr>
  <tr>
   <td>intersection</td>
   <td>a value that belongs to all of a number of types</td>
  </tr>
  <tr>
   <td>distinct</td>
   <td></td>
  </tr>
  <tr>
   <td>anydata</td>
   <td>plain data (a simple value, sequence value or structured value that
   does not contain behavioral members at any depth)</td>
  </tr>
  <tr>
   <td>json</td>
   <td>the union of (), int, float, decimal, string, and maps and arrays whose
values are, recursively, json</td>
  </tr>
  <tr>
   <td>byte</td>
   <td>int in the range 0 to 255 inclusive</td>
  </tr>
</table>
<p>
Type descriptors other than <code>readonly</code> describes types using only the
primary aspect of shape: whether a value belongs to the type is not affected by
the read-only aspect of the value's shape. The <code>readonly</code> type uses
only the read-only aspect: whether a value belongs to the <code>readonly</code>
type depends only on the read-only aspect of the value's shape.
</p>
<p>
In addition to describing a type, a type descriptor may also include information
used to construct a value of the type, as well as metadata. Whereas the type
described by a type descriptor is known at compile time, this additional
information may need to be resolved at runtime. The typedesc basic type
represents a type descriptor that has been resolved.
</p>
</section>
<section>
<h4 id="section_5.1.3">5.1.3 Type-ids</h4>
<p>
Ballerina has a feature, called <em>distinct types</em>, which provides
functionality similar to that provided by nominal types, but which works within
Ballerina's structural type system. Distinct types are similar to the branded
types found in some other structurally typed languages, such as Modula-3.
</p>
<p>
The semantics of distinct types are based on type-ids. These are similar to the
brands used by branded types. A distinct type is created by a <a href="#distinct-types">distinct-type-descriptor</a>. Each occurrence of a
distinct-type-descriptor in a source module has a distinct type-id, which
uniquely identifies it within a Ballerina program. A type-id has three parts:
</p>
<ol>
<li>a module id, which identifies the module within which the
distinct-type-descriptor occurs; this consists of an organization, a module
name, and a version number;</li>
<li>a local id, which identifies the occurrence of the
distinct-type-descriptor within the module; this takes one of two forms:
<ul>
<li>named - if a distinct-type-descriptor is the only distinct-type-descriptor
occurring within a module-type-defn, then the local id is the name of the type
defined by the module-type-defn</li>
<li>anonymous - otherwise, the local id is a compiler-generated integer;</li>
</ul>
</li>
<li>a boolean flag saying whether the type-id is public; this flag is on if and
only if the local id part is named and is the name of a module-type-defn that is
public.</li>
</ol>
<p>
Distinct types can be used with only the object or error basic types. An object
value or error value has a set of type-ids. These type-ids are fixed at the
time of construction and are immutable thereafter. A value's set of type-ids may
be empty. The type-ids of a value are part of the value's shape and so can
affect when an object belongs to a type. The set of type-ids of an object or
error value are divided into primary type-ids and secondary type-ids: the
secondary type-ids could be inferred from the primary type-ids using the
program's source.
</p>
<p>
An object or error value is always constructed using a specific type descriptor.
A type descriptor for objects and errors thus performs a dual role: it denotes a
type and it defines a mechanism to construct a value of the type. A type
descriptor is <em>definite</em> if it induces a specific set of type-ids. The
set of type-ids of an object or error value are those induced by the
type-descriptor used to construct it; such a type descriptor must therefore be
definite. A type descriptor that denotes a type that does not allow object or
error values induces an empty set of type-ids and so is vacuously definite. For
other type descriptors, the section that specifies that type descriptor will say
when it is definite, the set of type-ids that it induces when it is, and which
of those are primary.
</p>

</section>
<section>
<h4 id="section_5.1.4">5.1.4 Iterability</h4>
<p>
Values of some basic types are <em>iterable</em>. An iterable value supports an
iteration operation, which treats the iterable value as consisting of a sequence
of zero or more simpler values, which are in some sense a part of the iterable
value; the iteration operation provides the values in the sequence, one after
another. The sequence of values that an iteration operation on a value provides
is the <em>iteration sequence</em> of the value. Each iterable basic type
defines the iteration sequence for a value of that basic type. There is also a
value associated with the completion of the iteration operation, which is nil if
the iteration completed successfully and an error otherwise. The iteration
operation thus determines two associated types for an iterable type: the value
type, which is the type of the values in the iteration sequence, and the
completion type, which is the type of the iteration completion value.
</p>
<p>
The following tables summarizes the iterable basic types.
</p>
<table>
<tr>
<th>Basic type</th>
<th>Iteration sequence</th>
<th>Type descriptor</th>
<th>Value type</th>
<th>Completion type</th>
</tr>
<tr>
<td>string</td>
<td>length 1 substrings</td>
<td><code>string</code></td>
<td><code>string:Char</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td>xml</td>
<td>singleton xml values</td>
<td><code>xml&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td>list</td>
<td>members in order</td>
<td><code>T[]</code></td>
<td><code>T</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td>mapping</td>
<td>members</td>
<td><code>map&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td>table</td>
<td>members in order</td>
<td><code>table&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td>stream</td>
<td>items</td>
<td><code>stream&lt;T,C&gt;</code></td>
<td><code>T</code></td>
<td><code>C</code></td>
</tr>
</table>
</section>
</section>

<section>
<h3 id="section_5.2">5.2 Simple values</h3>
<p>
A simple value belongs to exactly one of the following basic types:
</p>
<ul>
<li>nil</li>
<li>boolean</li>
<li>int</li>
<li>float</li>
<li>decimal</li>
</ul>
<p>
The type descriptor for each simple basic type contains all the values of the
basic type.
</p>
<p>
All simple basic types are inherently immutable.
</p>

<pre class="grammar"><span class="ntdfn" id="simple-type-descriptor">simple-type-descriptor</span> :=
   <a href="#nil-type-descriptor"><span class="ntref">nil-type-descriptor</span></a>
   | <a href="#boolean-type-descriptor"><span class="ntref">boolean-type-descriptor</span></a>
   | <a href="#int-type-descriptor"><span class="ntref">int-type-descriptor</span></a>
   | <a href="#floating-point-type-descriptor"><span class="ntref">floating-point-type-descriptor</span></a>
</pre>
<section>
<h4 id="section_5.2.1">5.2.1 Nil</h4>

<pre class="grammar"><span class="ntdfn" id="nil-type-descriptor">nil-type-descriptor</span> :=  <code>(</code> <code>)</code>
<span class="ntdfn" id="nil-literal">nil-literal</span> :=  <code>(</code> <code>)</code> | <code>null</code>
</pre>
<p>
The nil type contains a single value, called nil, which is used to represent the
absence of any other value. The nil value is written <code>()</code>. The nil
value can also be written <code>null</code>, for compatibility with JSON; the
use of null should be restricted to JSON-related contexts.
</p>
<p>
The nil type is special, in that it is the only basic type that consists of a
single value. The type descriptor for the nil type is not written using a
keyword, but is instead written <code>()</code> like the value.
</p>
</section>
<section>
<h4 id="section_5.2.2">5.2.2 Boolean</h4>

<pre class="grammar"><span class="ntdfn" id="boolean-type-descriptor">boolean-type-descriptor</span> := <code>boolean</code>
<span class="ntdfn" id="boolean-literal">boolean-literal</span> := <code>true</code> | <code>false</code>
</pre>
<p>
The boolean type consists of the values true and false.
</p>
</section>
<section>
<h4 id="section_5.2.3">5.2.3 Int</h4>

<pre class="grammar"><span class="ntdfn" id="int-type-descriptor">int-type-descriptor</span> := <code>int</code>
<span class="ntdfn" id="int-literal">int-literal</span> := <a href="#DecimalNumber"><span class="ntref">DecimalNumber</span></a> | <a href="#HexIntLiteral"><span class="ntref">HexIntLiteral</span></a>
<span class="ntdfn" id="DecimalNumber">DecimalNumber</span> := <code>0</code> | <a href="#NonZeroDigit"><span class="ntref">NonZeroDigit</span></a> <a href="#Digit"><span class="ntref">Digit</span></a>*
<span class="ntdfn" id="HexIntLiteral">HexIntLiteral</span> := <a href="#HexIndicator"><span class="ntref">HexIndicator</span></a> <a href="#HexNumber"><span class="ntref">HexNumber</span></a>
<span class="ntdfn" id="HexNumber">HexNumber</span> := <a href="#HexDigit"><span class="ntref">HexDigit</span></a>+
<span class="ntdfn" id="HexIndicator">HexIndicator</span> := <code>0x</code> | <code>0X</code>
<span class="ntdfn" id="HexDigit">HexDigit</span> := <a href="#Digit"><span class="ntref">Digit</span></a> | <code>a</code> .. <code>f</code> | <code>A</code> .. <code>F</code>
<span class="ntdfn" id="NonZeroDigit">NonZeroDigit</span> := <code>1</code> .. <code>9</code>
</pre>
<p>
The int type consists of integers between -9,223,372,036,854,775,808 and
9,223,372,036,854,775,807 (i.e. signed integers than can fit into 64 bits using
a two's complement representation).
</p>
<p>
The <a href="#byte_type"><code>byte</code> type</a> is a subtype of
<code>int</code>. The <code>lang.int</code> lang library module are also
provides <a href="#built-in_subtypes">built-in subtypes</a> for signed and
unsigned integers representable in 8, 16 and 32 bits.
</p>

</section>
<section>
<h4 id="section_5.2.4">5.2.4 Floating point types</h4>

<pre class="grammar"><span class="ntdfn" id="floating-point-type-descriptor">floating-point-type-descriptor</span> := <code>float</code> | <code>decimal</code>
<span class="ntdfn" id="floating-point-literal">floating-point-literal</span> :=
   <a href="#DecimalFloatingPointNumber"><span class="ntref">DecimalFloatingPointNumber</span></a> | <a href="#HexFloatingPointLiteral"><span class="ntref">HexFloatingPointLiteral</span></a>
<span class="ntdfn" id="DecimalFloatingPointNumber">DecimalFloatingPointNumber</span> :=
   <a href="#DecimalNumber"><span class="ntref">DecimalNumber</span></a> <a href="#Exponent"><span class="ntref">Exponent</span></a> [<a href="#FloatingPointTypeSuffix"><span class="ntref">FloatingPointTypeSuffix</span></a>]
   | <a href="#DottedDecimalNumber"><span class="ntref">DottedDecimalNumber</span></a> [<a href="#Exponent"><span class="ntref">Exponent</span></a>] [<a href="#FloatingPointTypeSuffix"><span class="ntref">FloatingPointTypeSuffix</span></a>]
   | <a href="#DecimalNumber"><span class="ntref">DecimalNumber</span></a> <a href="#FloatingPointTypeSuffix"><span class="ntref">FloatingPointTypeSuffix</span></a>
<span class="ntdfn" id="DottedDecimalNumber">DottedDecimalNumber</span> :=
   <a href="#DecimalNumber"><span class="ntref">DecimalNumber</span></a> <code>.</code> <a href="#Digit"><span class="ntref">Digit</span></a>*
   | <code>.</code> <a href="#Digit"><span class="ntref">Digit</span></a>+
<span class="ntdfn" id="Exponent">Exponent</span> := <a href="#ExponentIndicator"><span class="ntref">ExponentIndicator</span></a> [<a href="#Sign"><span class="ntref">Sign</span></a>] <a href="#Digit"><span class="ntref">Digit</span></a>+
<span class="ntdfn" id="ExponentIndicator">ExponentIndicator</span> := <code>e</code> | <code>E</code>
<span class="ntdfn" id="HexFloatingPointLiteral">HexFloatingPointLiteral</span> := <a href="#HexIndicator"><span class="ntref">HexIndicator</span></a> <a href="#HexFloatingPointNumber"><span class="ntref">HexFloatingPointNumber</span></a>
<span class="ntdfn" id="HexFloatingPointNumber">HexFloatingPointNumber</span> :=
   <a href="#HexNumber"><span class="ntref">HexNumber</span></a> <a href="#HexExponent"><span class="ntref">HexExponent</span></a>
   | <a href="#DottedHexNumber"><span class="ntref">DottedHexNumber</span></a> [<a href="#HexExponent"><span class="ntref">HexExponent</span></a>]
<span class="ntdfn" id="DottedHexNumber">DottedHexNumber</span> :=
   <a href="#HexDigit"><span class="ntref">HexDigit</span></a>+ <code>.</code> <a href="#HexDigit"><span class="ntref">HexDigit</span></a>*
   | <code>.</code> <a href="#HexDigit"><span class="ntref">HexDigit</span></a>+
<span class="ntdfn" id="HexExponent">HexExponent</span> := <a href="#HexExponentIndicator"><span class="ntref">HexExponentIndicator</span></a> [<a href="#Sign"><span class="ntref">Sign</span></a>] <a href="#Digit"><span class="ntref">Digit</span></a>+
<span class="ntdfn" id="HexExponentIndicator">HexExponentIndicator</span> := <code>p</code> | <code>P</code>
<span class="ntdfn" id="Sign">Sign</span> := <code>+</code> | <code>-</code>
<span class="ntdfn" id="FloatingPointTypeSuffix">FloatingPointTypeSuffix</span> := <a href="#DecimalTypeSuffix"><span class="ntref">DecimalTypeSuffix</span></a> | <a href="#FloatTypeSuffix"><span class="ntref">FloatTypeSuffix</span></a>
<span class="ntdfn" id="DecimalTypeSuffix">DecimalTypeSuffix</span> := <code>d</code> | <code>D</code>
<span class="ntdfn" id="FloatTypeSuffix">FloatTypeSuffix</span> :=  <code>f</code> | <code>F</code>
</pre>

<section>
<h5 id="section_5.2.4.1">5.2.4.1 Float</h5>

<p>
The float type corresponds to IEEE 754-2008 64-bit binary (radix 2) floating
point numbers. A float value can be represented by either a
DecimalFloatingPointNumber with an optional FloatTypeSuffix, or by a
HexFloatingPointLiteral.
</p>
<p>
The multiple bit patterns that IEEE 754 treats as NaN are considered to be the
same value in Ballerina. Positive and negative zero of a floating point basic
type are distinct values, following IEEE 754, but are defined to have the same
shape, so that they will usually be treated as being equal.
</p>
<p>
IEEE-defined operations on float values must be performed using a
rounding-direction attribute of roundTiesToEven (which is the default IEEE
rounding direction, sometimes called <em>round to nearest</em>). All float
values, including the intermediate results of expressions, must use the value
space defined for the float type; implementations must not use extended
precision for intermediate results. This ensures that all implementations will
produce identical results. (This is the same as what is required by strictfp in
Java.)
</p>
</section>
<section>
<h5 id="section_5.2.4.2">5.2.4.2 Decimal</h5>

<p>
The decimal type corresponds to a subset of IEEE 754-2008 128-bit decimal (radix
10) floating point numbers. Any decimal value can be represented by a
DecimalFloatingPointNumber with an optional DecimalTypeSuffix.
</p>
<p>
A decimal value is a triple (<var>s</var>, <var>c</var>, <var>e</var>) where
</p>
<ul>
<li>
<var>s</var> is sign, either 0 or -1</li>
<li>
<var>c</var> is the coefficient, an unsigned integer that can be exactly
represented in 34 decimal digits</li>
<li>
<var>e</var> is the exponent, a signed integer</li>
</ul>
<p>
representing the mathematical value -1<sup><var>s</var></sup> Ã
<var>c</var> Ã 10<sup><var>e</var></sup>. The range for the exponent
<var>e</var> is implementation dependent, but must be at least the range
supported by the IEEE 754-2008 decimal128 format (which is -6176 to 6111
inclusive).
</p>
<p>
The decimal type corresponds to the ANSI X3.X274 subset of IEEE 754-2008, which
has the following simplifications:
</p>
<ul>
<li>+0 and -0 are not distinguished; if the coefficent is zero, then the sign is
also constrained to be zero;</li>
<li>NaN, infinities and subnormals are not supported; operations that would
result in one of these values according to the normal rules of IEEE 754-2008
instead result in a panic.</li>
</ul>
<p>
Operations on the decimal type use the roundTiesToEven rounding mode, like the
float type.
</p>
<p>
The shape of a decimal value is its mathematical value. Thus two decimal values
have the same shape if they represent the same mathematical value, even if they
do so using different exponents.
</p>
</section>
</section>
</section>
<section>
<h3 id="section_5.3">5.3 Sequence values</h3>

<pre class="grammar"><span class="ntdfn" id="sequence-type-descriptor">sequence-type-descriptor</span> :=
   <a href="#string-type-descriptor"><span class="ntref">string-type-descriptor</span></a>
   | <a href="#xml-type-descriptor"><span class="ntref">xml-type-descriptor</span></a>
</pre>
<p>
A sequence value belongs to one of the following two basic types:
</p>
<ul>
<li>string</li>
<li>xml</li>
</ul>
<p>
A sequence value consists of an ordered sequence of zero or more constituent
items, where the constituent items belong to the same basic type as the sequence
value itself. The <em>length</em> of a sequence value is the number of its
constituent items. Each constituent of a sequence value has an integer index
â¥ 0 and &lt; length. A sequence value is a <em>singleton</em> if its
length is 1. For each sequence basic type, there is an <em>empty</em> value,
which has length 0. As with other basic types, the sequence basic types are
disjoint with themselves and with other basic types. Thus the empty value for
string is distinct from the empty value for xml, and these are both distinct
from nil.
</p>
<p>
The values belonging to a sequence basic type B can be defined in terms of its
singleton values and a concatenation operation, by the following rules:
</p>
<ul>
<li>
the singleton values of B belong to B;
</li>
<li>
the empty value of B belongs to B;
</li>
<li>
if v<sub>1</sub> and v<sub>2</sub> belong to B, then the concatenation of
v<sub>1</sub> and v<sub>2</sub> belongs to B.
</li>
</ul>
<p>
The concatenation of any value v belonging to B with the empty sequence of B in
either order is v.
</p>
<p>
Note that for a sequence consisting of a single item v is the same thing as v. A
single item <em>is a</em> sequence. The type of the constituent items of a
sequence of basic type B is thus a subtype of B. This is a fundamental
difference between sequences and lists.
</p>
<p>
Only singleton values of a sequence type can have storage identity. When a
constituent of a sequence value has storage identity, what is stored in the
sequence value is a reference to the location where the constituent value is
stored rather than the constituent value itself.
</p>
<p>
A sequence value is iterable: the iteration sequence consists of the singleton
items of the sequence value in order and the iteration completion value is
always nil.
</p>

<section>
<h4 id="section_5.3.1">5.3.1 Strings</h4>

<pre class="grammar"><span class="ntdfn" id="string-type-descriptor">string-type-descriptor</span> := <code>string</code>
<span class="ntdfn" id="string-literal">string-literal</span> := <a href="#DoubleQuotedStringLiteral"><span class="ntref">DoubleQuotedStringLiteral</span></a>
<span class="ntdfn" id="DoubleQuotedStringLiteral">DoubleQuotedStringLiteral</span> := <code>"</code> (<a href="#StringChar"><span class="ntref">StringChar</span></a> | <a href="#StringEscape"><span class="ntref">StringEscape</span></a>)* <code>"</code>
<span class="ntdfn" id="StringChar">StringChar</span> := ^ ( 0xA | 0xD | <code>\</code> | <code>"</code> )
<span class="ntdfn" id="StringEscape">StringEscape</span> := <a href="#StringSingleEscape"><span class="ntref">StringSingleEscape</span></a> | <a href="#StringNumericEscape"><span class="ntref">StringNumericEscape</span></a>
<span class="ntdfn" id="StringSingleEscape">StringSingleEscape</span> := <code>\t</code> | <code>\n</code> | <code>\r</code> | <code>\\</code> | <code>\"</code>
<span class="ntdfn" id="StringNumericEscape">StringNumericEscape</span> := <code>\u{</code> <a href="#CodePoint"><span class="ntref">CodePoint</span></a> <code>}</code>
<span class="ntdfn" id="CodePoint">CodePoint</span> := <a href="#HexDigit"><span class="ntref">HexDigit</span></a>+
</pre>
<p>
A string is an sequence of zero or more Unicode characters. More precisely, it
is a sequence whose singleton values represent Unicode scalar values, where a
Unicode scalar value is any code point in the Unicode range of 0x0 to 0x10FFFF
inclusive, other than surrogate code points, which are 0xD800 to 0xDFFF
inclusive. Note that a string may include Unicode noncharacters, such as 0xFFFE
and 0xFFFF.
</p>
<p>
In a <code>StringNumericEscape</code>, <code>CodePoint</code> must valid Unicode
code point; more precisely, it must be a hexadecimal numeral denoting an
integer <em>n</em> where 0 â¤ <em>n</em> &lt; 0xD800 or 0xDFFF &lt; n â¤
0x10FFFF.
</p>
<p>
String values do not have storage identity and so the string basic type is
inherently immutable.
</p>
<p>
There is a <a href="#built-in_subtypes">built-in subtype</a>
<code>string:Char</code> for single character strings.
</p>
</section>
<section>
<h4 id="XML">5.3.2 XML</h4>

<p>
An xml value is a sequence representing parsed XML, such as occurs in the
content of an XML element. The singleton values are of the following types:
</p>
<ul>
<li>element</li>
<li>processing instruction</li>
<li>comment</li>
<li>text</li>
</ul>
<p>
The element, processing instruction and comment singletons correspond directly
to information items in the XML Information Set. A text singleton corresponds to
one or more character information items. When an xml value is constructed,
consecutive text singletons are merged, so that an xml value never contains
consecutive text singletons. There are <a href="#built-in_subtypes">built-in
subtypes</a> <code>xml:Element</code>, <code>xml:ProcessingInstruction</code>,
<code>xml:Comment</code> and <code>xml:Text</code> corresponding to the above
singletons; <code>xml:Text</code> also allows the empty xml value.
</p>
<pre class="grammar"><span class="ntdfn" id="xml-type-descriptor">xml-type-descriptor</span> := <code>xml</code> [<a href="#type-parameter"><span class="ntref">type-parameter</span></a>]
<span class="ntdfn" id="type-parameter">type-parameter</span> := <code>&lt;</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>&gt;</code>
</pre>
<p>
A shape belongs to type <code>xml</code> if its basic type is <code>xml</code>.
A type parameter of an xml-type-descriptor must be a subtype of
<code>xml</code>. A shape belongs to type <code>xml&lt;T&gt;</code> if all of
its constituent items belong to <code>T</code>. So, for example,
<code>xml&lt;xml:Element&gt;</code> is the type for xml values containing
only elements. Note that <code>xml&lt;xml&lt;<var>T</var>&gt;&gt;</code> is the
same as <code>xml&lt;<var>T</var>&gt;</code> and that
<code>xml&lt;xml:Text&gt;</code> is the same as <code>xml:Text</code>.
</p>
<p>
The name of an element is represented by a string. The attributes of an element
are represented by a value of type <code>map&lt;string&gt;</code>. The children
of an element is represented by a value of type <code>xml</code>.
</p>
<p>
Singleton element, processing instruction and comment values have storage
identity. Other xml values do not.
</p>
<p>
The <code>xml:Text</code> type is inherently immutable. This implies that both
text singletons and empty xml values always have their read-only bits on. The
<code>xml:Element</code>, <code>xml:ProcessingInstruction</code> and
<code>xml:Comment</code> types are selectively immutable. The read-only bit of a
xml value with length greater than one is on if and only if the read-only bit
of all its constituent items is on. Immutability of xml values is deep: if the
read-only bit of an <code>xml:Element</code> is on, then the read-only bits of the
mapping representing its attributes and of the xml value representing its
children are also on.
</p>
<p>
Note that although the mutable constituents of mutable xml value can be mutated,
the number and the storage identity of the constituents of a xml value are fixed
when the value is constructed. The storage identity of the attributes map of an
element are also fixed when the element is constructed.
</p>
<section>
<h5 id="section_5.3.2.1">5.3.2.1 XML namespaces</h5>
<p>
The name of an element or attribute, which in the XML Information Set is
represented by a combination of the [namespace name] and [local name] properties
of an element information item (EII) or attribute information item (AII), is
represented by a single <em>expanded name</em> string. If the [namespace name]
property has no value, then the expanded name consists of just the value of the
[local name] property; otherwise, the expanded name is of the form:
</p>
<pre>
   {<var>namespace-uri</var>}<var>local-name</var>
</pre>
<p>
where <code><var>namespace-uri</var></code> and
<code><var>local-name</var></code> are the values of the [namespace name] and
[local name] properties respectively.
</p>
<p>
The attributes map for an element includes not only an entry for each AII in the
[attributes] property of the EII, but also an entry for each attribute in the
[namespace attributes] property. The key of the entry is the string representing
the name of the attribute, constructed from the AII item as described in the
previous paragraph. The name of every namespace attribute will thus start with
the string <code>{http://www.w3.org/2000/xmlns/}</code>.
</p>
<p>
The attributes map can also contain entries representing namespace attributes
synthesized from the [in-scope namespaces] property. There will be a synthesized
namespace attribute for every prefix other than <code>xml</code> that occurs as
a prefix of the EII or of an AII in the element's [attributes] property and for
which there is no declaration in the [namespace attributes] property. No
namespace attribute will be synthesized for the default namespace. (The
synthesized namespace attributes ensure that namespace prefixes will not be lost
if the element is extracted into a new context.)
</p>
<p>
An xml value can be converted to an XML information set for serialization. This
is done in the context of a set of namespace declarations that are in-scope from
the xml value's parent element, if any. The process of converting an xml element
singleton into an EII has the following stages.
</p>
<ol>
<li>The [namespace name] and [local name] properties of the EII are determined
from the element's expanded name.</li>
<li>An AII is constructed for each entry in the element's attribute map, with
the [namespace name] and [local name] properties of the AII determined from the
entry's key, which is the attribute's expanded name. Each AII is added to either
the [attributes] or [namespace attributes] property of the EII depending on the
AII's [namespace name] property. The [prefix] property of each AII in the
[namespace attributes] property can also be set at this point.</li>
<li>The [namespace attributes] property of the EII is pruned by removing an
AII with [normalized value] N if the AII is not a default namespace declaration,
and the in-scope namespace declarations include a declaration with namespace
name N, and either the EII or one of the AIIs has a [namespace name] property
equal to N. (In this case, the entry for the namespace attribute would get
synthesized when the information set is converted to an xml value.)</li>
<li>For each AII in the EII's [attributes] property that has a [namespace name]
property, a [prefix] property is assigned. If the namespace name is
<code>http://www.w3.org/XML/1998/namespace</code>, then use a prefix of
<code>xml</code>. If there is already a namespace declaration in the [namespace
attributes] that declares a prefix with that namespace name, then that prefix is
used. Otherwise if there is a namespace declaration in the in-scope namespaces
that declares a prefix with that namespace and it is not redeclared or
undeclared by the [namespace attributes], then that prefix is used. Otherwise
generate a prefix and add an AII to the [namespace attributes] to declare
it.</li>
<li>If the EII has no [namespace name] property, but a default namespace
declaration is in scope, then an <code>xmlns=""</code> AII is added to the
[namespace attributes] property to undeclare the default namespace.</li>
<li>If the EII has a [namespace name] property N, then we need
to ensure that there is an applicable namespace declaration:
<ol>
<li>if one of the [namespace attributes] declares N as the default namespace,
then nothing needs to be done;</li>
<li>similarly, if an in-scope namespace declaration declares N as the default
namespace, and the [namespace attributes] do not undeclare it, then nothing
needs to be done;</li>
<li>otherwise, try to find, in the same way as for an AII, a prefix P which is
already declared as N; if there is one, set the [prefix] property of the EII to
P;</li>
<li>otherwise, if the [namespace attributes] property does not contain a default
namespace declaration or undeclaration, generate a default namespace declaration
for N and add it to the [namespace attributes] property;</li>
<li>otherwise, generate a new prefix P, set the [prefix] property of the EII to
P, and add an AII to the [namespace attributes] to declare it.</li>
</ol>
</li>
<li>Generate the [in-scope namespaces] property for this EII, using the parent's
in-scope namespaces and the [namespace attributes].</li>
<li>Convert the children of the xml element, including the element children, to
a list of information items, in the context of this EII's in-scope
namespaces.</li>
</ol>

</section>

</section>

</section>
<section>
<h3 id="section_5.4">5.4 Structured values</h3>
<p>
Structured values are containers for other values, which are called their
members. There are three basic types of structured value: list, mapping and
table.
</p>
<p>
Structured values are usually mutable. Mutating a structured value changes which
values it contains. Structured values can also be constructed as immutable.
Immutability is deep: immutable structured values cannot contain mutable
structured values; if the read-only bit of a structured value is on, then the
read-only bit of each of its members is on.
</p>
<p>
The shape of the members of a structured value contributes to the shape of the
structured value. A structured type descriptor describe the shape of the
structured value in terms of the shapes of its members. Mutating a member of a
structured value can cause the shape of the structured value to change. A
structured value has an inherent type, which is a type descriptor which is part
of the structured value's runtime value. At runtime, the structured value
prevents any mutation that might lead to the structured value having a shape
that is not a member of its inherent type. Thus a structured value belongs to a
type if and only if its inherent type is a subtype of that type.
</p>
<p>
The inherent type of an immutable structured value is a singleton type with the
structured value's shape as its single member. Thus, an immutable structured
value belongs to a type if and only if the type contains the shape of the value.
</p>
<p>
Every structured value has a length, which is the number of its members.
All structured values are iterable: the iteration sequence consists of the
members of the structure and the completion type is always nil.
</p>
<p>
A structured value provides random access to its members using a key that
uniquely identifies each member within the structure. A key can be out-of-line,
meaning it is independent of the member, or in-line, meaning it is part of the
member. The <em>member type</em> for a key type K in a structured type T
consists of all shapes v such that there is a shape in T with key in K and shape
v. A type K is an <em>optional key type</em> for T if there is a shape v in T
and a key k in K such that v does not have a member k; a type that is not an
optional key type is a required key type.
</p>

<pre class="grammar"><span class="ntdfn" id="structured-type-descriptor">structured-type-descriptor</span> :=
   <a href="#list-type-descriptor"><span class="ntref">list-type-descriptor</span></a>
   | <a href="#mapping-type-descriptor"><span class="ntref">mapping-type-descriptor</span></a>
   | <a href="#table-type-descriptor"><span class="ntref">table-type-descriptor</span></a>
</pre>
<p>
The following table summarizes the type descriptors for structured types.
</p>
<table>
  <tr>
   <td>Structured type</td>
   <td>list</td>
   <td>mapping</td>
   <td>table</td>
  </tr>
  <tr>
   <td>Key source</td>
   <td>out-of-line</td>
   <td>out-of-line</td>
   <td>in-line</td>
  </tr>
  <tr>
   <td>Key type</td>
   <td>integer</td>
   <td>string</td>
   <td>anydata</td>
  </tr>
  <tr>
   <td>Type descriptor with uniform member type</td>
   <td>array</td>
   <td>map</td>
   <td>table</td>
  </tr>
  <tr>
   <td>Type descriptor with separate member types</td>
   <td>tuple</td>
   <td>record</td>
   <td>-</td>
  </tr>
</table>

<section>
<h4 id="section_5.4.1">5.4.1 Lists</h4>
<p>
A list value is a container that keeps its members in an ordered list. The
number of members of the list is called the <em>length</em> of the list. The key
for a member of a list is the integer index representing its position in the
list, with the index of the first member being 0. For a list of length
<em>n</em>, the indices of the members of the list, from first to last, are
0,1,...,<em>n</em> - 1. The shape of a list value is an ordered list of the
shapes of its members.
</p>
<p>
A list is iterable: the iteration sequence consists of the members of the
list in order and the iteration completion value is always nil.
</p>
<p>
The type of list values can be described by two kinds of type descriptors.
</p>

<pre class="grammar"><span class="ntdfn" id="list-type-descriptor">list-type-descriptor</span> :=
   <a href="#array-type-descriptor"><span class="ntref">array-type-descriptor</span></a> | <a href="#tuple-type-descriptor"><span class="ntref">tuple-type-descriptor</span></a>
</pre>
<p>
The inherent type of a list value must be a <code>list-type-descriptor</code>.
The inherent type of a list value determines a type T<sub><em>i</em></sub> for a
member with index <em>i</em>. The runtime system will enforce a constraint that
a value written to index <em>i</em> will belong to type T<sub><em>i</em></sub>.
Note that the constraint is not merely that the value looks like
T<sub><em>i</em></sub>.
</p>
<p>
Both kinds of type descriptor are covariant in the types of their members.
</p>
<section>
<h5 id="section_5.4.1.1">5.4.1.1 Array types</h5>
<p>
An array type-descriptor describes a type of list value by specifying the type
that the value for all members must belong to, and optionally, a length.
</p>

<pre class="grammar"><span class="ntdfn" id="array-type-descriptor">array-type-descriptor</span> := <a href="#member-type-descriptor"><span class="ntref">member-type-descriptor</span></a> <code>[</code> [ <a href="#array-length"><span class="ntref">array-length</span></a> ] <code>]</code>
<span class="ntdfn" id="member-type-descriptor">member-type-descriptor</span> := <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>
<span class="ntdfn" id="array-length">array-length</span> :=
   <a href="#int-literal"><span class="ntref">int-literal</span></a>
   | <a href="#constant-reference-expr"><span class="ntref">constant-reference-expr</span></a>
   | <a href="#inferred-array-length"><span class="ntref">inferred-array-length</span></a>
<span class="ntdfn" id="inferred-array-length">inferred-array-length</span> := <code>*</code>
</pre>
<p>
A type <code>T[]</code> contains a list shape if all members of the list shape
are in <code>T</code>. A type <code>T[n]</code> contains a list shape if in
addition the length of the list shape is n.
</p>
<p>
A <code>constant-reference-expr</code> in an <code>array-length</code> must
evaluate to a non-negative integer. An array length of <code>*</code> means that
the length of the array is to be inferred from the context; this is allowed only
within a type descriptor occurring in a context that is specified to be
inferable; its meaning is the same as if the length was specified explicitly.
</p>
<p>
Note also that <code>T[n]</code> is a subtype of <code>T[]</code>, and that if
<code>S</code> is a subtype of <code>T</code>, then <code>S[]</code> is a
subtype of <code>T[]</code>; this is a consequence of the definition of
subtyping in terms of subset inclusion of the corresponding sets of shapes.
</p>
<p>
The type of the values in the iteration sequence of a value belonging
<code>T[]</code> is <code>T</code>.
</p>
</section>
<section>
<h5 id="section_5.4.1.2">5.4.1.2 Tuple types</h5>
<p>
A tuple type descriptor describes a type of list value by specifying a separate
type for each member of the list.
</p>

<pre class="grammar"><span class="ntdfn" id="tuple-type-descriptor">tuple-type-descriptor</span> :=
   <code>[</code> <a href="#tuple-member-type-descriptors"><span class="ntref">tuple-member-type-descriptors</span></a> <code>]</code>
<span class="ntdfn" id="tuple-member-type-descriptors">tuple-member-type-descriptors</span> :=
   <a href="#member-type-descriptor"><span class="ntref">member-type-descriptor</span></a> (<code>,</code> <a href="#member-type-descriptor"><span class="ntref">member-type-descriptor</span></a>)* [<code>,</code> <a href="#tuple-rest-descriptor"><span class="ntref">tuple-rest-descriptor</span></a>]
   | [ <a href="#tuple-rest-descriptor"><span class="ntref">tuple-rest-descriptor</span></a> ]
<span class="ntdfn" id="tuple-rest-descriptor">tuple-rest-descriptor</span> := <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>...</code>

</pre>
<p>
A tuple type descriptor T with m member type descriptors contains a list shape L
of length n if and only if:
</p>
<ul>
<li>m is less than or equal to n</li>
<li>the i-th member type descriptor of T contains the i-th member of L for each
i from 1 to m;</li>
<li>if n is greater than m, then T has a tuple-rest-descriptor
R<code>...</code>, and R contains the j-th member of L for each j from m + 1 to
n.</li>
</ul>
<p>
Note that a tuple type where all the <code>member-type-descriptor</code>s are
the same and there is no tuple-rest-descriptor is equivalent to an
array-type-descriptor with a length.
</p>
</section>
</section>
<section>
<h4 id="section_5.4.2">5.4.2 Mappings</h4>
<p>
A mapping value is a container where each member has a key, which is a string,
that uniquely identifies within the mapping. We use the term <em>field</em> to
mean the member together its key; the name of the field is the key, and the
value of the field is that value of the member; no two fields in a mapping value
can have the same name.
</p>
<p>
The shape of a mapping value is an unordered collection of field shapes one for
each field. The field shape for a field f has a name, which is the same as the
name of f, and a shape, which is the shape of the value of f.
</p>
<p>
Each field also has a read-only bit. This is in addition to the read-only bit of
the mapping value. If a mapping value's field has its read-only bit on, then
that field cannot be assigned to nor removed. If the mapping value's read-only
bit is on, then the read-only bit of every field is also on. A field's read-only
bit is fixed when the mapping value is constructed, and cannot be changed
thereafter. If a field's read-only bit is on, the read-only bit of the value of
the field is also on. The read-only bit of a field is part of the read-only
aspect of the mapping value's shape.
</p>
<p>
A mapping is iterable: the iteration sequence consists of the members of the
mapping and the iteration completion value is always nil. The order of the iteration
sequence is implementation-dependent, but implementations are encouraged to
preserve and use the order in which the fields were added.
</p>
<p>
The type of mapping values can be described by two kinds of type descriptors.
</p>

<pre class="grammar"><span class="ntdfn" id="mapping-type-descriptor">mapping-type-descriptor</span> :=
   <a href="#map-type-descriptor"><span class="ntref">map-type-descriptor</span></a> | <a href="#record-type-descriptor"><span class="ntref">record-type-descriptor</span></a>
</pre>
<p>
The inherent type of a mapping value must be a
<code>mapping-type-descriptor</code>. The inherent type of a mapping value
determines a type T<sub><em>f</em></sub> for the value of the field with name
<em>f</em>. The runtime system will enforce a constraint that a value written to
field <em>f</em> will belong to type T<sub><em>f</em></sub>. Note that the
constraint is not merely that the value looks like T<sub><em>f</em></sub>.
</p>
<p>
Both kinds of type descriptor are covariant in the types of their members.
</p>
<section>
<h5 id="section_5.4.2.1">5.4.2.1 Map types</h5>
<p>
A map type-descriptor describes a type of mapping value by specifying the type
that the value for all fields must belong to.
</p>

<pre class="grammar"><span class="ntdfn" id="map-type-descriptor">map-type-descriptor</span> := <code>map</code> <a href="#type-parameter"><span class="ntref">type-parameter</span></a>
</pre>
<p>
A type <code>map&lt;T&gt;</code> contains a mapping shape <em>m</em> if every field
shape in <em>m</em> has a value shape that is in <code>T</code>.
</p>
<p>
The type of the values in the iteration sequence of a value belonging
<code>map&lt;T&gt;</code> is <code>T</code>.
</p>
<p>
If a type descriptor T has <a href="#lax_static_typing">lax static typing</a>,
then the type <code>map&lt;T&gt;</code> also has lax static typing.
</p>
</section>
<section>
<h5 id="section_5.4.2.2">5.4.2.2 Record types</h5>
<p>
A record type descriptor describes a type of mapping value by specifying a type
separately for the value of each field.
</p>

<pre class="grammar"><span class="ntdfn" id="record-type-descriptor">record-type-descriptor</span> :=
   <a href="#inclusive-record-type-descriptor"><span class="ntref">inclusive-record-type-descriptor</span></a> | <a href="#exclusive-record-type-descriptor"><span class="ntref">exclusive-record-type-descriptor</span></a>
<span class="ntdfn" id="inclusive-record-type-descriptor">inclusive-record-type-descriptor</span> :=
   <code>record</code> <code>{</code> <a href="#field-descriptor"><span class="ntref">field-descriptor</span></a>* <code>}</code>
<span class="ntdfn" id="exclusive-record-type-descriptor">exclusive-record-type-descriptor</span> :=
   <code>record</code> <code>{|</code> <a href="#field-descriptor"><span class="ntref">field-descriptor</span></a>* [<a href="#record-rest-descriptor"><span class="ntref">record-rest-descriptor</span></a>] <code>|}</code>
<span class="ntdfn" id="field-descriptor">field-descriptor</span> :=
   <a href="#individual-field-descriptor"><span class="ntref">individual-field-descriptor</span></a> | <a href="#record-type-inclusion"><span class="ntref">record-type-inclusion</span></a>
<span class="ntdfn" id="individual-field-descriptor">individual-field-descriptor</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a> [<code>readonly</code>] <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <a href="#field-name"><span class="ntref">field-name</span></a> [<code>?</code> | <a href="#default-value"><span class="ntref">default-value</span></a>] <code>;</code>
<span class="ntdfn" id="field-name">field-name</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
<span class="ntdfn" id="default-value">default-value</span> := <code>=</code> <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="record-type-inclusion">record-type-inclusion</span> := <code>*</code> <a href="#type-reference"><span class="ntref">type-reference</span></a> <code>;</code>
<span class="ntdfn" id="record-rest-descriptor">record-rest-descriptor</span> := <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>...</code> <code>;</code>
</pre>
<p>
Each <code>individual-field-descriptor</code> specifies an additional constraint
that a mapping value shape must satisfy for it to be a member of the described
type. The constraint depends on whether <code>?</code> is present:
</p>
<ul>
<li>if <code>?</code> is not present, then the constraint is that the mapping
value shape must have a field shape with the specified field-name and with a
value shape that is a member of the specified type-descriptor; this is called a
required field;</li>
<li>if <code>?</code> is present, then the constraint is that if the mapping
value shape has a field shape with the specified field-name, then its value
shape must be a member of the specified type-descriptor; this is called an
optional field.</li>
</ul>
<p>
If an <code>individual-field-descriptor</code> specifies <code>readonly</code>,
then there is also a constraint that the field has its read-only bit set.
Furthermore, the type of the field is the intersection of <code>readonly</code>
and the type specified by the type-descriptor.
</p>
<p>
The order of the <code>individual-field-descriptor</code>s within a
<code>record-type-descriptor</code> is not significant. Note that the delimited
identifier syntax allows the field name to be any non-empty string.
</p>
<p>
An exclusive-record-type-descriptor, which uses the <code>{|</code> and
<code>|}</code> delimiters, allows exclusively the fields described. More
precisely, for a mapping value shape and a record-type-descriptor, let the extra
field shapes be the field shapes of the mapping value shapes whose names are not
the same as field-name of any individual-field-descriptor; a mapping value shape
is a member of the type described by an exclusive-record-type-descriptor only if
either:
</p>
<ul>
<li>there are no extra fields shapes, or</li>
<li>there is a record-rest-descriptor <code>T...</code>, and the value shape of
every extra field shape is a member of <code>T</code>.</li>
</ul>
<p>
An inclusive-record-type-descriptor, which uses the <code>{</code> and
<code>}</code> delimiters, allows any mapping value that includes the fields
described, provided that the values of all other fields are plain data. A type
descriptor <code>record { F };</code> is thus equivalent to <code>record {| F;
anydata...; |}</code>, where <code>anydata</code> is defined <a href="#anydata">below</a> as the type descriptor for plain data.
</p>
<p>
A record type descriptor that either is an inclusive-record-type-descriptor or
is an exclusive-record-type-descriptor with a record-rest-descriptor is called
<em>open</em>; a record type descriptor that is not open is called
<em>closed</em>.
</p>
<p>
If a record type descriptor is closed and every individual-type-descriptor
specifies <code>readonly</code>, then it describes a type that is a subtype of
<code>readonly</code>: a shape belongs to the type only if its read-only bit is
set.
</p>
<p>
A <code>default-value</code> specifies a default value for the field, which is
used when the record type descriptor is used to construct a mapping value but no
value is specified explicitly for the field. The type descriptor contains a
0-argument function closure for each default value. The closure is created from
the expression when the type descriptor is resolved. The closure is evaluated to
create a field value each time the default is used in the construction of a
mapping value. The default value does not affect the type described by the type
descriptor.
</p>
<p>
A <code>record-type-inclusion</code> includes fields from a named record type.
The <code>type-reference</code> must reference a type described by a
<code>record-type-descriptor</code>. The <code>field-descriptor</code>s and any
<code>record-rest-descriptor</code> are included the type being defined; the
meaning is the same as if they had been specified explicitly. For default
values, the closure rather than the expression is copied in. An
<code>individual-field-descriptor</code> in a
<code>record-type-descriptor</code> can override an
<code>individual-field-descriptor</code> of the same name in an included
<code>record-type-descriptor</code>, provided the type declared for the field in
the overriding field descriptor is a subtype of the type declared in the
overridden field descriptor. It is an error for an
<code>record-type-descriptor</code> to directly or indirectly include itself. A
<code>record-rest-descriptor</code> in the including type overrides any
<code>record-rest-descriptor</code> in the included type. For the purposes of
resolving a <code>record-type-reference</code>, a including or included type
that is an <code>inclusive-record-type-descriptor</code> is treated as if it
were the equivalent <code>exclusive-record-type-descriptor</code> with an
explicit <code>record-rest-descriptor</code>.
</p>
</section>
</section>
<section>
<h4 id="tables">5.4.3 Tables</h4>
<p>
A table is a structural value, whose members are mapping values. A table
provides access to its members using a key that comes from the read-only fields
of the member. It keeps its members in order, but does not provide random access
to a member using its position in this order.
</p>
<p>
Every table value has, in addition to its members, a key sequence, which is used
to provide keyed access to its members. The key sequence is an ordered sequence
of field names. The key sequence of a table is fixed when a table is
constructed and cannot be changed thereafter. For each field name in the key
sequence, every member of the table must have a read-only field with that name
and the value of the field must be acyclic plain data. A table's key sequence
determines a key value for each member of the table: if the key sequence
consists of a single field name f, then the key value of a member is that value
of field f of that member. If the key sequence consists of multiple field names
f<sub>1</sub>,f<sub>2</sub>,...,f<sub>n</sub> where n is â¥ 2, then the
key value for a member r is a tuple with members
v<sub>1</sub>,v<sub>2</sub>,...,v<sub>n</sub> where v<sub>i</sub> is the value
of field f<sub>i</sub> of r. A table constrains its membership so that a key
value uniquely identifies a member within the table. More precisely, for every
two rows r<sub>i</sub> and r<sub>j</sub> in a table with i not equal to j, the
key value for r<sub>i</sub> must not be equal to the key value for
r<sub>j</sub>. Key values are compared for equality using the <a href="#DeepEquals">DeepEquals</a> abstract operation. This constraint is
enforced by the table both when the table is constructed and when the table is
mutated. As a special case, a table's key sequence may be empty; this represents
a keyless table, whose members are not uniquely identified by a key.
</p>
<p>
The shape of a table value is a triple consisting of
</p>
<ul>
<li>an ordered list containing for each table member, the shape of that member</li>
<li>the table's key sequence, and</li>
<li>a set containing for each table member, the shape of the key value of that
member (derived from the table members and the key sequence)</li>
</ul>

<pre class="grammar"><span class="ntdfn" id="table-type-descriptor">table-type-descriptor</span> := <code>table</code> <a href="#row-type-parameter"><span class="ntref">row-type-parameter</span></a> [<a href="#key-constraint"><span class="ntref">key-constraint</span></a>]
<span class="ntdfn" id="row-type-parameter">row-type-parameter</span> := <a href="#type-parameter"><span class="ntref">type-parameter</span></a>
<span class="ntdfn" id="key-constraint">key-constraint</span> := <a href="#key-specifier"><span class="ntref">key-specifier</span></a> | <a href="#key-type-constraint"><span class="ntref">key-type-constraint</span></a>
<span class="ntdfn" id="key-specifier">key-specifier</span> := <code>key</code> <code>(</code> [ <a href="#field-name"><span class="ntref">field-name</span></a> (<code>,</code> <a href="#field-name"><span class="ntref">field-name</span></a>)* ] <code>)</code>
<span class="ntdfn" id="key-type-constraint">key-type-constraint</span> := <code>key</code> <a href="#type-parameter"><span class="ntref">type-parameter</span></a>
</pre>
<p>
The row-type-parameter specifies the shape of the table's members. A table type
<code>table&lt;<var>R</var>&gt; <var>KC</var> </code> contains a table shape if
and only if every table member shape belongs to <code><var>R</var></code> and
the table shape satisfies the key constraint <code><var>KC</var></code>. The
type specified by a row-type-parameter must be a subtype of
<code>map&lt;any|error&gt;</code>
</p>
<p>
In a table-type-descriptor <code>table&lt;<var>R</var>&gt;
key(<var>ks</var>)</code>, <code><var>R</var></code> and
<code><var>ks</var></code> must be consistent in the following sense: for each
field name f<sub>i</sub> in <code><var>ks</var></code>, f<sub>i</sub> must be a
required, read-only field of <code><var>R</var></code> with a type that is a
subtype of <code>anydata</code>. A table shape satisfies a key-constraint
<code>key(<var>ks</var>)</code> if and only if its key sequence is
<code><var>ks</var></code>. A table shape satisfies a key-constraint
<code>key&lt;K&gt;</code> if and and only if its set of key value shapes are a
subset of <code><var>K</var></code>. The shape of a keyless table satisfies the
key-constraint <code>key&lt;never&gt;</code>.
</p>
<p>
As with other structured values, a table value has an inherent type. The
inherent type of a table value must be a table-type-descriptor with a
key-constraint that is a key-specifier.
</p>
<p>
A table is iterable: the iteration sequence consists of the members of the
table in order and the iteration completion value is always nil.
</p>

</section>
</section>
<section>
<h3 id="section_5.5">5.5 Behavioral values</h3>

<pre class="grammar"><span class="ntdfn" id="behavioral-type-descriptor">behavioral-type-descriptor</span> :=
   <a href="#error-type-descriptor"><span class="ntref">error-type-descriptor</span></a>
   | <a href="#function-type-descriptor"><span class="ntref">function-type-descriptor</span></a>
   | <a href="#object-type-descriptor"><span class="ntref">object-type-descriptor</span></a>
   | <a href="#future-type-descriptor"><span class="ntref">future-type-descriptor</span></a>
   | <a href="#service-type-descriptor"><span class="ntref">service-type-descriptor</span></a>
   | <a href="#typedesc-type-descriptor"><span class="ntref">typedesc-type-descriptor</span></a>
   | <a href="#handle-type-descriptor"><span class="ntref">handle-type-descriptor</span></a>
   | <a href="#stream-type-descriptor"><span class="ntref">stream-type-descriptor</span></a>
</pre>

<section>
<h4 id="section_5.5.1">5.5.1 Errors</h4>

<pre class="grammar"><span class="ntdfn" id="error-type-descriptor">error-type-descriptor</span> := <code>error</code> [<a href="#error-type-param"><span class="ntref">error-type-param</span></a>]
<span class="ntdfn" id="error-type-param">error-type-param</span> := <code>&lt;</code> (<a href="#detail-type-descriptor"><span class="ntref">detail-type-descriptor</span></a> | <a href="#inferred-type-descriptor"><span class="ntref">inferred-type-descriptor</span></a>) <code>&gt;</code>
<span class="ntdfn" id="detail-type-descriptor">detail-type-descriptor</span> := <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>
<span class="ntdfn" id="inferred-type-descriptor">inferred-type-descriptor</span> := <code>*</code>
</pre>
<p>
An error value provides information about an error that has occurred. Error
values belong to a separate basic type; this makes it possible for language
constructs to handle errors differently from other values.
</p>
<p>
The error type is inherently immutable. An error value contains the following
information:
</p>
<ul>
<li>a message, which is a string containing a human-readable message describing
the error</li>
<li>a cause, which is either nil or another error value that was the cause of
this error</li>
<li>a detail, which is an immutable mapping providing additional information about
the error</li>
<li>a stack trace, which is an immutable snapshot of the state of the execution
stack</li>
</ul>
<p>
The detail mapping must be a subtype of <code>map&lt;anydata|readonly&gt;</code>.
</p>
<p>
The shapes of the message, cause and detail record are part of the shape of the
error; the stack trace is not part of the shape. A type descriptor
<code>error&lt;<var>T</var>&gt;</code> contains an error shape if
<code><var>T</var></code> contains the shape of the detail. The type
<code>error</code> contains a shape if its basic type is error.
</p>
<p>
A type of <code>error&lt;*&gt;</code> means that the type is a subtype of error,
where the precise subtype is to be inferred from the context. This is allowed
only within type descriptors occurring in a context that is specified to be
inferable.
</p>
<p>
An error-type-descriptor is always definite and induces an empty set of
type-ids. An intersecion type can be used to describe an error type that induces
a non-empty set of type-ids.
</p>
</section>

<section>
<h4 id="functions">5.5.2 Functions</h4>

<pre class="grammar"><span class="ntdfn" id="function-type-descriptor">function-type-descriptor</span> := <code>function</code> <a href="#function-signature"><span class="ntref">function-signature</span></a>
<span class="ntdfn" id="function-signature">function-signature</span> := <code>(</code> <a href="#param-list"><span class="ntref">param-list</span></a> <code>)</code> <a href="#return-type-descriptor"><span class="ntref">return-type-descriptor</span></a>
</pre>
<p>
A function is a part of a program that can be explicitly executed. In Ballerina,
a function is also a value, implying that it can be stored in variables, and
passed to or returned from functions. When a function is executed, it is passed
an argument list as input and returns a value as output.
</p>

<pre class="grammar"><span class="ntdfn" id="param-list">param-list</span> :=
   <a href="#required-params"><span class="ntref">required-params</span></a> [<code>,</code> <a href="#defaultable-params"><span class="ntref">defaultable-params</span></a>] [<code>,</code> <a href="#rest-param"><span class="ntref">rest-param</span></a>]
   | <a href="#defaultable-params"><span class="ntref">defaultable-params</span></a> [<code>,</code> <a href="#rest-param"><span class="ntref">rest-param</span></a>]
   | [<a href="#rest-param"><span class="ntref">rest-param</span></a>]
<span class="ntdfn" id="required-params">required-params</span> := <a href="#required-param"><span class="ntref">required-param</span></a> (<code>,</code> <a href="#required-param"><span class="ntref">required-param</span></a>)*
<span class="ntdfn" id="required-param">required-param</span> := [<a href="#annots"><span class="ntref">annots</span></a>] [<code>public</code>] <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> [<a href="#param-name"><span class="ntref">param-name</span></a>]
<span class="ntdfn" id="defaultable-params">defaultable-params</span> := <a href="#defaultable-param"><span class="ntref">defaultable-param</span></a> (<code>,</code> <a href="#defaultable-param"><span class="ntref">defaultable-param</span></a>)*
<span class="ntdfn" id="defaultable-param">defaultable-param</span> := [<a href="#annots"><span class="ntref">annots</span></a>] [<code>public</code>] <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> [<a href="#param-name"><span class="ntref">param-name</span></a>] <a href="#default-value"><span class="ntref">default-value</span></a>
<span class="ntdfn" id="rest-param">rest-param</span> := [<a href="#annots"><span class="ntref">annots</span></a>] <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>...</code> [<a href="#param-name"><span class="ntref">param-name</span></a>]
<span class="ntdfn" id="param-name">param-name</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
</pre>
<p>
A param-name can be omitted from a required-param, defaultable-param or
rest-param only when occuring in the function-signature of a
function-type-descriptor.
</p>
<p>
The argument list passed to a function consists of zero or more arguments in order;
each argument is a value, but the argument list itself is not passed as a value.
The argument list must conform to the param-list as described in this section.
Usually, the compiler's type checking will ensure that this is the case; if not,
the function will panic.
</p>
<p>
It is convenient to consider the complete param-list as having a type. This type
is described by a tuple-type-descriptor that has a member-type-descriptor for
each required-param and defaultable-param, and has a tuple-rest-descriptor if
and only if there is a rest-param. The i-th member-type-descriptor of the tuple
type descriptor is the same as the type-descriptor of the i-th member of the
param-list; the type-descriptor of the tuple-rest-descriptor, if present, is the
same as the type-descriptor of the rest-param.
</p>
<p>
An argument list consisting of values v<sub>1</sub>,..., v<sub>n</sub> conforms
to a param-list that has type P, if and only if for each i with 1 â¤ i â¤
n, v<sub>i</sub> belongs to T<sub>i</sub>, where T<sub>i</sub> is defined to be the type
that contains a shape s if and only if P contains a list shape whose i-th member
is s.
</p>
<p>
When an argument list is passed to a function, the non-rest parameters are
initialized from the arguments in the argument list in order. The conformance of
the argument list to the param-list declared for the function ensures that each
parameter will be initialized to a value that belongs to the declared type of
the parameter. If there is a rest-param, then that is a initialized to a newly
created lists containing the remaining arguments in the argument-list; the
inherent type of this list will be T[] where T is the type of the rest-param.
The conformance of the argument list ensures that the members of this list will
belong to type T.
</p>
<p>
A defaultable-param is a parameter for which a default value is specified. The
expression specifying the default value may refer to previous parameters by
name. For each defaultable parameter, the function's type descriptor includes a
closure that computes the default value for the parameter using the values of
previous parameters. The caller of the function uses the closures in the
function's type descriptor to compute default values for any defaultable
arguments that were not specified explicitly. These default values are included
in the argument list passed to the function. Whether a parameter is defaultable,
and what its default is, do not affect the shape of the function and thus do not
affect typing. The closures computing the defaultable parameters are created
when the type descriptor is resolved; the default value is computed by calling
the closure each time the function is called and the corresponding parameter is
not specified. Whether a parameter is defaultable is used at compile time, but
the closure that computes the default value is only used at runtime.
</p>
<p>
The name of each parameter is included in the function's type descriptor. A
caller of the function may specify the name of the parameter that an argument is
supplying. In this case, the caller uses the parameter name at compile time in
conjunction with the type descriptor to create the argument list. For each
parameter name, the function's type descriptor also includes the region of code
within which the name of the parameter is visible; as usual, if
<code>public</code> is specified, the region is the entire program, otherwise it
is the module in which the function type descriptor occurs. The name of a
parameter can only be used to specify an argument in a function call that occurs
within the region of code within which the parameter name is visible. The
parameter names do not affect the shape of the function and thus do not affect
typing.
</p>
<p>
The process by which the function caller creates an argument list, which may
make use of arguments specified both by position and by name, is described in
more detail in the <a href="#function_call">section on function calls</a>.
</p>
<pre class="grammar"><span class="ntdfn" id="return-type-descriptor">return-type-descriptor</span> := [ <code>returns</code> [<a href="#annots"><span class="ntref">annots</span></a>] <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> ]
</pre>
<p>
When the execution of a function returns to its caller, it returns exactly one
value. A function that would in other programming languages not return a value
is represented in Ballerina by a function returning <code>()</code>. Note that
the function definition does not have to explicitly return <code>()</code>; a
return statement or falling off the end of the function body will implicitly
return <code>()</code>.
</p>
<p>
The value returned by a function will belong to the type specified in the
return-type-descriptor. An empty return-type-descriptor is equivalent to
<code>returns ()</code>.
</p>
<p>
A return-type-descriptor may be depend on the param-list in the following way. A
type-reference occurring in a return-type-descriptor can refer to a parameter
name if the type of the parameter is a subtype of <code>typedesc</code>. If p is
such a parameter, then a reference to p in the return-type-descriptor denotes
the type that is the value of p. The return-type-descriptor thus denotes a
distinct set of shapes for each invocation of the function. A function-signature
with a return-type-descriptor that uses a type-reference to refer to a parameter
name in this way is said to be <em>dependently-typed</em>. Functions with
dependently-types signatures can be declared and used within Ballerina, but
Ballerina does not yet provide a mechanism to define such functions.
</p>
<p>
Function types are covariant in their return types and contravariant in the type
of their parameter lists. More precisely, a function type with return type R and
parameter list type P is a subtype of a function type with return type R' and
parameter list type P' if and only if R is a subtype of R' and P' is a subtype
of P. A function value f belongs to a function type T if the declared type of f
is a subtype of T.
</p>
</section>
<section>
<h4 id="section_5.5.3">5.5.3 Objects</h4>
<p>
Objects are a combination of fields along with a set of associated functions,
called methods, which can be used to manipulate them. An object's methods are
associated with the object when the object is constructed and cannot be changed
thereafter. The fields and methods of an object are in separate symbol spaces, so
it is possible for an object to have a field and a method with the same name.
</p>
<p>
An object type descriptor, in addition to describing the object type, also
defines a way to construct an object of this type, in particular it provides the
method definitions that are associated with the object when it is constructed.
</p>
<p>
It is also possible to have an object type descriptor that only describes an
object type and cannot be used to construct an object; this is called an
abstract object type descriptor.
</p>

<pre class="grammar"><span class="ntdfn" id="object-type-descriptor">object-type-descriptor</span> :=
   <a href="#object-type-quals"><span class="ntref">object-type-quals</span></a> <code>object</code> <code>{</code>
      <a href="#object-member-descriptor"><span class="ntref">object-member-descriptor</span></a>*
   <code>}</code>
<span class="ntdfn" id="object-type-quals">object-type-quals</span> :=
   [<code>abstract</code>] [<code>client</code>] | [<code>client</code>] <code>abstract</code>
<span class="ntdfn" id="object-member-descriptor">object-member-descriptor</span> :=
   <a href="#object-field-descriptor"><span class="ntref">object-field-descriptor</span></a>
   | <a href="#object-method"><span class="ntref">object-method</span></a>
   | <a href="#object-type-inclusion"><span class="ntref">object-type-inclusion</span></a>
</pre>
<p>
If <code>object-type-quals</code> contains the keyword <code>abstract</code>,
then the object type descriptor is an abstract object type descriptor.
</p>
<p>
If <code>object-type-quals</code> contains the keyword <code>client</code>, then
the object type is a client object type. A client object type may have remote
methods; other objects types must not.
</p>
<section>
<h5 id="section_5.5.3.1">5.5.3.1 Fields</h5>

<pre class="grammar"><span class="ntdfn" id="object-field-descriptor">object-field-descriptor</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a> <a href="#object-visibility-qual"><span class="ntref">object-visibility-qual</span></a> [<code>readonly</code>] <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <a href="#field-name"><span class="ntref">field-name</span></a> [<a href="#default-value"><span class="ntref">default-value</span></a>]<code>;</code>
</pre>
<p>
An <code>object-field-descriptor</code> specifies a field of the object. The
names of all the fields of an object must be distinct.
</p>
<p>
The object basic type is selectively immutable. Each field has a read-only bit,
which is on if and only if <code>object-field-descriptor</code> includes
<code>readonly</code>. If the read-only bit of a field is on, it means the field
cannot be assigned to after it has been constructed. The read-only bit of an
object value is on if and only if the read-only bit of all its fields is on.
When an <code>object-field-descriptor</code> includes readonly, the type of the
field is the intersection of <code>readonly</code> and the type specified by the
type-descriptor.
</p>
</section>
<section>
<h5 id="section_5.5.3.2">5.5.3.2 Methods</h5>
<p>
Methods are functions that are associated to the object and are called via a
value of that type using a <code>method-call-expr</code>.
</p>

<pre class="grammar"><span class="ntdfn" id="object-method">object-method</span> := <a href="#method-decl"><span class="ntref">method-decl</span></a> | <a href="#method-defn"><span class="ntref">method-defn</span></a>
<span class="ntdfn" id="method-decl">method-decl</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   <a href="#method-defn-quals"><span class="ntref">method-defn-quals</span></a>
   <code>function</code> <a href="#method-name"><span class="ntref">method-name</span></a> <a href="#function-signature"><span class="ntref">function-signature</span></a> <code>;</code>
<span class="ntdfn" id="method-defn">method-defn</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   <a href="#method-defn-quals"><span class="ntref">method-defn-quals</span></a>
   <code>function</code> <a href="#method-name"><span class="ntref">method-name</span></a> <a href="#function-signature"><span class="ntref">function-signature</span></a> <a href="#method-defn-body"><span class="ntref">method-defn-body</span></a>
<span class="ntdfn" id="method-defn-quals">method-defn-quals</span> := <a href="#object-visibility-qual"><span class="ntref">object-visibility-qual</span></a> [<code>remote</code>]
<span class="ntdfn" id="method-name">method-name</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
<span class="ntdfn" id="method-defn-body">method-defn-body</span> := <a href="#function-defn-body"><span class="ntref">function-defn-body</span></a>
</pre>
<p>
The names of all the methods of an object must be distinct: there is no method
overloading. The method name <code>init</code> is used for initialization and
treated specially.
</p>
<p>
Within a <code>method-defn-body</code>, the fields and methods of the object are not
implicitly in-scope; instead the keyword <code>self</code> is bound to the
object and can be used to access fields and methods of the object.
</p>
<p>
If an object type is abstract, every method must be specified using a
<code>method-decl</code>. Otherwise every method must be specified using a
<code>method-defn</code>.
</p>
<p>
A method that is declared or defined with the remote qualifier is a remote
method. A remote method is allowed only in a client object. A remote method is
invoked using a different syntax from a non-remote method.
</p>

</section>
<section>
<h5 id="section_5.5.3.3">5.5.3.3 Visibility</h5>

<pre class="grammar"><span class="ntdfn" id="object-visibility-qual">object-visibility-qual</span> := [<a href="#explicit-visibility-qual"><span class="ntref">explicit-visibility-qual</span></a>]
<span class="ntdfn" id="explicit-visibility-qual">explicit-visibility-qual</span> := <code>public</code> | <code>private</code>
</pre>
<p>
Each field and method of an object type is visible within and can be accessed
from a specific region of code, which is specified by its object-visibility-qual
as follows:
</p>
<ul>
<li>if the object-visibility qual is <code>private</code>, then the visibility
region consists of the methods defined by this object type descriptor;</li>
<li>if the object-visibility-qual is empty, then the visibility region is the
entire module containing this object type descriptor; this is called
module-level visibility;</li>
<li>if the object-visibility-qual is <code>public</code>, then the visibility region
contains all modules.</li>
</ul>
<p>
The visibility of a method or field of an abstract object type cannot be
<code>private</code>.
</p>
</section>
<section>
<h5 id="section_5.5.3.4">5.5.3.4 Typing</h5>

<p>
The shape of an object consists of an unordered collection of object field
shapes and an unordered collection of object method shapes. An object field
shape or object method shape is a triple consisting of the name of the field or
method, the visibility region, and a shape for the value of the field or for the
method's function.
</p>
<p>
An object type is inclusive, in a similar way to an
inclusive-record-type-descriptor: an object shape belongs to an object type if
it has at least the fields and methods described in the object-type-descriptor.
Thus all object values belong to the type <code>object { }</code>.
</p>
<p>
An object-type-descriptor that has a field with name f, visibility region R and
type T contains an object shape only if the object shape contains an object
field shape that has name f, visibility region R and a value shape that is
contained in T. An object-type-descriptor that has a method with name m,
visibility region R and function type T contains an object shape only if the
object shape contains an object method shape that has name m, visibility region
R and a function value that belongs to type T.
</p>
<p>
Thus an object type T' is a subtype of an object type T only if for each field
or method f of T there is a corresponding field or method f' of T such that the
type of f' in T' is a subtype of the type of f in T and the visibility region of
f' in T' is the same as the visibility region of f in T.
</p>
<p>
This implies that:
</p>
<ul>
<li>if an object type descriptor T has private fields or methods, then it is not
possible to define another object type descriptor that is a subtype of T,
and</li>
<li>if an object type descriptor T has fields or methods with module-level
visibility, then it is possible to define another object type descriptor that is
a subtype of T only within the same module as T.</li>
</ul>
<p>
The read-only bit of a field is part of the read-only aspect of the object's
shape.
</p>
 
</section>
<section>
<h5 id="section_5.5.3.5">5.5.3.5 Initialization</h5>
<p>
A non-abstract object type provides a way to initialize an object of the type.
An object is initialized by:
</p>
<ol>
<li>allocating storage for the object</li>
<li>initializing each field with its default value, if it has one</li>
<li>initializing the methods of the object using the type's method definitions</li>
<li>calling the object's <code>init</code> method, if there is one</li>
</ol>
<p>
The return type of the <code>init</code> method must be a subtype of the union
of error and nil, and must contain nil; if <code>init</code> returns an error,
it means that initialization of the object failed. The <code>init</code>
method can declare parameters in the same way as any other method.
</p>
<p>
At any point in the body of a <code>init</code> method, the compiler
determines which fields are potentially uninitialized. A field is potentially
uninitialized at some point if that field does not have a default value and it
is not definitely assigned at that point. It is a compile error if a
<code>init</code> method:
</p>
<ul>
<li>accesses a field at a point where it is potentially initialized, or</li>
<li>at a point where there is any potentially uninitialized field
<ul>
<li>returns nil, or</li>
<li>uses the <code>self</code> variable other than to access or modify the value of a field.</li>
</ul>
</li>
</ul>
<p>
An object must have an <code>init</code> method unless all its fields have a
default value. An object without an <code>init</code> method behaves as it had
an <code>init</code> method with no parameters and an empty body (which will
always return nil).
</p>
<p>
The visibility of the <code>init</code> method cannot be <code>private</code>.
</p>
<p>
Any <code>init</code> method is not part of the shape of an object, and so
does not affect when an object value belongs to a type. An abstract object type
must not declare an <code>init</code> object. The <code>init</code> method
can be called in a <code>method-call-expr</code> only when the expression
preceding the <code>.</code> is <code>self</code>.
</p>
</section>
<section>
<h5 id="section_5.5.3.6">5.5.3.6 Inclusion and type-ids</h5>

<pre class="grammar"><span class="ntdfn" id="object-type-inclusion">object-type-inclusion</span> := <code>*</code> <a href="#type-reference"><span class="ntref">type-reference</span></a> <code>;</code>
</pre>
<p>
Every type descriptor referenced directly or indirectly by a
<code>type-reference</code> in an <code>object-type-inclusion</code> must be an
<code>object-type-descriptor</code>, <code>distinct-type-descriptor</code> or
<code>intersection-type-descriptor</code>; the referenced type descriptor will
thus necessarily be definite and a subtype of object. The
<code>object-field-descriptor</code>s and <code>object-method</code>s from the
referenced type are included in the type being defined; the meaning is the same
as if they had been specified explicitly, except that the method definitions are
not copied. More precisely, if an <code>object-method</code> is a
<code>method-defn</code>, then a <code>method-decl</code> declaring the
<code>method-defn</code> is included instead of the <code>method-defn</code>. An
<code>object-field-descriptor</code> or <code>object-method</code> in a
<code>object-type-descriptor</code> can override an
<code>object-field-descriptor</code> or <code>object-method</code> of the same
name in an included <code>object-type-descriptor</code>, provided the type
declared for the field or method in the overriding descriptor is a subtype of
the type declared in the overridden descriptor. If the including object type is
not abstract, then each included <code>method-decl</code>, must be overridden by
a <code>method-defn</code>. It is an error for an
<code>object-type-descriptor</code> to directly or indirectly include itself.
</p>
<p>
If a non-abstract object type T<sub>o</sub> includes an abstract
object type T<sub>a</sub>, then each method declared in T<sub>a</sub> must be
defined in T<sub>o</sub> using a <code>method-defn</code> with the same
visibility. If T<sub>a</sub> has a method or field with module-level visibility,
the T<sub>o</sub> must be in the same module.
</p>
<p>
An object-type-descriptor is always definite. The set of type-ids induced by an
object-type-descriptor is the union of the set of type-ids induced by the type
descriptors that it includes. An induced typeid is primary in an
object-type-descriptor if and only if it is primary in any of the included type
descriptors. It is an error if the induced set of type-ids includes a non-public
type-id from another module.
</p>
</section>
</section>
<section>
<h4 id="section_5.5.4">5.5.4 Futures</h4>

<pre class="grammar"><span class="ntdfn" id="future-type-descriptor">future-type-descriptor</span> := <code>future</code> [<a href="#type-parameter"><span class="ntref">type-parameter</span></a>]
</pre>
<p>
A future value refers to a named worker, which will return a value. A future
value belongs to a type <code>future&lt;T&gt;</code> if the return type of the
named worker is a subtype of T.
</p>
<p>
A value belongs to a type <code>future</code> (without the type-parameter)
if it has basic type future.
</p>
</section>
<section>
<h4 id="section_5.5.5">5.5.5 [Preview] Services</h4>

<pre class="grammar"><span class="ntdfn" id="service-type-descriptor">service-type-descriptor</span> := <code>service</code>
</pre>
<p>
A service is like an object, but differs in the following respects:
</p>
<ul>
<li>a method of a service can be declared as a resource method, but cannot be
declared as a remote method</li>
<li>a service is stateless and does not have fields</li>
</ul>
<p>
A resource method is a special kind of method, with associated configuration
data, that is invoked in response to network messages received by a Listener. A
service can be thought of as the dual of a client object.
</p>
<p>
All service values belong to the type <code>service</code>.
</p>
<p>
It is planned that a future version of Ballerina will provide a mechanism that
allows more precise typing of services. In the meantime, implementations can use
annotations on type definitions to support this.
</p>
</section>
<section>
<h4 id="section_5.5.6">5.5.6 Type descriptors</h4>
<pre class="grammar"><span class="ntdfn" id="typedesc-type-descriptor">typedesc-type-descriptor</span> := <code>typedesc</code> [<a href="#type-parameter"><span class="ntref">type-parameter</span></a>]
</pre>
<p>
A type descriptor value is an immutable value representing a resolved type
descriptor. The type typedesc contains all values with basic type typedesc. A
typedesc value <var>t</var> belongs to a type typedesc&lt;<var>T</var>&gt; if
and only if the type described by <code>t</code> is a subtype of <var>T</var>.
The typedesc type is thus covariant with its type parameter.
</p>
<p>
Referencing an identifier defined by a type definition in an expression context
will result in a type descriptor value.
</p>

</section>
<section>
<h4 id="section_5.5.7">5.5.7 Handles</h4>
<pre class="grammar"><span class="ntdfn" id="handle-type-descriptor">handle-type-descriptor</span> := <code>handle</code>
</pre>
<p>
A handle value is a reference to storage managed externally to a Ballerina
program. Handle values are useful only in conjunction with functions that have
external function bodies; in particular, a new handle value can be created only
by a function with an external function body. Handle values are inherently
immutable.
</p>
<p>
A value belongs to a type <code>handle</code> if it has a basic type of handle.
</p>

</section>

<section>
<h4 id="section_5.5.8">5.5.8 [Preview] Streams</h4>

<pre class="grammar"><span class="ntdfn" id="stream-type-descriptor">stream-type-descriptor</span> := <code>stream</code> [<a href="#stream-type-parameters"><span class="ntref">stream-type-parameters</span></a>]
<span class="ntdfn" id="stream-type-parameters">stream-type-parameters</span> := <code>&lt;</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> [<code>,</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>]<code>&gt;</code>
</pre>
<p>
A stream is an object-like value that can generate a sequence of values. There
is also a value associated with the completion of the generation of the
sequence, which is either nil, indicating the generation of the sequence completed
successfully, or an error. A stream belongs to type
<code>stream&lt;T,C&gt;</code> if the values in the generated sequence all
belong to T and if the completion value belongs to C. The type
<code>stream&lt;T&gt;</code> is equivalent to <code>stream&lt;T,()&gt;</code>. A
value belongs to a type <code>stream</code> (without the type-parameter) if it
has basic type stream. A type <code>stream&lt;T,C&gt;</code> where C does not
include nil represents an unbounded stream.
</p>
<p>
A stream supports two primitive operations: a next operation and a close
operation. The next operation has the same semantics as the next method on the
Iterator abstract object type. The close operation informs the stream that there
will be no more next operations and thus allows the stream to release resources
used by the stream; the close operation on a <code>stream&lt;T,C&gt;</code> has
a result of type <code>C?</code>, where nil means that the close operation was
successful.
</p>
<p>
The normal implementation of a <code>stream&lt;T,C&gt;</code> is a wrapper
around an object belonging to <a href="#StreamImplementor">abstract object type
<code>StreamImplementor&lt;T,C&gt;</code></a>. The next and close operations on
the stream delegate to the next and close methods on the StreamImplementor.
</p>
<p>
The stream module of the <a href="#lang_library">lang library</a> provides
additional operations on stream that can be implemented in terms of the
primitive next and close operations.
</p>
<p>
A stream is iterable. A stream of type <code>stream&lt;T,C&gt;</code> has value
type <code>T</code> and completion type <code>C</code>. Calling the next method
on the iterator created for an iteration has the same effect as performing the
next operation on the stream. The stream does not keep a copy of the sequence of
values returned by the next operation. Any subsequent iteration operation on the
same stream will not generate further values, so the iteration sequence for
iterations other than the first will be the empty sequence.
</p>
<p>
Note that in this version of Ballerina the stream type is not an object type
because Ballerina does not yet support parameterized object types.
</p>
</section>

</section>
<section>
<h3 id="section_5.6">5.6 Other type descriptors</h3>

<pre class="grammar"><span class="ntdfn" id="other-type-descriptor">other-type-descriptor</span> :=
   | <a href="#type-reference"><span class="ntref">type-reference</span></a>
   | <a href="#singleton-type-descriptor"><span class="ntref">singleton-type-descriptor</span></a>
   | <a href="#any-type-descriptor"><span class="ntref">any-type-descriptor</span></a>
   | <a href="#never-type-descriptor"><span class="ntref">never-type-descriptor</span></a>
   | <a href="#readonly-type-descriptor"><span class="ntref">readonly-type-descriptor</span></a>
   | <a href="#distinct-type-descriptor"><span class="ntref">distinct-type-descriptor</span></a>
   | <a href="#union-type-descriptor"><span class="ntref">union-type-descriptor</span></a>
   | <a href="#intersection-type-descriptor"><span class="ntref">intersection-type-descriptor</span></a>
   | <a href="#optional-type-descriptor"><span class="ntref">optional-type-descriptor</span></a>
   | <a href="#anydata-type-descriptor"><span class="ntref">anydata-type-descriptor</span></a>
   | <a href="#json-type-descriptor"><span class="ntref">json-type-descriptor</span></a>
   | <a href="#byte-type-descriptor"><span class="ntref">byte-type-descriptor</span></a>
   | <code>(</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>)</code>
</pre>
<p>
It is important to understand that the type descriptors specified in this
section do not add to the universe of values. They are just adding new ways to
describe subsets of this universe.
</p>
<section>
<h4 id="section_5.6.1">5.6.1 Type reference</h4>
<pre class="grammar"><span class="ntdfn" id="type-reference">type-reference</span> := <a href="#identifier"><span class="ntref">identifier</span></a> | <a href="#qualified-identifier"><span class="ntref">qualified-identifier</span></a>
</pre>

<p>
A type descriptor can use a type-reference to refer to a type definition in the
same module or another module.
</p>
<p>
A type-reference referring to a type descriptor <var>T</var> is definite if and
only if <var>T</var>. If it is, the type-ids induced by are the same as those
induced by <var>T</var> and a type-id is primary in <var>t</var> if and only if
it is primary in <var>T</var>. It is an error if the induced set of type-ids
includes a non-public type-id from another module.
</p>

</section>
<section>
<h4 id="section_5.6.2">5.6.2 Singleton types</h4>

<pre class="grammar"><span class="ntdfn" id="singleton-type-descriptor">singleton-type-descriptor</span> := <a href="#simple-const-expr"><span class="ntref">simple-const-expr</span></a>

</pre>
<p>
A singleton type is a type containing a single shape. A singleton type is
described using an compile-time constant expression for a single value: the type
contains the shape of that value. Note that it is possible for the
variable-reference within the simple-const-expr to reference a structured value;
in this case, the value will have its read-only bit set; a value without its
read-only bit set will thus not belong to any singleton type.
</p>
</section>
<section>
<h4 id="section_5.6.3">5.6.3 Any type</h4>

<pre class="grammar"><span class="ntdfn" id="any-type-descriptor">any-type-descriptor</span> := <code>any</code>
</pre>
<p>
The type descriptor <code>any</code> describes the type consisting of all values
other than errors. A value belongs to the any type if and only if its basic type
is not error. Thus all values belong to the type <code>any|error</code>. Note
that a structure with members that are errors belongs to the <code>any</code>
type.
</p>
<p>
The any-type-descriptor is not definite.
</p>
</section>
<section>
<h4 id="section_5.6.4">5.6.4 Never type</h4>

<pre class="grammar"><span class="ntdfn" id="never-type-descriptor">never-type-descriptor</span> := <code>never</code>
</pre>
<p>
The type descriptor <code>never</code> describes the type that does not contain
any shapes. No value ever belongs to the <code>never</code>.
</p>
<p>
This can be useful to describe for the return type of a function, if the
function never returns. It can also be useful as a type parameter. For example,
<code>xml&lt;never&gt;</code> describes the an xml type that has no
constituents, i.e. the empty xml value.
</p>
<p>
Note that for anytype <code>T</code>, the type <code>T|never</code> is the same
as <code>T</code>.
</p>
</section>
<section>
<h4 id="section_5.6.5">5.6.5 Readonly type</h4>
<pre class="grammar"><span class="ntdfn" id="readonly-type-descriptor">readonly-type-descriptor</span> := <code>readonly</code>
</pre>
<p>
A shape belongs to the type <code>readonly</code> if its read-only bit is on.
</p>
<p>
A value belonging to an inherently immutable basic type will always have its
read-only bit on. These basic types are:
</p>
<ul>
<li>all simple types
<ul>
<li>nil</li>
<li>boolean</li>
<li>int</li>
<li>float</li>
<li>decimal</li>
</ul>
</li>
<li>string</li>
<li>error</li>
<li>function</li>
<li>service</li>
<li>typedesc</li>
<li>handle</li>
</ul>
<p>
A value belonging to a selectively immutable basic type may have its read-only
bit on. These basic types are:
</p>
<ul>
<li>xml</li>
<li>list</li>
<li>mapping</li>
<li>table</li>
<li>object</li>
</ul>

</section>
<section>
<h4 id="distinct_types">5.6.6 Distinct types</h4>
<pre class="grammar"><span class="ntdfn" id="distinct-type-descriptor">distinct-type-descriptor</span> := <code>distinct</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>
</pre>
<p>
Each occurrence of a distinct-type-descriptor describes a type that is distinct
from any other occurrence of a distinct-type-descriptor. Only object and error
values can belong to a type described by a distinct-type-descriptor.
</p>
<p>
The type denoted by a distinct-type-descriptor <code><var>D</var></code>, where
<code><var>D</var></code> is <code>distinct <var>T</var></code>, and
<var>d</var> is the type-id of this occurrence of <code><var>D</var></code>,
contains a shape <var>s</var> of an object or error value if and only if both
<code><var>T</var></code> contains <var>s</var> and the set of type-ids of
<var>s</var> contains <var>d</var>. The set of type-ids induced by
<code><var>D</var></code> consists of <var>d</var> as the primary type-id and
the type-ids induced by <code><var>T</var></code> as the secondary type-ids. The
type <code><var>T</var></code> must be definite and must be a subtype of object
or a subtype of error. The type <code><var>D</var></code> is always definite.
Note that <code><var>D</var></code> is always a proper subtype of
<code><var>T</var></code>.
</p>

</section>
<section>
<h4 id="section_5.6.7">5.6.7 Union types</h4>

<pre class="grammar"><span class="ntdfn" id="union-type-descriptor">union-type-descriptor</span> := <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>|</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>
</pre>
<p>
The set of shapes denoted by an union type <code>T1|T2</code> is the union of
the set of shapes denoted by <code>T1</code> and the set of shapes denoted by
<code>T2</code>. Thus, the type <code>T1|T2</code> contains a shape if and only
if either the type denoted by <code>T1</code> contains the shape or the type
denoted by <code>T2</code> contains the shape.
</p>
<p>
A union type <code>T1|T2</code> is definite if and only if both <code>T1</code>
and <code>T2</code> are definite and the set of type-ids induced by
<code>T1</code> and <code>T2</code> are the same. If it is definite, then it
induces the same set of type-ids as <code>T1</code> and <code>T2</code>, and a
type-id is primary if it is primary in either <code>T1</code> or
<code>T2</code>.
</p>
</section>
<section>
<h4 id="section_5.6.8">5.6.8 Intersection types</h4>

<pre class="grammar"><span class="ntdfn" id="intersection-type-descriptor">intersection-type-descriptor</span> := <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>&amp;</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>
</pre>
<p>
The set of shapes denoted by an intersection type <code>T1&amp;T2</code> is the
intersection of the set of shapes denoted by <code>T1</code> and the set of
shapes denoted by <code>T2</code>. Thus, the type <code>T1&amp;T2</code>
contains a shape if and only if the types denoted by <code>T1</code> and
<code>T2</code> both contain the shape. It is a error to have an intersection
type that denotes an empty set of shapes. In an intersection type
<code>T1&amp;T2</code>, it is an error if either <code>T1</code> or
<code>T2</code> refer to an object type that is not abstract; it is also an
error if <code>T1</code> and <code>T2</code> are both function types unless
there is a single function-type-descriptor that denotes a type that is a subtype
of both <code>T1</code> and <code>T2</code>.
</p>
<p>
An intersection type <code>T1&amp;T2</code> is definite if and only if both
<code>T1</code> and <code>T2</code> are definite. If it is definite, then it
induces the union of the set of type-ids induced by <code>T1</code> and
<code>T2</code>, and a type-id is primary if it is primary in either
<code>T1</code> or <code>T2</code>.
</p>
<p>
Intersection types are particularly useful in conjunction with
<code>readonly</code>. A set of readonly shapes can be described by
<code>readonly&amp;T</code>, where <code>T</code> describes the primary aspect
of the shape.
</p>
</section>

<section>
<h4 id="section_5.6.9">5.6.9 Optional types</h4>

<pre class="grammar"><span class="ntdfn" id="optional-type-descriptor">optional-type-descriptor</span> := <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>?</code>
</pre>
<p>
A type <code><var>T</var>?</code> means the union of <code><var>T</var></code>
and <code>()</code>. It is completely equivalent to
<code><var>T</var>|()</code>.
</p>
</section>

<section>
<h4 id="anydata">5.6.10 Anydata type</h4>

<pre class="grammar"><span class="ntdfn" id="anydata-type-descriptor">anydata-type-descriptor</span> := <code>anydata</code>
</pre>
<p>
The type descriptor <code>anydata</code> describes the type of plain data. The
type <code>anydata</code> contains a shape if and only if it is the shape of a
value that is plain data. The <code>anydata</code> type can thus be defined as:
</p>

<pre>  () | boolean | int | float | decimal
    | string | xml
    | anydata[] | map&lt;anydata&gt; | table&lt;map&lt;anydata&gt;&gt;
</pre>
</section>
<section>
<h4 id="section_5.6.11">5.6.11 JSON types</h4>

<pre class="grammar"><span class="ntdfn" id="json-type-descriptor">json-type-descriptor</span> := <code>json</code>
</pre>
<p>
The <code>json</code> type is designed for processing data expression in JSON
format. It is a built-in name for a union defined as follows:
</p>
<pre>type json = () | boolean | int | float | decimal | string | json[] | map&lt;json&gt;;
</pre>
<p>
In addition, the <code>json</code> type is defined to have <a href="#lax_static_typing">lax static typing</a>.
</p>

</section>

<section>
<h4 id="byte_type">5.6.12 Byte type</h4>

<pre class="grammar"><span class="ntdfn" id="byte-type-descriptor">byte-type-descriptor</span> := <code>byte</code>
</pre>
<p>
The byte type is a predefined name for a union of the int values in the range 0
to 255 inclusive. It is equivalent to the <a href="#built-in_subtypes">built-in
subtype</a> <code>int:Unsigned8</code>.
</p>
</section>

</section>
<section>
<h3 id="built-in_abstract_object_types">5.7 Built-in abstract object types</h3>
<p>
There are several abstract object types that are built-in in the sense that the
language treats objects with these types specially. There are two kinds of
abstract object type:
</p>
<ul>
<li>purely structural types; the name of the type is internal to this
specification and not exposed to the language;</li>
<li>distinct types; the name of the type is defined in a lang library
module.</li>
</ul>

<section>
<h4 id="section_5.7.1">5.7.1 Iterator</h4>
<p>
A value of iterable type with iteration value type T and iteration completion
type C provides a way of creating an iterator object that belongs to the object
type
</p>

<pre>    abstract object {
       public next() returns record {| T value; |}|C;
    }
</pre>
<p>
In this specification, we refer to this type as Iterator&lt;T,C&gt;.
</p>
<p>
Conceptually an iterator is at a position between members of the iteration sequence. 
Possible positions are at the beginning (immediately before the first member if
any), between members and at the end (immediately after the last member if any).
A newly created iterator is at the beginning position. For an empty sequence,
there is only one possible position which is both at the beginning and at the
end.
</p>
<p>
The <code>next()</code> method behaves as follows:
</p>
<ul>
<li>if the iteration has encountered an error, return an error value</li>
<li>otherwise, if the iterator has completed successfully by reaching the end
position without an error, return nil</li>
<li>otherwise
<ul>
<li>move the iterator to next position, and</li>
<li>return a record <code>{ value: v }</code> where v is the member of the
sequence between the previous position and the new position</li>
</ul>
</li>
</ul>
<p>
Mutation of a structured value during iteration is handled as follows. A call to
<code>next()</code> must panic if there has been any mutation to the structured
value since the iterator was created other than the following:</p>
<ul>
<li>removing a member of the structured value that a preceding call to the
iterator has already returned;</li>
<li>changing the member associated with an existing key.</li>
</ul>
<p>
In the latter case, <code>next()</code> must return the value associated with
the key at the point when <code>next()</code> is called.
</p>
<p>
Note that it is not possible for the <code>next()</code> method simply to return
the values in the iteration sequence, since there would be no way to distinguish
a nil or error value that is part of the iteration sequence from a nil or error
value that represents the result of the iteration.
</p>
</section>
<section>
<h4 id="section_5.7.2">5.7.2 Iterable</h4>
<p>
An object belongs to the abstract object type Iterable&lt;T,C&gt; if it has a
method named <code>iterator</code> with no arguments and a return type that is
subtype of Iterator&lt;T,C&gt; and it belongs to the distinct type
<code>Iterable</code> defined in <code>lang.object</code>. An object that
belongs to Iterable&lt;T,C&gt; is iterable: the object returned by the
<code>iterator</code> method determines the iteration sequence and iteration
completion value.
</p>
</section>
<section>
<h4 id="StreamImplementor">5.7.3 StreamImplementor</h4>
<p>
An object belongs to the abstract object type StreamImplementor&lt;T,C&gt; if it
belongs to Iterator&lt;T,C&gt; and also optionally has a method
<code>close()</code> with return value <code>C?</code>. This is equivalent to
belonging to the following type.
</p>

<pre>    abstract object {
       public next() returns record {| T value; |}|C;
    }
    | abstract object {
       public next() returns record {| T value; |}|C;
       public close() returns C?;
    }
</pre>

<p>
The close method says that there will be no more calls to the next method. Any
call to a next method after the close method has been called must result in a
panic. A missing close method behaves like a close method that puts the object
into a closed state, in which calls to next will result in a panic, and then
immediately returns <code>()</code>.
</p>

</section>
<!--
<section>
<h4>Collection</h4>
<p>
An object can declare itself to be a collection of values of type V indexed by
keys of type K, but defining a <code>__get(K k)</code> method returning a value
of type V, that returns the value associated with key k. If the collection is
mutable, then the object can also declare a <code>__put(K k, V v)</code> method
that changes the value associated with key k to to value v. In this
specification, we refer to these types as ImmutableCollection&lt;T&gt; and
MutableCollection&lt;T&gt;.
</p>
</section>
-->
<section>
<h4 id="section_5.7.4">5.7.4 Listener</h4>
<p>
The Listener type is defined in <code>lang.object</code> as follows.
</p>

<pre>distinct abstract object {
   public function attach(service s, string? name = ()) returns error?;
   public function detach(service s) returns error?;
   public function start() returns error?;
   public function gracefulStop() returns error?;
   public function immediateStop() returns error?;
}
</pre>
<p>
Note that if an implementation does precise service typing using annotations on
type definitions, it will need to treat Listener as being parameterized in the
precise service type that is used to the first argument to
<code>attach</code>.
</p>
</section>
</section>
<section>
<h3 id="section_5.8">5.8 Abstract operations</h3>
<p>
These section specifies a number of operations that can be performed on values.
These operations are for internal use by the specification. These operations are
named in CamelCase with an initial upper-case letter to distinguish them from
functions in the lang library.
</p>
<section>
<h4 id="FillMember">5.8.1 FillMember</h4>
<p>
The FillMember(s, k) operation is defined for a structured value s and an
out-of-line key value k. It can be performed when s does not have a member with
key k; if it succeeds, it will result in a member with key k being added to s.
It will succeed if the inherent type of s allows the addition of a member with
key k and there is a way to construct a filler value for the type descriptor
that the inherent type of s requires for member k. The following table specifies
when and how a filler value can be constructed for a type descriptor.
</p>
<table>
<tr>
<th>Type descriptor</th>
<th>Filler value</th>
<th>When available</th>
</tr>
<tr>
<td><code>()</code></td>
<td><code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>+0.0f</code></td>
<td></td>
</tr>
<tr>
<td><code>decimal</code></td>
<td><code>+0.0d</code></td>
<td></td>
</tr>
<tr>
<td><code>string</code></td>
<td><code>""</code></td>
<td></td>
</tr>
<tr>
<td>array or tuple type descriptor</td>
<td><code>[]</code></td>
<td>if that is a valid constructor for the type</td>
</tr>
<tr>
<td>map or record type descriptor</td>
<td><code>{ }</code></td>
<td>if that is a valid constructor for the type</td>
</tr>
<tr>
<td>table</td>
<td>empty table (with no rows)</td>
<td></td>
</tr>
<tr>
<td>object</td>
<td><code>new T()</code></td>
<td>if this is valid and its static type does not include error, where
<code>T</code> is the object type descriptor (an abstract object type will not
have a filler value)</td>
</tr>
<tr>
<td>stream</td>
<td>empty stream</td>
<td></td>
</tr>
<tr>
<td><code>xml</code></td>
<td><code>xml``</code></td>
<td></td>
</tr>
<tr>
<td>built-in subtype of <code>xml</code>
</td>
<td><code>xml``</code></td>
<td>if this belongs to the subtype, i.e. if the subtype is
<code>xml:Text</code>
</td>
</tr>
<tr>
<td>singleton</td>
<td>the single value used to specify the type</td>
<td></td>
</tr>
<tr>
<td rowspan="2">union</td>
<td><code>()</code></td>
<td>if <code>()</code> is a member of the union</td>
</tr>
<tr>
<td>the filler value for basic type B</td>
<td>if all members of the union belong to a single basic type B,
and the filler value for B also belongs to the union</td>
</tr>
<tr>
<td><code>T?</code></td>
<td><code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>any</code></td>
<td><code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>anydata</code></td>
<td><code>()</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td>built-in subtype of <code>int</code>
</td>
<td><code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>json</code></td>
<td><code>()</code></td>
<td></td>
</tr>
</table>

</section>
<section>
<h4 id="Clone">5.8.2 Clone</h4>
<p>
Clone(v) is defined for any value v that belongs to the type
<code>anydata|readonly</code>. It performs a deep copy, recursively copying all
structural values and their members and recursively copying all sequence values
and their constituents. Clone(v) for an immutable value v returns v. If v is of
a basic type that has an inherent type, Clone(v) has the same inherent type as
v. The graph of references of Clone(v) must have the same structure as that of
v. This implies that the number of distinct references reachable from Clone(v)
must be the same as the number of distinct references reachable from v. Clone(v)
must terminate even if v has cycles.
</p>
<p>
Clone(v) cannot be implemented simply by recursively calling Clone on all
members of v. Rather Clone must maintain a map that records the result of
cloning each reference value. When a Clone operation starts, this map as empty.
When cloning a reference value, it must use the result recorded in the map if
there is one.
</p>
<p>
The Clone operation is exposed by the <code>clone</code> function in the
lang.value module of the lang library.
</p>
</section>
<section>
<h4 id="ImmutableClone">5.8.3 ImmutableClone</h4>
<p>
ImmutableClone(v) is defined for any value v that belongs to the type
<code>anydata|readonly</code>. It performs a deep copy of v similar to Clone(v),
except that newly constructed values will be constructed as immutable and so
have their read-only bit on. Any immutable value is not copied. So the result
of Immutable always has its read-only bit on.
</p>
<p>
Like Clone, ImmutableClone must preserve graph structure, including cycles.
Conceptually the whole graph is constructed before being made immutable.
</p>
<p>
The ImmutableClone operation is exposed by the <code>cloneReadOnly</code>
function in the lang.value module of the lang library.
</p>
</section>
<section>
<h4 id="DeepEquals">5.8.4 DeepEquals</h4>
<p>
DeepEquals(v1, v2) is defined for any values v1, v2 that belong to type anydata.
It returns true or false depending of whether the primary aspect of the shape v1
and of v2 are the same. In other words, DeepEquals returns true if and only if
the values are the same ignoring whether read-only bits are on or off.
DeepEquals(v1, v2) must terminate for any values v1 and v2 of type anydata, even
if v1 or v2 have cycles. DeepEquals(v1, v2) returns true if v1 and v2 have the
same shape, even if the graphs of references of v1 and v2 have different
structures. If two values v1 and v2 have different basic types, then
DeepEquals(v1, v2) will be false.
</p>
<p>
The possibility of cycles means that DeepEquals cannot be implemented simply by
calling DeepEquals recursively on members. Rather DeepEquals must maintain a
mapping that records for each pair of references whether it is already in
process of comparing those references. When a DeepEquals operation starts, this
map is empty. Whenever it starts to compare two references, it should see
whether it has already recorded that pair (in either order), and, if it has,
proceed on the assumption that they compare equal.
</p>
<p>
DeepEquals(Clone(x), x) is guaranteed to be true for any value of type anydata.
</p>
</section>
<section>
<h4 id="section_5.8.5">5.8.5 NumericConvert</h4>
<p>
NumericConvert(t, v) is defined if t is the typedesc for float, decimal or int,
and v is a numeric value. It converts v to a value in t, or returns an error,
according to the following table.
</p>
<table>
  <tr>
   <td>from \ to</td>
   <td>float</td>
   <td>decimal</td>
   <td>int</td>
  </tr>
  <tr>
   <td>float</td>
   <td>unchanged</td>
   <td>closest math value</td>
   <td rowspan="2">round, error for NaN or out of int range</td>
  </tr>
  <tr>
   <td>decimal</td>
   <td>closest math value</td>
   <td>unchanged</td>
  </tr>
  <tr>
   <td>int</td>
   <td>same math value</td>
   <td>same math value</td>
   <td>unchanged</td>
  </tr>
</table>
</section>
</section>
<section>
<h3 id="functionally_constructible_types">5.9 Functionally constructible types</h3>
<p>
A type that is <em>functionally constructible</em> allows values of the type to
be destructured and constructed using a functional syntax. A functionally
constructible type has a list of construction parameters, where each parameter
is identified either by a position or by a name, and defines a decomposition
that maps a value of the type into an argument list, with one member for each
construction parameter.
</p>
<pre class="grammar"><span class="ntdfn" id="functionally-constructible-type-reference">functionally-constructible-type-reference</span> := <code>error</code> | <a href="#type-reference"><span class="ntref">type-reference</span></a>
</pre>
<p>
A functionally-constructible-type-reference must refer to a type that is functionally constructible.
</p>
<p>
The following table describes the functionally constructible types and their
construction parameters. The last column specifies what happens if there is no
argument for a parameter when a value is constructed.
</p>

<table>
<tr>
<td>Constructed type</td>
<td>Parameter id</td>
<td>Parameter type</td>
<td>Parameter description</td>
<td>Parameter missing</td>
</tr>
<tr>
<td rowspan="3"><code>xml:Element</code></td>
<td>Position 1</td>
<td><code>string</code></td>
<td>name</td>
<td>not allowed</td>
</tr>
<tr>
<td>Position 2</td>
<td><code>map&lt;string&gt;</code></td>
<td>attribute map</td>
<td>defaults to empty map</td>
</tr>
<tr>
<td>Position 3</td>
<td><code>xml</code></td>
<td>children</td>
<td>defaults to empty xml value</td>
</tr>
<tr>
<td rowspan="2"><code>xml:ProcessingInstruction</code></td>
<td>Position 1</td>
<td><code>string</code></td>
<td>target</td>
<td>not allowed</td>
</tr>
<tr>
<td>Position 2</td>
<td><code>string</code></td>
<td>content</td>
<td>defaults to empty string</td>
</tr>
<tr>
<td><code>xml:Comment</code></td>
<td>Position 1</td>
<td><code>string</code></td>
<td>content</td>
<td>defaults to empty string</td>
</tr>
<tr>
<td><code>xml:Text</code></td>
<td>Position 1</td>
<td><code>string</code></td>
<td>characters</td>
<td>defaults to empty string</td>
</tr>
<tr>
<td rowspan="3"><code>error&lt;<var>T</var>&gt;</code></td>
<td>Position 1</td>
<td><code>string</code></td>
<td>message</td>
<td>not allowed</td>
</tr>
<tr>
<td>Position 2</td>
<td><code>error?</code></td>
<td>cause</td>
<td>defaults to nil</td>
</tr>
<tr>
<td>Name <var>k</var>
</td>
<td>type of field <var>k</var> of <code><var>T</var></code>, which will be a
subtype of <code>anydata|readonly</code>
</td>
<td>field <var>k</var> of detail record</td>
<td>detail record has no field <var>k</var>
</td>
</tr>
</table>
<p>
In the above table, argument position 1 refers to the first positional argument.
</p>
<p>
A type descriptor that is a subtype of <code>error</code> is functionally
constructible only if it is definite. In particular, it may be an
intersection-type-descriptor.
</p>
</section>

<section>
<h3 id="section_5.10">5.10 Binding patterns and variables</h3>
<section>
<h4 id="section_5.10.1">5.10.1 Binding patterns</h4>
<p>
Binding patterns are used to support destructuring, which allows different parts
of a single structured value each to be assigned to separate variables at the
same time.
</p>

<pre class="grammar"><span class="ntdfn" id="binding-pattern">binding-pattern</span> :=
   <a href="#capture-binding-pattern"><span class="ntref">capture-binding-pattern</span></a>
   | <a href="#wildcard-binding-pattern"><span class="ntref">wildcard-binding-pattern</span></a>
   | <a href="#list-binding-pattern"><span class="ntref">list-binding-pattern</span></a>
   | <a href="#mapping-binding-pattern"><span class="ntref">mapping-binding-pattern</span></a>
   | <a href="#functional-binding-pattern"><span class="ntref">functional-binding-pattern</span></a>
<span class="ntdfn" id="capture-binding-pattern">capture-binding-pattern</span> := <a href="#variable-name"><span class="ntref">variable-name</span></a>
<span class="ntdfn" id="variable-name">variable-name</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
<span class="ntdfn" id="wildcard-binding-pattern">wildcard-binding-pattern</span> := <code>_</code>
<span class="ntdfn" id="list-binding-pattern">list-binding-pattern</span> := <code>[</code> <a href="#list-member-binding-patterns"><span class="ntref">list-member-binding-patterns</span></a> <code>]</code>
<span class="ntdfn" id="list-member-binding-patterns">list-member-binding-patterns</span> :=
   <a href="#binding-pattern"><span class="ntref">binding-pattern</span></a> (<code>,</code> <a href="#binding-pattern"><span class="ntref">binding-pattern</span></a>)* [<code>,</code> <a href="#rest-binding-pattern"><span class="ntref">rest-binding-pattern</span></a>]
   | [ <a href="#rest-binding-pattern"><span class="ntref">rest-binding-pattern</span></a> ]
<span class="ntdfn" id="mapping-binding-pattern">mapping-binding-pattern</span> := <code>{</code> <a href="#field-binding-patterns"><span class="ntref">field-binding-patterns</span></a> <code>}</code>
<span class="ntdfn" id="field-binding-patterns">field-binding-patterns</span> :=
   <a href="#field-binding-pattern"><span class="ntref">field-binding-pattern</span></a> (<code>,</code> <a href="#field-binding-pattern"><span class="ntref">field-binding-pattern</span></a>)* [<code>,</code> <a href="#rest-binding-pattern"><span class="ntref">rest-binding-pattern</span></a>]
   | [ <a href="#rest-binding-pattern"><span class="ntref">rest-binding-pattern</span></a> ] 
<span class="ntdfn" id="field-binding-pattern">field-binding-pattern</span> :=
   <a href="#field-name"><span class="ntref">field-name</span></a> <code>:</code> <a href="#binding-pattern"><span class="ntref">binding-pattern</span></a>
   | <a href="#variable-name"><span class="ntref">variable-name</span></a>
<span class="ntdfn" id="rest-binding-pattern">rest-binding-pattern</span> := <code>...</code> <a href="#variable-name"><span class="ntref">variable-name</span></a>
<span class="ntdfn" id="functional-binding-pattern">functional-binding-pattern</span> := <a href="#functionally-constructible-type-reference"><span class="ntref">functionally-constructible-type-reference</span></a> <code>(</code> <a href="#arg-list-binding-pattern"><span class="ntref">arg-list-binding-pattern</span></a> <code>)</code>
<span class="ntdfn" id="arg-list-binding-pattern">arg-list-binding-pattern</span> :=
   <a href="#positional-arg-binding-patterns"><span class="ntref">positional-arg-binding-patterns</span></a> [<code>,</code> <a href="#other-arg-binding-patterns"><span class="ntref">other-arg-binding-patterns</span></a>]
   | <a href="#other-arg-binding-patterns"><span class="ntref">other-arg-binding-patterns</span></a>
<span class="ntdfn" id="positional-arg-binding-patterns">positional-arg-binding-patterns</span> := <a href="#positional-arg-binding-pattern"><span class="ntref">positional-arg-binding-pattern</span></a> (<code>,</code> <a href="#positional-arg-binding-pattern"><span class="ntref">positional-arg-binding-pattern</span></a>)*
<span class="ntdfn" id="positional-arg-binding-pattern">positional-arg-binding-pattern</span> := <a href="#binding-pattern"><span class="ntref">binding-pattern</span></a>
<span class="ntdfn" id="other-arg-binding-patterns">other-arg-binding-patterns</span> :=
   <a href="#named-arg-binding-patterns"><span class="ntref">named-arg-binding-patterns</span></a> [<code>,</code> <a href="#rest-binding-pattern"><span class="ntref">rest-binding-pattern</span></a>]
   | [<a href="#rest-binding-pattern"><span class="ntref">rest-binding-pattern</span></a>]
<span class="ntdfn" id="named-arg-binding-patterns">named-arg-binding-patterns</span> := <a href="#named-arg-binding-pattern"><span class="ntref">named-arg-binding-pattern</span></a> (<code>,</code> <a href="#named-arg-binding-pattern"><span class="ntref">named-arg-binding-pattern</span></a>)*
<span class="ntdfn" id="named-arg-binding-pattern">named-arg-binding-pattern</span> := <a href="#arg-name"><span class="ntref">arg-name</span></a> <code>=</code> <a href="#binding-pattern"><span class="ntref">binding-pattern</span></a>
</pre>
<p>
A binding pattern may succeed or fail in matching a value. A successful match
causes values to be assigned to all the variables occurring the binding-pattern.
</p>
<p>
A binding pattern matches a value in any of the following cases.
</p>
<ul>
<li>a capture-binding-pattern always matches a value and causes the matched
value to be assigned to named variable;</li>
<li>a wildcard-binding-pattern matches a value if the value belongs to type any,
in other words if the basic type of the value is not error; it does not cause
any assignments to be made;</li>
<li>a list-binding-pattern with m binding patterns matches a list with n
members if m is less than or equal to n, and the i-th binding pattern matches
the i-th member of the list for each i in 1 to m, and either m is equal to n or
the list-binding-pattern includes a rest-binding-pattern; if there is a
rest-binding-pattern <code>...v</code>, then a successful match causes a new
list value consisting of all members of the matched list except for the the
first m values to be assigned to <code>v</code>;</li>
<li>a mapping-binding-pattern { f<sub>1</sub>: p<sub>1</sub>, f<sub>2</sub>:
p<sub>2</sub>, ..., f<sub>n</sub>: p<sub>n</sub>, r } matches a mapping value m
that includes fields f<sub>1</sub>, f<sub>2</sub>, ... , f<sub>n</sub> if
p<sub>i</sub> matches the value of field f<sub>i</sub> for each i in 1 to n; if
r is <code>...v</code> then a successful match causes a new mapping value
consisting of all the other fields to be assigned to <code>v</code>; a
field-binding-pattern consisting of just a variable-name <code>x</code> is
equivalent to a field-binding-pattern <code>x: x</code>;
</li>
<li>a functional-binding-pattern T(p<sub>1</sub>,
p<sub>1</sub>,...,p<sub>m</sub>, arg<sub>1</sub> = p<sub>m + 1</sub>,
arg<sub>2</sub> = p<sub>m + 2</sub>, ..., arg<sub>m + n</sub> = p<sub>n</sub>,
r) matches a value if the shape of the value belongs to T and the decomposition
of the value has m or more positional arguments and for each i in 1 to m,
p<sub>i</sub> matches the i-th positional argument, and for each j in 1 to n,
the decomposition has a named argument arg<sub>j</sub> and p<sub>m + j</sub>
matches the value of that named argument; if r is <code>...v</code> then a
successful match causes a new mapping value consisting of all named arguments in
the decomposition other than arg<sub>1</sub>, arg<sub>2</sub>, ... ,
arg<sub>n</sub> to be assigned to <code>v</code>;</li>
</ul>
<p>
All the variables in a binding-pattern must be distinct e.g. [x, x] is not
allowed.
</p>
<p>
Given a type descriptor for every variable in a binding-pattern, there is a type
descriptor for the binding-pattern that will contain a value just in case that
the binding pattern successfully matches the value causing each variable to be
assigned a value belonging to the type descriptor for that variable.
</p>
<ul>
<li>for a capture-binding-pattern, the type descriptor is the type descriptor
for that variable;</li>
<li>for a wildcard-binding-pattern, the type descriptor is any</li>
<li>for a list-binding-pattern, the type descriptor is a tuple type descriptor;</li>
<li>for a mapping-binding-pattern, the type descriptor is a record type
descriptor;</li>
<li>for an error-binding-pattern, the type descriptor is an error type
descriptor.</li>
</ul>

</section>
<section>
<h4 id="section_5.10.2">5.10.2 Typed binding patterns</h4>

<pre class="grammar"><span class="ntdfn" id="typed-binding-pattern">typed-binding-pattern</span> := <a href="#inferable-type-descriptor"><span class="ntref">inferable-type-descriptor</span></a> <a href="#binding-pattern"><span class="ntref">binding-pattern</span></a>
<span class="ntdfn" id="inferable-type-descriptor">inferable-type-descriptor</span> := <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> | <code>var</code>
</pre>
<p>
A typed-binding-pattern combines a type-descriptor and a binding-pattern, and is
used to create the variables occurring in the binding-pattern. If var is used
instead of a type-descriptor, it means the type is inferred. How the type is
inferred depends on the context of the typed-binding-pattern. An
inferable-type-descriptor is an inferable context for a type descriptor, which
means that <code>*</code> can be used with the type descriptor to infer certain
parts of it.
</p>
<p>
The simplest and most common form of a typed-binding-pattern is for the binding
pattern to consist of just a variable name. In this case, the variable is
constrained to contain only values matching the type descriptor.
</p>
<p>
When the binding pattern is more complicated, the binding pattern must be
consistent with the type-descriptor, so that the type-descriptor unambiguously
determines a type for each variable occurring in the binding pattern. A binding
pattern occurring in a typed-binding-pattern must also be irrefutable with
respect to the type of value against which it is to be matched. In other words,
the compiler will ensure that matching such a binding pattern against a value
will never fail at runtime.
</p>
</section>
<section>
<h4 id="section_5.10.3">5.10.3 Variable and identifier scoping</h4>
<p>
For every variable, there is place in the program that declares it. Variables
are lexically scoped: every variable declaration has a scope which determines
the region of the program within which the variable can be referenced.
</p>
<p>
There are two kinds of scope: module-scope and block-scope. A variable with
module-scope can be referenced anywhere within a module; if declared
<code>public</code>, it can also be referenced from outside the module.
</p>
<p>
Identifiers with module-scope are used to identify not only variables but other
module-level entities such as functions. Within module-scope, identifiers are
separated into three symbol spaces:
</p>
<ul>
<li>the <em>main</em> symbol space includes identifiers for variables,
constants, types, functions and other identifiers that do not belong to any of
the other two symbol spaces;</li>
<li>the <em>prefix</em> symbol space contains prefixes declared by import
declarations and XML namespace declaration statements;</li>
<li>the <em>annotation tag</em> symbol space contains annotation tags declared
by annotation declarations.</li>
</ul>
<p>
The prefix symbol space is special in that it is associated with a source part
rather than a module.
</p>
<p>
Block-scope is divided into symbol spaces in the same way as module-scope,
except that block-scope does not have a symbol space for annotation tags, since
annotation tags cannot be declared with block-scope.
</p>
<p>
An identifier declared with block-scope can be referenced only within a
particular block (always delimited with curly braces). Block-scope variables are
created by a variety of different constructs, many of which use a
typed-binding-pattern. Parameters are treated as read-only variables with
block-scope.
</p>
<p>
It is not an error if an identifier is declared with block-scope and there is
already a declaration of the same identifier in the same symbol space with
module-scope. In this case, the block-scope declaration will hide the
module-scope declaration for the region where the block-scope declaration is in
scope. However, it is a compile error if an identifier is declared with
block-scope and its scope overlaps with the scope of another declaration of the
same identifier in the same symbol space also with block-scope.
</p>
</section>
</section>
</section>
<section>
<h2 id="expressions">6. Expressions</h2>

<pre class="grammar"><span class="ntdfn" id="expression">expression</span> := 
   <a href="#literal"><span class="ntref">literal</span></a>
   | <a href="#string-template-expr"><span class="ntref">string-template-expr</span></a>
   | <a href="#xml-template-expr"><span class="ntref">xml-template-expr</span></a>
   | <a href="#structural-constructor-expr"><span class="ntref">structural-constructor-expr</span></a>
   | <a href="#new-expr"><span class="ntref">new-expr</span></a>
   | <a href="#service-constructor-expr"><span class="ntref">service-constructor-expr</span></a>
   | <a href="#variable-reference-expr"><span class="ntref">variable-reference-expr</span></a>
   | <a href="#field-access-expr"><span class="ntref">field-access-expr</span></a>
   | <a href="#optional-field-access-expr"><span class="ntref">optional-field-access-expr</span></a>
   | <a href="#xml-attribute-access-expr"><span class="ntref">xml-attribute-access-expr</span></a>
   | <a href="#annot-access-expr"><span class="ntref">annot-access-expr</span></a>
   | <a href="#member-access-expr"><span class="ntref">member-access-expr</span></a>
   | <a href="#function-call-expr"><span class="ntref">function-call-expr</span></a>
   | <a href="#method-call-expr"><span class="ntref">method-call-expr</span></a>
   | <a href="#functional-constructor-expr"><span class="ntref">functional-constructor-expr</span></a>
   | <a href="#anonymous-function-expr"><span class="ntref">anonymous-function-expr</span></a>
   | <a href="#let-expr"><span class="ntref">let-expr</span></a>
   | <a href="#type-cast-expr"><span class="ntref">type-cast-expr</span></a>
   | <a href="#typeof-expr"><span class="ntref">typeof-expr</span></a>
   | <a href="#unary-expr"><span class="ntref">unary-expr</span></a>
   | <a href="#multiplicative-expr"><span class="ntref">multiplicative-expr</span></a>
   | <a href="#additive-expr"><span class="ntref">additive-expr</span></a>
   | <a href="#shift-expr"><span class="ntref">shift-expr</span></a>
   | <a href="#range-expr"><span class="ntref">range-expr</span></a>
   | <a href="#numerical-comparison-expr"><span class="ntref">numerical-comparison-expr</span></a>
   | <a href="#is-expr"><span class="ntref">is-expr</span></a>
   | <a href="#equality-expr"><span class="ntref">equality-expr</span></a>
   | <a href="#binary-bitwise-expr"><span class="ntref">binary-bitwise-expr</span></a>
   | <a href="#logical-expr"><span class="ntref">logical-expr</span></a>
   | <a href="#conditional-expr"><span class="ntref">conditional-expr</span></a>
   | <a href="#checking-expr"><span class="ntref">checking-expr</span></a>
   | <a href="#trap-expr"><span class="ntref">trap-expr</span></a>
   | <a href="#query-expr"><span class="ntref">query-expr</span></a>
   | <a href="#xml-navigate-expr"><span class="ntref">xml-navigate-expr</span></a>
   | <code>(</code> <a href="#expression"><span class="ntref">expression</span></a> <code>)</code>
</pre>
<p>
For simplicity, the expression grammar is ambiguous. The following table shows
the various types of expression in decreasing order of precedence, together with
associativity.
</p>
<table>
  <tr>
   <td><strong>Operator</strong></td>
   <td><strong>Associativity</strong></td>
  </tr>
  <tr>
   <td>
<code>m:x</code>
<br>
<code>x.k</code>
<br>
<code>x.@a</code>
<br>
<code>f(x)</code>
<br>
<code>x.f(y)</code>
<br>
<code>x[y]</code>
<br>
<code>new T(x)</code>
   </td>
   <td></td>
  </tr>
  <tr>
   <td>
<code>+x</code>
<br>
<code>-x</code>
<br>
<code>~x</code>
<br>
<code>!x</code>
<br>
<code>&lt;T&gt; x</code>
<br>
<code>typeof x</code>
<code>check x</code>
<code>checkpanic x</code>
<code>trap x</code>
   </td>
   <td></td>
  </tr>
  <tr>
   <td>
<code>x * y</code>
<br>
<code>x / y</code>
<br>
<code>x % y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td>
<code>x + y</code>
<br>
<code>x - y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td>
<code>x &lt;&lt; y</code>
<br>
<code>x &gt;&gt; y</code>
<br>
<code>x &gt;&gt;&gt; y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td>
<code>x ... y</code>
<br>
<code>x ..&lt; y</code>
   </td>
   <td>non</td>
  </tr>
  <tr>
   <td>
<code>x &lt; y</code>
<br>
<code>x &gt; y</code>
<br>
<code>x &lt;= y</code>
<br>
<code>x &gt;= y</code>
<br>
<code>x is y</code>
   </td>
   <td>non</td>
  </tr>
  <tr>
   <td>
<code>x == y</code>
<br>
<code>x != y</code>
<br>
<code>x === y</code>
<br>
<code>x !== y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x &amp; y</code></td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x ^ y</code></td>
   <td>left</td>
  </tr>
  <tr>
   <td>
<code>x | y</code>
   </td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x &amp;&amp; y</code></td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x || y</code></td>
   <td>left</td>
  </tr>
  <tr>
   <td><code>x ?: y</code></td>
   <td>right</td>
  </tr>
  <tr>
   <td><code>x ? y : z</code></td>
   <td>right</td>
  </tr>
  <tr>
   <td>
<code>(x) =&gt; y</code>
<br>
<code>let x = y in z</code>
   </td>
   <td>right</td>
  </tr>

</table>
<section>
<h3 id="section_6.1">6.1 Expression evaluation</h3>
<p>
When the evaluation of an expression completes normally, it produces a result,
which is a value. The evaluation of an expression may also complete abruptly.
There are two kinds of abrupt completion: check-fail and panic. With both kinds
of abrupt completion there is an associated value, which always has basic type
error.
</p>
<p>
The following sections describes how each kind expression is evaluated, assuming
that evaluation of subexpressions complete normally. Except where explicitly
stated to the contrary, expressions handle abrupt completion of subexpressions
as follows. If in the course of evaluating an expression E, the evaluation of
some subexpression E1 completes abruptly, then then evaluation of E also
completes abruptly in the same way as E1.
</p>
</section>
<section>
<h3 id="section_6.2">6.2 Static typing of expressions</h3>
<p>
A type is computed for every expression at compile type; this is called the
static type of the expression. The compiler and runtime together guarantee that
if the evaluation of an expression at runtime completes normally, then the
resulting value will belong to the static type. A type is also computed for
check-fail abrupt completion, which will be a (possibly empty) subtype of error;
however, for panic abrupt completion, no type is computed.
</p>
<p>
The detailed rules for the static typing of expressions are quite elaborate and
are not yet specified completely in this document.
</p>

<section>
<h4 id="lax_static_typing">6.2.1 Lax static typing</h4>
<p>
In some situations it is convenient for static typing to be less strict than
normal. One such situation is when processing data in Ballerina using a static
type that is less precisse than the type that the data is in fact expected to
belong to. For example, when the Ballerina <code>json</code> type is used for
the processing of data in JSON format, the Ballerina static type will not
capture the constraints of the particular JSON format that is been processed.
</p>
<p>
Ballerina supports this situation through the concept of lax static typing,
which has two parts: the first part is that a type descriptor can be classified
as lax; the second part is that particular kinds of expression can have less
strict static typing rules when the static type of a subexpression is described
by a lax type descriptor. With these less strict rules, a potential type error
that would have been a compile-time error according to the normal strict static
typing rules would instead be allowed at compile-time and result in an error
value at runtime; the effect is thus that some static type-checking is instead
done dynamically.
</p>
<p>
In this version of Ballerina, only the first step has been taken towards
supporting this concept. There is a fixed set of type descriptors that are
classified as lax: specifically <code>json</code> is lax, and
<code>map&lt;T&gt;</code> is lax if T is lax. The only kinds of expression for
which lax typing rules are specified are field-access-expr and
optional-field-access-expr.
</p>

</section>
<section>
<h4 id="section_6.2.2">6.2.2 Contextually expected type</h4>
<p>
For a context in which an expression occurs, there may be a type descriptor that
describes the static type that the expression is expected to have. This is
called the <em>contextually expected type</em>. For example, if a variable is
declared by a type descriptor TD, then TD will be the contextually expected type
for the expression initializing the variable. A type descriptor must be
resolved before it can be used to provide a contextually expected type.</p>
<p>
Many kinds of expression that construct values use the contextually expected
type to determine the type of value constructed, rather than requiring the type
to be specified explicitly. For each such kind of expression, there is a set of
basic types (most often consisting of a single basic type) that the value
constructed by that kind of expression will always belong to. In this case, the
contextually expected type is narrowed by intersecting it with this set of basic
types; this narrowed type is called the <em>applicable</em> contextually
expected type. The narrowing is performed on the type descriptor by first
normalizing the type descriptor into a union, where each member of the union is
not a union and describes shapes from a single basic type, and then eliminating
any members of the union with the wrong basic type; if this leaves no members,
then it is a compile-time error; if it leaves a single member of the union, then
the the applicable contextually expected type is this single member, otherwise
it is a union of the remaining members.
</p>
<p>
Note the language provides a way to say that the type of a variable is to be
inferred from the static type of the expression used to initialize the variable.
In this case, there is no contextually expected type for the evaluation of the
expression. Not having a contextually expected type is different from having a
contextually expected type that allows all values.
</p>
</section>
<section>
<h4 id="section_6.2.3">6.2.3 Precise and broad types</h4>
<p>
There is an additional complexity relating to inferring types. Expressions in
fact have two static types, a precise type and a broad type. Usually, the
precise type is used. However, in a few situations, using the precise type would
be inconvenient, and so Ballerina uses the broad type. In particular, the broad
type is used for inferring the type of an implicitly typed non-final variable.
Similarly, the broad type is used when it is necessary to infer the member type
of the inherent type of a structured value.
</p>
<p>
In most cases, the precise type and the broad type of an expression are the
same. For a compound expression, the broad type of an expression is computed
from the broad type of the sub-expressions in the same way as the precise type
of the expression is computed from the precise type of sub-expressions.
Therefore in most cases, there is no need to mention the distinction between
precise and broad types.
</p>
<p>
The most important case where the precise type and the broad type are different
is literals. The precise type is a singleton type containing just the shape of
the value that the literal represents, whereas the broad type is the precise
type widened to contain the entire basic type of which it is a subtype. For
example, the precise type of the string literal <code>"X"</code> is the
singleton type <code>"X"</code>, but the broad type is <code>string</code>.
</p>
<p>
For a type-cast-expr, the precise type and the broad type are the type
specified in the cast.
</p>
</section>
</section>
<section>
<h3 id="section_6.3">6.3 Casting and conversion</h3>
<p>
Ballerina makes a sharp distinction between type conversion and type casting.
</p>
<p>
Casting a value does not change the value. Any value always belongs to multiple
types. Casting means taking a value that is statically known to be of one type,
and using it in a context that requires another type; casting checks that the
value is of that other type, but does not change the value.
</p>
<p>
Conversion is a process that takes as input a value of one type and produces as
output a possibly distinct value of another type. Note that conversion does not
mutate the input value.
</p>
<p>
Ballerina always requires programmers to make conversions explicit, even between
different types of number; there are no implicit conversions.
</p>
</section>
<section>
<h3 id="section_6.4">6.4 Constant expressions</h3>

<pre class="grammar"><span class="ntdfn" id="const-expr">const-expr</span> := 
   <a href="#literal"><span class="ntref">literal</span></a>
   | <a href="#string-template-expr"><span class="ntref">string-template-expr</span></a>
   | <a href="#xml-template-expr"><span class="ntref">xml-template-expr</span></a>
   | <a href="#structural-constructor-expr"><span class="ntref">structural-constructor-expr</span></a>
   | <a href="#functional-constructor-expr"><span class="ntref">functional-constructor-expr</span></a>
   | <a href="#constant-reference-expr"><span class="ntref">constant-reference-expr</span></a>
   | <a href="#type-cast-expr"><span class="ntref">type-cast-expr</span></a>
   | <a href="#unary-expr"><span class="ntref">unary-expr</span></a>
   | <a href="#multiplicative-expr"><span class="ntref">multiplicative-expr</span></a>
   | <a href="#additive-expr"><span class="ntref">additive-expr</span></a>
   | <a href="#shift-expr"><span class="ntref">shift-expr</span></a>
   | <a href="#range-expr"><span class="ntref">range-expr</span></a>
   | <a href="#numerical-comparison-expr"><span class="ntref">numerical-comparison-expr</span></a>
   | <a href="#is-expr"><span class="ntref">is-expr</span></a>
   | <a href="#equality-expr"><span class="ntref">equality-expr</span></a>
   | <a href="#binary-bitwise-expr"><span class="ntref">binary-bitwise-expr</span></a>
   | <a href="#logical-expr"><span class="ntref">logical-expr</span></a>
   | <a href="#conditional-expr"><span class="ntref">conditional-expr</span></a>
   | <code>(</code> <a href="#const-expr"><span class="ntref">const-expr</span></a> <code>)</code>
</pre>
<p>
A value resulting from the evaluation of a <code>const-expr</code> always has
its read-only bit on.
</p>
<p>
Within a <code>const-expr</code>, any nested expression must also be a
const-expr. A <code>functional-constructor-expr</code> within a
<code>const-expr</code> must not construct an error value.
</p>

<pre class="grammar"><span class="ntdfn" id="constant-reference-expr">constant-reference-expr</span> := <a href="#variable-reference-expr"><span class="ntref">variable-reference-expr</span></a>
</pre>
<p>
A <code>constant-reference-expr</code> must reference a constant defined with
<code>module-const-decl</code>.
</p>
<p>
A <code>const-expr</code> is evaluated at compile-time. Constructors called
within a <code>const-expr</code> construct their values as immutable. Note that
the syntax of const-expr does not allow for the construction of error values.
The result of a <code>const-expr</code> is always immutable.
</p>

<pre class="grammar"><span class="ntdfn" id="simple-const-expr">simple-const-expr</span> :=
  <a href="#nil-literal"><span class="ntref">nil-literal</span></a>
  | <a href="#boolean-literal"><span class="ntref">boolean-literal</span></a>
  | [<a href="#Sign"><span class="ntref">Sign</span></a>] <a href="#int-literal"><span class="ntref">int-literal</span></a>
  | [<a href="#Sign"><span class="ntref">Sign</span></a>] <a href="#floating-point-literal"><span class="ntref">floating-point-literal</span></a>
  | <a href="#string-literal"><span class="ntref">string-literal</span></a>
  | <a href="#constant-reference-expr"><span class="ntref">constant-reference-expr</span></a>
</pre>
<p>
A simple-const-expr is a restricted form of const-expr used in contexts where
various forms of constructor expression would not make sense. Its semantics are
the same as a const-expr.
</p>
</section>
<section>
<h3 id="section_6.5">6.5 Literals</h3>

<pre class="grammar"><span class="ntdfn" id="literal">literal</span> :=
   <a href="#nil-literal"><span class="ntref">nil-literal</span></a>
   | <a href="#boolean-literal"><span class="ntref">boolean-literal</span></a>
   | <a href="#numeric-literal"><span class="ntref">numeric-literal</span></a>
   | <a href="#string-literal"><span class="ntref">string-literal</span></a>
   | <a href="#byte-array-literal"><span class="ntref">byte-array-literal</span></a>
<span class="ntdfn" id="numeric-literal">numeric-literal</span> := <a href="#int-literal"><span class="ntref">int-literal</span></a> | <a href="#floating-point-literal"><span class="ntref">floating-point-literal</span></a>
</pre>
<p>
A numeric-literal represents a value belonging to one of the basic types
int, float or decimal. The basic type to which the value belongs is determined
as follows:
</p>
<ul>
<li>if the numeric-literal includes a <code>FloatTypeSuffix</code>, then the
basic type is float;</li>
<li>if the numeric-literal includes a <code>DecimalTypeSuffix</code>, then the
basic type is decimal;</li>
<li>if the numeric-literal is a <code>HexFloatingPointLiteral</code>, then the
basic type is float;</li>
<li>otherwise, the basic type depends on the applicable expected numeric type
(where the possible basic types are int, float and decimal):
<ul>
<li>if the applicable contextually expected type is a subtype of decimal, then
the basic type is decimal;</li>
<li>if the applicable contextually expected type is a subtype of float, then the
basic type is float;</li>
<li>otherwise, if the numeric literal is an int-literal, then the basic type is
int;</li>
<li>otherwise, the basic type is float.</li>
</ul>
</li>
</ul>
<p>
The precise type of a numeric-literal is the singleton type containing just the
shape of the value that the numeric-literal represents. The broad type is
the basic type of which the precise type is a subset.
</p>

<pre class="grammar"><span class="ntdfn" id="byte-array-literal">byte-array-literal</span> := <a href="#Base16Literal"><span class="ntref">Base16Literal</span></a> | <a href="#Base64Literal"><span class="ntref">Base64Literal</span></a>
<span class="ntdfn" id="Base16Literal">Base16Literal</span> := <code>base16</code> <a href="#WS"><span class="ntref">WS</span></a> <code>`</code> <a href="#HexGroup"><span class="ntref">HexGroup</span></a>* <a href="#WS"><span class="ntref">WS</span></a> <code>`</code>
<span class="ntdfn" id="HexGroup">HexGroup</span> := <a href="#WS"><span class="ntref">WS</span></a> <a href="#HexDigit"><span class="ntref">HexDigit</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#HexDigit"><span class="ntref">HexDigit</span></a>
<span class="ntdfn" id="Base64Literal">Base64Literal</span> := <code>base64</code> <a href="#WS"><span class="ntref">WS</span></a> <code>`</code> <a href="#Base64Group"><span class="ntref">Base64Group</span></a>* [<a href="#PaddedBase64Group"><span class="ntref">PaddedBase64Group</span></a>] <a href="#WS"><span class="ntref">WS</span></a> <code>`</code>
<span class="ntdfn" id="Base64Group">Base64Group</span> :=
   <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a>
<span class="ntdfn" id="PaddedBase64Group">PaddedBase64Group</span> :=
   <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#PaddingChar"><span class="ntref">PaddingChar</span></a>
   | <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#Base64Char"><span class="ntref">Base64Char</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#PaddingChar"><span class="ntref">PaddingChar</span></a> <a href="#WS"><span class="ntref">WS</span></a> <a href="#PaddingChar"><span class="ntref">PaddingChar</span></a>
<span class="ntdfn" id="Base64Char">Base64Char</span> := <code>A</code> .. <code>Z</code> | <code>a</code> .. <code>z</code> | <code>0</code> .. <code>9</code> | <code>+</code> | <code>/</code>
<span class="ntdfn" id="PaddingChar">PaddingChar</span> := <code>=</code>
<span class="ntdfn" id="WS">WS</span> := <a href="#WhiteSpaceChar"><span class="ntref">WhiteSpaceChar</span></a>*
</pre>
<p>
The static type of byte-array-literal is <code>byte[N]</code>, where N is the
number of bytes encoded by the Base16Literal or Base64Literal. The inherent type
of the array value created is also <code>byte[N]</code>.
</p>
</section>
<section>
<h3 id="section_6.6">6.6 Template expressions</h3>
<p>
Template expressions make use of strings enclosed in backticks with interpolated
expressions.
</p>
<pre class="grammar"><span class="ntdfn" id="BacktickString">BacktickString</span> :=
  <code>`</code> <a href="#BacktickItem"><span class="ntref">BacktickItem</span></a>* <a href="#Dollar"><span class="ntref">Dollar</span></a>* <code>`</code>
<span class="ntdfn" id="BacktickItem">BacktickItem</span> :=
   <a href="#BacktickSafeChar"><span class="ntref">BacktickSafeChar</span></a>
   | <a href="#BacktickDollarsSafeChar"><span class="ntref">BacktickDollarsSafeChar</span></a>
   | <a href="#Dollar"><span class="ntref">Dollar</span></a>* <a href="#interpolation"><span class="ntref">interpolation</span></a>
<span class="ntdfn" id="interpolation">interpolation</span> := <code>${</code> <a href="#expression"><span class="ntref">expression</span></a> <code>}</code>
<span class="ntdfn" id="BacktickSafeChar">BacktickSafeChar</span> := ^ ( <code>`</code> | <code>$</code> )
<span class="ntdfn" id="BacktickDollarsSafeChar">BacktickDollarsSafeChar</span> :=  <code>$</code>+ ^ ( <code>{</code> | <code>`</code> | <code>$</code>)
<span class="ntdfn" id="Dollar">Dollar</span> := <code>$</code>
</pre>

<section>
<h4 id="section_6.6.1">6.6.1 String template expression</h4>

<pre class="grammar"><span class="ntdfn" id="string-template-expr">string-template-expr</span> := <code>string</code> <a href="#BacktickString"><span class="ntref">BacktickString</span></a>
</pre>
<p>
A <code>string-template-expr</code> interpolates the results of evaluating
expressions into a literal string. The static type of the expression in each
interpolation must be a simple type and must not be nil. Within a
<code>BacktickString</code>, every character that is not part of an
<code>interpolation</code> is interpreted as a literal character. A
string-template-expr is evaluated by evaluating the expression in each
interpolation in the order in which they occur, and converting the result of the
each evaluation to a string as if using by <code>toString</code> function of the
<code>lang.value</code> module of the lang library. The result
of evaluating the <code>string-template-expr</code> is a string comprising the
literal characters and the results of evaluating and converting the
interpolations, in the order in which they occur in the
<code>BacktickString</code>.
</p>
<p>
A literal <code>`</code> can be included in string template by using an
interpolation <code>${"`"}</code>.
</p>
</section>
<section>
<h4 id="section_6.6.2">6.6.2 XML template expression</h4>

<pre class="grammar"><span class="ntdfn" id="xml-template-expr">xml-template-expr</span> := <code>xml</code> <a href="#BacktickString"><span class="ntref">BacktickString</span></a>
</pre>
<p>
An XML template expression constructs an xml value as follows:
</p>
<ol>
<li>The backtick string is parsed to produce a string of literal characters with
interpolated expressions</li>
<li>The result of the previous step is parsed as XML content. More precisely, it
is parsed using the production <code>content</code> in the W3C XML
Recommendation. For the purposes of parsing as XML, each interpolated expression
is interpreted as if it were an additional character allowed by the CharData and
AttValue productions but no other. The result of this step is an XML Infoset
consisting of an ordered list of information items such as could occur as the
[children] property of an element information item, except that interpolated
expressions may occur as Character Information Item or in the [normalized value]
of an Attribute Information Item. Interpolated expressions are not allowed in
the value of a namespace attribute.</li>
<li>This infoset is then converted to an xml value, as described in the <a href="#XML">XML type</a> section, together with an ordered list of interpolated
expressions, and for each interpolated expression a position within the XML
value at which the value of the expression is to be inserted.</li>
<li>The static type of an expression occurring in an attribute value must be a
simple type and must not be nil. The static type type of an expression occurring
in content can either be xml or a non-nil simple type.</li>
<li>When the xml-template-expr is evaluated, the interpolated expressions are evaluated
in the order in which they occur in the <code>BacktickString</code>, and
converted to strings if necessary. A new copy is made of the xml value and the
result of the expression evaluations are inserted into the corresponding
position in the newly created xml value. This xml value is the result of the
evaluation.</li>
</ol>
<p>
An xml-template-expr occurring within a const-expr will construct an xml value
that has its read-only bit on.
</p>
</section>
</section>

<section>
<h3 id="section_6.7">6.7 Structural constructors</h3>
<p>
Each basic type of structure has its own expression syntax for constructing a
value of the type.
</p>
<pre class="grammar"><span class="ntdfn" id="structural-constructor-expr">structural-constructor-expr</span> := <a href="#list-constructor-expr"><span class="ntref">list-constructor-expr</span></a> | <a href="#table-constructor-expr"><span class="ntref">table-constructor-expr</span></a> | <a href="#mapping-constructor-expr"><span class="ntref">mapping-constructor-expr</span></a>
</pre>

<p>
An structural-constructor-expr occurring within a const-expr will construct a
structural value that has its read-only bit on.
</p>

<section>
<h4 id="section_6.7.1">6.7.1 List constructor</h4>

<pre class="grammar"><span class="ntdfn" id="list-constructor-expr">list-constructor-expr</span> := <code>[</code> [ <a href="#expr-list"><span class="ntref">expr-list</span></a> ] <code>]</code>
<span class="ntdfn" id="expr-list">expr-list</span> := <a href="#expression"><span class="ntref">expression</span></a> (<code>,</code> <a href="#expression"><span class="ntref">expression</span></a>)*
</pre>
<p>
A list-constructor-expr creates a new list value. The members of the list come from evaluating each
expression in the expr-list in order.
</p>
<p>
If there is a contextually expected type, then the inherent type of the newly
created list is derived from the applicable contextually expected type. If the
applicable contextually expected type is a list type descriptor, then that used
as the inherent type. If the applicable contextually expected type is a union
type descriptor, then any members of the union that do not contain list shapes
of length N will be ignored, where N is the number of expressions in the
<code>expr-list</code>; it is a compile-time error if this does not leave a
single list type descriptor, which is then used as the inherent type. The static
type of the list-constructor-expr will be the same as the inherent type.
</p>
<p>
If there is no contextually expected type, then the inherent type will be a
tuple-type-descriptor with a member-type-descriptor for each expression in the
expr-list; the type of each member-type-descriptor will be the broad type of the
corresponding expression in the expr-list.
</p>
<p>
If there is a contextually expected type, then the type that the inherent type
requires for each list member provides the contextually expected type for the
expression for the member; otherwise there is no contextually expected type for
the expressions for members.
</p>
<p>
A member of a list can be filled in automatically if the <a href="#FillMember">FillMember</a> abstract operation would succeed on it. The
inherent type of a list establishes either a fixed length for the list or just a
minimum length for the list, which may be zero. In either case, a list
constructor may specify only the first <var>k</var> members, provided that for
each <var>i</var> from <var>k</var> + 1 up to the fixed length of the list, the
<var>i</var>-th member can be filled in automatically.
</p>

</section>
<section>
<h4 id="section_6.7.2">6.7.2 Mapping constructor</h4>

<pre class="grammar"><span class="ntdfn" id="mapping-constructor-expr">mapping-constructor-expr</span> := <code>{</code> [<a href="#field"><span class="ntref">field</span></a> (<code>,</code> <a href="#field"><span class="ntref">field</span></a>)*] <code>}</code>
<span class="ntdfn" id="field">field</span> := 
  <a href="#specific-field"><span class="ntref">specific-field</span></a>
  | <a href="#computed-name-field"><span class="ntref">computed-name-field</span></a>
  | <a href="#spread-field"><span class="ntref">spread-field</span></a>
<span class="ntdfn" id="specific-field">specific-field</span> :=
   [<code>readonly</code>] (<a href="#field-name"><span class="ntref">field-name</span></a> | <a href="#string-literal"><span class="ntref">string-literal</span></a>) <code>:</code> <a href="#value-expr"><span class="ntref">value-expr</span></a>
   | [<code>readonly</code>] [<a href="#variable-name"><span class="ntref">variable-name</span></a>]
<span class="ntdfn" id="value-expr">value-expr</span> := <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="computed-name-field">computed-name-field</span> := <code>[</code> <a href="#field-name-expr"><span class="ntref">field-name-expr</span></a> <code>]</code> <code>:</code> <a href="#value-expr"><span class="ntref">value-expr</span></a>
<span class="ntdfn" id="field-name-expr">field-name-expr</span> := <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="spread-field">spread-field</span> := <code>...</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A mapping-constructor-expr creates a new mapping value. 
</p>
<p>
A specific-field specifies a single field, where the field name is known at
compile-time. A specific-field that consists of just a variable name
<code><var>x</var></code> is equivalent to a field <code><var>x</var>:
<var>x</var></code>.
</p>
<p>
The static type of the expression in a spread-field must allow only mapping
values, i.e. must be a subtype of <code>map&lt;any|error&gt;</code>. All the
fields of the mapping value that results from evaluating that expression are
included in the mapping value being constructed. It is a compile-time error if
the static type of the expression in a spread-field allows a field that
duplicates a specific-field or that could also occur in another spread-field.
Note that a spread-field with an inclusive record type of <code>record { never
x?; }</code> cannot duplicate a specific field for <code>x</code>.
</p>
<p>
If there is a contextually expected type, then the inherent type of the newly
created mapping is derived from the applicable contextually expected type. If
the applicable contextually expected type is a mapping type descriptor, then
that used as the inherent type. If the applicable contextually expected type is
a union type descriptor, then any members of the union that are inconsistent
with the field names specified in a specific-field in the
mapping-constructor-expr will be ignored; it is a compile-time error if this
does not leave a single mapping type descriptor, which is then used as the
inherent type. The static type of the mapping-constructor-expr will be the same
as the inherent type.
</p>
<p>
If there is no contextually expected type, then the inherent type will be an
exclusive-record-type-descriptor with an individual-field-descriptor for each
specific-field; the type of each field-descriptor will be the broad type of the
value-expr in the field, unless the field is read-only in which case the type of
the field-descriptor will be the precise type. The static type of the expression
in every spread-field will also be added to the inherent type. If there are
fields specified as a computed-name-field, then there will also be a
record-rest-descriptor <code>T...</code>, where <code>T</code> is the union of
the broad types of the value-expr in all such fields.
</p>
<p>
If a specific-field does not use a string-literal for the name of the field and
the inherent type descriptor is a record type descriptor, then the record type
descriptor must include an individual-type-descriptor for that field.
</p>
<p>
If the inherent type descriptor is a record type descriptor, a field will be
added to the constructed value using the default value from the type descriptor
for any field that is not specified explicitly in the mapping constructor and
that has a default value.
</p>
<p>
If there is a contextually expected type, then the type that the inherent type
requires for each field provides the contextually expected type for the
value-expr in a field; otherwise there is no contextually expected type for the
value-expr for fields. If there is a contextually expected type, the
contextually expected type for the expression in a spread-field is map&lt;T&gt;,
where the T is the smallest type such that the inherent type is a subtype of
map&lt;T&gt;. The contextually expected type for a field-name-expr is string.
</p>
<p>
A computed-name-field specifies a single field, where the name of the field is
specified by an expression enclosed in square brackets. A
mapping-constructor-expr first constructs a mapping value without considering
any computed-name-field. The effect of a computed-name-field is to modify the
member of the mapping with the specified name after the mapping has been
constructed. If the modification is incompatible with the inherent type, then
the mapping-constructor-expr will panic. The modifications are performed in the
order in which the computed-name-fields occur in the mapping-constructor-expr.
</p>
<p>
If the applicable contextually expected type is a subtype of readonly, then the
mapping will be constructed with its read-only bit on. If the inherent type
makes a specific field readonly, then that field will be constructed with its
read-only bit on. A specific-field that starts with <code>readonly</code> will
also be constructed with its read-only bit on.
</p>

</section>
<section>
<h4 id="section_6.7.3">6.7.3 Table constructor</h4>

<pre class="grammar"><span class="ntdfn" id="table-constructor-expr">table-constructor-expr</span> := <code>table</code> [<a href="#key-specifier"><span class="ntref">key-specifier</span></a>] <code>[</code> [<a href="#row-list"><span class="ntref">row-list</span></a>] <code>]</code>
<span class="ntdfn" id="row-list">row-list</span> := <a href="#mapping-constructor-expr"><span class="ntref">mapping-constructor-expr</span></a> (<code>,</code> <a href="#mapping-constructor-expr"><span class="ntref">mapping-constructor-expr</span></a>)*
</pre>
<p>
A table-constructor-expr creates a new table value. The members of the table
come from evaluating each mapping-constructor-expr in the row-list in order.
</p>
<p>
For example,
</p>

<pre>table key(email) [
   { email: "sanjiva@weerawarana.org", firstName: "Sanjiva", lastName: "Weerawarana" },
   { email: "jjc@jclark.com", firstName: "James", lastName: "Clark" }
]
</pre>
<p>
The inherent type of the constructed table is a table type descriptor including
a key-specifier <code>table&lt;<var>T</var>&gt; key(<var>ks</var>)</code>, where
<code><var>T</var></code> is the member type and <code><var>ks</var></code> is
the key sequence. The inherent type is determined from the contextually expected
type togther with the table-constructor-expr. The static type of the
table-constructor-expr will be the same as this inherent type.
</p>
<p>
If there is a contextually expected type, then the member type of inherent type
of the newly created table is derived from the applicable contextually expected
type, which must be a table-type-descriptor. If there is no contextually
expected type, then the member type of the inherent type is derived from the the
static type of the expressions for the members: the member type will be the
smallest record type that is a supertype of the static types of all the
expressions in the expr-list.
</p>
<p>
The key sequence of the inherent type comes from the key-specifier of applicable
contextually expected type or the key-specifier in the table-constructor-expr.
If both of these are present, then they must be the same. If neither of them are
present, then the key sequence is empty. The key sequence of the table value is
the same as that of its inherent type. The key sequence and member type must
meet the same consistency requirements as if they were specified together in a
<a href="#tables">table type descriptor</a>. For every field-name in the key
sequence of the inherent type every mapping-constructor-expr in the row-list
must include a specific-field that has a value-expr that is a const-expr. It is
a compile-time error if two or more rows of the table have the same key value.
</p>
<p>
If there is a contextually expected type, then the type that the inherent type
requires for each table member provides the contextually expected type for the
expressions in the expr-list; otherwise there is no contextually expected type
for these expressions.
</p>

</section>
</section>

<section>
<h3 id="section_6.8">6.8 New expression</h3>

<pre class="grammar"><span class="ntdfn" id="new-expr">new-expr</span> := <a href="#explicit-new-expr"><span class="ntref">explicit-new-expr</span></a> | <a href="#implicit-new-expr"><span class="ntref">implicit-new-expr</span></a>
<span class="ntdfn" id="explicit-new-expr">explicit-new-expr</span> := <code>new</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>(</code> <a href="#arg-list"><span class="ntref">arg-list</span></a> <code>)</code>
</pre>
<p>
A new-expr constructs a new object or stream. The type-descriptor in an
explicit-new-expr must specify an object type or a stream type.
</p>
<p>
When the type-descriptor is an object type, the explicit-new-expr allocates
storage for the object and initializes it, passing the supplied arg-list to the
object's <code>init</code> method. It is a compile error if the
type-descriptor if the arg-list does not match the signature of the object
type's <code>init</code> method. If the result of calling the
<code>init</code> method is an error value e, then the result of evaluating
the explicit-new-expr is e; otherwise the result is the newly initialized
object.
</p>
<p>
When the type-descriptor is a stream type <code>stream&lt;T,E&gt;</code>, the
arg-list must either be empty or be a single argument belonging to abstract
object type StreamImplementor&lt;T,E?&gt;. When the arg-list is empty, the
result will be an empty stream (i.e. a stream whose next method returns nil).
When the arg-list evaluates to a StreamImplementor object, the result will be a
stream that wraps that object.
</p>
<p>
An explicit-type-expr specifying a type descriptor T has static type T, except
that if T is an object type and the type of the <code>init</code> method is
E?, where E is a subtype of error, then it has static type T|E.
</p>
<pre class="grammar"><span class="ntdfn" id="implicit-new-expr">implicit-new-expr</span> := <code>new</code> [<code>(</code> <a href="#arg-list"><span class="ntref">arg-list</span></a> <code>)</code>]
</pre>
<p>
An implicit-new-expr is equivalent to an explicit-new-expr that specifies the
applicable contextually expected type as the type descriptor. An
implicit-new-expr consisting of just <code>new</code> is equivalent to
<code>new()</code>.
</p>
</section>
<section>
<h3 id="section_6.9">6.9 Service constructor</h3>

<pre class="grammar"><span class="ntdfn" id="service-constructor-expr">service-constructor-expr</span> := [<a href="#annots"><span class="ntref">annots</span></a>] <code>service</code> <a href="#service-body-block"><span class="ntref">service-body-block</span></a>
<span class="ntdfn" id="service-body-block">service-body-block</span> := <code>{</code> <a href="#service-method-defn"><span class="ntref">service-method-defn</span></a>* <code>}</code>
<span class="ntdfn" id="service-method-defn">service-method-defn</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   [<code>resource</code>]
   <code>function</code> <a href="#identifier"><span class="ntref">identifier</span></a> <a href="#function-signature"><span class="ntref">function-signature</span></a> <a href="#method-defn-body"><span class="ntref">method-defn-body</span></a>
</pre>
<p>
A <code>service-constructor-expr</code> constructs a service value. The result
of evaluating a service-constructor-expr is a value of type service. If a
service-method-defn contains a <code>resource</code> qualifier, then it defines
a resource method. The self variable can be used in a method-defn-body of a
service-method-defn in the same way as for objects.
</p>
<p>
Each service value has a distinct type descriptor. (Evaluating a service
constructor thus has an effect analogous to defining an anonymous object type
and then creating a value of that type.)
</p>
<p>
The return type of a resource method must be a subtype of <code>error?</code> and must contain
nil.
</p>
</section>
<section>
<h3 id="section_6.10">6.10 Variable reference expression</h3>

<pre class="grammar"><span class="ntdfn" id="variable-reference-expr">variable-reference-expr</span> := <a href="#variable-reference"><span class="ntref">variable-reference</span></a>
<span class="ntdfn" id="variable-reference">variable-reference</span> := <a href="#identifier"><span class="ntref">identifier</span></a> | <a href="#qualified-identifier"><span class="ntref">qualified-identifier</span></a> | <a href="#xml-qualified-name"><span class="ntref">xml-qualified-name</span></a>
<span class="ntdfn" id="xml-qualified-name">xml-qualified-name</span> := <a href="#xml-namespace-prefix"><span class="ntref">xml-namespace-prefix</span></a> <code>:</code> <a href="#identifier"><span class="ntref">identifier</span></a>
</pre>
<p>
A variable-reference can refer to a variable, a parameter, a constant (defined
with a module constant declaration), a function or a type (defined with a type
definition).
</p>
<p>
When the variable reference has a prefix and the prefix has been declared using
an xmlns-decl rather than an import-decl, then the result of evaluating the
variable-reference-expr is a string of the form:
</p>
<pre>
   {<var>namespace-uri</var>}<var>local-name</var>
</pre>
<p>
where the namespace-uri comes from xml-namespace-uri specified in the
xmlns-decl, and the local-name comes from the identifier following the colon.
</p>
<p>
If the variable-reference references a type defined with a type definition, then
the result of evaluating the variable-reference-expr is a typedesc value for
that type.
</p>
</section>
<section>
<h3 id="section_6.11">6.11 Field access expression</h3>

<pre class="grammar"><span class="ntdfn" id="field-access-expr">field-access-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>.</code> <a href="#field-name"><span class="ntref">field-name</span></a>
</pre>
<p>
A field-access-expr accesses a field of an object or a member of a mapping. The
semantics depends on the static type T of expression. A field-access-expr where
T is a subtype of xml is interpreted as an xml-required-attribute-access-expr.
</p>
<p>
If T is a subtype of the object basic type, then T must have a field field-name
and the static type of the field-access-expr is the type of that field. In this
case, the field-access-expr is evaluated by first evaluating the expression to
get a value <var>obj</var>; the result of the field-access-expr is the value of
that field of <var>obj</var>. The rest of this subsection applies when T is not
a subtype of the object basic type.
</p>
<p>
Let T' be the intersection of T and basic type mapping, let K be the singleton type
containing just the string field-name, and let M be the member type for K in T'.
The compile-time requirements on the field-access-expr depend on whether the
type descriptor describing T is lax:
</p>
<ul>
<li>if it is lax, then the only compile-time requirement is M is non-empty;</li>
<li>if it is not lax, then T must be a subtype of the mapping basic type and K
must be a required key type for T.</li>
</ul>
<p>
The static type of field-access-expr is M|E, where E is empty if K is a required
key type and T' is a subtype of T, and error otherwise (E can only be error in
the lax case.) In the lax case, if M is lax, then the static type of the
field-access-expr is lax even if E is an error.
</p>
<p>
A field-access-expr is evaluated as follows:
</p>
<ol>
<li>expression is evaluated resulting in a value <var>v</var>
</li>
<li>if <var>v</var> has basic type error, the result is <var>v</var> (this can
only happen in the lax case)</li>
<li>otherwise, if <var>v</var> does not have basic type mapping, the result is a
new error value (this can only happen in the lax case)</li>
<li>otherwise, if <var>v</var> does not have a member whose key is field-name,
the result is a new error value (this can only happen in the lax case)</li>
<li>otherwise, the result is the member of <var>v</var> whose key is
field-name.</li>
</ol>

</section>
<section>
<h3 id="section_6.12">6.12 Optional field access expression</h3>

<pre class="grammar"><span class="ntdfn" id="optional-field-access-expr">optional-field-access-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>?.</code> <a href="#field-name"><span class="ntref">field-name</span></a>
</pre>
<p>
An optional-field-access-expr accesses a possibly undefined mapping member,
returning <code>()</code> if the member does not exist.
</p>
<p>
An optional-field-access-expr where the static type of <code>expression</code> is
a subtype of xml is interpreted as an xml-optional-attribute-access-expr.
</p>
<p>
Let T be the static type of expression, let T' be the intersection of T and
basic type mapping, let K be the singleton type containing just the string
field-name and let M be the member type of K in T'. The compile-time
requirements on the optional-field-access-expr depend on whether the type
descriptor describing T is lax:
</p>
<ul>
<li>if it is lax, then the only compile-time requirement is that M is
non-empty;</li>
<li>if it is not lax, then, in addition, T must be a subtype of the union of
<code>()</code> and the mapping basic type, and the type descriptor for T must
include <code>field-name</code> as an individual-type-descriptor (if the type
descriptor is a union, then this requirement must be satisfied by at least one
member of the union).</li>
</ul>
<p>
The static type of the optional-field-access-expr is M|N|E where
</p>
<ul>
<li>N is <code>()</code> if <code>()</code> is a subtype of T or K is not a
required key type for T', and empty otherwise;</li>
<li>E is <code>error</code> if T' is not a subtype of T?, and empty otherwise (E
can only be error in the lax case).</li>
</ul>

<p>
An optional-field-access-expr is evaluated as follows:
</p>
<ol>
<li>expression is evaluated resulting in a value <var>v</var>
</li>
<li>if <var>v</var> is <code>()</code>, the result is <code>()</code>
</li>
<li>otherwise, if <var>v</var> has basic type error, the result is <var>v</var>
(this can only happen in the lax case)</li>
<li>otherwise, if <var>v</var> does not have basic type mapping, the result is a
new error value (this can only happen in the lax case)</li>
<li>otherwise, if <var>v</var> does not have a member whose key is field-name,
the result is <code>()</code>
</li>
<li>otherwise, the result is the member of <var>v</var> whose key is
field-name.</li>
</ol>

</section>

<section>
<h3 id="section_6.13">6.13 XML attribute access expression</h3>

<pre class="grammar"><span class="ntdfn" id="xml-attribute-access-expr">xml-attribute-access-expr</span> := <a href="#xml-required-attribute-access-expr"><span class="ntref">xml-required-attribute-access-expr</span></a> | <a href="#xml-optional-attribute-access-expr"><span class="ntref">xml-optional-attribute-access-expr</span></a>
<span class="ntdfn" id="xml-required-attribute-access-expr">xml-required-attribute-access-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>.</code> <a href="#xml-attribute-name"><span class="ntref">xml-attribute-name</span></a>
<span class="ntdfn" id="xml-optional-attribute-access-expr">xml-optional-attribute-access-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>?.</code> <a href="#xml-attribute-name"><span class="ntref">xml-attribute-name</span></a>
<span class="ntdfn" id="xml-attribute-name">xml-attribute-name</span> := <a href="#xml-qualified-name"><span class="ntref">xml-qualified-name</span></a> | <a href="#qualified-identifier"><span class="ntref">qualified-identifier</span></a> | <a href="#identifier"><span class="ntref">identifier</span></a>
</pre>

<p>
An XML attribute access expression provides convenient access to an attribute of
an XML element. It is a compile-time requirement that the static type of the
expression is a subtype of xml.
</p>
<p>
A string representing the name of the attribute is computed at compile-time from
the xml-attribute-name. When the xml-attribute-name is an identifier without a
prefix, the attribute name string is the identifier. When the xml-attribute-name
has a prefix, normally the xml-attribute-name is an xml-qualified-name, in which
the prefix is an xml-namespace-prefix declared using an xmlns-decl. In this
case, the xml-qualified-name is expanded at compile-time into an attribute name
string of the form
</p>
<pre>
   {<var>namespace-uri</var>}<var>local-name</var>
</pre>
<p>
where the namespace-uri comes from xml-namespace-uri specified in the
xmlns-decl, and the local-name comes from the identifier following the colon.
</p>
<p>
It is also allowed for the xml-attribute-name to be specified as a
qualified-identifier, in which the prefix is a module-prefix declared using an
import-decl. In this case the qualified-identifier must refer to a
module-const-decl of type string, and the attribute name string is the value of
the referenced constant. This allows e.g. <code>xml:lang</code> to work.
</p>
<p>
An xml-optional-attribute-access-expr is evaluated as follows. The expression is
evaluated resulting in an xml value <var>v</var>. If <var>v</var> is an empty
xml value, the result is <code>()</code>. Otherwise, if <var>v</var> is not a
singleton element, the result is an error. Otherwise, let <var>m</var> be that
element's attribute map and let <var>k</var> be the attribute name string
computed at compile-time from the xml-attribute-name. If <var>m</var> has a
member <var>s</var> with key <var>k</var>, the the result is <var>s</var>.
Otherwise, the result is <code>()</code>.
</p>
<p>
An xml-required-attribute-access-expr is evaluated the same as an
xml-optional-attribute-expr, except that for cases where the result of the
xml-optional-attribute-expr would be <code>()</code>, the result of the
xml-required-attribute-access-expr is an error.
</p>
<p>
The static type of an xml-required-attribute-access-expr is
<code>string|error</code> The static type of an
xml-optional-attribute-access-expr is <code>string|error|()</code>.
</p>

</section>
<section>
<h3 id="section_6.14">6.14 Annotation access expression</h3>

<pre class="grammar"><span class="ntdfn" id="annot-access-expr">annot-access-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>.@</code> <a href="#annot-tag-reference"><span class="ntref">annot-tag-reference</span></a>
</pre>
<p>
The annot-tag-reference must refer to an annotation tag declared with an
annotation declaration. The static type of expression must be a subtype of
<code>typedesc</code>.
</p>
<p>
An <code>annot-access-expr</code> is evaluated by first evaluating
<code>expression</code> resulting in a typedesc value <em>t</em>. If <em>t</em>
has an annotation with the tag referenced by <code>annot-tag-reference</code>,
then the result of the <code>annot-access-expr</code> is the value of that
annotation; otherwise, the result is nil.
</p>
<p>
The static type of the <code>annot-access-expr</code> is T? where T is the type
of the annotation tag.
</p>
</section>
<section>
<h3 id="section_6.15">6.15 Member access expression</h3>

<pre class="grammar"><span class="ntdfn" id="member-access-expr">member-access-expr</span> := <a href="#container-expression"><span class="ntref">container-expression</span></a> <code>[</code> (<a href="#key-expression"><span class="ntref">key-expression</span></a> | <a href="#multi-key-expression"><span class="ntref">multi-key-expression</span></a>) <code>]</code>
<span class="ntdfn" id="container-expression">container-expression</span> := <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="key-expression">key-expression</span> := <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="multi-key-expression">multi-key-expression</span> := <a href="#expression"><span class="ntref">expression</span></a> (<code>,</code> <a href="#expression"><span class="ntref">expression</span></a>)+
</pre>
<p>
A member-access-expr accesses a member of a structured value using its key,
or a constituent of a sequence value using its index.
</p>
<p>
The requirements on the static type of container-expression and key-expression are as
follows:
</p>
<ul>
<li>if the static type of container-expression is a subtype of string or of xml
or of basic type list, then the contextually expected type for key-expression is
int and the static type of key-expression must be a subtype of int;</li>
<li>if the static type of container-expression is a subtype of table, then the
contextually expected type for key-expression is <code><var>K</var></code> and
the static type of key-expression must be a subtype of
<code><var>K</var></code>, where the static type of container-expression is
<code>table&lt;<var>R</var>&gt; key&lt;<var>K</var>&gt;</code>;</li>
<li>otherwise the static type of container-expression must be a subtype of the
union of nil and basic type map; in this case the contextually expected type for
key-expression is string and the static type of key-expression must be a subtype
of string.</li>
</ul>
<p>
A multi-key-expression is allowed only when the static type of a
container-expression is a subtype of table. A multi-key-expression
<code>E<sub>1</sub>, E<sub>2</sub>,..., E<sub>n</sub></code> is equivalent to a
list-constructor-expr <code>[E<sub>1</sub>, E<sub>2</sub>,...,
E<sub>n</sub>]</code>.
</p>

<p>
A member-access-expr is evaluated as follows:
</p>
<ol>
<li>the container-expression is evaluated to get a value <var>c</var>;</li>
<li>the key-expression is evaluated to get a value <var>k</var>;</li>
<li>depending on the basic type of <var>c</var>
<ul>
<li>if it is string, and <var>k</var> is &lt; 0 or â¥ the length of
<var>c</var>, then the evaluation completes abruptly with a panic; otherwise,
the result is a string of length 1 containing the character with index
<var>k</var> in <var>c</var>;</li>
<li>if it is xml, and <var>k</var> is &lt; 0, then the evaluation completes
abruptly with a panic; if <var>k</var> is â¥ the length of <var>c</var>, then
the result is an empty xml value; otherwise, the result is a singleton xml
value containing the item with index <var>k</var> in <var>c</var>;</li>
<li>if it is list, and <var>k</var> is &lt; 0 or â¥ the length of
<var>c</var>, then the evaluation completes abruptly with a panic; otherwise,
the result is the member of <var>c</var> with index <var>k</var>;</li>
<li>if it is table, then if <var>c</var> does not contain a member with key
<var>k</var>, the result is <code>()</code>; otherwise, the result is the member
of <var>c</var> with key <var>k</var>.</li>
<li>if it is mapping, then if <var>c</var> is <code>()</code> or <var>c</var>
does not contain a member with key <var>k</var>, the result is <code>()</code>;
otherwise, the result is the member of <var>c</var> with key <var>k</var>.</li>
</ul>
</li>
</ol>
<p>
Let T the static type of container-expression. If T is a subtype of string, then
the static type of the member-access-expr is <a href="#built-in_subtypes"><code>string:Char</code></a>, that is the subtype of
strings containing strings of length 1. If T is a subtype of xml&lt;M&gt;, then
the static type of the member-access-expr is M|E, where E is the type of the
empty xml value. If T is a subtype of table&lt;R&gt;, then the static type of
member-access-expr is R?. Otherwise, let K be the static type of key-expression
and let M be the member type of K in T; if T contains nil, or T is a subtype of
mapping and K is an optional key type for T, then the static type of the
member-access-expr is M?, otherwise the static type is M.
</p>

</section>
<section>
<h3 id="function_call">6.16 Function call expression</h3>

<pre class="grammar"><span class="ntdfn" id="function-call-expr">function-call-expr</span> := <a href="#function-reference"><span class="ntref">function-reference</span></a> <code>(</code> <a href="#arg-list"><span class="ntref">arg-list</span></a> <code>)</code>
<span class="ntdfn" id="function-reference">function-reference</span> := <a href="#variable-reference"><span class="ntref">variable-reference</span></a>
<span class="ntdfn" id="arg-list">arg-list</span> :=
   <a href="#positional-args"><span class="ntref">positional-args</span></a> [<code>,</code> <a href="#other-args"><span class="ntref">other-args</span></a>]
   | [<a href="#other-args"><span class="ntref">other-args</span></a>]
<span class="ntdfn" id="positional-args">positional-args</span> := <a href="#positional-arg"><span class="ntref">positional-arg</span></a> (<code>,</code> <a href="#positional-arg"><span class="ntref">positional-arg</span></a>)*
<span class="ntdfn" id="positional-arg">positional-arg</span> := <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="other-args">other-args</span> := <a href="#named-args"><span class="ntref">named-args</span></a> | <a href="#rest-arg"><span class="ntref">rest-arg</span></a>
<span class="ntdfn" id="named-args">named-args</span> := <a href="#named-arg"><span class="ntref">named-arg</span></a> (<code>,</code> <a href="#named-arg"><span class="ntref">named-arg</span></a>)*
<span class="ntdfn" id="named-arg">named-arg</span> := <a href="#arg-name"><span class="ntref">arg-name</span></a> <code>=</code> <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="arg-name">arg-name</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
<span class="ntdfn" id="rest-arg">rest-arg</span> := <code>...</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A function-call-expr is evaluated by constructing an argument list and passing
the argument list to the function referred to by the variable-name. If the
function terminates normally, then the result of the function-call-expr is the
return value of the function; otherwise the function-call-expr completes
abruptly with a panic. The static type of the function-call-expr is the return
type of the function type.
</p>
<p>
A function-call-expr where the function-reference refers to a type is interpreted
as a functional-constructor-expr.
</p>
<p>
The variable-reference must refer to a variable with function type. The type
descriptor of that function type is used to construct an argument list from the
specified arg-list. Note that it is the type descriptor of the declared type of
the variable that is used for this purpose, rather than the runtime type
descriptor of the referenced function value.
</p>
<p>
The expressions occurring in the arg-list are evaluated in the order in which
they occur in the arg-list. The result of evaluating each positional-arg is
added to the argument list in order. The contextually expected type for the
expression in the i-th positional-arg is the type of the i-th parameter.
</p>
<p>
If there is a rest-arg, then it is evaluated. The result must be a list value.
Each member of the list value is added to the argument in the order that it
occurs. The static type of the list value must be such as to guarantee that the
resulting argument list will conform to the function's declared param-list. The
rest-arg is not restricted to supplying the part of the argument list that will
be bound to a rest-param, and its static type is not restricted to being an
array type. If there is rest-arg, then no parameter defaults are added.
</p>
<p>
If there is no rest-arg, then each non-rest parameter that was not supplied by
positional argument is added in order from a named argument, if there is one,
and otherwise using the parameter default. An arg-list can only use a named
argument to specify a parameter if the name of the parameter is visible at the
point where the arg-list occurs. The contextually expected type for
the expression specifying a named argument is the type declared for the
corresponding parameter. A default parameter is computed by calling the closure
in the type descriptor, passing it the previous arguments in the argument list.
It is a compile-time error if there is a non-rest parameter for which there was
no positional argument and no named argument and which is not defaultable. It is
also an error if there is a named argument for a parameter that was supplied by
a positional argument.
</p>
<p>
When a function to be called results from the evaluation of an expression that
is not merely a variable reference, the function can be called by first storing
the value of the expression in a variable.
</p>

</section>
<section>
<h3 id="section_6.17">6.17 Method call expression</h3>

<pre class="grammar"><span class="ntdfn" id="method-call-expr">method-call-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>.</code> <a href="#method-name"><span class="ntref">method-name</span></a> <code>(</code> <a href="#arg-list"><span class="ntref">arg-list</span></a> <code>)</code>
</pre>
<p>
A <code>method-call-expr</code> either calls a method or calls a function in the
lang library. The evaluation of the method-call-expr starts by evaluating
<code>expression</code> resulting in some value <var>v</var>. There is no
contextually expected type for <code>expression</code>.
</p>
<p>
If the static type of <code>expression</code> is a subtype of object, and the
object type includes a method named <code>method-name</code>, then the
<code>method-call-expr</code> is executed by calling that method on
<var>v</var>. A <code>method-call-expr</code> can be used within a method of a
service to call another method of that service other than a resource method; in
this case, <code>expression</code> must be <code>self</code>. The
<code>arg-list</code> is used to construct an argument list that is passed to
the method in the same way as with a <code>function-call-expr</code>. A
<code>method-call-expr</code> cannot be used to call a remote method; it can
only be called by a <code>remote-method-call-action</code>. A
<code>method-call-expr</code> cannot be used to call a resource method.
</p>
<p>
Otherwise, the <code>method-call-expr</code> will be turned into a call to a
function in the lang library <code>m:method-name(expression, arg-list)</code>,
where m is an automatically created module prefix for a module lang.M of the lang
library, where M is selected as follows.
</p>
<ul>
<li>If the static type of <code>expression</code> is a subtype of some basic
type with identifier B, and the module lang.B contains a function
<code>method-name</code> then M is B. The identifier for a basic type is the
reserved identifier used in type descriptors for subtypes of that basic type, as
listed in the <a href="#lang_library">Lang library</a> section.</li>
<li>Otherwise, M is <code>value</code>.</li>
</ul>
<p>
It is a compile-time error if the resulting function call does not satisfy all
the constraints that would apply if it has been written explicitly as a
<code>function-call-expr</code>.
</p>
</section>
<section>
<h3 id="section_6.18">6.18 Functional constructor</h3>

<pre class="grammar"><span class="ntdfn" id="functional-constructor-expr">functional-constructor-expr</span> := <a href="#functionally-constructible-type-reference"><span class="ntref">functionally-constructible-type-reference</span></a> <code>(</code> <a href="#arg-list"><span class="ntref">arg-list</span></a> <code>)</code>
</pre>
<p>
A functional constructor uses functional syntax to construct a new value of a <a href="#functionally_constructible_types">functionally constructible type</a>. The
functionally-constructible-type-reference identifies the type of value to be
constructed.
</p>
<p>
An argument list consisting of positional and named argument values is
constructed by evaluating the expressions in the <code>arg-list</code>. The
construction parameter types determine the contextually expected type of each of
the expressions. If there is no argument for a construction parameter that can
be defaulted, then an argument for that parameter is added to the argument list
with the default value.
</p>
<p>
When constructing an error value, the ImmutableClone abstract operation is
applied to each named argument. The detail record is constructed as immutable.
The stack trace describes the execution stack at the point where the functional
constructor was evaluated. Any fields of the detail record that were not
specified by a named argument can be defaulted using the defaults specified in
the detail record type.
</p>
<p>
A functional-constructor-expr occurring within a const-expr will construct a
value with its read-only bit on.
</p>

</section>
<section>
<h3 id="section_6.19">6.19 Anonymous function expression</h3>

<pre class="grammar"><span class="ntdfn" id="anonymous-function-expr">anonymous-function-expr</span> := <a href="#explicit-anonymous-function-expr"><span class="ntref">explicit-anonymous-function-expr</span></a> | <a href="#infer-anonymous-function-expr"><span class="ntref">infer-anonymous-function-expr</span></a>
<span class="ntdfn" id="explicit-anonymous-function-expr">explicit-anonymous-function-expr</span> := [<a href="#annots"><span class="ntref">annots</span></a>] <code>function</code> <a href="#function-signature"><span class="ntref">function-signature</span></a> (<a href="#block-function-body"><span class="ntref">block-function-body</span></a>|<a href="#expr-function-body"><span class="ntref">expr-function-body</span></a>)
</pre>
<p>
Evaluating an anonymous-function-expr creates a closure, whose basic type is
function. With an explicit-anonymous-function-expr, the type of the function is
specified explicitly as usual with a function-signature. With an
infer-anonymous-function-expr, the type of the function is inferred.
</p>
<p>
If block-function-body refers to a block-scope variable defined
outside of the block-function-body, the closure will capture a reference to that
variable; the captured reference will refer to the same storage as the original
reference not a copy.
</p>

<pre class="grammar"><span class="ntdfn" id="expr-function-body">expr-function-body</span> := <code>=&gt;</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
An expr-function-body is used for an expression-bodied function, that is a
function whose body is specified by an expression. An expr-function-body of the
form <code>=&gt; <var>E</var></code> is short for a block-function-body <code>{
return <var>E</var>}</code>.
</p>

<pre class="grammar"><span class="ntdfn" id="infer-anonymous-function-expr">infer-anonymous-function-expr</span> := <a href="#infer-param-list"><span class="ntref">infer-param-list</span></a> <a href="#expr-function-body"><span class="ntref">expr-function-body</span></a>
<span class="ntdfn" id="infer-param-list">infer-param-list</span> :=
   <a href="#identifier"><span class="ntref">identifier</span></a>
   | <code>(</code>[<a href="#identifier"><span class="ntref">identifier</span></a> (<code>,</code> <a href="#identifier"><span class="ntref">identifier</span></a>)*]<code>)</code>
</pre>
<p>
An infer-anonymous-function-expr can only be used in a context where a function
type is expected. The types of the parameters are inferred from the expected
function type. The scope of the parameters is <code>expr-function-body</code>.
The static type of the infer-anonymous-function-expr will be a function type
whose return type is the static type of the <code>expression</code> in
<code>expr-function-body</code>. If the contextually expected type for the
<code>anonymous-function-expr</code> is a function type with return type T, then
the contextually expected type for <code>expression</code> in
<code>expr-function-body</code> is T.
</p>
</section>

<section>
<h3 id="section_6.20">6.20 Let expression</h3>

<pre class="grammar"><span class="ntdfn" id="let-expr">let-expr</span> := <code>let</code> <a href="#let-var-decl"><span class="ntref">let-var-decl</span></a> [<code>,</code> <a href="#let-var-decl"><span class="ntref">let-var-decl</span></a>]* <code>in</code> <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="let-var-decl">let-var-decl</span> := [<a href="#annots"><span class="ntref">annots</span></a>] <a href="#typed-binding-pattern"><span class="ntref">typed-binding-pattern</span></a> <code>=</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>

<p>
A let-expr binds variables and then evaluates an expression with those variables in scope.
</p>
<p>
A let-expr <code>let T B = E<sub>1</sub> in E<sub>2</sub></code> is evaluated as
follows. E<sub>1</sub> is evaluated resulting in a value v. The typed binding
pattern T B is matched to v, causing assignments to the variables occuring in B.
Then E<sub>2</sub> is evaluated with those variables in scope; the resulting
value is the result of the let-expr.
</p>
<p>
A let-expr <code>let D<sub>1</sub>, D<sub>2</sub>,...,D<sub>n</sub> in E</code>
is transformed into <code>let D<sub>1</sub> in let D<sub>2</sub> in ... let
D<sub>n</sub> in E</code>.
</p>
<p>
The typed-binding-pattern is used unconditionally, meaning that it is a compile
error if the static types do not guarantee the success of the match. If the
typed-binding-pattern uses <code>var</code>, then the type of the variable is
inferred from the precise static type of the expression following
<code>=</code>.
</p>
<p>
Since expressions cannot modify variables, the variables bound in a let-var-decl
are implicitly final.
</p>

</section>

<section>
<h3 id="section_6.21">6.21 Type cast expression</h3>

<pre class="grammar"><span class="ntdfn" id="type-cast-expr">type-cast-expr</span> := <code>&lt;</code> <a href="#type-cast-param"><span class="ntref">type-cast-param</span></a> <code>&gt;</code> <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="type-cast-param">type-cast-param</span> := [<a href="#annots"><span class="ntref">annots</span></a>] <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> | <a href="#annots"><span class="ntref">annots</span></a>
</pre>
<p>
Normally, the parameter for a type-cast-expr includes a type-descriptor.
However, it is also allowed for the parameter to consist only of annotations; in
this case, the only effect of the type cast is for the contextually expected
type for expression to be augmented with the specified annotations. The rest of
this subsection describes the normal case, where the type-cast-expr includes a
type-descriptor.
</p>
<p>
A <code>type-cast-expr</code> casts the value resulting from evaluating
<code>expression</code> to the type described by the type-descriptor, performing
a numeric conversion if required.
</p>
<p>
A type-cast-expr is evaluated by first evaluating <code>expression</code>
resulting in a value v. Let T be the type described by
<code>type-descriptor</code>. If v belongs T, then the result of the
type-cast-expr is v. Otherwise, if T includes shapes from exactly one basic
numeric type N and v is belongs to another basic numeric type, then let n be
NumericConvert(N, v); if n is not an error and n belongs to T, then the result
of the type-cast-expr is n. Otherwise, the evaluation of the type-cast-expr
completes abruptly with a panic.
</p>
<p>
Let T be the static type described by <code>type-descriptor</code>, and let TE
be the static type of <code>expression</code>. Then the static type of the
<code>type-cast-expr</code> is the intersection of T and TE', where TE' is TE
with its numeric shapes transformed to take account to the possibility of the
numeric conversion specified in the previous paragraph.
</p>
<p>
The contextually expected type for <code>expression</code> is the intersection
of the contextually expected type of the <code>type-cast-expr</code> and the
type described by the <code>type-descriptor</code>.
</p>
<p>
Note that a <code>type-cast-expr</code> of <code>&lt;readonly&gt;</code> can be
used both to cause constructors withing the <code>expression</code> to construct
values with the read-only bit on and to verify that the value resulting from
the evaluation of <code>expression</code> has its read-only bit on.
</p>

</section>
<section>
<h3 id="section_6.22">6.22 Typeof expression</h3>

<pre class="grammar"><span class="ntdfn" id="typeof-expr">typeof-expr</span> := <code>typeof</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
The result of a <code>typeof-expr</code> is a typedesc value for the runtime
type of v, where v is the result of evaluating <code>expression</code>.
</p>
<p>
The runtime type of v is the narrowest type to which v belongs.
</p>
<ul>
<li>When v is a simple value, the resulting typedesc will describe a type
consisting of a single shape, which is the shape of the value. The typedesc will
not have any annotations. Each evaluation of <code>typeof</code> with a simple
value produces a new typedesc value.</li>
<li>When v is a reference value, each evaluation of <code>typeof</code> with an
identical reference value produces an identical typedesc value. The type
descriptor resulting from <code>typeof</code> will be the same as the type
descriptor used to construct the value. For containers, this is the same as the
inherent type; when the container is immutable, it will be a singleton type. For
an object, this is the same as the type descriptor used with new. For an error,
this is the same as the type descriptor used in the functional-constructor-expr.
Any annotations that were attached to the type descriptor used to construct the
value will this be available on the constructed value.</li>
</ul>
<p>
The static type of <code>typeof-expr</code> is typedesc&lt;T&gt;, where T is the
static type of <code>expression</code>.
</p>
</section>
<section>
<h3 id="section_6.23">6.23 Unary expression</h3>

<pre class="grammar"><span class="ntdfn" id="unary-expr">unary-expr</span> :=
   <code>+</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <code>-</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <code>~</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <code>!</code> <a href="#expression"><span class="ntref">expression</span></a>

</pre>
<p>
The unary <code>-</code> operator performs negation. The static type of the
operand must be a number; the static type of the result is the same basic type
as the static type of the operand. The semantics for each basic type are as
follows:
</p>
<ul>
<li>int: negation for int is the same as subtraction from zero; a panic will
occur on overflow, which happens when the operand is -2<sup>63</sup>)</li>
<li>float, decimal: negation for floating point types corresponds to the negate
operation as defined by IEEE 754-2008 (this is not the same as subtraction from
zero);</li>
</ul>
<p>
If the contextually expected type for a <code>-</code> expression is T, then the
contextualy expected type for the operand expressions is T', where a value v is
in T' if it belongs to int, decimal or float, and T contains a value with the
same basic type as v.
</p>
<p>
The unary + operator returns the value of its operand expression. The static
type of the operand must be a number, and the static type of the result is the
same as the static type of the operand expression.
</p>
<p>
The ~ operator inverts the bits of its operand expression. The static type of
the operand must be int, and the static type of the result is an int.
</p>
<p>
The <code>!</code> operator performs logical negation. The static type of the
operand expression must be boolean. The <code>!</code> operator returns true if
its operand is false and false if its operand is true.
</p>
</section>
<section>
<h3 id="section_6.24">6.24 Multiplicative expression</h3>

<pre class="grammar"><span class="ntdfn" id="multiplicative-expr">multiplicative-expr</span> :=
   <a href="#expression"><span class="ntref">expression</span></a> <code>*</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>/</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>%</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
The <code>*</code> operator performs multiplication; the <code>/</code> operator
performs division; the <code>%</code> operator performs remainder.
</p>
<p>
The static type of both operand expressions is required to be a subtype of the
same basic type; this basic type will be the static type of the result. The
following basic types are allowed:
</p>
<ul>
<li>int
<ul>
<li>
<code>*</code> performs integer multiplication; a panic will occur on overflow</li>
<li>
<code>/</code> performs integer division, with any fractional part discarded
ie with truncation towards zero; a panic will occur on division by zero or
overflow, which happens if the first operand is -2<sup>63</sup> and the second
operand is -1</li>
<li>
<code>%</code> performs integer remainder consistent with integer division,
so that if <code><var>x</var>/<var>y</var></code> does not result in a panic,
then <code>(<var>x</var>/<var>y</var>)*<var>y</var> +
(<var>x</var>%<var>y</var>)</code> is equal to <code><var>x</var></code>; a
panic will occur if the second operand is zero; if the first operand is
-2<sup>63</sup> and the second operand is -1, then the result is 0</li>
</ul>
</li>
<li>float, decimal
<ul>
<li>
<code>*</code> performs the multiplication operation with the destination
format being the same as the source format, as defined by IEEE 754-2008; this
never causes a panic to occur</li>
<li>
<code>/</code> performs the division operation with the destination format
being the same as the source format, as defined by IEEE 754-2008; this never
causes a panic to occur</li>
<li>
<code>%</code> performs a remainder operation; the remainder is not the
IEEE-defined remainder operation but is instead a remainder operation analogous
to integer remainder; more precisely,
<ul>
<li>if <code><var>x</var></code> is NaN or <code><var>y</var></code> is NaN or
<code><var>x</var></code> is an infinity or <code><var>y</var></code> is a zero,
then <code><var>x</var> % <var>y</var></code> is NaN</li>
<li>for finite <code>x</code>, and infinite <code>y</code>, <code><var>x</var> %
<var>y</var></code> is <code><var>x</var></code>
</li>
<li>for finite <code><var>x</var></code> and finite non-zero
<code><var>y</var></code>, <code><var>x</var> % <var>y</var></code> is equal to
the result of rounding <code><var>x</var> - (<var>y</var> Ã <var>n</var>)</code>
to the nearest representable value using the roundTiesToEven rounding mode,
where <code><var>n</var></code> is the integer that is nearest to the
mathematical quotient of <code><var>x</var></code> and <code><var>y</var></code>
without exceeding it in magnitude; if the result is zero, then its sign is that
of <code><var>x</var></code>
</li>
<li>no exceptions are thrown</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>
If the contextually expected type for a multiplicative-expr is T, then the
contextualy expected type for both operand expressions is T', where a value v is
in T' if it belongs to int, decimal or float, and T contains a value with the
same basic type as v.
</p>
</section>
<section>
<h3 id="section_6.25">6.25 Additive expression</h3>

<pre class="grammar"><span class="ntdfn" id="additive-expr">additive-expr</span> :=
   <a href="#expression"><span class="ntref">expression</span></a> <code>+</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>-</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
The <code>+</code> operator is used for both addition and concatenation; the
<code>-</code> operator is used for subtraction.
</p>
<p>
It is required that either
</p>
<ul>
<li>the static type of both operand expressions is a subtype of the same basic
type, in which case this basic type will be the static type of the result,
or</li>
<li>the static type of one operand expression must be a subtype of xml and of
the other operand expression must be a subtype of string, in which case the
static type of the result is xml</li>
</ul>
<p>
The semantics for each basic type is as follows:
</p>
<ul>
<li>int
<ul>
<li>
<code>+</code> performs integer addition; a panic will occur on
overflow</li>
<li>
<code>-</code> performs integer subtraction; a panic will occur on
overflow</li>
</ul>
</li>
<li>float, decimal
<ul>
<li>
<code>+</code> performs the addition operation with the destination format
being the same as the source format, as defined by IEEE 754-2008; this never
causes a panic to occur</li>
<li>
<code>-</code> performs the subtraction operation with the destination
format being the same as the source format, as defined by IEEE 754-2008; this
never causes a panic to occur</li>
</ul>
</li>
<li>string, xml
<ul>
<li>if both operands are a string, then the result is a string that is the
concatenation of the operands</li>
<li>if both operands are xml, then the result is a new xml value that is the
concatenation of the operands; this does not perform a copy on
the constituents of the operand values</li>
<li>if one operand is an empty string and one is xml, then
the result is the xml value operand</li>
<li>if one operand is a non-empty string and one is xml, then the string is
treated as if it were an xml singleton text value whose characters are the same
as the characters of the string;</li>
</ul>
</li>
</ul>
<p>
If the contextually expected type for a multiplicative-expr is T, then the
contextualy expected type for both operand expressions is T', where a value v is
in T' if it belongs to int, decimal, float, string or xml and T contains a value
with the same basic type as v.
</p>

</section>
<section>
<h3 id="section_6.26">6.26 Shift expression</h3>

<pre class="grammar"><span class="ntdfn" id="shift-expr">shift-expr</span> :=
   <a href="#expression"><span class="ntref">expression</span></a> <code>&lt;&lt;</code> <a href="#expression"><span class="ntref">expression</span></a>
   <a href="#expression"><span class="ntref">expression</span></a> <code>&gt;&gt;</code> <a href="#expression"><span class="ntref">expression</span></a>
   <a href="#expression"><span class="ntref">expression</span></a> <code>&gt;&gt;&gt;</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A shift-expr performs a bitwise shift. Both operand expressions must have static
type that is a subtype of int. The left hand operand is the value to be shifted;
the right hand value is the shift amount; all except the bottom 6 bits of the
shift amount are masked out (as if by x &amp; 0x3F). Then a bitwise shift is
performed depending on the operator:
</p>
<ul>
<li>
<code>&lt;&lt;</code> performs a left shift, the bits shifted in on the
right are zero</li>
<li>
<code>&gt;&gt;</code> performs a signed right shift; the bits shifted in on the
left are the same as the most significant bit</li>
<li>
<code>&gt;&gt;&gt;</code> performs a unsigned right shift, the bits shifted in on the
left are zero</li>
</ul>
<p>
If the operator is &gt;&gt; or &gt;&gt;&gt; and the left hand operand is a
subtype of <code>int:Unsigned<var>K</var></code> when <code><var>K</var></code>
is 8, 16 or 32, then the static type of the result is
<code>int:Unsigned<var>N</var></code> where <code><var>N</var></code> is the
smallest such <code><var>K</var></code>; otherwise, the static type of the
result is <code>int</code>.
</p>
</section>
<section>
<h3 id="section_6.27">6.27 Range expression</h3>

<pre class="grammar"><span class="ntdfn" id="range-expr">range-expr</span> :=
   <a href="#expression"><span class="ntref">expression</span></a> <code>...</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>..&lt;</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
The result of a range-expr is a new object belonging to the abstract object type
Iterable&lt;int,()&gt; that will iterate over a sequence of integers in increasing
order, where the sequence includes all integers n such that
</p>
<ul>
<li>the value of the first expression is less than or equal to n, and</li>
<li>n is
<ul>
<li>if the operator is <code>...</code>, less than or equal to the value of the
second expression</li>
<li>if the operator is <code>..&lt;</code>, less than the value of the second
expression</li>
</ul>
</li>
</ul>
<p>
It is a compile error if the static type of either expression is not a subtype
of int.
</p>
<p>
A range-expr is designed to be used in a foreach statement, but it can be used
elsewhere.
</p>
</section>
<section>
<h3 id="section_6.28">6.28 Numerical comparison expression</h3>

<pre class="grammar"><span class="ntdfn" id="numerical-comparison-expr">numerical-comparison-expr</span> :=
   <a href="#expression"><span class="ntref">expression</span></a> <code>&lt;</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>&gt;</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>&lt;=</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>&gt;=</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A numerical-comparison-expr compares two numbers.
</p>
<p>
The static type of both operands must be of the same basic type, which must be
int, float or decimal. The static type of the result is boolean.
</p>
<p>
Floating point comparisons follow IEEE, 754-2008, so
</p>
<ul>
<li>if either operand is NaN, the result is false</li>
<li>positive and negative zero compare equal</li>
</ul>
</section>
<section>
<h3 id="section_6.29">6.29 Type test expression</h3>

<pre class="grammar"><span class="ntdfn" id="is-expr">is-expr</span> :=
   <a href="#expression"><span class="ntref">expression</span></a> <code>is</code> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>
</pre>
<p>
An is-expr tests where a value belongs to a type.
</p>
<p>
An is-expr is evaluated by evaluating the expression yielding a result v. If v
belongs to the type denoted by type-descriptor, then the result of the is-expr
is true; otherwise the result of the is-expr is false.
</p>
</section>
<section>
<h3 id="section_6.30">6.30 Equality expression</h3>

<pre class="grammar"><span class="ntdfn" id="equality-expr">equality-expr</span> :=
   <a href="#expression"><span class="ntref">expression</span></a> <code>==</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>!=</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>===</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>!==</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
An equality-expr tests whether two values are equal. For all four operators, it
is a compile time error if the intersection of the static types of the operands
is empty.
</p>
<p>
The === operator tests for exact equality. The !== operator results in the
negation of the result of the === operator. Two values v<sub>1</sub> and
v<sub>2</sub> are exactly equal if they have the same basic type T and
</p>
<ul>
<li>T is simple type, and  v<sub>1</sub> and v<sub>2</sub> are identical values
within the possible of values allowed for T;</li>
<li>T is a sequence type, and the length of v<sub>1</sub> is the same as the length of v<sub>2</sub> and
<ul>
<li>the length is 1, and either
<ul>
<li>v<sub>1</sub> and v<sub>2</sub> both have storage identity and that storage
identity is the same, or</li>
<li>v<sub>1</sub> and v<sub>2</sub> both do not have storage identity and the
shape of v<sub>1</sub> is the same as the shape of v<sub>2</sub>
</li>
</ul>
</li>
<li>the length is not 1, and every constituent of v<sub>1</sub> is exactly equal
as the corresponding constituent of v<sub>2</sub>;</li>
</ul>
</li>
<li>T is a structural or behavioural type, and the storage identity of
v<sub>1</sub> is the same as the storage identity of v<sub>2</sub>.</li>
</ul>
<p>
The == operator tests for deep equality. The != operator results in the negation
of the result of the == operator. For both == and !=, both operands must have a
static type that is a subtype of anydata. Two values v1, v2 are deeply equal if
DeepEquals(v1, v2) is true.
</p>
<p>
Note that === and == are the same for simple values except for floating point types.
</p>
<p>
For the float type, the operators differ as regards floating point zero: ==
treats positive and negative zero from the same basic type as equal whereas ===
treats them as unequal. Both == and === treat two NaN values from the same basic
type as equal. This means that neither of these operators correspond to
operations defined by IEEE 754-2008, because they do not treat NaN in the
special way defined for those operations.
</p>
<p>
For the decimal type, the operators differ in whether they consider the
precision of the value. For example, <code>1.0 == 1.00</code> is true but
<code>1.0 === 1.00</code> is false.
</p>

</section>
<section>
<h3 id="section_6.31">6.31 Binary bitwise expression</h3>

<pre class="grammar"><span class="ntdfn" id="binary-bitwise-expr">binary-bitwise-expr</span> :=
   <a href="#bitwise-and-expr"><span class="ntref">bitwise-and-expr</span></a>
   | <a href="#bitwise-xor-expr"><span class="ntref">bitwise-xor-expr</span></a>
   | <a href="#bitwise-or-expr"><span class="ntref">bitwise-or-expr</span></a>
<span class="ntdfn" id="bitwise-and-expr">bitwise-and-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>&amp;</code> <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="bitwise-xor-expr">bitwise-xor-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>^</code> <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="bitwise-or-expr">bitwise-or-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>|</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A binary-bitwise-expr does a bitwise AND, XOR, or OR operation on its operands.
</p>
<p>
The static type of both operands must be a subtype of int. The static type of
the result is as follows:
</p>
<ul>
<li>for AND, if the type of either operand is a subtype of
<code>int:Unsigned<var>K</var></code> when <code><var>K</var></code> is 8, 16 or
32, then the static type of the result is <code>int:Unsigned<var>N</var></code>
where <code><var>N</var></code> is the smallest such <code><var>K</var></code>;
otherwise, the static type of the result is <code>int</code>;</li>
<li>for XOR or OR, if the type of both operands is a
subtype of <code>int:Unsigned<var>K</var></code> when <code><var>K</var></code>
is 8, 16 or 32, then the static type of the result is
<code>int:Unsigned<var>N</var></code> where <code><var>N</var></code> is the
smallest such <code><var>K</var></code>; otherwise, the static type of the result
is <code>int</code>.</li>
</ul>
</section>

<section>
<h3 id="section_6.32">6.32 Logical expression</h3>

<pre class="grammar"><span class="ntdfn" id="logical-expr">logical-expr</span> := <a href="#logical-and-expr"><span class="ntref">logical-and-expr</span></a> | <a href="#logical-or-expr"><span class="ntref">logical-or-expr</span></a>
<span class="ntdfn" id="logical-and-expr">logical-and-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>&amp;&amp;</code> <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="logical-or-expr">logical-or-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>||</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>

<p>
The static type of each expression in a logical-expr must be a subtype of
boolean.
</p>
<p>
A logical-and-expr is evaluated as follows:
</p>
<ol>
<li>the left-hand expression is evaluated, resulting in a value <var>x</var>;</li>
<li>if <var>x</var> is <code>false</code>, then the result of the
logical-and-expr is <var>x</var>, and the right-hand expression is not
evaluated;</li>
<li>otherwise, the result of the logical-and-expr is the result of evaluating
the right-hand expression.</li>
</ol>
<p>
A logical-or-expr is evaluated as follows:
</p>
<ol>
<li>the left-hand expression is evaluated, resulting in a value <var>x</var>;</li>
<li>if <var>x</var> is <code>true</code>, then the result of the
logical-or-expr is <var>x</var>, and the right-hand expression is not
evaluated;</li>
<li>otherwise, the result of the logical-or-expr is the result of evaluating
the right-hand expression.</li>
</ol>
</section>

<section>
<h3 id="section_6.33">6.33 Conditional expression</h3>

<pre class="grammar"><span class="ntdfn" id="conditional-expr">conditional-expr</span> :=
   <a href="#expression"><span class="ntref">expression</span></a> <code>?</code> <a href="#expression"><span class="ntref">expression</span></a> <code>:</code> <a href="#expression"><span class="ntref">expression</span></a>
   | <a href="#expression"><span class="ntref">expression</span></a> <code>?:</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
L <code>?:</code> R is evaluated as follows:
</p>
<ol>
<li>Evaluate L to get a value x</li>
<li>If x is not nil, then return x.</li>
<li>Otherwise, return the result of evaluating R.</li>
</ol>
</section>
<section>
<h3 id="section_6.34">6.34 Checking expression</h3>

<pre class="grammar"><span class="ntdfn" id="checking-expr">checking-expr</span> := <a href="#checking-keyword"><span class="ntref">checking-keyword</span></a> <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="checking-keyword">checking-keyword</span> := <code>check</code> | <code>checkpanic</code>
</pre>
<p>
Evaluates expression resulting in value v. If v has basic type error, then
</p>
<ul>
<li>if the checking-keyword is <code>check</code>, then the check-expression
completes abruptly with a check-fail with associated value v;</li>
<li>if the checking-keyword is <code>checkpanic</code>, then the check-expression
completes abruptly with a panic with associated value v.</li>
</ul>
<p>
If the static type of expression e is T|E, where E is a subtype of error, then
the static type of check e is T.
</p>
</section>
<section>
<h3 id="section_6.35">6.35 Trap expression</h3>
<p>
The trap expression stops a panic and gives access to the error value associated
with the panic.
</p>
<pre class="grammar"><span class="ntdfn" id="trap-expr">trap-expr</span> := <code>trap</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>  
<p>
Semantics are:
</p>
<ul>
<li>Evaluate <code>expression</code> resulting in value v
<ul>
<li>If evaluation completes abruptly with panic with associated value e, then
result of trap-exp is e</li>
<li>Otherwise result of trap-expr is v</li>
</ul>
</li>
<li>If type of <code>expr</code> is T, then type of <code>trap expr</code> is
T|error.</li>
</ul>
</section>

<section>
<h3 id="section_6.36">6.36 Query expression</h3>
<p>
A query expression provides a language-integrated query feature using SQL-like
syntax. In this version of Ballerina, the functionality is similar to a list
comprehensions; future versions will provided richer functionality.
</p>

<pre class="grammar"><span class="ntdfn" id="query-expr">query-expr</span> := [<a href="#query-construct-type"><span class="ntref">query-construct-type</span></a>] <a href="#query-pipeline"><span class="ntref">query-pipeline</span></a> <a href="#select-clause"><span class="ntref">select-clause</span></a>
<span class="ntdfn" id="query-construct-type">query-construct-type</span> :=
  <code>table</code> <a href="#key-specifier"><span class="ntref">key-specifier</span></a>
  | <code>stream</code>
<span class="ntdfn" id="query-pipeline">query-pipeline</span> := <a href="#from-clause"><span class="ntref">from-clause</span></a> <a href="#intermediate-clause"><span class="ntref">intermediate-clause</span></a>*
<span class="ntdfn" id="intermediate-clause">intermediate-clause</span> :=
   <a href="#from-clause"><span class="ntref">from-clause</span></a>
   | <a href="#where-clause"><span class="ntref">where-clause</span></a>
   | <a href="#let-clause"><span class="ntref">let-clause</span></a>
</pre>
<p>
A query expression consists of a sequence of clauses. The semantics of clauses
is specified in terms of transforming a sequence of frames, where a frame is a
binding of variables to values. The input to each clause is a sequence of
frames. As each clause is executed, it iterates over its input frames and emits
output: the final clause, which is a <code>select</code> clause, emits output
<em>values</em>; the other clauses emit output <em>frames</em>. When a
query-expr is evaluated, its clauses are executed in a pipeline by making the
sequence of frames emitted by one clause be the input to the next clause. Each
clause in the pipeline is executed lazily, pulling input from its preceding
clause. The input to the first clause is a single empty frame.
</p>
<p>
The execution of a clause may complete early with an error value, in which case
this error value is the result of the query, except when constructing a stream.
Otherwise, the result of evaluating a query expression is a single value, which
is constructed from the sequence of values emitted by the last clause. The
result must be one of the following basic types:
</p>
<ul>
<li>list - the constructed list has a member for each emitted value; every
emitted value must beloing to type T, where T[] is the type of the constructed
value</li>
<li>table - the constructed table has a member for each emitted value; every
emitted value must belong to type T, where table&lt;T&gt; is the type of the
constructed value</li>
<li>string - the constructed string is the concatenation of the emitted values;
every emitted value must be of type string</li>
<li>xml - the constructed xml value is the concatenation of the emitted values;
every emitted value must be of type xml</li>
<li>stream - the stream generates the emitted values</li>
</ul>
<p>
A query-expr that constructs a stream must start with the <code>stream</code>
keyword and is evaluated differently from a query-expr that constructs a value
of other basic types. The clauses in the query-expr are executed lazily: clauses
in the query-expr becomes closures, which are called as a result of next
operations being performed on the stream. If a next operation causes the
execution of a clause that completes early with an error value, then the error
value is returned by the next operation; the evaluation of the query-expr will
already have resulted in a stream value. If the next operation results in the
evaluation of an expression within the query-expr completing abruptly with a
check-fail, the associated error value will be returned as the result of the
next operation. If the next operation results in the evaluation of an expression
within the query-expr completely abruptly with a panic, then the next operation
will complete abruptly with a panic.
</p>
<p>
If the query-expr starts with <code>table</code>, then the query-expr will
construct a table; the key-specifier specifies the key sequence of the
constructed table in the same way as with a table-constructor-expr. Otherwise,
the applicable contextually expected type determines which basic type is
constructed. If there is no contextually expected type, then it is determined
from the static type of the expression in the initial <code>from</code> clause;
it is a compile-time error if this static type is not a subtype of one of the
basic types that a query expression can construct.
</p>
<p>
When during the construction of a table, an emitted value is added as a new
member, it replaces any existing member with the same key value; when a new
member replaces an existing member, it will have the same position in the order
of members as the existing member.
</p>
<p>
Variables bound by the clauses of a query-pipeline are implicitly final, and
cannot be modified.
</p>

<section>
<h4 id="section_6.36.1">6.36.1 From clause</h4>
<pre class="grammar"><span class="ntdfn" id="from-clause">from-clause</span> := <code>from</code> <a href="#typed-binding-pattern"><span class="ntref">typed-binding-pattern</span></a> <code>in</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A <code>from</code> clause is executed as follows:
</p>
<ul>
<li>for each input frame <var>f</var>
<ul>
<li>evaluate the <code>in</code> expression with <var>f</var> in scope resulting
in an iterable value <var>c</var>;</li>
<li>create an Iterator object <var>i</var> from <var>c</var>
</li>
<li>do the following in a loop <var>L</var>
<ul>
<li>call <code><var>i</var>.next()</code> resulting in a value <var>r</var>;</li>
<li>if <var>r</var> is an error, then complete execution of the from-clause
early with error <var>r</var>;</li>
<li>if <var>r</var> is <code>()</code>, stop loop <var>L</var>;</li>
<li>let <var>v</var> be <code><var>r</var>.value</code>;</li>
<li>emit a frame consisting of <var>f</var> augmented with the variables
resulting from binding typed-binding-pattern to <var>v</var>.</li>
</ul>
</li>  
</ul>
</li>  
</ul>
</section>

<section>
<h4 id="section_6.36.2">6.36.2 Where clause</h4>
<pre class="grammar"><span class="ntdfn" id="where-clause">where-clause</span> := <code>where</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A <code>where</code> clause is executed as follows:
</p>
<ul>
<li>for each input frame <var>f</var> 
<ul>
<li>execute the <code>expression</code> with <var>f</var> in scope resulting in
value <var>b</var>;</li>
<li>if <var>b</var> is true, emit <var>f</var>.</li>
</ul>
</li> 
</ul>
</section>

<section>
<h4 id="section_6.36.3">6.36.3 Let clause</h4>
<pre class="grammar"><span class="ntdfn" id="let-clause">let-clause</span> := <code>let</code> <a href="#let-var-decl"><span class="ntref">let-var-decl</span></a> [<code>,</code> <a href="#let-var-decl"><span class="ntref">let-var-decl</span></a>]* 
</pre>
<p>
A <code>let</code> clause consisting of a single let-var-decl is executed as follows:
</p>
<ul>
<li>for each input frame <var>f</var> 
<ul>
<li>evaluate the expression with <var>f</var> in scope resulting in a value <var>v</var>;</li>
<li>emit a frame consisting of <var>f</var> augmented with the result of binding
type-binding-pattern to <var>v</var>.</li>
</ul>
</li> 
</ul>
<p>
A <code>let</code> clause with more than one <code>let-var-decl</code> is
transformed into multiple <code>let</code> clauses: <code>let x<sub>1</sub> =
E<sub>1</sub>, x<sub>2</sub> = E<sub>2</sub></code> is transformed into
<code>let x<sub>1</sub> = E<sub>1</sub> let x<sub>2</sub> =
E<sub>2</sub></code>.
</p>
</section>

<section>
<h4 id="section_6.36.4">6.36.4 Select clause</h4>
<pre class="grammar">
<span class="ntdfn" id="select-clause">select-clause</span> := <code>select</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A <code>select</code> clause is executed as follows:
</p>
<ul>
<li>for each input frame <var>f</var> 
<ul>
<li>evaluate the expression with <var>f</var> in scope resulting in value <var>v</var>
</li>
<li>emit <var>v</var>
</li> 
</ul>
</li> 
</ul>
</section>
</section>
<section>
<h3 id="section_6.37">6.37 XML navigation expression</h3>
<p>
XML navigation expressions allow for convenient navigation of XML element structure,
in a similar way to XPath.
</p>

<pre class="grammar"><span class="ntdfn" id="xml-navigate-expr">xml-navigate-expr</span> := <a href="#xml-filter-expr"><span class="ntref">xml-filter-expr</span></a> | <a href="#xml-step-expr"><span class="ntref">xml-step-expr</span></a>
</pre>
<section>
<h4 id="section_6.37.1">6.37.1 XML name pattern</h4>
<pre class="grammar"><span class="ntdfn" id="xml-name-pattern">xml-name-pattern</span> := <a href="#xml-atomic-name-pattern"><span class="ntref">xml-atomic-name-pattern</span></a> [<code>|</code> <a href="#xml-atomic-name-pattern"><span class="ntref">xml-atomic-name-pattern</span></a>]*

<span class="ntdfn" id="xml-atomic-name-pattern">xml-atomic-name-pattern</span> :=
  <code>*</code>
  | <a href="#identifier"><span class="ntref">identifier</span></a>
  | <a href="#xml-namespace-prefix"><span class="ntref">xml-namespace-prefix</span></a> <code>:</code> <a href="#identifier"><span class="ntref">identifier</span></a>
  | <a href="#xml-namespace-prefix"><span class="ntref">xml-namespace-prefix</span></a> <code>:</code> <code>*</code>
</pre>

<p>
An XML name pattern matches a string specifying the name of an XML element.
</p>
<p>
An xml-atomic-name-pattern that is <code>*</code> matches any name.
</p>
<p>
An xml-namespace-prefix in an xml-atomic-name-pattern must be declared by an
xmlns-decl. If there is an in-scope default namespace (declared by an
xmlns-decl), an xml-atomic-pattern that is just an identifier specifies a
name in that default namespace.
</p>
</section>
<section>
<h4 id="section_6.37.2">6.37.2 XML filter expression</h4>
<pre class="grammar"><span class="ntdfn" id="xml-filter-expr">xml-filter-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>.&lt;</code> <a href="#xml-name-pattern"><span class="ntref">xml-name-pattern</span></a> <code>&gt;</code>
</pre>
<p>
An xml-filter-expr selects constituents of a sequence that are elements with a
name matching a specified name pattern. The static type of the expression must
be a subtype of xml. The static type of the xml-filter-expr is
<code>xml&lt;xml:Element&gt;</code>.
</p>
</section>
<section>
<h4 id="section_6.37.3">6.37.3 XML step expression</h4>
<p>
An xml-step-expr provides access to the children or descendants of an element,
similar to a location path in XPath.
</p>
<pre class="grammar"><span class="ntdfn" id="xml-step-expr">xml-step-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <a href="#xml-step-start"><span class="ntref">xml-step-start</span></a> <a href="#xml-step-extend"><span class="ntref">xml-step-extend</span></a>*

<span class="ntdfn" id="xml-step-start">xml-step-start</span> :=
   <a href="#xml-all-children-step"><span class="ntref">xml-all-children-step</span></a>
   | <a href="#xml-element-children-step"><span class="ntref">xml-element-children-step</span></a>
   | <a href="#xml-element-descendants-step"><span class="ntref">xml-element-descendants-step</span></a>
<span class="ntdfn" id="xml-all-children-step">xml-all-children-step</span> := <code>/*</code>
<span class="ntdfn" id="xml-element-children-step">xml-element-children-step</span> := <code>/&lt;</code> <a href="#xml-name-pattern"><span class="ntref">xml-name-pattern</span></a> <code>&gt;</code>
<span class="ntdfn" id="xml-element-descendants-step">xml-element-descendants-step</span> := <code>/**/&lt;</code> <a href="#xml-name-pattern"><span class="ntref">xml-name-pattern</span></a> <code>&gt;</code>

<span class="ntdfn" id="xml-step-extend">xml-step-extend</span> :=
   <code>.&lt;</code> <a href="#xml-name-pattern"><span class="ntref">xml-name-pattern</span></a> <code>&gt;</code>
   | <code>[</code> <a href="#expression"><span class="ntref">expression</span></a> <code>]</code>
   | <code>.</code> <a href="#method-name"><span class="ntref">method-name</span></a> <code>(</code> <a href="#arg-list"><span class="ntref">arg-list</span></a> <code>)</code>
</pre>
<p>
The static type of the expression must be a subtype of xml.
</p>
<p>
An xml-step-expr that starts with an xml-all-children-step
</p>
<pre>
   <var>E</var> /* <var>X</var>
</pre>
<p>
is equivalent to
</p>
<pre>
   xml:map(xml:elements(<var>E</var>), v =&gt; xml:getChildren(v) <var>X</var>)
</pre>
<p>
where <code>v</code> is a variable name not used in <code><var>X</var></code>.
</p>
<p>
An xml-step-expr that starts with an xml-element-children-step
</p>
<pre>
   <var>E</var> /&lt; <var>NP</var> &gt; <var>X</var>
</pre>
<p>
is equivalent to
</p>
<pre>
   xml:map(xml:elements(<var>E</var>), v =&gt; xml:getChildren(v) .&lt;<var>NP</var>&gt; <var>X</var>)
</pre>
<p>
where <code>v</code> is a variable name not used in <code><var>X</var></code>.
</p>
<p>
An xml-step-expr that starts with an xml-element-descendants-step
</p>
<pre>
   <var>E</var> /**/&lt; <var>NP</var> &gt; <var>X</var>
</pre>
<p>
is equivalent to
</p>
<pre>
   xml:map(xml:elements(<var>E</var>), v =&gt; xml:getDescendants(v) .&lt;<var>NP</var>&gt; <var>X</var>)
</pre>
<p>
where <code>v</code> is a variable name not used in <code><var>X</var></code>.
</p>
</section>
</section>
</section>
<section>
<h2 id="actions_statements">7. Actions and statements</h2>
<section>
<h3 id="section_7.1">7.1 Actions</h3>

<pre class="grammar"><span class="ntdfn" id="action">action</span> :=
   <a href="#start-action"><span class="ntref">start-action</span></a>
   | <a href="#wait-action"><span class="ntref">wait-action</span></a>
   | <a href="#send-action"><span class="ntref">send-action</span></a>
   | <a href="#receive-action"><span class="ntref">receive-action</span></a> 
   | <a href="#flush-action"><span class="ntref">flush-action</span></a>
   | <a href="#remote-method-call-action"><span class="ntref">remote-method-call-action</span></a>
   | <a href="#query-action"><span class="ntref">query-action</span></a>
   | <a href="#type-cast-action"><span class="ntref">type-cast-action</span></a>
   | <a href="#checking-action"><span class="ntref">checking-action</span></a>
   | <a href="#trap-action"><span class="ntref">trap-action</span></a>
   | <code>(</code> <a href="#action"><span class="ntref">action</span></a> <code>)</code>
<span class="ntdfn" id="action-or-expr">action-or-expr</span> := <a href="#action"><span class="ntref">action</span></a> | <a href="#expression"><span class="ntref">expression</span></a>
<span class="ntdfn" id="type-cast-action">type-cast-action</span> := <code>&lt;</code> <a href="#type-cast-param"><span class="ntref">type-cast-param</span></a> <code>&gt;</code> <a href="#action"><span class="ntref">action</span></a>
<span class="ntdfn" id="checking-action">checking-action</span> := <a href="#checking-keyword"><span class="ntref">checking-keyword</span></a> <a href="#action"><span class="ntref">action</span></a>
<span class="ntdfn" id="trap-action">trap-action</span> := <code>trap</code> <a href="#action"><span class="ntref">action</span></a>
</pre>
<p>
Actions are an intermediate syntactic category between expressions and
statements. Actions are similar to expressions, in that they yield a value.
However, an action cannot be nested inside an expression; it can only occur as
part of a statement or nested inside other actions. This is because actions are
shown in the sequence diagram in the graphical syntax.
</p>
<p>
The syntax for actions is defined by the above grammar and precedence rules. The
precedence rules are that a remote-method-call-action has higher precedence than
a checking-action or a trap-action.
</p>
<p>
An action is evaluated in the same way as an expression. Static typing for
actions is the same as for expressions.
</p>
<p>
A <code>type-cast-action</code>, <code>checking-action</code> or
<code>trap-action</code> is evaluated in the same way as a
<code>type-cast-expr</code>, <code>checking-expr</code> or
<code>trap-expr</code> respectively.
</p>

</section>
<section>
<h3 id="section_7.2">7.2 Threads and strands</h3>

<p>
Ballerina's concurrency model supports both threads and coroutines. A Ballerina
program is executed on one or more threads. A thread may run on a separate core
simultaneously with other threads, or may be pre-emptively multitasked with
other threads onto a single core.
</p>
<p>
Each thread is divided into one or more <em>strands</em>. No two strands
belonging to the same thread can run simultaneously. Instead, all the strands
belonging to a particular thread are cooperatively multitasked. Strands within
the same thread thus behave as coroutines relative to each other. A strand
enables cooperative multitasking by <em>yielding</em>. When a strand yields,
the runtime scheduler may suspend execution of the strand, and switch its thread
to executing another strand. The following actions cause a strand to yield:
</p>
<ul>
<li>worker-receive-action</li>
<li>wait-action</li>
<li>flush-action</li>
<li>sync-send-action</li>
</ul>
<p>
In addition, any function with an external-function-body can potentially yield;
it should only do so if it performs a system call that would block. or calls a
Ballerina function that itself yields. Functions in the lang library do not
themselves yield, although if they call a function passed as an argument, that
function may result in yielding.
</p>
<p>
There are two language constructs whose execution causes the creation of new
strands: named-worker-decl and start-action. These constructs may use
annotations to indicate that the newly created strand should be in a separate
thread from the current strand. In the absence of such annotations, the new
strand must be part of the same thread as the current strand.
</p>

</section>
<section>
<h3 id="section_7.3">7.3 Function and worker execution</h3>

<pre class="grammar"><span class="ntdfn" id="block-function-body">block-function-body</span> :=
   <code>{</code> [<a href="#default-worker-init"><span class="ntref">default-worker-init</span></a> <a href="#named-worker-decl"><span class="ntref">named-worker-decl</span></a>+] <a href="#default-worker"><span class="ntref">default-worker</span></a> <code>}</code>
<span class="ntdfn" id="default-worker-init">default-worker-init</span> := <a href="#sequence-stmt"><span class="ntref">sequence-stmt</span></a>
<span class="ntdfn" id="default-worker">default-worker</span> := <a href="#sequence-stmt"><span class="ntref">sequence-stmt</span></a>
<span class="ntdfn" id="named-worker-decl">named-worker-decl</span> :=
   [<a href="#annots"><span class="ntref">annots</span></a>] <code>worker</code> <a href="#worker-name"><span class="ntref">worker-name</span></a> <a href="#return-type-descriptor"><span class="ntref">return-type-descriptor</span></a> <code>{</code> <a href="#sequence-stmt"><span class="ntref">sequence-stmt</span></a> <code>}</code>
<span class="ntdfn" id="worker-name">worker-name</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
</pre>
<p>
A worker represents a single strand of a function invocation. A statement
is always executed in the context of a current worker. A worker is in one of
three states: active, inactive or terminated. When a worker is in the
terminated state, it has a termination value. A worker terminates either
normally or abnormally. An abnormal termination results from a panic, and in
this case the termination value is always an error. If the termination value of
a normal termination is an error, then the worker is said to have terminated
with failure; otherwise the worker is said to have terminated with success. Note
that an error termination value resulting from a normal termination is
distinguished from an error termination value resulting from an abnormal
termination.
</p>
<p>
A function always has a single default worker, which is unnamed. The strand for the
default worker is the same as the strand of the worker on which function was called.
When a function is called, the current worker becomes inactive, and a default worker
for the called function is started. When the default worker terminates, the function
returns to its caller, and the caller's worker is reactivated. Thus only one worker
in each strand is active at any given time. If the default worker terminates
normally, then its termination value provides the return value of the function.
If the default worker terminates abnormally, then the evaluation of the function
call expression completes abruptly with a panic and the default worker's
termination value provides the associated value for the abrupt completion of the
function call. The function's return type is the same as the return type of the
function's default worker.
</p>
<p>
A function also has zero or more named workers. Each named worker runs on its
own new strand. The termination of a function is independent of the termination
of its named workers. The termination of a named worker does not automatically
result in the termination of its function. When a default worker terminates
causing the function to terminate, the function does not automatically wait for
the termination of its named workers.
</p>
<p>
A named worker has a return type. If the worker terminates normally, the
termination value will belong to the return type. If the return type of a worker
is not specified, it defaults to nil as for functions. A return-type-descriptor
in a named-worker-decl is an inferable context for a type descriptor, which
means that <code>*</code> can be used to infer parts of the type descriptor; in
particular, it is convenient to use <code>error&lt;*&gt;</code> to specify the
error type.
</p>
<p>
When a function has named workers, the default worker executes in three stages,
as follows:
</p>
<ol>
<li>The statements in default-worker-init are executed.</li>
<li>All the named workers are started. Each named worker executes its
sequence-stmt on its strand.</li>
<li>The statements in default-worker are executed. This happens without waiting
for the termination of the named workers started in stage 2.</li>
</ol>
<p>
Variables declared in default-worker-init are in scope within named workers,
whereas variables declared in default-worker are not.
</p>
<p>
The execution of a worker's sequence-stmt may result in the execution of a
statement that causes the worker to terminate. For example, a return statement
causes the worker to terminate. If this does not happen, then the worker
terminates as soon as it has finished executing its sequence-stmt. In this case,
the worker terminates normally, and the termination value is nil. In other
words, falling off the end of a worker is equivalent to <code>return;</code>,
which is in turn equivalent to <code>return ();</code>.
</p>
<p>
The parameters declared for a function are in scope in the block-function-body.
They are implicitly final: they can be read but not modified. They are in scope
for named workers as well as for the default worker.
</p>
<p>
The scope of a worker-name in a named-worker-decl that is part of a
block-function-body is the entire block-function-body with the exception of the
default-worker-init. When a worker-name is in scope, it can be used in a
variable-reference-expr. The result of evaluating such a variable reference is a
future value that refers to the value to be returned by that named worker. The
static type of the result is future&lt;T&gt;, where T is the return type of the
worker.
</p>
<p>
A strand can initiate a wait on another strand by using a wait-action with a
value of type future. Only one wait on a strand can succeed; this wait receives
the value returned by the strand. Any other waits on that strand fail. It is a
compile-time error if for any named worker it is possible for the name of that
worker to be evaluated as a variable-reference more than once for any execution
of that worker. This ensures that wait operations that use just a worker-name to
identify the strand to wait on cannot fail at runtime.
</p>
<p>
In the above, function includes method, and function call includes method call.
</p>
</section>
<section>
<h3 id="section_7.4">7.4 Statement execution</h3>

<pre class="grammar"><span class="ntdfn" id="statement">statement</span> := 
   <a href="#action-stmt"><span class="ntref">action-stmt</span></a>
   | <a href="#block-stmt"><span class="ntref">block-stmt</span></a>
   | <a href="#local-var-decl-stmt"><span class="ntref">local-var-decl-stmt</span></a>
   | <a href="#local-type-defn-stmt"><span class="ntref">local-type-defn-stmt</span></a>
   | <a href="#xmlns-decl-stmt"><span class="ntref">xmlns-decl-stmt</span></a>
   | <a href="#assignment-stmt"><span class="ntref">assignment-stmt</span></a>
   | <a href="#compound-assignment-stmt"><span class="ntref">compound-assignment-stmt</span></a>
   | <a href="#destructuring-assignment-stmt"><span class="ntref">destructuring-assignment-stmt</span></a>
   | <a href="#call-stmt"><span class="ntref">call-stmt</span></a>
   | <a href="#if-else-stmt"><span class="ntref">if-else-stmt</span></a>
   | <a href="#match-stmt"><span class="ntref">match-stmt</span></a>
   | <a href="#foreach-stmt"><span class="ntref">foreach-stmt</span></a>
   | <a href="#while-stmt"><span class="ntref">while-stmt</span></a>
   | <a href="#break-stmt"><span class="ntref">break-stmt</span></a>
   | <a href="#continue-stmt"><span class="ntref">continue-stmt</span></a>
   | <a href="#fork-stmt"><span class="ntref">fork-stmt</span></a>
   | <a href="#panic-stmt"><span class="ntref">panic-stmt</span></a>
   | <a href="#return-stmt"><span class="ntref">return-stmt</span></a>
   | <a href="#lock-stmt"><span class="ntref">lock-stmt</span></a>
</pre>
<p>
The execution of any statement may involve the evaluation of actions and
expressions, and the execution of substatements. The following sections
describes how each kind of statement is evaluated, assuming that the evaluation
of those expressions and actions completes normally, and assuming that the
execution of any substatements does not cause termination of the current worker.
 Except where explicitly stated to the contrary, statements handle abrupt
completion of the evaluation of expressions and actions as follows. If in the
course of executing a statement, the evaluation of some expression or action
completes abruptly with associated value e, then the current worker is
terminated with termination value e; if the abrupt termination is a check-fail,
then the termination is normal, otherwise the termination is abnormal. If the
execution of a substatement causes termination of the current worker, then the
execution of the statement terminates at that point.
</p>

<pre class="grammar"><span class="ntdfn" id="sequence-stmt">sequence-stmt</span> := <a href="#statement"><span class="ntref">statement</span></a>*
<span class="ntdfn" id="block-stmt">block-stmt</span> := <code>{</code> <a href="#sequence-stmt"><span class="ntref">sequence-stmt</span></a> <code>}</code>
</pre>
<p>
A <code>sequence-stmt</code> executes its statements sequentially. A
<code>block-stmt</code> is executed by executing its <code>sequence-stmt</code>.
</p>
</section>
<section>
<h3 id="section_7.5">7.5 Fork statement</h3>

<pre class="grammar"><span class="ntdfn" id="fork-stmt">fork-stmt</span> := <code>fork</code> <code>{</code> <a href="#named-worker-decl"><span class="ntref">named-worker-decl</span></a>+ <code>}</code>
</pre>
<p>
The fork statement starts one or more named workers, which run in parallel with
each other, each in its own new strand.
</p>
<p>
Variables and parameters in scope for the fork-stmt remain in scope within the
workers (similar to the situation with parameters and workers in a function
body).
</p>
<p>
The scope of the worker-name in a named-worker-decl that is part of a fork-stmt
consists of both other workers in the same fork-stmt and the block containing
the fork-stmt starting from the point immediately after the fork-stmt. Within
its scope, the worker-name can be used in a variable-reference-expr in the same
way as the worker-name of a named-worker-decl that is part of a
block-function-body.
</p>
</section>
<section>
<h3 id="section_7.6">7.6 Start action</h3>

<pre class="grammar"><span class="ntdfn" id="start-action">start-action</span> := [<a href="#annots"><span class="ntref">annots</span></a>] <code>start</code> (<a href="#function-call-expr"><span class="ntref">function-call-expr</span></a>|<a href="#method-call-expr"><span class="ntref">method-call-expr</span></a>|<a href="#remote-method-call-action"><span class="ntref">remote-method-call-action</span></a>)
</pre>

<p>
The keyword <code>start</code> causes the following function or method
invocation to be executed on a new strand. The arguments for the function or
method call are evaluation on the current strand. A start-action returns a value
of basic type future immediately. If the static type of the call expression or
action <code><var>C</var></code> is T, then the static type of <code>start
<var>C</var></code> is future&lt;T&gt;.
</p>

</section>
<section>
<h3 id="section_7.7">7.7 Wait action</h3>
<p>
A wait-action waits for one or more strands to terminate, and gives access to
their termination values.
</p>

<pre class="grammar"><span class="ntdfn" id="wait-action">wait-action</span> :=
   <a href="#single-wait-action"><span class="ntref">single-wait-action</span></a>
   | <a href="#multiple-wait-action"><span class="ntref">multiple-wait-action</span></a>
   | <a href="#alternate-wait-action"><span class="ntref">alternate-wait-action</span></a>

<span class="ntdfn" id="wait-future-expr">wait-future-expr</span> := <a href="#expression"><span class="ntref">expression</span></a> <em>but not</em> <a href="#mapping-constructor-expr"><span class="ntref">mapping-constructor-expr</span></a>
</pre>
<p>
A wait-future-expr is used by a wait-action to refer to the worker to be waited
for. Its static type must be future&lt;T&gt; for some T. As elsewhere, a
wait-future-expr can use an in-scope worker-name in a variable-reference-expr to
refer to named worker.
</p>
<p>
Evaluation of a wait-action performs a wait operation on the future value that
results from evaluating a wait-future-expr. This wait operation may complete
normally or abruptly. The wait operation initiates a wait for the strand that
the future refers to. If the wait fails, then the wait operation completes
normally and the result is an error. If the wait succeeds, and the strand
completed normally, then the wait operation completes normally, and the result
is the termination value of the strand. If the wait succeeds, but the strand
completed abnormally, then the wait operation completes abruptly with a panic
and the associated value is the termination value of the strand.
</p>
<p>
In addition to a static type, a wait-future-expr has a compile-time <em>eventual
type</em>. If a wait-future-expr is a variable-reference-expr referring to the
worker-name of a named worker with return type T, then the eventual type of the
wait-future-expr is T. Otherwise, the eventual of a wait-future-expr with static
type future&lt;T&gt; is T|error. The result of a wait operation that completes
normally will belong to the eventual type of the wait-future-expr, since the
compiler ensures that a wait for a wait-future-expr that is a variable reference
to a named worker cannot fail.
</p>
<p>
Note that it is only possible to wait for a named worker, which will start its
own strand. It is not possible to wait for a default worker, which runs on an
existing strand.
</p>
<p>
A mapping-constructor-expr is not recognized as a wait-future-expr (it would not
type-check in any case).
</p>
<section>
<h4 id="section_7.7.1">7.7.1 Single wait action</h4>

<pre class="grammar"><span class="ntdfn" id="single-wait-action">single-wait-action</span> := <code>wait</code> <a href="#wait-future-expr"><span class="ntref">wait-future-expr</span></a>
</pre>
<p>
A single-wait-action waits for a single future.
</p>
<p>
A single-wait-action is evaluated by first evaluating wait-future-expr resulting
in a value f of basic type future; the single-wait-action then performs a wait
operation on f.
</p>
<p>
The static type of the single-wait-action is the eventual type of the
wait-future-expr.
</p>
</section>
<section>
<h4 id="section_7.7.2">7.7.2 Multiple wait action</h4>

<pre class="grammar"><span class="ntdfn" id="multiple-wait-action">multiple-wait-action</span> := <code>wait</code> <code>{</code> <a href="#wait-field"><span class="ntref">wait-field</span></a> (<code>,</code> <a href="#wait-field"><span class="ntref">wait-field</span></a>)* <code>}</code>
<span class="ntdfn" id="wait-field">wait-field</span> :=
  <a href="#variable-name"><span class="ntref">variable-name</span></a>
  | <a href="#field-name"><span class="ntref">field-name</span></a> <code>:</code> <a href="#wait-future-expr"><span class="ntref">wait-future-expr</span></a>
</pre>
<p>
A multiple-wait-action waits for multiple futures, returning the result as a
record.
</p>
<p>
A wait-field that is a variable-name <code>v</code> is equivalent to a
wait-field <code>v: v</code>, where <code>v</code> must be the name of an
in-scope named worker.
</p>
<p>
A multiple-wait-action is evaluated by evaluating each wait-future-expr
resulting in a value of type future for each wait-field. The
multiple-wait-action then performs a wait operation on all of these futures. If
all the wait operations complete normally, then it constructs a record with a
field for each wait-field, whose name is the field-name and whose value is the
result of the wait operation. If any of the wait operations complete abruptly,
then the multiple-wait-action completes abruptly.
</p>
<p>
The static type of the multiple-wait-action is a record where the static type of
each field is the eventual type of the corresponding wait-future-expr.
</p>
</section>
<section>
<h4 id="section_7.7.3">7.7.3 Alternate wait action </h4>

<pre class="grammar"><span class="ntdfn" id="alternate-wait-action">alternate-wait-action</span> := <code>wait</code> <a href="#wait-future-expr"><span class="ntref">wait-future-expr</span></a> (<code>|</code> <a href="#wait-future-expr"><span class="ntref">wait-future-expr</span></a>)+
</pre>
<p>
An alternate-wait-action waits for one of multiple futures to terminate.
</p>
<p>
An alternate-wait-action is evaluated by first evaluating each wait-future-expr,
resulting in a set of future values. The alternate-wait-action then performs a
wait operation on all of these members of this set. As soon as one of the wait
operations completes normally with a non-error value v, the
alternate-wait-action completes normally with result v. If all of the wait
operations complete normally with an error, then it completes normally with
result e, where e is the result of the last wait operation to complete. If any
of the wait operations completely abruptly before the alternate-wait-action
completes, then the alternate-wait-action completes abruptly.
</p>
<p>
The static type of the alternate-wait-action is the union of the eventual type
of all of its wait-future-exprs.
</p>
</section>
</section>
<section>
<h3 id="section_7.8">7.8 Worker message passing</h3>
<p>
Messages can be sent between workers.
</p>
<p>
Sends and receives are matched up at compile-time. This allows the connection
between the send and the receive to be shown in the sequence diagram. It is also
guarantees that any sent message will be received, provided that neither the
sending nor the receiving worker terminate abnormally or with an error.
</p>
<p>
Messages can only be sent between workers that are peers of each other. The
default worker and the named workers in a function are peers of each other. The
workers created in a fork-stmt are also peers of each other. The workers created
in a fork-stmt are not peers of the default worker and named workers created by
a function.
</p>

<pre class="grammar"><span class="ntdfn" id="peer-worker">peer-worker</span> := <a href="#worker-name"><span class="ntref">worker-name</span></a> | <code>default</code>
</pre>
<p>
A worker-name refers to a worker named in a named-worker-decl, which must be in
scope; default refers to the default worker. The referenced worker must be a
peer worker.
</p>
<p>
Each worker maintains a separate logical queue for each peer worker to which it
sends messages; a sending worker sends a message by adding it to the queue; a
receiving worker receives a message by removing it from the sending worker's
queue for that worker; messages are removed in the order in which they were
added to the queue.
</p>
<section>
<h4 id="section_7.8.1">7.8.1 Send action</h4>

<pre class="grammar"><span class="ntdfn" id="send-action">send-action</span> := <a href="#sync-send-action"><span class="ntref">sync-send-action</span></a> | <a href="#async-send-action"><span class="ntref">async-send-action</span></a>
<span class="ntdfn" id="sync-send-action">sync-send-action</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>-&gt;&gt;</code> <a href="#peer-worker"><span class="ntref">peer-worker</span></a>
<span class="ntdfn" id="async-send-action">async-send-action</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>-&gt;</code> <a href="#peer-worker"><span class="ntref">peer-worker</span></a> <code>;</code>
</pre>
<p>
A send-action sends a message to the worker that is identified by peer-worker. A
send-action starts by evaluating the expression, resulting in a value
<code><var>v</var></code>; the Clone abstract operation to
<code><var>v</var></code> resulting in value <code><var>c</var></code>. This
value <code><var>c</var></code> is added to the message queue maintained by the
sending worker for messages to be sent to the sending worker;this queue
continues to exist even if the receiving worker has already terminated.
</p>
<p>
For each send-action S, the compiler determines a unique corresponding
receive-action R, such that a message sent by S will be received by R, unless
R's worker has terminated abnormally or with failure. It is a compile-time error
if this cannot be done. The compiler determines a <em>failure type</em> for the
corresponding receive-action. If the receive-action was not executed and its
worker terminated normally, then the termination value of the worker will belong
to the failure type. The failure type will be a (possibly empty) subtype of
error.
</p>
<p>
The difference between async-send-action and sync-send-action is in what happens
after the message is added to the queue. The evaluation of async-send-action
completes immediately after this, and the result is always <code>()</code>. A
subsequent flush action can be used to check whether the message was received.
With sync-send-action, evaluation waits until the receiving worker either
executes a receive action that receives the queued message or terminates. The
evaluation of sync-send-action completes as follows:
</p>
<ul>
<li>if the queued message was received, then normally with result nil;</li>
<li>otherwise
<ul>
<li>if the receiving worker terminated with failure, then normally with the
result being the the termination value of the receiving worker, which will be an
error;</li>
<li>if the receiving worker terminated abnormally, then abruptly with a panic,
with the associated value being the termination value of the receiving worker.</li>
</ul>
</li>
</ul>
<p>
The static type of the sync-send-action is F|() where F is the failure type of
the corresponding receive action. If F is empty, then this static type will be
equivalent to ().
</p>
<p>
The static type of the <code>expression</code> must be a subtype of
<code>anydata|readonly</code>. The contextually expected type used to interpret
<code>expression</code> is the contextually expected type from the corresponding
receive-action.
</p>
<p>
If the receive-action corresponding to an async-send-action has a non-empty
failure type, then it is a compile-time error unless it can be determined that a
sync-send-action or a flush-action will be executed before the sending worker
terminates with success.
</p>
<p>
If a worker W is about to terminate normally and there are messages still to be
sent in a queue (which must be the result of executing an async-send-action), then
the worker waits until the messages have been received or some receiving worker
terminates. If a receiving worker R terminates without the message being
received, R must have terminated abnormally, because the rule in the preceding
paragraph. In this case, W terminates abnormally and W will use R's termination
value as its termination value.
</p>
</section>
<section>
<h4 id="section_7.8.2">7.8.2 Receive action</h4>

<pre class="grammar"><span class="ntdfn" id="receive-action">receive-action</span> := <a href="#single-receive-action"><span class="ntref">single-receive-action</span></a> | <a href="#multiple-receive-action"><span class="ntref">multiple-receive-action</span></a>
</pre>
<section>
<h5 id="section_7.8.2.1">7.8.2.1 Single receive action</h5>

<pre class="grammar"><span class="ntdfn" id="single-receive-action">single-receive-action</span> := <code>&lt;-</code> <a href="#peer-worker"><span class="ntref">peer-worker</span></a>
</pre>
<p>
A single-receive-action receives a message from a single worker.
</p>
<p>
For each single-receive-action R receiving from worker W, the compiler
determines a <em>corresponding send set</em>. The corresponding send set S is a
set of send actions in W, such that
</p>
<ul>
<li>in any execution of W that terminates successfully, exactly one member of S
is executed and is executed once only</li>
<li>if R is evaluated, it will receive the single message sent by a member of S,
unless W has terminated abnormally or with failure.</li>
</ul>
<p>
The compiler terminates a failure type for the corresponding send set. If no
member of the corresponding send set was evaluated and the sending worker
terminated normally, then the termination value of the sending worker will
belong to the failure type. The failure type will be a (possibly empty) subtype
of error.
</p>
<p>
A single-receive-action is evaluated by waiting until there is a message
available in the queue or the sending worker terminates.  The evaluation of
single-receive-action completes as follows:
</p>
<ul>
<li>if a message becomes available in the queue, then the first available
message is removed and the evaluation completes normally with the result being
that message;</li>
<li>otherwise
<ul>
<li>if the sending worker terminated with failure, then normally with the result
being the the termination value of the sending worker, which will be an error;</li>
<li>if the sending worker terminated abnormally, then abruptly with a panic,
with the associated value being the termination value of the sending worker.</li>
</ul>
</li>
</ul>
<p>
The static type of the single-receive-action is T|F where T is the union of the
static type of the expressions in the corresponding send set and F is the
failure type of the corresponding send set.
</p>
</section>
<section>
<h5 id="section_7.8.2.2">7.8.2.2 Multiple receive action</h5>

<pre class="grammar"><span class="ntdfn" id="multiple-receive-action">multiple-receive-action</span> :=
   <code>&lt;-</code>  <code>{</code> <a href="#receive-field"><span class="ntref">receive-field</span></a> (<code>,</code> <a href="#receive-field"><span class="ntref">receive-field</span></a>)* <code>}</code>
<span class="ntdfn" id="receive-field">receive-field</span> :=
   <a href="#peer-worker"><span class="ntref">peer-worker</span></a>
   | <a href="#field-name"><span class="ntref">field-name</span></a> <code>:</code> <a href="#peer-worker"><span class="ntref">peer-worker</span></a>
</pre>
<p>
A multiple-receive-action receives a message from multiple workers.
</p>
<p>
A peer-worker can occur at most once in a multiple-receive-action.
</p>
<p>
A receive-field consisting of a peer-worker <code>W</code> is equivalent to a
field <code>W:W</code>.
</p>
<p>
The compiler determines a corresponding send set for each receive field, in the
same way as for a single-receive-action. A multiple-receive-action is evaluated
by waiting until there is a message available in the queue for every
peer-worker.  If any of the peer workers W terminate before a message becomes
available, then the evaluation of the multiple-receive-action completes as
follows
</p>
<ul>
<li>if the sending worker terminated with failure, then normally with the result
being the the termination value of the sending worker, which will be an error;</li>
<li>if the sending worker terminated abnormally, then abruptly with a panic,
with the associated value being the termination value of the sending worker.</li>
</ul>
<p>
Otherwise, the result of the evaluation of multiple-receive-action completes by
removing the first message from each queue and constructing a record with one
field for each receive-field, where the value of the record is the message
received.
</p>
<p>
The contextually expected typed for the multiple-receive-action determines a
contextually expected type for each receive-field, in the same way as for a
mapping constructor. The contextually expected type for each receive-field
provides the contextually expected type for the expression in each member of the
corresponding send set.
</p>
<p>
The static type of multiple-receive-action is R|F where
</p>
<ul>
<li>R is a record type, where R is determined in the same way as for a mapping
constructor, where the static type of each field comes from the union of the
static types of the expressions in each member of the corresponding send set and
the contextually expected type is the contextually expected type of the
multiple-receive-action</li>
<li>F is the union of the failure types for the corresponding send set for each
receive-field</li>
</ul>
</section>
</section>
<section>
<h4 id="section_7.8.3">7.8.3 Flush action</h4>

<pre class="grammar"><span class="ntdfn" id="flush-action">flush-action</span> := <code>flush</code> [<a href="#peer-worker"><span class="ntref">peer-worker</span></a>]
</pre>
<p>
If peer-worker is specified, then flush waits until the queue of messages to be
received by peer-worker is empty or until the peer-worker terminates.
</p>
<p>
Send-receive correspondence for async-send-action implies that the queue will
eventually become empty, unless the peer-worker terminates abnormally or with
failure. The evaluation of flush-action completes as follows:
</p>
<ul>
<li>if the queue of messages is empty, then normally with result nil;</li>
<li>otherwise
<ul>
<li>if the peer-worker terminated with failure, then normally with the result
being the the termination value of the peer-worker, which will be an error;</li>
<li>if the peer-worker terminated abnormally, then abruptly with a panic, with
the associated value being the termination value of the peer-worker.</li>
</ul>
</li>
</ul>
<p>
If the flush-action has a preceding async-send-action without any intervening
sync-send-action or other flush-action, then the static type of the flush-action
is F|(), where F is the failure type of the receive-action corresponding to that
async-send-action. Otherwise, the static type of the flush-action is nil.
</p>
<p>
If peer-worker is omitted, then the flush-action flushes the queues to all other
workers. In this case, the static type will be the union of the static type of
flush on each worker separately.
</p>
</section>
<section>
<h4 id="section_7.8.4">7.8.4 Send-receive correspondence</h4>
<p>
This section provides further details about how compile-time correspondence is
established between sends and receive. This is based on the concept of the index
of a message in its queue: a message has index n in its queue if it is the nth
message added to the queue during the current execution of the worker.
</p>
<ul>
<li>A send action/statement has index i in its queue if the message that it adds
to the queue is always the i-th message added to the queue during the execution
of its worker. It is a compile time error if a send statement or action does not
have an index in its queue.</li>
<li>A receive action has index i in a queue if any message that it removes from
the queue is always the i-th message removed from the queue during the execution
of its worker. It is a compile time error if a receive action does not have an
index in each of its queues.</li>
<li>A send action/statement and a receive action correspond if they have the
same index in a queue.</li>
<li>It is a compile time error if two or more receive actions have the same
index in a queue.</li>
<li>A send action/statement is in the same send set as another send
action/statement if they have the same index in a queue. It is allowed for a
send set to have more than one member.</li>
<li>The maximum index that a receive action has in a queue must be the same as
the maximum index that a send action or statement has in that queue.</li>
<li>It is a compile time error if it is possible for a worker to terminate with
success before it has executed all its receive actions.</li>
<li>It is a compile time error if it is possible for a worker to terminate with
success before it has executed one member from every send set.</li>
</ul>
</section>
</section>

<section>
<h3 id="section_7.9">7.9 Remote interaction</h3>

<p>
A client object is a stub that allows a worker to send network messages to a
remote process according to some protocol. A local variable declared with client
object type will be depicted as a lifeline in the function's sequence diagram.
The remote methods of the client object correspond to distinct network messages
defined by the protocol for the role played by the client object. The return
value of a remote method represents the protocol's response. A
remote-method-call-action is depicted as a horizontal arrow from the worker
lifeline to the client object lifeline.
</p>

<pre class="grammar"><span class="ntdfn" id="remote-method-call-action">remote-method-call-action</span> := <a href="#expression"><span class="ntref">expression</span></a> <code>-&gt;</code> <a href="#method-name"><span class="ntref">method-name</span></a> <code>(</code> <a href="#arg-list"><span class="ntref">arg-list</span></a> <code>)</code>
</pre>
<p>
Calls a remote method. This works the same as a method call expression, except
that it is used only for a method with the <code>remote</code> modifier.
</p>

</section>

<section>
<h3 id="section_7.10">7.10 Query action</h3>
<pre class="grammar"><span class="ntdfn" id="query-action">query-action</span> := <a href="#query-pipeline"><span class="ntref">query-pipeline</span></a> <a href="#do-clause"><span class="ntref">do-clause</span></a>
<span class="ntdfn" id="do-clause">do-clause</span> := <code>do</code> <a href="#block-stmt"><span class="ntref">block-stmt</span></a>
</pre>
<p>
The clauses in the query-pipeline of query-action are executed in the same way
as the clauses in the query-pipeline of a query-expr.
</p>
<p>
The query-action is executed as follows. For each input frame <var>f</var>
emitted by the query-pipeline, execute the block-stmt with <var>f</var> in
scope. If a clause in the query-pipeline completes early with error
<var>e</var>, the result of the query-action is <var>e</var>. Otherwise, the
result of the query-action is nil.
</p>

</section>

<section>
<h3 id="section_7.11">7.11 Local variable declaration statements</h3>

<pre class="grammar"><span class="ntdfn" id="local-var-decl-stmt">local-var-decl-stmt</span> :=
   <a href="#local-init-var-decl-stmt"><span class="ntref">local-init-var-decl-stmt</span></a>
   | <a href="#local-no-init-var-decl-stmt"><span class="ntref">local-no-init-var-decl-stmt</span></a>
<span class="ntdfn" id="local-init-var-decl-stmt">local-init-var-decl-stmt</span> :=
   [<a href="#annots"><span class="ntref">annots</span></a>] [<code>final</code>] <a href="#typed-binding-pattern"><span class="ntref">typed-binding-pattern</span></a> <code>=</code> <a href="#action-or-expr"><span class="ntref">action-or-expr</span></a> <code>;</code>
</pre>
<p>
A <code>local-var-decl-stmt</code> is used to declare variables with a scope
that is local to the block in which they occur.
</p>
<p>
The scope of variables declared in a <code>local-var-decl-stmt</code> starts
immediately after the statement and continues to the end of the block statement
in which it occurs.
</p>
<p>
A local-init-var-decl-stmt is executed by evaluating the action-or-expr
resulting in a value, and then matching the typed-binding-pattern to the value,
causing assignments to the variables occurring in the typed-binding-pattern. The
typed-binding-pattern is used unconditionally, meaning that it is a compile
error if the static types do not guarantee the success of the match. If the
typed-binding-pattern uses <code>var</code>, then the type of the variable is
inferred from the static type of the action-or-expr; if the
local-init-var-decl-stmt includes final, the precise type is used, and otherwise
the broad type is used. If the typed-binding-pattern specifies a
type-descriptor, then that type-descriptor provides the contextually expected
type for action-or-expr.
</p>
<p>
If <code>final</code> is specified, then the variables declared must not be
assigned to outside the local-init-var-decl-stmt.
</p>

<pre class="grammar"><span class="ntdfn" id="local-no-init-var-decl-stmt">local-no-init-var-decl-stmt</span> :=
   [<a href="#annots"><span class="ntref">annots</span></a>] [<code>final</code>] <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <a href="#variable-name"><span class="ntref">variable-name</span></a> <code>;</code>
</pre>
<p>
A local variable declared <code>local-no-init-var-decl-stmt</code> must be
definitely assigned at each point that the variable is referenced. This means
that the compiler must be able to verify that the local variable will have been
assigned before that point. If <code>final</code> is specified, then the
variable must not be assigned more than once.
</p>
</section>
<section>
<h3 id="section_7.12">7.12 Implicit variable type narrowing</h3>
<p>
Usually the type of a reference to a variable is determined by the variable's
declaration, either explicitly specified by a type descriptor or inferred from
the static type of the initializer.
</p>
<p>
In addition, this section defines cases where a variable is used in certain
kinds of boolean expression in a conditional context, and it can be proved at
compile time that the value stored in local variable or parameter will, within a
particular region of code, always belong to a type that is narrower that the
static type of the variable. In these cases, references to the variable within
particular regions of code will have a static type that is narrower that the
variable type.
</p>
<p>
Given an expression E with static type boolean, and a variable x with static
type Tx, we define how to determine
</p>
<ul>
<li>a narrowed type for x implied by truth of E and</li>
<li>a narrowed type for x implied by falsity of E</li>
</ul>
<p>
based on the syntactic form of E as follows.
</p>
<ul>
<li>If E has the form x is T, then
<ul>
<li>the narrowed type for x implied by truth of E is the intersection of Tx and
T</li>
<li>the narrowed type for x implied by falsity of E is Tx with T removed</li>
</ul>
</li>
<li>If E has the form x == E1 or E1 == x where the static type of E1 is an
expression whose static type is a singleton simple type T1, then
<ul>
<li>the narrowed type for x implied by truth of E is the intersection of Tx and
T1</li>
<li>the narrowed type for x implied by falsity of E is Tx with T1 removed</li>
</ul>
</li>
<li>If E has the form x != E1 or E1 != x where the static type of E1 is an
expression whose static type is a singleton simple type T1, then
<ul>
<li>the narrowed type for x implied by truth of E is Tx with T1 removed</li>
<li>the narrowed type for x implied by falsity of E is the intersection of Tx
and T1</li>
</ul>
</li>
<li>If E has the form !E1, then
<ul>
<li>the narrowed type for x implied by truth of E is the narrowed type for x
implied by falsity of E1</li>
<li>the narrowed type for x implied by falsity of E is the narrowed type for x
implied by truth of E1</li>
</ul>
</li>
<li>If E has the form E1 &amp;&amp; E2
<ul>
<li>the narrowed type for x implied by truth of E is the intersection of T1 and
T2, where T1 is the narrowed type for x implied by the truth of T1 and T2 is the
narrowed type for x implied by the truth of T2</li>
<li>the narrowed type for x implied by falsity of E is T1|T2, where T1 is the
narrowed type for x implied by the falsity of E1, and T2 is the intersection of
T3 and T4, where T3 is the narrowed type for x implied by the truth of E1 and T4
is the narrowed type for x implied by the falsity of E2</li>
</ul>
</li>
<li>If E has the form E1 || E2, then
<ul>
<li> the narrowed type for x implied by truth of E is T1|T2, where T1 is the
narrowed type for x implied by the truth of E1, and T2 is the intersection of T3
and T4, where T3 is the narrowed type for x implied by the falsity of E1 and T4
is the narrowed type for x implied by the truth of E2</li>
<li>the narrowed type for x implied by falsity of E is the intersection of T1
and T2, where T1 is narrowed type for x implied by the falsity of E1 and T2 is
the narrowed type for x implied by the falsity of E2</li>
</ul>
</li>
<li>If E has any other form, then
<ul>
<li>the narrowed type for x implied by the truth of E is Tx</li>
<li>the narrowed type for x implied by the falsity of E is Tx</li>
</ul>
</li>
</ul>
<p>
Narrowed types apply to regions of code as follows:
</p>
<ul>
<li>in an expression E1 || E2, the narrowed types implied by the falsity of E1
apply within E2</li>
<li>in an expression E1 &amp;&amp; E2, the narrowed types implied by the truth of E1
apply within E2</li>
<li>in an expression E1 ? E2 : E3, the narrowed types implied by the truth of E1
apply within E2 and the narrowed types implied by the falsity of E1 apply within
E3</li>
<li>in a statement if E1 { B1 } else { B2 }, the narrowed types implied by the
truth of E1 apply within B1 and the narrowed types implied by the falsity of E1
apply within E2</li>
<li>in a match-clause P if E =&gt; { B }, the narrowed types implied by the truth
of E apply within B</li>
<li>the narrowed type for a variable x no longer applies as soon as there is a
possibility of x being assigned to</li>
</ul>
</section>
<section>
<h3 id="section_7.13">7.13 Local type definition statement</h3>

<pre class="grammar"><span class="ntdfn" id="local-type-defn-stmt">local-type-defn-stmt</span> :=
   [<a href="#annots"><span class="ntref">annots</span></a>] <code>type</code> <a href="#identifier"><span class="ntref">identifier</span></a> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>;</code>
</pre>
<p>
A local-type-defn-stmt binds the identifier to a type descriptor within the
scope of the current block. The type-descriptor is resolved when the statement
is executed.
</p>
</section>
<section>
<h3 id="XML_namespace_declaration_statement">7.14 XML namespace declaration statement</h3>

<pre class="grammar"><span class="ntdfn" id="xmlns-decl-stmt">xmlns-decl-stmt</span> := <a href="#xmlns-decl"><span class="ntref">xmlns-decl</span></a>
<span class="ntdfn" id="xmlns-decl">xmlns-decl</span> := <code>xmlns</code> <a href="#xml-namespace-uri"><span class="ntref">xml-namespace-uri</span></a> [ <code>as</code> <a href="#xml-namespace-prefix"><span class="ntref">xml-namespace-prefix</span></a> ] <code>;</code>
<span class="ntdfn" id="xml-namespace-uri">xml-namespace-uri</span> := <a href="#simple-const-expr"><span class="ntref">simple-const-expr</span></a>
<span class="ntdfn" id="xml-namespace-prefix">xml-namespace-prefix</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
</pre>
<p>
An <code>xmlns-decl</code> is used to declare a XML namespace. If there is
an <code>xml-namespace-prefix</code>, then the in-scope namespaces that are used
to perform namespace processing on an <code>xml-template-expr</code> will include a
binding of that prefix to the specified <code>xml-namespace-uri</code>;
otherwise the in-scope namespaces will include a default namespace with the
specified <code>xml-namespace-uri</code>.
</p>
<p>
An <code>xml-namespace-prefix</code> declared by an <code>xmlns-decl</code>
is in the same symbol space as a <code>module-prefix</code> declared by an
<code>import-decl</code>. This symbol space is distinct from a module's main
symbol space used by other declarations. An <code>xmlns-decl</code> in a
<code>xmlns-decl-stmt</code> declares the prefix within the scope of the current
block.
</p>
<p>
The prefix <code>xmlns</code> is predeclared as
<code>http://www.w3.org/2000/xmlns/</code> and cannot be redeclared.
</p>
<p>
The static type of the <code>simple-const-expr</code> must be a subtype of
string.
</p>
</section>
<section>
<h3 id="section_7.15">7.15 Assignment</h3>

<p>
There are three kinds of assignment statement:
</p>
<ul>
<li>an ordinary assignment statement, which is usually called simply an
assignment statement,</li>
<li>a compound assignment statement, and</li>
<li>a destructuring assignment statement.</li>
</ul>
<p>
The first two of these build on the concept of an <em>lvalue</em>, whereas the
last one builds on the concept of a binding pattern.
</p>

<section>
<h4 id="section_7.15.1">7.15.1 Lvalues</h4>

<p>
An lvalue is what the left hand side of an assignment evaluates to. An lvalue
refers to a storage location which is one of the following:
</p>
<ul>
<li>a variable;</li>
<li>a specific named field of an object;</li>
<li>the member of a structured value having a specific out-of-line key, which
will be either an integer or a string according as the structured value is a
list or a mapping.</li>
</ul>
<p>
Note that an lvalue cannot refer to a member of a table.
</p>

<p>
An lvalue that is both defined and initialized refers to a storage location that
holds a value:
</p>
<ul>
<li>an lvalue referring to a variable is always defined but may be
uninitialized;</li>
<li>an lvalue referring to a specific named field of an object is always defined
but may not be initialized until the <code>init</code> method returns</li>
<li>an lvalue referring to member of a structured value having a specific key is
undefined if the structured value does not have a member with that key; if such an
lvalue is defined, it is also initialized; note that an lvalue always refers to
a structured value that is already constructed.</li>
</ul>

<pre class="grammar"><span class="ntdfn" id="lvexpr">lvexpr</span> :=
   <a href="#variable-reference-lvexpr"><span class="ntref">variable-reference-lvexpr</span></a>
   | <a href="#field-access-lvexpr"><span class="ntref">field-access-lvexpr</span></a>
   | <a href="#member-access-lvexpr"><span class="ntref">member-access-lvexpr</span></a>
</pre>

<p>
The left hand side of an assignment is syntactically a restricted type of
expression, called an lvexpr. When the evaluation of an lvexpr completes
normally, its result is an lvalue. The evaluation of an lvexpr can also complete
abruptly, with a panic or check-fail, just as with the evaluation of an
expression.
</p>
<p>
The compiler determines a static type for each lvexpr just as it does for
expressions, but the meaning is slightly different. For an lvexpr L to have
static type T means that if the runtime evaluation of L completes normally
resulting in an lvalue x, then if x is defined and initialized, it refers to a
storage location that holds a value belonging to type T. In addition to a type,
the compiler determines for each lvexpr whether it is potentially undefined and
whether it is potentially uninitialized.
</p>
<p>
An lvalue supports three operations: store, read and filling-read.
</p>
<p>
The fundamental operation on an lvalue is to store a value in the storage
location it refers to. This operation does not required the lvalue to be defined
or initialized; a successful store operation on an undefined lvalue will result
in the addition of a member to the structured value; a store on an uninitialized lvalue
will initialize it. When an lvalue refers to a variable, it is possible to
determine at compile-time whether the store of a value is permissible based on
the declaration of the variable and the static type of the value to be stored.
However, when the lvalue refers to a member of a structured value, this is not in
general possible for three reasons.
</p>
<ol>
<li>The guarantee provided by an lvalue having a static type T is not that the
referenced storage location can hold every value that belongs to type T; rather
the guarantee is that every value that the referenced storage location can hold
belongs to type T. This is because structured types are covariant in their
member types. The values that the storage location can actually hold are
determined by the inherent type of the structured value.</li>
<li>The member may not be defined and the inherent type of the structured value may not
allow a member with that specific key. The permissible keys of a structured value can
be constrained by closed record types, fixed-length array types, and tuple types
(with any rest descriptor).</li>
<li>The structured value may be immutable. The static type of an lvalue referring to a
member of a structured value makes no guaranteees that the structured value is not immutable.</li>
</ol>
<p>
The first of these reasons also applies to lvalues that refer to fields of
objects. Accordingly, stores to lvalues other than lvalues that refer to
variables must be verified at runtime to ensure that they are not impermissible
for any of the above three reasons. An attempt to perform an impermissible store
results in a panic at runtime.
</p>
<p>
List values maintain the invariant that there is a unique integer n, the length
of the list, such that a member k of the list is defined if and only if k is a
non-negative integer less than n. When a store is performed on an lvalue
referring to a member k of a list value and the length of the list is n and k is
&gt; n, then each member with index i for each â¤ i &lt; k is filled in, by
using the FillMember abstract operation. The FillMember abstract operation may
fail; in particular it will fail if the list is a fixed-length array. If the
FillMember operation fails, then the attempt to store will panic.
</p>
<p>
An lvalue also allows a read operation, which is used by the compound assignment
statement. Unlike a store operation, a read operation cannot result in a runtime
panic. A read operation cannot be performed on an lvalue that is undefined or
uninitialized.
</p>
<p>
Finally, a lvalue supports a filling-read operation, which is used to support
chained assignment. A filling-read is performed only an lvalue with a static
type that is a structured type. It differs from a read operation only when it is
performed on a potentially undefined lvalue. If the lvalue is undefined at
runtime, then the filling-read will use the FillMember abstract operation on the
member that the lvalue refers to. If the FillMember operation fails, then the
filling-read panics. Unlike the read operation, the filling-read operation can
be performed on an undefined lvalue; it cannot, however, be performed on an
uninitialized lvalue.
</p>
<p>
The evaluation of an lvexpr is specified in terms of the evaluation of its
subexpressions, the evaluation of its sub-lvexprs, and store and
filling-read operations on lvalues. If any of these result in a panic, then
the evaluation of the lvexpr completes abruptly with a panic.
</p>

<pre class="grammar"><span class="ntdfn" id="variable-reference-lvexpr">variable-reference-lvexpr</span> := <a href="#variable-reference"><span class="ntref">variable-reference</span></a>
</pre>
<p>
The result of evaluating variable-reference-lvexpr is an lvalue referring to a
variable. Its static type is the declared or inferred type of the variable. The
lvexpr is potentially uninitialized if it is possible for execution to have
reached this point without initializing the referenced variable.
</p>

<pre class="grammar"><span class="ntdfn" id="field-access-lvexpr">field-access-lvexpr</span> := <a href="#lvexpr"><span class="ntref">lvexpr</span></a> <code>.</code> <a href="#field-name"><span class="ntref">field-name</span></a>
</pre>

<p>
The static type of lvexpr must be either a subtype of the mapping basic type
or a subtype of the object basic type.
</p>
<p>
In the case where the static type of lvexpr is a subtype of the object basic
type, the object type must have a field with the specified name, and the
resulting lvalue refers to that object field.
</p>
<p>
In the case where the static type of lvexpr is a subtype of the mapping basic
type, the semantics are as follows.
</p>
<ul>
<li>The following requirements apply at compile time: the type of lvexpr must
include mapping shapes that have the specified field-name; type descriptor for
lvexpr must include <code>field-name</code> as an individual-type-descriptor (if
lvexpr is a union, then this requirement applies to every member of the union);
lvexpr must not be potentially uninitialized, but may be potentially
undefined.</li>
<li>
It is evaluated as follows:
<ol>
<li>evaluate lvexpr to get lvalue <var>lv</var>;</li>
<li>perform a filling-read operation on <var>lv</var> to get mapping value
<var>m</var>;</li>
<li>the result is an lvalue referring to the member of <var>m</var> with the
specified field-name.</li>
</ol>
</li>
<li>The static type of the field-access-expr is the member type for the key type
K in T, where T is the static type of the lvexpr and K is the singleton string
type containing the field-name; the field-access-expr is potentially undefined
if K is an optional key type for T.</li>
</ul>

<pre class="grammar"><span class="ntdfn" id="member-access-lvexpr">member-access-lvexpr</span> := <a href="#lvexpr"><span class="ntref">lvexpr</span></a> <code>[</code> <a href="#expression"><span class="ntref">expression</span></a> <code>]</code>
</pre>
<p>
The static type of lvexpr must be either a subtype of the mapping basic type or
a subtype of the list basic type. In the former case, the contextually expected
type of expression must be string and it is an error if the static type of
expression is not string; in the latter case, the contextually expected type of
expression must be int and it is an error if the static type of expression is
not int.
</p>
<p>
It is evaluated as follows:
</p>
<ol>
<li>evaluate expression to get a string or int <var>k</var>;</li>
<li>evaluate lvexpr to get lvalue <var>lv</var>;</li>
<li>perform a filling-read operation on <var>lv</var> to get a list or mapping value
<var>v</var>;</li>
<li>the result is an lvalue referring to the member of <var>c</var> with key
<var>k</var>.</li>
</ol>
<p>
The static type of the member-access-expr is the member type for the key type K
in T, where T is the static type of the lvexpr and K is the static type type of
expression; the member-access-expr is potentially undefined if K is an optional
key type for T.
</p>

</section>
<section>
<h4 id="section_7.15.2">7.15.2 Assignment statement</h4>

<pre class="grammar"><span class="ntdfn" id="assignment-stmt">assignment-stmt</span> := <a href="#lvexpr"><span class="ntref">lvexpr</span></a> <code>=</code> <a href="#action-or-expr"><span class="ntref">action-or-expr</span></a> <code>;</code>
</pre>
<p>
The static type of action-or-expr must be a subtype of the static type of
lvexpr. The static type of lvexpr provides the contextually expected type for
action-or-expr. It is not an error for lvexpr to be potentially undefined or
potentially uninitialized.
</p>
<p>
It is executed at as follows:
</p>
<ol>
<li>execute action-or-expr to get a value <var>v</var>;</li>
<li>evaluate lvexpr to get an lvalue <var>lv</var>;</li>
<li>perform the store operation of <var>lv</var> with value <var>v</var>.</li>
</ol>

</section>
<section>
<h4 id="section_7.15.3">7.15.3 Compound assignment statement</h4>

<pre class="grammar"><span class="ntdfn" id="compound-assignment-stmt">compound-assignment-stmt</span> := <a href="#lvexpr"><span class="ntref">lvexpr</span></a> <a href="#CompoundAssignmentOperator"><span class="ntref">CompoundAssignmentOperator</span></a> <a href="#action-or-expr"><span class="ntref">action-or-expr</span></a> <code>;</code>
<span class="ntdfn" id="CompoundAssignmentOperator">CompoundAssignmentOperator</span> := <a href="#BinaryOperator"><span class="ntref">BinaryOperator</span></a> <code>=</code>
<span class="ntdfn" id="BinaryOperator">BinaryOperator</span> := <code>+</code> | <code>-</code> | <code>*</code> | <code>/</code> | <code>&amp;</code> | <code>|</code> | <code>^</code> | <code>&lt;&lt;</code> | <code>&gt;&gt;</code> | <code>&gt;&gt;&gt;</code>
</pre>
<p>
It is a compile error if lvexpr is potentially undefined unless the static type
of lvexpr is a subtype of the list basic type. It is a compile error if lvexpr
is potentially uninitialized.
</p>
<p>
Let T1 be the static type of lvexpr, and let T2 be the static type of
action-expr. Then let T3 be the static type of an expression E1 BinaryOp E2
where E1 has type T1 and E2 has type T2. It is a compile error if T3 is not a
subtype of T1.
</p>
<p>
It is executed as follows:
</p>
<ol>
<li>execute action-or-expr to get a value <var>v2</var>;</li>
<li>evaluate lvexpr to get an lvalue <var>lv</var>;</li>
<li>if <var>lv</var> is undefined, panic (<var>lv</var> must refer to an
undefined member of a list)</li>
<li>perform the read operation on <var>lv</var> to get a value
<var>v1</var>
</li>
<li>perform the operation specified by BinaryOperator on operands <var>v1</var>
and <var>v2</var>, resulting in a value <var>v3</var>
</li>
<li>perform the store operation on <var>lv</var> with value <var>v3</var>.</li>
</ol>

</section>
<section>
<h4 id="section_7.15.4">7.15.4 Destructuring assignment statement</h4>

<pre class="grammar"><span class="ntdfn" id="destructuring-assignment-stmt">destructuring-assignment-stmt</span> :=
   <a href="#binding-pattern-not-variable-reference"><span class="ntref">binding-pattern-not-variable-reference</span></a> <code>=</code> <a href="#action-or-expr"><span class="ntref">action-or-expr</span></a> <code>;</code>
<span class="ntdfn" id="binding-pattern-not-variable-reference">binding-pattern-not-variable-reference</span> :=
   <a href="#wildcard-binding-pattern"><span class="ntref">wildcard-binding-pattern</span></a>
   | <a href="#list-binding-pattern"><span class="ntref">list-binding-pattern</span></a>
   | <a href="#mapping-binding-pattern"><span class="ntref">mapping-binding-pattern</span></a>
   | <a href="#functional-binding-pattern"><span class="ntref">functional-binding-pattern</span></a>
</pre>
<p>
A destructuring assignment is executed by evaluating the action-or-expr
resulting in a value v, and then matching the binding pattern to v, causing
assignments to the variables occurring in the binding pattern.
</p>
<p>
The binding-pattern has a static type implied by the static type of the
variables occurring in it. The static type of action-or-expr must be a subtype
of this type.
</p>
</section>
</section>
<section>
<h3 id="section_7.16">7.16 Action statement</h3>

<pre class="grammar"><span class="ntdfn" id="action-stmt">action-stmt</span> := <a href="#action"><span class="ntref">action</span></a> <code>;</code>
</pre>
<p>
An action-stmt is a statement that is executed by evaluating an action and
discarding the resulting value, which must be nil. It is a compile-time error if
the static type of an action in an action-stmt is not nil.
</p>
</section>
<section>
<h3 id="section_7.17">7.17 Call statement</h3>

<pre class="grammar"><span class="ntdfn" id="call-stmt">call-stmt</span> := <a href="#call-expr"><span class="ntref">call-expr</span></a> <code>;</code>
<span class="ntdfn" id="call-expr">call-expr</span> :=
   <a href="#function-call-expr"><span class="ntref">function-call-expr</span></a>
   | <a href="#method-call-expr"><span class="ntref">method-call-expr</span></a>
   | <a href="#checking-keyword"><span class="ntref">checking-keyword</span></a> <a href="#call-expr"><span class="ntref">call-expr</span></a>
</pre>
<p>
A call-stmt is executed by evaluating call-expr as an expression and discarding
the resulting value, which must be nil. It is a compile-time error if the static
type of the call-expr in an call-stmt is not a subtype of nil. Note that
<code>never</code> is a subtype of nil.
</p>
</section>
<section>
<h3 id="section_7.18">7.18 Conditional statement</h3>

<pre class="grammar"><span class="ntdfn" id="if-else-stmt">if-else-stmt</span> :=
   <code>if</code> <a href="#expression"><span class="ntref">expression</span></a> <a href="#block-stmt"><span class="ntref">block-stmt</span></a> 
   [ <code>else</code> <code>if</code> <a href="#expression"><span class="ntref">expression</span></a> <a href="#block-stmt"><span class="ntref">block-stmt</span></a> ]* 
   [ <code>else</code> <a href="#block-stmt"><span class="ntref">block-stmt</span></a> ]
</pre>
<p>
The if-else statement is used for conditional execution.
</p>
<p>
The static type of the expression following <code>if</code> must be boolean.
When an expression is true then the corresponding block statement is executed
and the if statement completes. If no expression is true then, if the else block
is present, the corresponding block statement is executed.
</p>
</section>
<section>
<h3 id="section_7.19">7.19 Match statement</h3>

<pre class="grammar"><span class="ntdfn" id="match-stmt">match-stmt</span> := <code>match</code> <a href="#action-or-expr"><span class="ntref">action-or-expr</span></a> <code>{</code> <a href="#match-clause"><span class="ntref">match-clause</span></a>+ <code>}</code>
<span class="ntdfn" id="match-clause">match-clause</span> :=
  <a href="#match-pattern-list"><span class="ntref">match-pattern-list</span></a> [<a href="#match-guard"><span class="ntref">match-guard</span></a>] <code>=&gt;</code> <a href="#block-stmt"><span class="ntref">block-stmt</span></a>
<span class="ntdfn" id="match-guard">match-guard</span> := <code>if</code> <a href="#expression"><span class="ntref">expression</span></a>
</pre>
<p>
A match statement selects a block statement to execute based on which patterns a
value matches.
</p>
<p>
A match-stmt is executed as follows:
</p>
<ol>
<li>the expression is evaluated resulting in some value v;</li>
<li>for each match-clause in order:
<ol>
<li>a match of match-pattern against v is attempted</li>
<li>if the attempted match fails, the execution of the match-stmt continues to
the next match-clause</li>
<li>if the attempted match succeeds, then the variables in match-pattern are
created</li>
<li>if there is a match-guard, then the expression in match-guard is executed
resulting in a value b</li>
<li>if b is false, then the execution of the match-stmt continues to the next
match-clause</li>
<li>otherwise, the block-stmt in the match-clause is executed</li>
<li>execution of the match-stmt completes</li>
</ol>
</li>
</ol>
<p>
The scope of any variables created in a match-pattern-list of a match-clause is
both the match-guard, if any, and the block-stmt in that match-clause. The
static type of the expression in match-guard must be a subtype of boolean.
</p>

<pre class="grammar"><span class="ntdfn" id="match-pattern-list">match-pattern-list</span> := 
  <a href="#match-pattern"><span class="ntref">match-pattern</span></a> (<code>|</code> <a href="#match-pattern"><span class="ntref">match-pattern</span></a>)*
</pre>
<p>
A match-pattern-list can be matched against a value. An attempted match can
succeed or fail. A match-pattern-list is matched against a value by attempting
to match each match-pattern until a match succeeds.
</p>
<p>
All the match-patterns in a given match-pattern-list must bind the same set of
variables.
</p>

<pre class="grammar"><span class="ntdfn" id="match-pattern">match-pattern</span> :=
  <code>var</code> <a href="#binding-pattern"><span class="ntref">binding-pattern</span></a>
   | <a href="#wildcard-match-pattern"><span class="ntref">wildcard-match-pattern</span></a>
   | <a href="#const-pattern"><span class="ntref">const-pattern</span></a>
   | <a href="#list-match-pattern"><span class="ntref">list-match-pattern</span></a>
   | <a href="#mapping-match-pattern"><span class="ntref">mapping-match-pattern</span></a>
   | <a href="#functional-match-pattern"><span class="ntref">functional-match-pattern</span></a>
</pre>
<p>
A match-pattern combines the destructuring done by a binding-pattern with the
ability to match a constant value.
</p>
<p>
Note that an identifier can be interpreted in two different ways within a
match-pattern:
</p>
<ul>
<li>in the scope of a <code>var</code>, an identifier names a variable which is
to be bound to a part of the matched value when a pattern match succeeds;</li>
<li>outside the scope of a var, an identifier references a constant that a value
must match for the pattern match to succeed.</li>
</ul>
<p>
A match-pattern must be linear: a variable that is to be bound cannot occur more
than once in a match-pattern.
</p>

<pre class="grammar"><span class="ntdfn" id="const-pattern">const-pattern</span> := <a href="#simple-const-expr"><span class="ntref">simple-const-expr</span></a>
</pre>
<p>
A const-pattern denotes a single value. Matching a const-pattern denoting a
value p against a value v succeeds if DeepEquals(p,v) is true. The static type
of the simple-const-expr in a const-pattern must be a subtype of anydata.
Successfully matching a const-pattern does not cause any variables to be
created.
</p>
<p>
Matching a wildcard-match-pattern against a value succeeds if the value belongs to
type any, in other words if the basic type of the value is not error.
</p>

<pre class="grammar"><span class="ntdfn" id="wildcard-match-pattern">wildcard-match-pattern</span> := <code>_</code>
<span class="ntdfn" id="list-match-pattern">list-match-pattern</span> := <code>[</code> <a href="#list-member-match-patterns"><span class="ntref">list-member-match-patterns</span></a> <code>]</code>
<span class="ntdfn" id="list-member-match-patterns">list-member-match-patterns</span> :=
   <a href="#match-pattern"><span class="ntref">match-pattern</span></a> (<code>,</code> <a href="#match-pattern"><span class="ntref">match-pattern</span></a>)* [<code>,</code> <a href="#rest-match-pattern"><span class="ntref">rest-match-pattern</span></a>]
   | [ <a href="#rest-match-pattern"><span class="ntref">rest-match-pattern</span></a> ]
<span class="ntdfn" id="mapping-match-pattern">mapping-match-pattern</span> := <code>{</code> <a href="#field-match-patterns"><span class="ntref">field-match-patterns</span></a> <code>}</code>
<span class="ntdfn" id="field-match-patterns">field-match-patterns</span> :=
   <a href="#field-match-pattern"><span class="ntref">field-match-pattern</span></a> (<code>,</code> <a href="#field-match-pattern"><span class="ntref">field-match-pattern</span></a>)* [<code>,</code> <a href="#rest-match-pattern"><span class="ntref">rest-match-pattern</span></a>]
   | [ <a href="#rest-match-pattern"><span class="ntref">rest-match-pattern</span></a> ] 
<span class="ntdfn" id="field-match-pattern">field-match-pattern</span> := <a href="#field-name"><span class="ntref">field-name</span></a> <code>:</code> <a href="#match-pattern"><span class="ntref">match-pattern</span></a>
<span class="ntdfn" id="rest-match-pattern">rest-match-pattern</span> := <code>...</code> <code>var</code> <a href="#variable-name"><span class="ntref">variable-name</span></a>
<span class="ntdfn" id="functional-match-pattern">functional-match-pattern</span> := <a href="#functionally-constructible-type-reference"><span class="ntref">functionally-constructible-type-reference</span></a> <code>(</code> <a href="#arg-list-match-pattern"><span class="ntref">arg-list-match-pattern</span></a> <code>)</code>
<span class="ntdfn" id="arg-list-match-pattern">arg-list-match-pattern</span> :=
   <a href="#positional-arg-match-patterns"><span class="ntref">positional-arg-match-patterns</span></a> [<code>,</code> <a href="#other-arg-match-patterns"><span class="ntref">other-arg-match-patterns</span></a>]
   | <a href="#other-arg-match-patterns"><span class="ntref">other-arg-match-patterns</span></a>
<span class="ntdfn" id="positional-arg-match-patterns">positional-arg-match-patterns</span> := <a href="#positional-arg-match-pattern"><span class="ntref">positional-arg-match-pattern</span></a> (<code>,</code> <a href="#positional-arg-match-pattern"><span class="ntref">positional-arg-match-pattern</span></a>)*
<span class="ntdfn" id="positional-arg-match-pattern">positional-arg-match-pattern</span> := <a href="#match-pattern"><span class="ntref">match-pattern</span></a>
<span class="ntdfn" id="other-arg-match-patterns">other-arg-match-patterns</span> :=
   <a href="#named-arg-match-patterns"><span class="ntref">named-arg-match-patterns</span></a> [<code>,</code> <a href="#rest-match-pattern"><span class="ntref">rest-match-pattern</span></a>]
   | [<a href="#rest-match-pattern"><span class="ntref">rest-match-pattern</span></a>]
<span class="ntdfn" id="named-arg-match-patterns">named-arg-match-patterns</span> := <a href="#named-arg-match-pattern"><span class="ntref">named-arg-match-pattern</span></a> (<code>,</code> <a href="#named-arg-match-pattern"><span class="ntref">named-arg-match-pattern</span></a>)*
<span class="ntdfn" id="named-arg-match-pattern">named-arg-match-pattern</span> := <a href="#arg-name"><span class="ntref">arg-name</span></a> <code>=</code> <a href="#match-pattern"><span class="ntref">match-pattern</span></a>
</pre>

<p>
Matching a <code>mapping-match-pattern</code> against a mapping value succeeds
if and only every <code>field-match-pattern</code> matches against a field of
the value. The variable in the <code>rest-match-pattern</code>, if specified, is
bound to a new mapping that contains just the fields for which that did not
match a <code>field-match-pattern</code>.
</p>
<p>
For a match of a <code>functional-match-pattern</code> against a value to
succeed, the type referenced by the functionally-constructible-type-reference
must contain the shape of the value; because of the limited mutability of the
xml and error basic types, this requirement is equivalent to requiring that the
value belong to the referenced type.
</p>

</section>
<section>
<h3 id="section_7.20">7.20 Foreach statement</h3>

<pre class="grammar"><span class="ntdfn" id="foreach-stmt">foreach-stmt</span> :=
   <code>foreach</code> <a href="#typed-binding-pattern"><span class="ntref">typed-binding-pattern</span></a> <code>in</code> <a href="#action-or-expr"><span class="ntref">action-or-expr</span></a> <a href="#block-stmt"><span class="ntref">block-stmt</span></a>
</pre>
<p>
A foreach statement iterates over an iterable value, executing a block statement
once for each value in the iterable value's iteration sequence. The static type
of action-or-expr must be an iterable type with an iteration completion type of
nil.
</p>
<p>
The scope of any variables created in typed-binding-pattern is block-stmt. These
variables are implicitly final.
</p>
<p>
In more detail, a foreach statement executes as follows:
</p>
<ol>
<li>evaluate the action-or-expr resulting in a value c</li>
<li>create an iterator object i from c as follows
<ol>
<li>if c is a basic type that is iterable, then i is the result of calling
c.iterator()</li>
<li>if c is an object and c belongs to Iterable&lt;T,()&gt; for some T, then i is the
result of calling c.iterator()</li>
</ol>
</li>
<li>call i.next() resulting in a value n</li>
<li>if n is nil, then terminate execution of the foreach statement</li>
<li>match typed-binding-pattern to n.value causing assignments to any variables
that were created in typed-binding-pattern</li>
<li>execute block-stmt with the variable bindings from step 5 in scope; in the
course of so doing
<ol>
<li>the execution of a break-stmt terminates execution of the foreach statement</li>
<li>the execution of a continue-stmt causes execution to proceed immediately to
step 3</li>
</ol>
</li>
<li>go back to step 3</li>
</ol>
<p>
In step 2, the compiler will give an error if the static type of expression is
not suitable for 2a or 2b.
</p>
<p>
In step 5, the typed-binding-pattern is used unconditionally, and the compiler
will check that the static types guarantee that the match will succeed. If the
typed-binding-pattern uses var, then the type will be inferred from the type of
<code>action-or-expr</code>.
</p>
</section>
<section>
<h3 id="section_7.21">7.21 While statement</h3>

<pre class="grammar"><span class="ntdfn" id="while-stmt">while-stmt</span> := <code>while</code> <a href="#expression"><span class="ntref">expression</span></a> <a href="#block-stmt"><span class="ntref">block-stmt</span></a>
</pre>
<p>
A while statement repeatedly executes a block statement so long as a
boolean-valued expression evaluates to true.
</p>
<p>
In more detail, a while statement executes as follows:
</p>
<ol>
<li>evaluate expression;</li>
<li>if expression evaluates to false, terminate execution of the while
statement;</li>
<li>execute block-stmt; in the course of so doing
<ol>
<li>the execution of a break-stmt results in termination of execution of the
while statement</li>
<li>the execution of a continue-stmt causes execution to proceed immediately to
step 1</li>
</ol>
</li>
<li>go back to step 1.</li>
</ol>
<p>
The static type of <code>expression</code> must be a subtype of boolean.
</p>
</section>
<section>
<h3 id="section_7.22">7.22 Continue statement</h3>

<pre class="grammar"><span class="ntdfn" id="continue-stmt">continue-stmt</span> := <code>continue</code> <code>;</code>
</pre>
<p>
A continue statement is only allowed if it is lexically enclosed within a
while-stmt or a foreach-stmt. Executing a continue statement causes execution of
the nearest enclosing while-stmt or foreach-stmt to jump to the end of the
outermost block-stmt in the while-stmt or foreach-stmt.
</p>
</section>
<section>
<h3 id="section_7.23">7.23 Break statement</h3>

<pre class="grammar"><span class="ntdfn" id="break-stmt">break-stmt</span> := <code>break</code> <code>;</code>
</pre>
<p>
A break statement is only allowed if it is lexically enclosed within a
while-stmt or a foreach-stmt. Executing a break statement causes the nearest
enclosing while-stmt or foreach-stmt to terminate.
</p>
</section>
<section>
<h3 id="section_7.24">7.24 Panic statement</h3>

<pre class="grammar"><span class="ntdfn" id="panic-stmt">panic-stmt</span> := <code>panic</code> <a href="#expression"><span class="ntref">expression</span></a> <code>;</code>
</pre>
<p>
A panic statement terminates the current worker abnormally. The result of
evaluating <code>expression</code> provides the termination value of the worker.
</p>
<p>
The static type of <code>expression</code> must be a subtype of error.
</p>
</section>
<section>
<h3 id="section_7.25">7.25 Return statement</h3>

<pre class="grammar"><span class="ntdfn" id="return-stmt">return-stmt</span> := <code>return</code> [ <a href="#action-or-expr"><span class="ntref">action-or-expr</span></a> ] <code>;</code>
</pre>
<p>
A return statement terminates the current worker normally.The result of
evaluating the action-or-expr provides the termination value of the worker. If
action-or-expr is omitted, then the termination value is nil.
</p>
</section>

<section>
<h3 id="section_7.26">7.26 Lock statement</h3>
<pre class="grammar"><span class="ntdfn" id="lock-stmt">lock-stmt</span> := <code>lock</code> <a href="#block-stmt"><span class="ntref">block-stmt</span></a>
</pre>

<p>
A lock-stmt executing in the context of some strand must execute its block-stmt
in such a way that the effect on the state of the program is consistent with the
execution of the block-stmt not being interleaved with the execution of a
lock-stmt on any other strand.
</p>
<p>
A naive implementation can simply acquire a single, program-wide, recursive mutex
before executing a lock statement, and release the mutex after completing the
execution of the lock statement. A more sophisticated implementation can perform
compile-time analysis to infer a more fine-grained locking strategy that will
have the same effects as the naive implementation.
</p>
<p>
It is not allowed to start a new strand within a lock. More precisely, when a
strand has started but not yet completed the execution of a lock-stmt, the
execution of a named-worker-decl or a start-action on that strand will result in
a panic. It is a compile-time error for a named-worker-decl or start-action to
occur lexically within a lock-stmt. The compiler may also give a compile-time
error if a function definition contains a named-worker-decl or start-action, and
there is a function call lexically within the lock-stmt that might result
directly or indirectly in a call to that defined function.
</p>

</section>

</section>
<section>
<h2 id="module_level">8. Module-level declarations</h2>
<p>
Each source part in a Ballerina module must match the production
<code>module-part</code>.
</p>
<p>
The import declarations must come before other declarations; apart from this,
the order of the definitions and declarations at the top-level of a module is
not constrained.
</p>

<pre class="grammar"><span class="ntdfn" id="module-part">module-part</span> := <a href="#import-decl"><span class="ntref">import-decl</span></a>* <a href="#other-decl"><span class="ntref">other-decl</span></a>*
<span class="ntdfn" id="other-decl">other-decl</span> :=
   <a href="#listener-decl"><span class="ntref">listener-decl</span></a>
   | <a href="#service-decl"><span class="ntref">service-decl</span></a>
   | <a href="#function-defn"><span class="ntref">function-defn</span></a>
   | <a href="#module-type-defn"><span class="ntref">module-type-defn</span></a>
   | <a href="#module-var-decl"><span class="ntref">module-var-decl</span></a>
   | <a href="#module-const-decl"><span class="ntref">module-const-decl</span></a>
   | <a href="#module-enum-decl"><span class="ntref">module-enum-decl</span></a>
   | <a href="#module-xmlns-decl"><span class="ntref">module-xmlns-decl</span></a>
   | <a href="#annotation-decl"><span class="ntref">annotation-decl</span></a>
</pre>
<section>
<h3 id="section_8.1">8.1 Import declaration</h3>

<pre class="grammar"><span class="ntdfn" id="import-decl">import-decl</span> := 
   <code>import</code> [<a href="#org-name"><span class="ntref">org-name</span></a> <code>/</code>] <a href="#module-name"><span class="ntref">module-name</span></a> [<code>version</code> <a href="#sem-ver"><span class="ntref">sem-ver</span></a>] 
   [<code>as</code> <a href="#import-prefix"><span class="ntref">import-prefix</span></a>] <code>;</code>
<span class="ntdfn" id="import-prefix">import-prefix</span> := <a href="#module-prefix"><span class="ntref">module-prefix</span></a> | <code>_</code>
<span class="ntdfn" id="module-prefix">module-prefix</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
<span class="ntdfn" id="org-name">org-name</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
<span class="ntdfn" id="module-name">module-name</span> := <a href="#identifier"><span class="ntref">identifier</span></a> (<code>.</code> <a href="#identifier"><span class="ntref">identifier</span></a>)*
<span class="ntdfn" id="sem-ver">sem-ver</span> := <a href="#major-num"><span class="ntref">major-num</span></a> [<code>.</code> <a href="#minor-num"><span class="ntref">minor-num</span></a> [<code>.</code> <a href="#patch-num"><span class="ntref">patch-num</span></a>]]
<span class="ntdfn" id="major-num">major-num</span> := <a href="#DecimalNumber"><span class="ntref">DecimalNumber</span></a>
<span class="ntdfn" id="minor-num">minor-num</span> := <a href="#DecimalNumber"><span class="ntref">DecimalNumber</span></a>
<span class="ntdfn" id="patch-num">patch-num</span> := <a href="#DecimalNumber"><span class="ntref">DecimalNumber</span></a>

<span class="ntdfn" id="qualified-identifier">qualified-identifier</span> := <a href="#module-prefix"><span class="ntref">module-prefix</span></a> <code>:</code> <a href="#identifier"><span class="ntref">identifier</span></a>
</pre>
<p>
If org-name is omitted, it is defaulted from the organization of the importing
module.
</p>
<p>
A <code>module-prefix</code> is a name that is used locally within the source of
a module to refer to another module. A <code>module-prefix</code> in a
qualified-identifier must refer to a <code>module-prefix</code> specified in an
import-declaration in the same source part.
</p>
<p>
An import-prefix of <code>_</code> causes the module to be imported without
making its symbols available via a module-prefix. In this case, the effect of
importing the module will be just to cause the module to be included in the
program and initialized. It is an error for a source-part to import a module
using a module-prefix and then not to use that module-prefix.
</p>
<p>
A <code>module-prefix</code> declared by an <code>import-decl</code> is in the
same symbol space as a <code>xmlns-namespace-prefix</code> declared by an
<code>xmlns-decl</code>. This symbol space is distinct from a module's main
symbol space used by other declarations.
</p>
<p>
A module prefix of <code><var>t</var></code>, where <code><var>t</var></code> is
one of <code>error</code>, <code>object</code> or <code>xml</code>, is
predeclared as referring to the <code>lang.<var>t</var></code> lang library
module, but this can be overridden by an import-decl.
</p>
<p>
It is an error for a module to directly or indirectly import itself. In other
words, the directed graph of module imports must be acyclic.
</p>

</section>

<section>
<h3 id="section_8.2">8.2 Module and program execution</h3>
<p>
A Ballerina program consists of one or more modules; one of these modules is
distinguished as the <em>root</em> module. The source code for a module uses
import declarations to identify the modules on which it depends directly. At
compile-time, a root module is specified, and the modules comprising the program
are inferred to be those that the root module imports directly or indirectly.
The directed graph of module imports must be acyclic.
</p>
<p>
Program execution may terminate successfully or unsuccessfully. Unsuccessful
program termination returns an error value. Program execution consists of two
consecutive phases: an initialization phase and a listening phase.
</p>
<p>
Module initialization is performed by calling an initialization function, which
is synthesized by the compiler for each module. Module initialization can fail,
in which case the initialization function returns an error value. The
initialization phase of program execution consists of initializing each of the
program's modules. If the initialization of a module is unsuccessful, then
program execution immediately terminates unsuccessfully, returning the error
value returned by the initialization function.
</p>
<p>
The initialization of a program's modules is ordered so that a module will not
be initialized until all of the modules on which it depends have been
initialized. (Such an ordering will always be possible, since the graph of
module imports is required to be acyclic.) The order in which modules are
initialized follows the order in which modules are imported so far as is
consistent with the previous constraint.
</p>
<p>
A module's initialization function performs expression evaluation so as to
initialize the identifiers declared in the module's declarations; if evaluation
of an expression completes abruptly, then the module initialization function
immediately returns the error value associated with the abrupt completion. If a
module defines a function named <code>init</code>, then a module's
initialization function will end by calling this function; if it terminates
abruptly or returns an error, then the module's initialization function will
return an error value. Note that the <code>init</code> function of the root
module will be the last function called during a program's initialization phase.
</p>
<p>
This specification does not define any mechanism for processing the program
command-line arguments typically provided by an operating system. The Ballerina
standard library provides a function to retrieve these command-line arguments.
In addition, the Ballerina platform provides a convenient mechanism for
processing these arguments. This works by generating a new command-line
processing module from the specified root module. The <code>init</code>
function of the generated module retrieves the command-line arguments, parses
them, and calls a public function of the specified root module (typically the
<code>main</code> function). The parsing of the command-line arguments is
controlled by the declared parameter types, annotations and names of the public
functions. The generated module, which imports the specified root module,
becomes the new root module.
</p>
<p>
If the initialization phase of program execution completes successfully, then
execution proceeds to the listening phase, which is described in the next
section. The termination of the listening phase, which may be successful or
unsuccessful, terminates the program execution.
</p>
</section>

<section>
<h3 id="section_8.3">8.3 Listeners and services</h3>

<p>
Services have resource methods, which are the network entry points of a
Ballerina program. Listeners provide the interface between the network and
services. A listener object receives network messages from a remote process
according to some protocol and translates the received messages into calls on
the resource methods of service values that have been attached to the listener
object. It is up to the listener object to determine how this translation
happens; the type of the listener object thus constrains the type of a service
that can be attached to the listener. (This constraint is not yet enforced by
Ballerina's type system.)
</p>
<p>
The return type of a resource method represents whether the method successfully
handled the protocol message. The listener typically calls a resource method
with a client object as a parameter. The remote methods on the client object
correspond to the distinct network messages defined by the protocol as possible
responses to the message that the resource method is handling. A resource method
called by a listener as a result of a network message received from a remote
process can then use the client object to send a response message back to that
remote process.
</p>
<p>
The methods defined by the Listener abstract object type allow for the
management of the lifecycle of a listener object and its attached services. A
listener declaration registers a listener object with a module, so that it can
be managed by the module. The runtime state of each module includes a list of
listener objects that have been registered with the module. A listener object
that has been registered with a module is called a <em>module listener</em>
</p>
<p>
If at the start of the listening phase of program execution there are no module
listeners, then the listening phase immediately terminates successfully.
Otherwise, the <code>__start</code> method of each module listener is called; if
any of these calls returns an error value, then the listening phase terminates
unsuccessfully with this error value as its return value.
</p>
<p>
The listening phase of program execution continues until either the program
explicitly exits, by calling a standard library function, or the user explicitly
requests the termination of the program using an implementation-dependent
operating system facility (such as a signal on a POSIX system). In the latter
case, the <code>__gracefulStop</code> or <code>__immediateStop</code> method of
each registered listener will be called before termination.
</p>

<section>
<h4 id="section_8.3.1">8.3.1 Listener declaration</h4>

<pre class="grammar"><span class="ntdfn" id="listener-decl">listener-decl</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   [<code>public</code>] <code>listener</code> [<a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>] <a href="#variable-name"><span class="ntref">variable-name</span></a> <code>=</code> <a href="#expression"><span class="ntref">expression</span></a> <code>;</code>
</pre>
<p>
A <code>listener-decl</code> declares a module listener. A module listener
declares a variable in a similar way to a final variable declaration, but the
type of the variable is always a subtype of the Listener abstract object type,
and it has the additional semantic of registering the variable's value with the
module as a listener. As with a variable declared in a final variable
declaration, the variable can be referenced by a variable-reference, but cannot
be assigned to. A module may have multiple multiple listeners.
</p>
<p>
If the type-descriptor is present it specifies the static type of the variable;
if it is not present, the the static type is the static type of
<code>expression</code>. In both cases, the static type is constrained to be a
subtype of the Listener abstract object type.
</p>
<p>
When a listener-decl is initialized as part of module initialization, its
expression is evaluated. If expression evaluation completes abruptly, then
module initialization fails. Otherwise the variable is initialized with the
result of the evaluation.
</p>

</section>

<section>
<h4 id="section_8.3.2">8.3.2 Service declaration</h4>

<pre class="grammar"><span class="ntdfn" id="service-decl">service-decl</span> :=
  <a href="#metadata"><span class="ntref">metadata</span></a>
  <code>service</code> [<a href="#variable-name"><span class="ntref">variable-name</span></a>] <code>on</code> <a href="#expression-list"><span class="ntref">expression-list</span></a> <a href="#service-body-block"><span class="ntref">service-body-block</span></a>
<span class="ntdfn" id="expression-list">expression-list</span> := <a href="#expression"><span class="ntref">expression</span></a> (<code>,</code> <a href="#expression"><span class="ntref">expression</span></a>)*
</pre>
<p>
A <code>service-decl</code> creates a service and attaches it to one or more
listeners. If a variable-name is specified, it also declares a variable; as with
a variable declared in a final variable declaration, the variable can be
referenced by a variable-reference, but cannot be assigned to.
</p>
<p>
The service-body-block has the same semantics as in a service-constructor-expr.
The static type of each expression in the expression list must be a subtype of
the union of error with the Listener abstract object type. If an implementation
is using annotations to provide more precise typing of services, then any
annotations on the service type that is the first parameter of the
<code>__attach</code> method in the object type of each expression in expression
list will constrain the type of the service value constructed by the
service-body-block.
</p>
<p>
A service-decl is initialized as part of module initialization as follows. The
service-body-block is evaluated as in a service-constructor resulting in a
service value <code><var>s</var></code>. If variable-name is specified, then the
variable is initialized to <code><var>s</var></code>. Then for each expression
in expression-list:
</p>
<ol>
<li>the expression is evaluated resulting in a value which is either an error or
an object <code><var>obj</var></code> that is a subtype of Listener;</li>
<li>if it is an error, module initialization fails;</li>
<li>otherwise, <code><var>obj</var></code> is registered as a module listener
(registering the same object multiple times is the same as registering it
once);</li>
<li>
<code><var>s</var></code> is then attached to <code><var>obj</var></code>
using <code><var>obj</var></code>'s <code>__attach</code> method;</li>
<li>if the call to <code>__attach</code> fails, then module initialization
fails.</li>
</ol>
</section>
</section>

<section>
<h3 id="section_8.4">8.4 Function definition</h3>

<pre class="grammar"><span class="ntdfn" id="function-defn">function-defn</span> := 
   <a href="#metadata"><span class="ntref">metadata</span></a>
   [<code>public</code>]
   <code>function</code> <a href="#identifier"><span class="ntref">identifier</span></a> <a href="#function-signature"><span class="ntref">function-signature</span></a> <a href="#function-defn-body"><span class="ntref">function-defn-body</span></a>
<span class="ntdfn" id="function-defn-body">function-defn-body</span> :=
   <a href="#block-function-body"><span class="ntref">block-function-body</span></a>
   | <a href="#expr-function-body"><span class="ntref">expr-function-body</span></a> <code>;</code>
   | <a href="#external-function-body"><span class="ntref">external-function-body</span></a> <code>;</code>
<span class="ntdfn" id="external-function-body">external-function-body</span> := <code>=</code> [<a href="#annots"><span class="ntref">annots</span></a>] <code>external</code> 
</pre>
<p>
An <code>external-function-body</code> means that the implementation of the
function is not provided in the Ballerina source module. A function-defn-body
with a function-signature that is dependently-typed must be an
external-function-body.
</p>
<p>
If a module has a function-defn with an identifier of <code>init</code>, it is
called called automatically by the system at the end of the initialization of
that module; if this call returns an error, then initialization of the module
fails. The following special requirements apply to the <code>init</code>
function of a module: it must not be declared <code>public</code>; its return
type must both be a subtype of <code>error?</code> and contain <code>()</code>;
it must have no parameters.
</p>

</section>

<section>
<h3 id="section_8.5">8.5 Module type definition</h3>

<pre class="grammar"><span class="ntdfn" id="module-type-defn">module-type-defn</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   [<code>public</code>] <code>type</code> <a href="#identifier"><span class="ntref">identifier</span></a> <a href="#type-descriptor"><span class="ntref">type-descriptor</span></a> <code>;</code>
</pre>
</section>
<section>
<h3 id="section_8.6">8.6 Module variable declaration</h3>

<pre class="grammar"><span class="ntdfn" id="module-var-decl">module-var-decl</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   [<code>final</code>]
   <a href="#typed-binding-pattern"><span class="ntref">typed-binding-pattern</span></a> <code>=</code> <a href="#expression"><span class="ntref">expression</span></a> <code>;</code>
</pre>
<p>
The scope of variables declared in a module-var-decl is the entire module. Note
that module variables are not allowed to be public. If final is specified, then
it is not allowed to assign to the variable. If the typed-binding-pattern uses
<code>var</code>, then the type of the variable is inferred from the static type
of <code>expression</code>; if the module-var-decl includes <code>final</code>,
the precise type is used, and otherwise the broad type is used. If the
typed-binding-pattern specifies a type-descriptor, then that type-descriptor
provides the contextually expected type for action-or-expr.
</p>
</section>
<section>
<h3 id="section_8.7">8.7 Module constant declaration</h3>

<pre class="grammar"><span class="ntdfn" id="module-const-decl">module-const-decl</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   [<code>public</code>] <code>const</code> [<a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>] <a href="#identifier"><span class="ntref">identifier</span></a> <code>=</code> <a href="#const-expr"><span class="ntref">const-expr</span></a> <code>;</code>
</pre>
<p>
A module-const-decl declares a compile-time constant. A compile-time constant is
an named immutable value, known at compile-time. A compile-time constant can be
used like a variable, and can also be referenced in contexts that require a
value that is known at compile-time, such as in a type-descriptor or in a
match-pattern.
</p>
<p>
The type of the constant is the intersection of <code>readonly</code> and the
singleton type containing just the shape of the value named by the constant. The
type of the constant determines the static type of a variable-reference-expr
that references this constant.
</p>
<p>
If type-descriptor is present, then it provides the contextually expected type
for the interpretation of const-expr. It is a compile-time error if the static
type of const-expr is not a subtype of that type. The type-descriptor must
specify a type that is a subtype of anydata. Note that the type-descriptor does
not specify the type of the constant, although the type of the constant will all
be a subtype of the type specified by the type-descriptor.
</p>
</section>

<section>
<h3 id="section_8.8">8.8 Module enumeration declaration</h3>

<pre class="grammar"><span class="ntdfn" id="module-enum-decl">module-enum-decl</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   [<code>public</code>] <code>enum</code> <a href="#identifier"><span class="ntref">identifier</span></a> <code>{</code> <a href="#enum-member"><span class="ntref">enum-member</span></a> (<code>,</code> <a href="#enum-member"><span class="ntref">enum-member</span></a>)* <code>}</code>
<span class="ntdfn" id="enum-member">enum-member</span> := <a href="#metadata"><span class="ntref">metadata</span></a> <a href="#identifier"><span class="ntref">identifier</span></a> [<code>=</code> <a href="#const-expr"><span class="ntref">const-expr</span></a>]
</pre>
<p>
A module-enum-decl provides a convenient syntax for declaring a union of string constants.
</p>
<p>
Each enum-member is defined as compile-time constant in the same way as if it
had been defined using a module-const-decl. The result of evaluating the
const-expr must be a string. If the const-expr is omitted, it defaults to be the
same as the identifier.
</p>
<p>
The identifier is defined as a type in the same was as if it had been defined by
a module-type-defn, with the type-descriptor being the union of the constants
defined by the members.
</p>
<p>
If the module-enum-decl is public, then both the type and the constants are public.
</p>
<p>
So for example:
</p>
<pre>
public enum Color {
  RED,
  GREEN,
  BLUE
}
</pre>
<p>
is exactly equivalent to:
</p>
<pre>
public const RED = "RED";
public const GREEN = "GREEN";
public const BLUE = "BLUE";
public type Color RED|GREEN|BLUE;
</pre>
</section>

<section>
<h3 id="section_8.9">8.9 Module XML namespace declaration</h3>
<pre class="grammar"><span class="ntdfn" id="module-xmlns-decl">module-xmlns-decl</span> := <a href="#xmlns-decl"><span class="ntref">xmlns-decl</span></a>
</pre>

<p>
A <code>module-xmlns-decl</code> declares an XML namespace prefix with module
scope. It applies only to the source part in which it occurs, as with an
import-decl.
</p>
<p>
The semantics of xmlns-decl are described in the <a href="#XML_namespace_declaration_statement">XML namespace declaration
statement</a> section.
</p>

</section>

</section>
<section>
<h2 id="metadata">9. Metadata</h2>
<p>
Ballerina allows metadata to be attached to a construct by specifying the
metadata before the construct.
</p>

<pre class="grammar"><span class="ntdfn" id="metadata">metadata</span> := [<a href="#DocumentationString"><span class="ntref">DocumentationString</span></a>] [<a href="#annots"><span class="ntref">annots</span></a>]
</pre>
<p>
There are two forms of metadata: documentation and annotations.
</p>
<section>
<h3 id="section_9.1">9.1 Annotations</h3>

<pre class="grammar"><span class="ntdfn" id="annots">annots</span> := <a href="#annotation"><span class="ntref">annotation</span></a>+
<span class="ntdfn" id="annotation">annotation</span> := <code>@</code> <a href="#annot-tag-reference"><span class="ntref">annot-tag-reference</span></a> <a href="#annot-value"><span class="ntref">annot-value</span></a>
</pre>
<p>
Annotations provide structured metadata about a particular construct. Multiple
annotations can be applied to a single construct. An annotation consists of a
tag and a value.
</p>

<pre class="grammar"><span class="ntdfn" id="annotation-decl">annotation-decl</span> :=
   <a href="#metadata"><span class="ntref">metadata</span></a>
   [<code>public</code>] [<code>const</code>] <code>annotation</code> [<a href="#type-descriptor"><span class="ntref">type-descriptor</span></a>] <a href="#annot-tag"><span class="ntref">annot-tag</span></a> 
   [<code>on</code> <a href="#annot-attach-points"><span class="ntref">annot-attach-points</span></a>] <code>;</code>
<span class="ntdfn" id="annot-tag">annot-tag</span> := <a href="#identifier"><span class="ntref">identifier</span></a>
</pre>
<p>
An annotation-decl declares an annotation tag. Annotations tags are in a
separate symbol space and cannot conflict with other module level declarations
and definitions. The annotation tag symbol space is also distinct from the
symbol space used by module prefixes and XML namespace prefixes.
</p>
<p>
The type-descriptor specifies the type of the annotation tag. The type must be a
subtype of one of the following three types: <code>true</code>,
<code>map&lt;anydata|readonly&gt;</code>,
<code>map&lt;anydata|readonly&gt;[]</code>. If the type-descriptor is omitted,
then the type is <code>true</code>.
</p>

<pre class="grammar"><span class="ntdfn" id="annot-tag-reference">annot-tag-reference</span> := <a href="#qualified-identifier"><span class="ntref">qualified-identifier</span></a> | <a href="#identifier"><span class="ntref">identifier</span></a>
<span class="ntdfn" id="annot-value">annot-value</span> := [<a href="#mapping-constructor-expr"><span class="ntref">mapping-constructor-expr</span></a>]
</pre>
<p>
An annot-tag-reference in an annotation must refer to an annot-tag declared in
an annotation declaration. When an annot-tag-reference is a
qualified-identifier, then the module-prefix of the qualified-identifier is
resolved using import declarations into a reference to a module, and that module
must contain an annotation-decl with the same identifier. An annot-tag-reference
that is an identifier rather than a qualified-identifier does <em>not</em> refer
to an annotation defined within the same module. Rather the compilation
environment determines which identifiers can occur as an
annotation-tag-reference, and for each such identifier which module defines that
annotation tag.
</p>
<p>
If the annotation includes a mapping-constructor-expr, then the value of the
annotation is the mapping value resulting from evaluating the
mapping-constructor-expr; otherwise the value is the boolean value
<code>true</code>. For every construct that has an annotation with a particular
tag, there is an <em>effective value</em> for that annotation tag, which is
constructed from the values of all annotations with that tag that were attached
to that construct. The effective value must belong to the type of the annotation
tag.
</p>
<p>
The type of the annotation tag constrains both the annotation value and the
occurrence of multiple annotations with the same tag on a single construct as
follows.
</p>
<ul>
<li>If the type of the annotation tag is T[] for some T, then the
mapping-constructor-expr must be specified and its static type must be a subtype
of T; multiple annotations are allowed; the effective value is a list containing
the value for each annotation with the tag in the order specified.</li>
<li>Otherwise, multiple annotations with this tag are not allowed and the
effective value for the tag is the value of the single annotation with the tag.
<ul>
<li>If the type of the annotation tag is true, then the mapping-constructor-expr
must not be specified.</li>
<li>Otherwise, the mapping-constructor-expr must be specified and its static
type must be a subtype of the type of the annotation tag.</li>
</ul>
</li>
</ul>
<p>
If the annotation-decl for a tag specifies <code>const</code>, then a
mapping-constructor-expr in annotations with that tag must be a const-expr and
is evaluated at compile-time with the semantics of a const-expr. Otherwise, the
mapping-constructor-expr is evaluated when the annotation is evaluated and the
ImmutableClone abstract operation is applied to the result.
</p>
<p>
An annotation applied to a module-level declaration is evaluated when the module
is initialized. An annotation applied to a service constructor is evaluated when
the service constructor is evaluated. An annotation occurring within a type
descriptor is evaluated when the type descriptor is resolved.
</p>

<pre class="grammar"><span class="ntdfn" id="annot-attach-points">annot-attach-points</span> := <a href="#annot-attach-point"><span class="ntref">annot-attach-point</span></a> (<code>,</code> <a href="#annot-attach-point"><span class="ntref">annot-attach-point</span></a>)*
<span class="ntdfn" id="annot-attach-point">annot-attach-point</span> :=
   <a href="#dual-attach-point"><span class="ntref">dual-attach-point</span></a>
   | <a href="#source-only-attach-point"><span class="ntref">source-only-attach-point</span></a>
<span class="ntdfn" id="dual-attach-point">dual-attach-point</span> := [<code>source</code>] <a href="#dual-attach-point-ident"><span class="ntref">dual-attach-point-ident</span></a>
<span class="ntdfn" id="dual-attach-point-ident">dual-attach-point-ident</span> :=
   [<code>object</code>] <code>type</code>
   | [<code>object</code>|<code>resource</code>] <code>function</code>
   | <code>parameter</code>
   | <code>return</code>
   | <code>service</code>
   | [<code>object</code>|<code>record</code>] <code>field</code>
<span class="ntdfn" id="source-only-attach-point">source-only-attach-point</span> := <code>source</code> <a href="#source-only-attach-point-ident"><span class="ntref">source-only-attach-point-ident</span></a>
<span class="ntdfn" id="source-only-attach-point-ident">source-only-attach-point-ident</span> :=
   <code>annotation</code>
   | <code>external</code>
   | <code>var</code>
   | <code>const</code>
   | <code>listener</code>
   | <code>worker</code>
</pre>
<p>
The <code>annot-attach-points</code> specify the constructs to which an
annotation can be attached.
</p>
<p>
When an attachment point is prefixed with <code>source</code>, then the
annotation is attached to a fragment of the source rather than to any runtime
value, and thus is not available at runtime. If any of the attachment points
specify <code>source</code>, the annotation-decl must specify
<code>const</code>.
</p>
<p>
When an attachment point is not prefixed with source, then the annotation is
accessible at runtime by applying the annotation access operator to a typedesc
value.
</p>
<p>
The available attachment points are described in the following table.
</p>
<table>
  <tr>
   <td><strong>Attachment point name</strong></td>
   <td><strong>Syntactic attachment point(s)</strong></td>
   <td><strong>Attached to which type descriptor at runtime</strong></td>
  </tr>
  <tr>
   <td>type</td>
   <td>module-type-defn, local-type-defn-stmt, module-enum-decl, type-cast-expr</td>
   <td>defined type</td>
  </tr>
  <tr>
   <td>object type</td>
   <td>module-type-defn or local-type-defn-stmt, whose type descriptor is a non-abstract object type
descriptor</td>
   <td>defined type (which will be type of objects constructed using this type)</td>
  </tr>
  <tr>
   <td>function</td>
   <td>function-defn, method-decl, method-defn, anonymous-function-expr, service-method-defn</td>
   <td>type of function</td>
  </tr>
  <tr>
   <td>object function</td>
   <td>method-decl, method-defn</td>
   <td>type of function</td>
  </tr>
  <tr>
   <td>resource function</td>
   <td>service-method-defn with resource modifier</td>
   <td>type of function, on service value</td>
  </tr>
  <tr>
   <td>return</td>
   <td>returns-type-descriptor</td>
   <td>indirectly to type of function</td>
  </tr>
  <tr>
   <td>parameter</td>
   <td>individual-param, rest-param</td>
   <td>indirectly to type of function</td>
  </tr>
  <tr>
   <td>service</td>
   <td>service-decl, service-constructor-expr</td>
   <td>type of service</td>
  </tr>
  <tr>
   <td>field</td>
   <td>individual-field-descriptor, object-field-descriptor</td>
   <td>type of mapping or object</td>
  </tr>
  <tr>
   <td>object field</td>
   <td>object-field-descriptor</td>
   <td>type of object</td>
  </tr>
  <tr>
   <td>record field</td>
   <td>individual-field-descriptor</td>
   <td>type of mapping</td>
  </tr>
  <tr>
   <td>listener</td>
   <td>listener-decl</td>
   <td>none</td>
  </tr>
  <tr>
   <td>var</td>
   <td>module-var-decl, local-var-decl-stmt, let-var-decl</td>
   <td>none</td>
  </tr>
  <tr>
   <td>const</td>
   <td>module-const-decl, enum-member</td>
   <td>none</td>
  </tr>
  <tr>
   <td>annotation</td>
   <td>annotation-decl</td>
   <td>none</td>
  </tr>
  <tr>
   <td>external</td>
   <td>external-function-body</td>
   <td>none</td>
  </tr>
  <tr>
   <td>worker</td>
   <td>named-worker-decl, start-action</td>
   <td>none</td>
  </tr>
</table>
</section>
<section>
<h3 id="section_9.2">9.2 Documentation</h3>
<p>
A documentation string is an item of metadata that can be associated with
module-level Ballerina constructs and with method declarations. The purpose of
the documentation strings for a module is to enable a programmer to use the
module. Information not useful for this purpose should be provided in in
comments.
</p>
<p>
A documentation string has the format of one or more lines each of which has a
<code>#</code> optionally preceded by blank space.
</p>
<p>
The documentation statement is used to document various Ballerina constructs.
</p>

<pre class="grammar"><span class="ntdfn" id="DocumentationString">DocumentationString</span> := <a href="#DocumentationLine"><span class="ntref">DocumentationLine</span></a> +
<span class="ntdfn" id="DocumentationLine">DocumentationLine</span> := <a href="#BlankSpace"><span class="ntref">BlankSpace</span></a>* <code>#</code> [<a href="#Space"><span class="ntref">Space</span></a>] <a href="#DocumentationContent"><span class="ntref">DocumentationContent</span></a>
<span class="ntdfn" id="DocumentationContent">DocumentationContent</span> := (^ 0xA)* 0xA
<span class="ntdfn" id="BlankSpace">BlankSpace</span> := <a href="#Tab"><span class="ntref">Tab</span></a> | <a href="#Space"><span class="ntref">Space</span></a>
<span class="ntdfn" id="Space">Space</span> := 0x20
<span class="ntdfn" id="Tab">Tab</span> := 0x9
</pre>
<p>
A <code>DocumentationString</code> is recognized only at the beginning of a
line. The content of a documentation string is the concatenation of the
<code>DocumentationContent</code> of each <code>DocumentationLine</code> in the
<code>DocumentationString</code>. Note that a single space following the # is
not treated as part of the DocumentationContent.
</p>
<p>
The content of a <code>DocumentationString</code> is parsed as Ballerina
Flavored Markdown (BFM). BFM is also used for a separate per-module
documentation file, conventionally called <code>Module.md</code>.
</p>
</section>
<section>
<h3 id="section_9.3">9.3 Ballerina Flavored Markdown</h3>
<p>
Ballerina Flavored Markdown is GitHub Flavored Markdown, with some additional
conventions.
</p>
<p>
In the documentation string attached to a function or method, there must be
documentation for each parameter, and for the return value if the return value
is not nil. The documentation for the parameters and a return value must consist
of a Markdown list, where each list item must have the form <code>ident -
doc</code>, where ident is either the parameter name or return, and doc is the
documentation of that parameter or of the return value.
</p>
<p>
The documentation for an object must contain a list of fields rather than
parameters. Private fields should not be included in the list.
</p>
<p>
BFM also provides conventions for referring to Ballerina-defined names from
within documentation strings in a source file. An identifier in backticks
<code>`X`</code>, when preceded by one of the following words:
</p>
<ul>
<li><code>type</code></li>
<li><code>service</code></li>
<li><code>variable</code></li>
<li><code>var</code></li>
<li><code>annotation</code></li>
<li><code>module</code></li>
<li><code>function</code></li>
<li><code>parameter</code></li>
</ul>
<p>
is assumed to be a reference to a Ballerina-defined name of the type indicated
by the word. In the case of <code>parameter</code>, the name must be unqualified
and be the name of a parameter of the function to which the documentation string
is attached. For other cases, if the name is unqualified it must refer to a
public name of the appropriate type in the source file's module; if it is a
qualified name M:X, then the source file must have imported M, and X must refer
to a public name of an appropriate type in M. BFM also recognizes
<code>`f()`</code> as an alternative to <code>function `f`</code>. In both
cases, f can have any of the following forms (where `m` is a module import, `x` is a
function name, `T` is an object type name, and `y` is a method name):
</p>

<pre>    x()
    m:x()
    T.y()
    m:T.y()
</pre>
<p>
Example
</p>

<pre>    # Adds parameter `x` and parameter `y`
    # + x - one thing to be added
    # + y - another thing to be added
    # + return - the sum of them
    function add (int x, int y) returns int { return x + y; }
</pre>

<p>
The Ballerina platform may define additional conventions, in particular relating
to headings with particular content. For example, a heading with a content of
<code>Deprecated</code> can be used to provide information about the deprecation
of the name to which the documentation string is attached.
</p>

</section>
</section>
<section>
<h2 id="lang_library">10. Lang library</h2>

<p>
Modules in the <code>ballerina</code> organization with a module name starting
with <code>lang.</code> are reserved for use by this specification. These
modules are called the <em>lang library</em>.
</p>
<p>
The lang library comprises the following modules. With the exception of the
<code>lang.value</code> module, each corresponds to a basic type.
</p>
<ul>
<li><code><a href="./lib/value.bal" type="text/plain">lang.value</a></code></li>
<li>
<code><a href="./lib/array.bal" type="text/plain">lang.array</a></code> for
basic type list</li>
<li>
<code><a href="./lib/boolean.bal" type="text/plain">lang.boolean</a></code> for
basic type boolean</li>
<li>
<code><a href="./lib/decimal.bal" type="text/plain">lang.decimal</a></code>
for basic type decimal</li>
<li>
<code><a href="./lib/error.bal" type="text/plain">lang.error</a></code> for
basic type error</li>
<li>
<code><a href="./lib/float.bal" type="text/plain">lang.float</a></code> for
basic type float</li>
<li>
<code><a href="./lib/future.bal" type="text/plain">lang.future</a></code>
for basic type future</li>
<li>
<code><a href="./lib/int.bal" type="text/plain">lang.int</a></code> for
basic type int</li>
<li>
<code><a href="./lib/map.bal" type="text/plain">lang.map</a></code> for
basic type mapping</li>
<li>
<code><a href="./lib/object.bal" type="text/plain">lang.object</a></code>
for basic type object</li>
<li>
<code><a href="./lib/string.bal" type="text/plain">lang.string</a></code>
for basic type string</li>
<li>
<code><a href="./lib/stream.bal" type="text/plain">lang.stream</a></code>
for basic type stream</li>
<li>
<code><a href="./lib/table.bal" type="text/plain">lang.table</a></code> for
basic type table</li>
<li>
<code><a href="./lib/typedesc.bal" type="text/plain">lang.typedesc</a></code> for
basic type typedesc</li>
<li>
<code><a href="./lib/xml.bal" type="text/plain">lang.xml</a></code> for
basic type xml</li>
</ul>
<p>
For each version of the specification, there is a separate version number for
each module in its lang library. The module version numbers for this version of
the specification are <a href="./lib/versions.json" type="text/plain">specified</a> in JSON format.
</p>
<p>
Modules in the lang library can make use generic typing. Since generic typing
has not yet been added to Ballerina, the source code for the modules use an
annotation to describe generic typing as follows. When a module type definition
has a <code>@typeParam</code> annotation, it means that this type serves as a
type parameter when it is used in a function definition: all uses of the type
parameter in a function definition refer to the same type; the definition of the
type is an upper bound on the type parameter.
</p>
<p>
<strong>Note</strong> We plan to provide full support for generic types in
a future version of this specification.
</p>

<section>
<h3 id="built-in_subtypes">10.1 Built-in subtypes</h3>
<p>
A module in the lang library can provide types that are <em>built-in</em> in the
sense that their meaning is defined by this specification. Each such built-in
type is a subtype of a single basic type; a built-in type that is a subtype of a
basic type <code><var>B</var></code> is provided by the module
<code>lang.<var>B</var></code>.
</p>
<p>
The built-types provided by lang library modules are described in the following
table.
</p>

<table>
<tr>
<th>Basic type</th>
<th>Type name</th>
<th>Criteria for <em>v</em> to belong to type</th>
</tr>
<tr>
<td rowspan="6">int</td>
<td>Unsigned8</td>
<td>0 â¤ <em>v</em> â¤ 255</td>
</tr>
<tr>
<td>Signed8</td>
<td>-128 â¤ <em>v</em> â¤ 127</td>
</tr>
<tr>
<td>Unsigned16</td>
<td>0 â¤ <em>v</em> â¤ 65,535</td>
</tr>
<tr>
<td>Signed16</td>
<td>-32,768 â¤ <em>v</em> â¤ 32,767</td>
</tr>
<tr>
<td>Unsigned32</td>
<td>0 â¤ <em>v</em> â¤ 4,294,967,295</td>
</tr>
<tr>
<td>Signed32</td>
<td>-2,147,483,648â¬ â¤ <em>v</em> â¤ 2,147,483,6487</td>
</tr>
<tr>
<td>string</td>
<td>Char</td>
<td>
<em>v</em> has length 1</td>
</tr>
<tr>
<td rowspan="4">xml</td>
<td>Element</td>
<td>
<em>v</em> is an element singleton</td>
</tr>
<tr>
<td>ProcessingInstruction</td>
<td>
<em>v</em> is a processing instruction singleton</td>
</tr>
<tr>
<td>Comment</td>
<td>
<em>v</em> is a comment singleton</td>
</tr>
<tr>
<td>Text</td>
<td>
<em>v</em> is either the empty xml value or a text singleton</td>
</tr>
</table>
<p>
Each built-in type has a type definition in the module that provides it. The
type descriptor of the type definition is the corresponding basic type. The type
definition has a <code>@builtinSubtype</code> annotation, which indicates that
the meaning of the type name is built-in, as specified in the above table,
rather than coming from its type descriptor. It is an error to use the
<code>@builtinSubtype</code> annotation except in a lang library module.
</p>
<p>
So, for example, the <code>lang.int</code> module would include the definition:
</p>
<pre>
@builtinSubtype
type Signed32 int;
</pre>
<p>
Semantically, these types behave like a predefined type that can be referenced
by an unqualified name, such as <code>byte</code>. Syntactically, these types
are referenced by a <code>type-reference</code> in the same way as if their
definitions were not built-in. A built-in type <code>T</code> which is a subtype
of basic type <code>B</code> can be referenced by a type-reference
<code>M:T</code>, where <code>M</code> is a module-prefix referring to module
<code>ballerina/lang.B</code>.
</p>
<p>
For convenience, this specification refers to the built-in subtype T provided by
the module for basic type B as B:T. For example, in this specification
<code>int:Signed32</code> refers to the <code>Signed32</code> built-in subtype
of <code>int</code>, which is provided by the <code>lang.int</code> module.
</p>
<p>
The <code>int:Unsigned8</code> type is equivalent to the predefined
<code>byte</code> type.
</p>
</section>

</section>
<section class="appendix">
<h2 id="references">A. References</h2>
<ul>
<li>Unicode</li>
<li>XML</li>
<li>JSON</li>
<li>RFC 3629 UTF-8</li>
<li>IEEE 754-2008</li>
<li>GitHub Markdown</li>
</ul>
</section>
<section class="appendix">
<h2 id="changes">B. Changes since previous versions</h2>
<section>
<h3 id="section_B.1">B.1 Summary of changes from 2020R1 to 2020R2</h3>
<ol>
<li>The <code>readonly</code> type has been added. Fields of records and objects
can also be declared as <code>readonly</code>.</li>
<li>Intersection types have been added.</li>
<li>Distinct types have been added; these provide the functionality of nominal
types with the framework of a structural type system.</li>
<li>The error type has been revised to take advantage of distinct types. Instead
an error value having a reason string for categorizing the error and separate
message string in the detail record, an error value has a message string in the
error and distinct types are used for categorizing. The cause has also moved
from the detail record into the error value.</li>
<li>Language-defined abstract object types now make use of distinct types,
instead of using names prefixed with double underscore.</li>
<li>The <code>__init</code> method of object and the <code>__init</code> function
of modules have been renamed to <code>init</code>.</li>
<li>The table type has been redesigned to be more consistent with other
structural types and no longer has preview status.</li>
<li>Enum declarations have been added.</li>
<li>The return type of a function with an external body can depend on the value
of a parameter of typedesc type.</li>
<li>The XML item-specific subtypes can be used as constructors, both in
expressions and in binding patterns.</li>
</ol>
</section>
<section>
<h3 id="section_B.2">B.2 Summary of changes from 2019R3 to 2020R1</h3>
<ol>
<li>Query expressions and query actions have been added. This is the first stage
of language-integrated query.</li>
<li>The stream basic type has been added.</li>
<li>Let expressions have been added.</li>
<li>The XML design has been refined and no longer has Preview status.
<ul>
<li>The various kinds of xml item (e.g. element and text) are subtypes of the
<code>xml</code> type.</li>
<li>The <code>xml</code> type can have a type parameter specifying the item
types.</li>
<li>Iteration over xml values exposes characters as text items rather than strings</li>
<li>Adjacent characters in XML content are chunked into a single text item.</li>
<li>The meaning of <code>===</code> for xml has changed.</li>
<li>The item of an xml sequence value x with index i can be accessed using an
expression x[i].</li>
<li>The syntax <code>x@</code> for accessing the attributes of an XML element has
been removed.</li>
</ul>
</li>
<li>The <code>lock</code> statement has been added.</li>
<li>When a list constructor or mapping constructor is used without a
contextually expected type, we now infer a tuple or record type rather than an
array or map type.</li>
<li>The syntax for Unicode escapes in strings has changed from
<code>\u[<em>CodePoint</em>]</code> to <code>\u{<em>CodePoint</em>}</code> so as
to align with ECMAScript. Although this is an incompatible change, the previous
syntax was not implemented.</li>
<li>The <code>never</code> type has been added.</li>
<li>Lang library modules can now provide built-in subtypes of existing basic
types.</li>
<li>There is a lang.boolean lang lib module.</li>
</ol>
</section>
<section>
<h3 id="section_B.3">B.3 Summary of changes from 2019R2 to 2019R3</h3>
<ol>
<li>An import declaration can use <code>as _</code> to include a module in the
program without using its symbols.</li>
<li>The specification of experimental features has been moved to a separate
document.</li>
<li>A wait-action can result in an error value when applied to a future that is
not a named worker.</li>
</ol>
</section>

<section>
<h3 id="section_B.4">B.4 Summary of changes from 2019R1 to 2019R2</h3>
<ol>
<li>The concept of a built-in method has been replaced by the concept of a lang
library. A method call on a value of non-object type is now treated as a
convenient syntax for a call to a function in a module of the lang library. The
design of the many of the existing built-in methods has been changed to fit in
with this. There are many functions in the lang library that were not previously
available as built-in methods.</li>
<li>A mapping value is now iterable as a sequence of its members (like list),
rather than as a sequence of key-value pairs. The <code>entries</code> lang library
function allows it to be iterated as a sequence of key-value pairs.</li>
<li>The basic type <code>handle</code> has been added.</li>
<li>The <code>table&lt;T&gt;</code> type descriptor shorthand has been brought
back.</li>
<li>There is now a variation on <code>check</code> called
<code>checkpanic</code>, which panics rather than returns on error.</li>
<li>A range-expr now returns an object belonging to the Iterable abstract object
type, rather than a list.</li>
<li>The decimal type now uses a simplified subset of IEEE 754-2008 decimal
floating point.</li>
<li>The status of XML-related features has been changed to preview.</li>
<li>The ability to define a method outside the object type has been
removed.</li>
<li>The UnfrozenClone operation has been removed.</li>
<li>The Freeze operation has been replaced by the ImmutableClone operation.</li>
<li>The semantics of field access, member access and assignment are now
fully specified.</li>
<li>A <code>?.</code> operator has been added for access to optional fields.</li>
<li>A type-cast-expr can include annotations.</li>
<li>The error detail record must belong to type Detail defined in the lang
library.</li>
<li>The compile-time requirement that the inherent type of a variable-length
list must allow members to be filled-in has been removed; this is instead caught
at run-time.</li>
<li>Parameter names now have public or module-level visibility, which determines
when a function call can use the parameter name to specify an argument.</li>
<li>A type descriptor <code>record { }</code> is open to <code>anydata</code>
rather than <code>anydata|error</code>.</li>
<li>Calls using <code>start</code> are treated as actions, and so are not
allowed within expressions.</li>
<li>There is a new syntax for allowing arbitrary strings as identifiers to
replace the old delimited identifier syntax <code>^"<var>s</var>"</code>.</li>
</ol>

</section>
<section>
<h3 id="section_B.5">B.5 Summary of changes from 0.990 to 2019R1</h3>
<p>
The specification has switched to a new versioning scheme. The <var>n</var>-th
version of the specification released in year 20<var>xy</var> will be labelled
20<var>xy</var>R<var>n</var>.
</p>
<ol>
<li>Tuples types now use square brackets, rather than parentheses, as do tuple
binding patterns and tuple match patterns. Array constructors and tuple
constructors are now unified into list constructors, which use square brackets.
Tuple types can have zero members or one member, and can use <code>T...</code>
syntax allow trailing members of a specified type.</li>
<li>The way that record type descriptors express openness has changed. Instead
of the <code>!...</code> syntax, there are two flavours of record type
descriptor, which use different delimiters: <code>record {| |}</code> allows any
mapping that has exclusively the specified fields, whereas <code>record {
}</code> allows any mapping that includes the specified fields; the former can
use the <code>T...</code> syntax, whereas the latter cannot. The
<code>!...</code> is no longer allowed for record binding patterns and record
match patterns.</li>
<li>The syntax for an array with an array length that is inferred has changed
from <code>T[!...]</code> to <code>T[*]</code>.</li>
<li>A type descriptor of <code>error&lt;*&gt;</code> can be used to specify an
error type whose subtype is inferred.</li>
<li>A new expression can no longer be used to create values of structural types;
it is only allowed for objects.</li>
<li>Symbolic string literals <code>'ident</code> have been removed (compile time
constants provide a more convenient approach).</li>
<li>
<code>untaint</code> expression has been removed (this will be handled by
annotations instead).</li>
<li>The syntax for named arguments in a function call has reverted to
<code>arg=</code> from <code>arg:</code>, since the latter caused syntactic
ambiguities.</li>
<li>The syntax for error constructors specifies fields of the error detail
separately as named arguments, rather than specifying the error detail as a
single argument; the syntax for binding patterns and match patterns for error
values has also changed accordingly.</li>
<li>The error reason argument can be omitted from an error constructor if it
can be determined from the contextually expected type.</li>
<li>The syntax for annotation declarations has been revised; the places where
annotations are allowed has been revised to match the possible attachment
points.</li>
<li>An <code>.@</code> binary operator has been added for accessing annotations
at runtime.</li>
<li>A unary <code>typeof</code> operator has been added.</li>
<li>The <code>typedesc</code> type now takes an optional type parameter.</li>
<li>The type parameters for <code>future</code> and <code>stream</code> are now
optional.</li>
<li>The syntax for a function with an external implementation has changed to use
<code>=external</code> in place of the curly braces.</li>
<li>A numeric literal can use a suffix of <code>d</code> or <code>f</code> to
indicate that it represents a value belonging to the decimal or float type
respectively.</li>
<li>Record type descriptors may now specify a default value for fields.</li>
<li>Providing a default value for a parameter no longer affects whether a function
call must supply the argument for that parameter positionally or by name. Instead
the argument for any parameter can be supplied either positionally or by name.
To avoid ambiguity, all arguments specified positionally must be specified before
arguments specified by name.</li>
<li>Expressions specifying the default value for function parameters are not
compile time constants, and are evaluated each time they are used to supply a
missing argument.</li>
<li>In the argument list of a function or method call, positional arguments are
now required to be specified before named arguments.</li>
<li>Types may now be defined within a block.</li>
</ol>
</section>
<section>
<h3 id="section_B.6">B.6 Summary of changes from 0.980 to 0.990</h3>
<p>
<strong>Structural types and values</strong>
</p>
<ol>
<li>Concepts relating to typing of mutable structural values have been changed
in order to make type system sound.</li>
<li>The <code>match</code> statement has been redesigned.</li>
<li>The <code>but</code> expression has been removed.</li>
<li>The <code>is</code> expression for dynamic type testing has been added.</li>
<li>The type-cast-expr &lt;T&gt;E now performs unsafe type casts.The only
conversions it performs are numeric conversions.</li>
<li>The <code>anydata</code> type has been added, which is a union of simple and
structural types.</li>
<li>Records are now by default open to <code>anydata|error</code>, rather than
<code>any</code>.</li>
<li>Type parameters for built-in types (map, stream, future), which previously
defaulted to any, are now required.</li>
<li>The type parameter for json (e.g. json&lt;T&gt;) is not allowed any more.</li>
<li>Type for table columns are restricted to subtype of anydata|error.</li>
<li>There are now two flavors of equality operator: == and != for deep equality
(which is allowed only for <code>anydata</code>), and ===  and !== for exact
equality.</li>
<li>There is a built-in clone operation for performing a deep copy on values of
type anydata.</li>
<li>There is a built-in freeze operation for making structural values deeply
immutable.</li>
<li>Compile-time constants (which are always a subtype of anydata and frozen)
have been added.</li>
<li>Singleton types have been generalized: any compile-time constant can be made
into a singleton value.</li>
<li>Variables can be declared final, with a similar semantic to Java.</li>
<li>Errors are now immutable.</li>
<li>Module variables are not allowed to be public: only compile-time constants
can be public.</li>
</ol>
<p>
<strong>Error handling</strong>
</p>
<ol>
<li>The <code>any</code> type no longer includes <code>error</code>.</li>
<li>
<code>check</code> is now an expression.</li>
<li>Exceptions have been replaced by panics
<ol>
<li>the <code>throw</code> statement has been replaced by the <code>panic</code>
statement</li>
<li>the<code> try</code> statement has been replaced by the <code>trap</code>
expression</li>
</ol>
</li>
<li>Object constructors (which could not return errors) have been replaced by
<code>__init</code> methods (which can return errors).</li>
</ol>
<p>
<strong>Concurrency</strong>
</p>
<ol>
<li>Workers in functions have been redesigned. In particular, workers now have a
return value.</li>
<li>The <code>done</code> statement has been removed.</li>
<li>The fork/join statement has been redesigned.</li>
<li>A syntactic category between expression and statement, called action, has
been added.</li>
<li>A synchronous message send action has been added.</li>
<li>A flush action has been added to flush asynchronously sent messages.</li>
<li>A wait action has been added to wait for a worker and get its return value.</li>
<li>Futures have been unified with workers. A future&lt;T&gt; represents a value to
be returned by a named worker.</li>
<li>Error handling of message send/receive has been redesigned.</li>
</ol>
<p>
<strong>Endpoints and services</strong>
</p>
<ol>
<li>Client endpoints have been replaced by client objects, and actions on client
endpoints have been replaced by remote methods on client objects. Remote methods
are called using a remote method call action, which replaces the action
invocation statement.</li>
<li>Module endpoint declaration has been replaced by module listener
declaration, which uses the Listener built-in object type.</li>
<li>The service type has been added as a new basic type of behavioral value,
together with service constructor expressions for creating service values.</li>
<li>Module service definitions have been redesigned.</li>
</ol>
<p>
<strong>Miscellaneous changes</strong>
</p>
<ol>
<li>Public/private visibility qualifiers must be repeated on an outside method
definition.</li>
</ol>
</section>
<section>
<h3 id="section_B.7">B.7 Summary of changes from 0.970 to 0.980</h3>
<ol>
<li>The decimal type has been added.</li>
<li>There are no longer any implicit numeric conversions.</li>
<li>The type of a numeric literal can be inferred from the context.</li>
<li>The error type is now a distinct basic type.</li>
<li>The byte type has been added as a predefined subtype of int; blobs have been
replaced by arrays of bytes.</li>
<li>The syntax of string templates and xml literals has been revised and
harmonized.</li>
<li>The syntax of anonymous functions has been revised to provide two
alternative syntaxes: a full syntax similar to normal function definitions and a
more convenient arrow syntax for when the function body is an expression.</li>
<li>The cases of a match statement are required to be exhaustive.</li>
<li>The + operator is specified to do string and xml concatenation as well as
addition.</li>
<li>Bitwise operators have been added (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>,
<code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>,
<code>~</code>) rather than = after the argument name.</li>
<li>In a function call or method call, named arguments have changed to use
<code>:</code>
</li>
<li>A statement with <code>check</code> always handles an error by returning it,
not by throwing it.</li>
<li>
<code>check</code> is allowed in compound assignment statements.</li>
<li>Method names are now looked up differently from field names; values of types
other than objects can now have built-in methods.</li>
<li>The <code>lengthof</code> unary expression has been removed; the length
built-in method can be used instead.</li>
<li>The semantics of &lt;T&gt;expr have been specified.</li>
<li>The value space for tuples and arrays is now unified, in the same way as the
value space for records and maps was unified. This means that tuples are now
mutable. Array types can now have a length.</li>
<li>The <code>next</code> keyword has been changed to <code>continue</code>.</li>
<li>The syntax and semantics of destructuring is now done in a consistent way
for the but expression, the match statement, the foreach statement,
destructuring assignment statements and variable declarations.</li>
<li>The implied initial value is not used as a default initializer in variable
declarations. A local variable whose declaration omits the initializer must be
initialized by an assignment before it is used. A global variable declaration
must always have an initializer. A new expression can be used with any reference
type that has an implicit initial value.</li>
<li>Postfix increment and decrement statements have been removed.</li>
<li>The <code>...</code> and <code>..&lt;</code> operators have been added for
creating integer ranges; this replaces the foreach statement's special treatment
of integer ranges.</li>
<li>An object type can be declared to be abstract, meaning it cannot be used
with <code>new</code>.</li>
<li>By default,  a record type now allows extra fields other than those
explicitly mentioned; <code>T...</code> requires extra fields to be of type T
and <code>!...</code> disallows extra fields.</li>
<li>In a mapping constructor, an expression can be used for the field name by
enclosing the expression in square brackets (as in ECMAScript).</li>
<li>Integer arithmetic operations are specified to throw an exception on
overflow.</li>
<li>The syntax for documentation strings has changed.</li>
<li>The deprecated construct has been removed (data related to deprecation will
be provided by an annotation; documentation related to deprecation will be part
of the documentation string).</li>
<li>The order of fields, methods and constructors in object types is no longer
constrained.</li>
<li>A function or method can be defined as <code>extern</code>. The
<code>native</code> keyword has been removed.</li>
</ol>
</section>
</section>
<section class="appendix">
<h2 id="planned_future_functionality">C. Planned future functionality</h2>

<p>
The vision for the Ballerina language includes a large range of functionality
that is not yet included in this specification.
</p>

<ul>
<li>
<em>Transactions</em> will provide language support both local and
distributed transactions.</li>
<li>
<em>Security</em> will combine language and platform features to make
programs secure by default.</li>
<li>
<em>Date/time basic types</em> will provide one or more basic types related
to date and time.</li>
<li>
<em>Event stream processing</em> will build on the <code>stream</code> type
to allow queries over timestamped sequences of events</li>
<li>
<em>Service typing</em> will allow for proper typing of service values,
including typing of the response of resource functions.</li>
<li>
<em>Generic types</em> will provide types that can be instantiated with one
or more type parameters.</li>
<li>
<em>Flexible message passing</em> will support patterns of communication
between workers/strands, where the number of messages is not fixed and/or
workers are not peers.</li>
<li>
<em>Long-running processes</em> will allow the execution of a program to be
automatically suspended and then later resumed upon the occurrence of particular
external events.</li>
<li>
<em>Reliable messaging</em> will allow for sending messages across the
network with some guarantees about reliability.</li>
<li>
<em>Concurrency safety</em> will be able automatically to make safe use of
multiple threads</li>
</ul>

<p>
<a href="https://github.com/ballerina-platform/ballerina-spec/blob/master/lang/proposals/README.md">Proposals</a>
for new language features relating to this and other functionality are
maintained in the specification's GitHub repository.
</p>

</section>

<section class="appendix">
<h2 id="contributors">D. Other contributors</h2>
<p>
The following contributed to establishing the design principles of the language:
</p>
<ul>
<li>Frank Leymann, <a href="mailto:frank.leymann@iaas.uni-stuttgart.de">frank.leymann@iaas.uni-stuttgart.de</a>
</li>
<li>Srinath Perera, <a href="mailto:srinath@wso2.com">srinath@wso2.com</a>
</li>
<li>Kasun Indrasiri, <a href="mailto:kasun@wso2.com">kasun@wso2.com</a>
</li>
</ul>
<p>
The following also contributed to the language in a variety of ways (in
alphabetical order):
</p>
<ul>
<li>Shafreen Anfar, <a href="mailto:shafreen@wso2.com">shafreen@wso2.com</a>
</li>
<li>Afkham Azeez, <a href="mailto:azeez@wso2.com">azeez@wso2.com</a>
</li>
<li>Anjana Fernando, <a href="mailto:anjana@wso2.com">anjana@wso2.com</a>
</li>
<li>Chanaka Fernando, <a href="mailto:chanakaf@wso2.com">chanakaf@wso2.com</a>
</li>
<li>Joseph Fonseka, <a href="mailto:joseph@wso2.com">joseph@wso2.com</a>
</li>
<li>Paul Fremantle, <a href="mailto:paul@wso2.com">paul@wso2.com</a>
</li>
<li>Antony Hosking, <a href="mailto:antony.hosking@anu.edu.au">antony.hosking@anu.edu.au</a>
</li>
<li>Tyler Jewell, <a href="mailto:tylerjewell@gmail.com">tylerjewell@gmail.com</a>
</li>
<li>Anupama Pathirage, <a href="mailto:anupama@wso2.com">anupama@wso2.com</a>
</li>
<li>Manuranga Perera, <a href="mailto:manu@wso2.com">manu@wso2.com</a>
</li>
<li>Supun Thilina Sethunga, <a href="mailto:supuns@wso2.com">supuns@wso2.com</a>
</li>
<li>Sriskandarajah Suhothayan, <a href="mailto:suho@wso2.com">suho@wso2.com</a>
</li>
<li>Isuru Udana, <a href="mailto:isuruu@wso2.com">isuruu@wso2.com</a>
</li>
<li>Rajith Lanka Vitharana, <a href="mailto:rajithv@wso2.com">rajithv@wso2.com</a>
</li>
<li>Mohanadarshan Vivekanandalingam, <a href="mailto:mohan@wso2.com">mohan@wso2.com</a>
</li>
<li>Lakmal Warusawithana, <a href="mailto:lakmal@wso2.com">lakmal@wso2.com</a>
</li>
<li>Ayoma Wijethunga, <a href="mailto:ayoma@wso2.com">ayoma@wso2.com</a>
</li>
</ul>
</section>
</body>
</html>
